/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils/utils.ts
function generateHash() {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i3 = 0; i3 < 8; i3++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}
function formatDate(date = new Date()) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}
function hexToRgba(hex, alpha = 1) {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g5 = parseInt(hex.substring(2, 4), 16);
  const b4 = parseInt(hex.substring(4, 6), 16);
  return `rgba(${r}, ${g5}, ${b4}, ${alpha})`;
}
function extractFilenameFromPath(path2) {
  if (!path2)
    return "";
  const parts2 = path2.split(/[\/\\]/);
  return parts2[parts2.length - 1];
}
var init_utils = __esm({
  "src/utils/utils.ts"() {
  }
});

// src/i18n/en.ts
var en_default;
var init_en = __esm({
  "src/i18n/en.ts"() {
    en_default = {
      // Common UI elements
      "Super Notes": "Super Notes",
      "Save": "Save",
      "Cancel": "Cancel",
      "Delete": "Delete",
      "Edit": "Edit",
      "Create": "Create",
      "Search": "Search",
      "Settings": "Settings",
      "Confirm": "Confirm",
      "Back": "Back",
      // Notices
      "server notification": "Server Notification",
      "Data saved": "Data saved",
      "Data loaded": "Data loaded",
      "Entry created": "Entry created",
      "Entry updated": "Entry updated",
      "Entry deleted": "Entry deleted",
      "Collection created": "Collection created",
      "Collection updated": "Collection updated",
      "Collection deleted": "Collection deleted",
      "Plan created": "Plan created",
      "Plan updated": "Plan updated",
      "Plan deleted": "Plan deleted",
      "Backup created": "Backup created",
      "Backup restored": "Backup restored",
      "License is invalid": "License is invalid",
      // Settings
      "Language": "Language",
      "Context length for each side": "Context length for each side",
      "PDF highlight opacity": "PDF highlight opacity",
      "Link templates": "Link templates",
      "Immediate annotation for Markdown": "Immediate annotation for Markdown",
      "FSRS global parameters": "FSRS global parameters",
      "AI service configuration": "AI service configuration",
      "RAG embedding settings": "RAG embedding settings",
      "Activation code": "Activation code",
      "PDF highlight mode": "PDF highlight mode",
      // Components
      "Create Annotation": "Create Annotation",
      "Collection": "Collection",
      "Tags": "Tags",
      "Content": "Content",
      "Source": "Source",
      "Name": "Name",
      "Color": "Color",
      "Icon": "Icon",
      "Description": "Description",
      "Review": "Review",
      "Created": "Created",
      "Updated": "Updated",
      "Plan": "Plan",
      "Collections View": "Collections",
      "Schedule": "Schedule",
      "Backup & Restore": "Backup & Restore",
      "Create Backup": "Create Backup",
      "Restore Backup": "Restore Backup",
      "Delete Backup": "Delete Backup",
      "Filename": "Filename",
      "Date": "Date",
      "Size": "Size",
      // Views
      "Collections": "Collections",
      "Plans": "Plans",
      "Backup": "Backup",
      "AI Chat": "AI Chat",
      "Review Session": "Review Session",
      "Start Review": "Start Review",
      "Next": "Next",
      "Previous": "Previous",
      "Again": "Again",
      "Hard": "Hard",
      "Good": "Good",
      "Easy": "Easy",
      "Review Completed": "Review Completed",
      // AI Chat
      "Send": "Send",
      "Type your message...": "Type your message...",
      "Thinking...": "Thinking...",
      "Error connecting to AI service": "Error connecting to AI service",
      "Please configure AI service in settings": "Please configure AI service in settings",
      "Select the AI service provider": "Select the AI service provider",
      "Ollama (Local)": "Ollama (Local)",
      "Model": "Model",
      // Video
      "open local video": "Open Local Video",
      // File Operations
      "file path updated for entries": "File path updated for {{count}} entries",
      "failed to update file paths": "Failed to update file paths",
      "copy link": "Copy Link",
      "copy card": "Copy Card",
      "export image": "Export Image"
    };
  }
});

// src/i18n/zh.ts
var zh_default;
var init_zh = __esm({
  "src/i18n/zh.ts"() {
    zh_default = {
      // Notices
      "server notification": "\u901A\u77E5\u6D88\u606F",
      "please select a collection first": "\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u96C6\u5408\u540E\u518D\u6DFB\u52A0\u5B57\u5E55\u6761\u76EE",
      "collection not found": "\u96C6\u5408\u4E0D\u5B58\u5728",
      "please input valid activation code": "\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u8F93\u5165\u6709\u6548\u6FC0\u6D3B\u7801\u4EE5\u542F\u7528 AI \u529F\u80FD",
      "markdown immediate annotation is now": "Markdown \u5373\u65F6\u6807\u6CE8\u5DF2",
      "enabled": "\u5F00\u542F",
      "disabled": "\u5173\u95ED",
      "server error": "\u670D\u52A1\u5668\u9519\u8BEF",
      "unknown error": "\u672A\u77E5\u9519\u8BEF",
      "activation failed": "\u6FC0\u6D3B\u5931\u8D25",
      "network request failed, please check your network connection": "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5",
      "activation successful": "\u6FC0\u6D3B\u6210\u529F\uFF0CAI \u529F\u80FD\u5DF2\u89E3\u9501",
      "activation failed, ai function is disabled": "\u6FC0\u6D3B\u5931\u8D25\uFF0CAI \u529F\u80FD\u5DF2\u7981\u7528",
      "no activation info found": "\u672A\u627E\u5230\u6FC0\u6D3B\u4FE1\u606F",
      "deactivation failed": "\u89E3\u7ED1\u5931\u8D25",
      "please input a number between 0 and 1": "\u8BF7\u8F93\u5165 0 \u5230 1 \u4E4B\u95F4\u7684\u6570\u5B57",
      "pdf highlight mode switched": "PDF\u9AD8\u4EAE\u6A21\u5F0F\u5DF2\u5207\u6362",
      "embedded": "\u5185\u5D4C",
      "layer": "\u56FE\u5C42",
      "all templates reset": "\u6240\u6709\u6A21\u677F\u5DF2\u91CD\u7F6E",
      "test failed": "\u6D4B\u8BD5\u5931\u8D25",
      "device unbound": "\u8BBE\u5907\u5DF2\u89E3\u7ED1",
      "added": "\u5DF2\u6DFB\u52A0",
      "images": "\u5F20\u56FE\u7247",
      "save image failed": "\u4FDD\u5B58\u56FE\u7247\u5931\u8D25",
      "remove link failed": "\u79FB\u9664\u94FE\u63A5\u5931\u8D25",
      "maximum 6 intervals": "\u6700\u591A\u8BBE\u7F6E 6 \u4E2A\u95F4\u9694",
      "name cannot be empty": "\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
      "empty preset name": "\u5B58\u5728\u7A7A\u7684\u9884\u8BBE\u540D\u79F0\uFF0C\u8BF7\u586B\u5199\u6240\u6709\u9884\u8BBE\u540D\u79F0",
      "duplicate preset name": "\u5B58\u5728\u91CD\u590D\u7684\u9884\u8BBE\u540D\u79F0",
      "presets saved": "\u9884\u8BBE\u5DF2\u4FDD\u5B58",
      "save presets failed": "\u4FDD\u5B58\u5931\u8D25",
      "available models": "\u53EF\u7528\u6A21\u578B",
      "backup failed": "\u5907\u4EFD\u5931\u8D25",
      "source data file data.json does not exist": "\u6E90\u6570\u636E\u6587\u4EF6 data.json \u4E0D\u5B58\u5728",
      "backup success": "\u5907\u4EFD\u6210\u529F",
      "backup file does not exist": "\u5907\u4EFD\u6587\u4EF6\u4E0D\u5B58\u5728",
      "restore failed": "\u6062\u590D\u5931\u8D25",
      "backup file does not contain the version": "\u5907\u4EFD\u538B\u7F29\u5305\u4E2D\u672A\u627E\u5230\u6761\u76EE",
      "restore success": "\u6062\u590D\u6210\u529F",
      "please restart Obsidian to apply changes": "\u8BF7\u91CD\u542F Obsidian \u4EE5\u5E94\u7528\u66F4\u6539",
      "cannot locate": "\u65E0\u6CD5\u5B9A\u4F4D",
      "entry is not associated with a source file": "\u6761\u76EE\u672A\u5173\u8054\u6E90\u6587\u4EF6",
      "source file not found": "\u672A\u627E\u5230\u6E90\u6587\u4EF6",
      "cannot navigate": "\u65E0\u6CD5\u5BFC\u822A",
      "video entry format is incorrect": "\u89C6\u9891\u6761\u76EE\u683C\u5F0F\u4E0D\u6B63\u786E",
      "unsupported entry type or missing necessary information": "\u4E0D\u652F\u6301\u7684\u6761\u76EE\u7C7B\u578B\u6216\u7F3A\u5C11\u5FC5\u8981\u4FE1\u606F",
      "cannot open sidebar view": "\u65E0\u6CD5\u6253\u5F00\u4FA7\u8FB9\u680F\u89C6\u56FE",
      "selected entry": "\u5DF2\u9009\u62E9\u6761\u76EE",
      "please right click another entry to establish a link": "\u8BF7\u53F3\u51FB\u53E6\u4E00\u4E2A\u6761\u76EE\u5EFA\u7ACB\u94FE\u63A5",
      "cannot link to itself": "\u4E0D\u80FD\u4E0E\u81EA\u8EAB\u5EFA\u7ACB\u94FE\u63A5",
      "linking operation cancelled": "\u94FE\u63A5\u64CD\u4F5C\u5DF2\u53D6\u6D88",
      "cannot find entry": "\u627E\u4E0D\u5230\u6761\u76EE",
      "link already exists": "\u94FE\u63A5\u5DF2\u5B58\u5728",
      "link established successfully": "\u5DF2\u6210\u529F\u5EFA\u7ACB\u94FE\u63A5",
      "link establishment failed": "\u5EFA\u7ACB\u94FE\u63A5\u5931\u8D25",
      "link removed successfully": "\u5DF2\u6210\u529F\u79FB\u9664\u94FE\u63A5",
      "link removal failed": "\u79FB\u9664\u94FE\u63A5\u5931\u8D25",
      "copied to clipboard": "\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
      "copy failed": "\u590D\u5236\u5931\u8D25",
      "image exported": "\u56FE\u7247\u5DF2\u5BFC\u51FA",
      "export image failed": "\u5BFC\u51FA\u56FE\u7247\u5931\u8D25",
      "copy link": "\u590D\u5236\u94FE\u63A5",
      "copy card": "\u590D\u5236\u5361\u7247",
      "export image": "\u5BFC\u51FA\u56FE\u7247",
      "no file path specified": "\u672A\u6307\u5B9A\u6587\u4EF6\u8DEF\u5F84",
      "no hash value specified": "\u672A\u6307\u5B9A\u54C8\u5E0C\u503C",
      "file not found": "\u672A\u627E\u5230\u6587\u4EF6",
      "cannot get active editor": "\u65E0\u6CD5\u83B7\u53D6\u6D3B\u52A8\u7F16\u8F91\u5668",
      "current view is not markdown view": "\u5F53\u524D\u89C6\u56FE\u4E0D\u662F Markdown \u89C6\u56FE",
      "entry not found": "\u672A\u627E\u5230\u6761\u76EE",
      "hash link processing failed": "\u5904\u7406\u54C8\u5E0C\u94FE\u63A5\u5931\u8D25",
      "video link not found": "\u672A\u627E\u5230\u89C6\u9891\u94FE\u63A5",
      "video link processing failed": "\u5904\u7406\u89C6\u9891\u94FE\u63A5\u5931\u8D25",
      "load settings failed": "\u52A0\u8F7D\u8BBE\u7F6E\u5931\u8D25",
      "save settings failed": "\u4FDD\u5B58\u8BBE\u7F6E\u5931\u8D25",
      "save data failed": "\u4FDD\u5B58\u6570\u636E\u5931\u8D25",
      "load data failed": "\u52A0\u8F7D\u6570\u636E\u5931\u8D25",
      "need to select only one entry": "\u9700\u8981\u540C\u65F6\u9009\u62E9\u4E14\u4EC5\u9009\u62E9\u4E00\u4E2A\u6761\u76EE",
      "need to input query content": "\u9700\u8981\u8F93\u5165\u67E5\u8BE2\u5185\u5BB9",
      "AI request failed": "AI \u8BF7\u6C42\u5931\u8D25",
      "please check network or API configuration": "\u8BF7\u68C0\u67E5\u7F51\u7EDC\u6216 API \u914D\u7F6E",
      "please select a set first": "\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u96C6\u5408\u540E\u518D\u8FDB\u884C\u77E9\u5F62\u622A\u53D6",
      "current view is not pdf view": "\u5F53\u524D\u89C6\u56FE\u4E0D\u662F PDF \u89C6\u56FE",
      "save cropped png failed": "\u4FDD\u5B58\u622A\u56FE\u5931\u8D25",
      "RAG indexing progress": "RAG \u7D22\u5F15\u8FDB\u5EA6",
      "RAG indexing completed": "RAG \u7D22\u5F15\u5B8C\u6210",
      "save RAG database failed": "\u4FDD\u5B58 RAG \u6570\u636E\u5E93\u5931\u8D25",
      "file path updated for entries": "\u5DF2\u4E3A {{count}} \u4E2A\u6761\u76EE\u66F4\u65B0\u6587\u4EF6\u8DEF\u5F84",
      "failed to update file paths": "\u66F4\u65B0\u6587\u4EF6\u8DEF\u5F84\u5931\u8D25",
      // modal ui
      "Front": "\u6B63\u9762",
      "Back": "\u53CD\u9762",
      "Collection": "\u96C6\u5408",
      "Tags": "\u6807\u7B7E",
      "Attachments": "\u9644\u4EF6",
      "add your comments...": "\u6DFB\u52A0\u4F60\u7684\u6279\u6CE8...",
      "add custom tags...": "\u6DFB\u52A0\u81EA\u5B9A\u4E49\u6807\u7B7E...",
      "add": "\u6DFB\u52A0",
      "cancel": "\u53D6\u6D88",
      "save changes": "\u4FDD\u5B58\u4FEE\u6539",
      "save annotation": "\u4FDD\u5B58\u6807\u6CE8",
      "save failed": "\u4FDD\u5B58\u5931\u8D25",
      "please select a collection": "\u8BF7\u9009\u62E9\u4E00\u4E2A\u96C6\u5408",
      "attachment image": "\u9644\u4EF6\u56FE\u7247",
      "no backups found": "\u672A\u627E\u5230\u4EFB\u4F55\u5907\u4EFD\u6587\u4EF6",
      "restore": "\u6062\u590D",
      "confirm restore": "\u60A8\u786E\u5B9A\u8981\u4ECE\u6B64\u7248\u672C\u6062\u590D\u5417\uFF1F",
      "this will overwrite all data and cannot be undone": "\u8FD9\u5C06\u8986\u76D6\u5F53\u524D\u6240\u6709\u6570\u636E\u4E14\u65E0\u6CD5\u64A4\u9500\uFF01",
      "auto": "\u81EA\u52A8",
      "manual": "\u624B\u52A8",
      "set(s)": "\u4E2A\u96C6\u5408",
      "entries": "\u4E2A\u6761\u76EE",
      "confirm-delete": "\u786E\u8BA4\u5220\u9664",
      "name": "\u540D\u79F0",
      "color": "\u989C\u8272",
      "type": "\u7C7B\u578B",
      "set": "\u96C6\u5408",
      "folder": "\u6587\u4EF6\u5939",
      "bind plan": "\u7ED1\u5B9A\u590D\u4E60\u8BA1\u5212",
      "move to": "\u79FB\u52A8\u5230",
      "root": "\u6839\u76EE\u5F55",
      "create": "\u521B\u5EFA",
      "save": "\u4FDD\u5B58",
      "collection name cannot be empty": "\u96C6\u5408\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
      "FSRS 17 weights adjustment": "FSRS 17 \u7EF4\u6743\u91CD\u8C03\u6574",
      "each item corresponds to w0-w16 in the paper. click save to take effect immediately.": "\u6BCF\u4E00\u9879\u5BF9\u5E94\u8BBA\u6587\u4E2D\u7684 w0-w16\u3002\u4FEE\u6539\u540E\u70B9\u51FB\u4FDD\u5B58\u7ACB\u5373\u751F\u6548\u3002",
      "reset default": "\u91CD\u7F6E\u9ED8\u8BA4",
      "close": "\u5173\u95ED",
      "cannot get canvas context": "\u65E0\u6CD5\u83B7\u53D6 Canvas \u4E0A\u4E0B\u6587",
      "linked entries": "\u94FE\u63A5\u5173\u7CFB",
      "current entry": "\u5F53\u524D\u6761\u76EE",
      "no linked entries": "\u6CA1\u6709\u94FE\u63A5\u7684\u6761\u76EE",
      "navigate to entry": "\u5BFC\u822A\u5230\u6761\u76EE",
      "remove link": "\u79FB\u9664\u94FE\u63A5",
      "confirm delete plan": "\u786E\u5B9A\u8981\u5220\u9664\u8BA1\u5212",
      "In how many days will review again after remembered last time": "\u672C\u6B21\u8BB0\u5F97\u540E\uFF0C\u591A\u5C11\u5929\u540E\u590D\u4E60",
      "last remembered": "\u4E0A\u6B21\u8BB0\u5F97",
      "FSRS for advanced intervals": "\u9AD8\u7EA7\u95F4\u9694\u4F7F\u7528 FSRS",
      "Random intervals (proficiency > 5)": "\u968F\u673A\u95F4\u9694 (\u719F\u7EC3\u5EA6>5)",
      "min value": "\u6700\u5C0F\u503C",
      "max value": "\u6700\u5927\u503C",
      "confirm": "\u786E\u8BA4",
      "AI preset prompt": "AI \u9884\u8BBE\u63D0\u793A\u8BCD",
      "create and manage your AI conversation preset prompts": "\u521B\u5EFA\u548C\u7BA1\u7406\u4F60\u7684 AI \u5BF9\u8BDD\u9884\u8BBE\u63D0\u793A\u8BCD",
      "preset list": "\u9884\u8BBE\u5217\u8868",
      "add new preset": "\u6DFB\u52A0\u65B0\u9884\u8BBE",
      "unnamed preset": "\u672A\u547D\u540D\u9884\u8BBE",
      "empty preset": "\u7A7A\u767D\u63D0\u793A\u8BCD",
      "delete preset": "\u5220\u9664\u9884\u8BBE",
      "preset name": "\u9884\u8BBE\u540D\u79F0",
      "input preset name": "\u8F93\u5165\u9884\u8BBE\u540D\u79F0",
      "preset content": "\u9884\u8BBE\u5185\u5BB9",
      "input preset content": "\u8F93\u5165\u9884\u8BBE\u5185\u5BB9",
      "new preset": "\u65B0\u9884\u8BBE",
      "total": "\u5171",
      "cards": "\u5F20\u5361\u7247",
      "cancel select all": "\u53D6\u6D88\u5168\u9009",
      "select all": "\u5168\u9009",
      "start review": "\u5F00\u59CB\u590D\u4E60",
      "review content will be shown here": "\u8FD9\u91CC\u663E\u793A\u9700\u8981\u590D\u4E60\u7684\u5185\u5BB9",
      "context": "\u8BED\u5883",
      "edit": "\u7F16\u8F91",
      "view": "\u67E5\u770B",
      "review completed": "\u{1F389} \u590D\u4E60\u5B8C\u6210\uFF01",
      "no matching results": "\u65E0\u5339\u914D\u7ED3\u679C",
      "search result jump failed": "\u641C\u7D22\u7ED3\u679C\u8DF3\u8F6C\u5931\u8D25",
      "current search range: this file": "\u5F53\u524D\u641C\u7D22\u8303\u56F4\uFF1A\u672C\u6587\u4EF6",
      "current search range: this collection": "\u5F53\u524D\u641C\u7D22\u8303\u56F4\uFF1A\u672C\u96C6\u5408",
      "current search range: all collections": "\u5F53\u524D\u641C\u7D22\u8303\u56F4\uFF1A\u6240\u6709\u96C6\u5408",
      "current search range: all collections in this folder": "\u5F53\u524D\u641C\u7D22\u8303\u56F4\uFF1A\u672C\u76EE\u5F55\u4E2D\u6240\u6709\u96C6\u5408",
      "home": "\u9996\u9875",
      "comments": "\u8BC4\u8BBA",
      "review": "\u590D\u4E60",
      "plan": "\u8BA1\u5212",
      "collection details": "\u96C6\u5408\u8BE6\u60C5",
      "no annotation in this file": "\u5F53\u524D\u6587\u4EF6\u6682\u65E0\u6807\u6CE8",
      // Settings
      "General notes settings": "\u5E38\u89C4\u7B14\u8BB0\u8BBE\u7F6E",
      "data backup": "\u6570\u636E\u5907\u4EFD",
      "backup now": "\u7ACB\u5373\u5907\u4EFD",
      "restore data": "\u6062\u590D\u6570\u636E",
      "search context length": "\u641C\u7D22\u4E0A\u4E0B\u6587\u957F\u5EA6",
      "pdf highlight opacity": "PDF \u9AD8\u4EAE\u900F\u660E\u5EA6",
      "pdf highlight mode": "PDF\u9AD8\u4EAE\u6A21\u5F0F",
      "embedded highlight": "\u5185\u5D4C\u9AD8\u4EAE",
      "layer highlight": "\u56FE\u5C42\u9AD8\u4EAE",
      "pdf link template": "PDF\u94FE\u63A5\u6A21\u677F",
      "markdown link template": "Markdown\u94FE\u63A5\u6A21\u677F",
      "video link template": "Video\u94FE\u63A5\u6A21\u677F",
      "card template": "\u5361\u7247\u6A21\u677F",
      "html export template": "HTML\u5BFC\u51FA\u6A21\u677F",
      "reset all templates": "\u91CD\u7F6E\u6240\u6709\u6A21\u677F",
      "fsrs target retention rate": "FSRS \u76EE\u6807\u8BB0\u5FC6\u4FDD\u6301\u7387",
      "the probability of remembering the target on the next review; the higher the value, the shorter the review interval": "\u4E0B\u4E00\u6B21\u590D\u4E60\u65F6\u4ECD\u8BB0\u4F4F\u7684\u76EE\u6807\u6982\u7387\uFF1B\u503C\u8D8A\u9AD8\uFF0C\u590D\u4E60\u95F4\u9694\u8D8A\u77ED",
      "fsrs maximum interval": "FSRS \u6700\u5927\u95F4\u9694 (\u5929)",
      "maximum_interval: the maximum review interval allowed to prevent the interval from extending indefinitely": "maximum_interval\uFF1A\u5141\u8BB8\u7684\u6700\u5927\u590D\u4E60\u95F4\u9694\uFF0C\u9632\u6B62\u95F4\u9694\u65E0\u9650\u5EF6\u957F",
      "fsrs detailed weights": "FSRS \u8BE6\u7EC6\u6743\u91CD",
      "AI service (OpenAI compatible)": "AI \u670D\u52A1 (OpenAI \u517C\u5BB9)",
      "enable ai function": "\u542F\u7528 AI \u529F\u80FD",
      "need activation": "\u9700\u6FC0\u6D3B",
      "base url": "Base URL",
      "interface base address, such as https://api.openai.com/v1": "\u63A5\u53E3\u57FA\u7840\u5730\u5740\uFF0C\u5982 https://api.openai.com/v1",
      "api key": "API Key",
      "bearer token": "Bearer Token",
      "default model name": "\u6A21\u578B\u540D\u79F0",
      "gpt-4o is recommended": "\u63A8\u8350 gpt-4o",
      "test connection": "\u8FDE\u63A5\u6D4B\u8BD5",
      "display available model list": "\u663E\u793A\u53EF\u7528\u6A21\u578B\u5217\u8868",
      "test": "\u6D4B\u8BD5",
      "ai preset prompt": "AI \u9884\u8BBE\u63D0\u793A\u8BCD",
      "manage common prompt, can be quickly selected in the chat input box through /": "\u7BA1\u7406\u5E38\u7528 prompt\uFF0C\u53EF\u5728\u804A\u5929\u8F93\u5165\u6846\u4E2D\u901A\u8FC7 / \u5FEB\u901F\u9009\u62E9",
      "manage": "\u7BA1\u7406",
      "embedding model": "Embedding Model",
      "RAG embedding settings": "RAG \u5D4C\u5165\u8BBE\u7F6E",
      "text-embedding-3-small is recommended": "\u63A8\u8350 text-embedding-3-small",
      "embedding base url": "\u5D4C\u5165\u6A21\u578B Base URL",
      "embedding api key": "\u5D4C\u5165\u6A21\u578B API Key",
      "minimum similarity threshold": "\u6700\u5C0F\u76F8\u4F3C\u5EA6\u9608\u503C",
      "the larger the value, the higher the result similarity; too high may result in no results; should not exceed 0.4": "\u503C\u8D8A\u5927\u7ED3\u679C\u76F8\u4F3C\u5EA6\u8D8A\u9AD8\uFF0C\u8FC7\u9AD8\u53EF\u80FD\u5BFC\u81F4\u65E0\u7ED3\u679C\uFF0C\u4E0D\u5E94\u8BE5\u8D85\u8FC70.4",
      "license": "\u6388\u6743",
      "please input activation code": "\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801",
      "input activation code and click 'activate' button": "\u8F93\u5165\u6FC0\u6D3B\u7801\u540E\u70B9\u51FB'\u6FC0\u6D3B'\u6309\u94AE",
      "activation code": "\u6FC0\u6D3B\u7801",
      "activate": "\u6FC0\u6D3B",
      "current license status": "\u5F53\u524D\u6388\u6743\u72B6\u6001",
      "unbind": "\u89E3\u7ED1",
      "Data backup and restore": "\u6570\u636E\u5907\u4EFD\u4E0E\u6062\u590D",
      "BetterNotes settings": "BetterNotes \u8BBE\u7F6E",
      // buttons
      "open": "\u6253\u5F00",
      "reset": "\u91CD\u7F6E",
      // commands
      "open-BetterNotes-sidebar": "\u6253\u5F00BetterNotes\u4FA7\u8FB9\u680F",
      "open-ai-chat-sidebar": "\u6253\u5F00AI\u804A\u5929\u4FA7\u8FB9\u680F",
      "AI assistant": "AI\u52A9\u624B",
      "toggle-md-immediate-annotation": "\u5207\u6362Markdown\u5373\u65F6\u6807\u6CE8",
      "open local video": "\u6253\u5F00\u672C\u5730\u89C6\u9891",
      "index-vault": "\u7D22\u5F15\u5E93 (\u589E\u91CF)",
      "reindex-vault": "\u5F3A\u5236\u91CD\u65B0\u7D22\u5F15\u5E93",
      "index-notes": "\u7D22\u5F15\u6240\u6709\u6761\u76EE (\u589E\u91CF)",
      "reindex-notes": "\u5F3A\u5236\u91CD\u65B0\u7D22\u5F15\u6240\u6709\u6761\u76EE",
      "cancel-internal-linking": "\u53D6\u6D88\u5185\u90E8\u94FE\u63A5\u64CD\u4F5C",
      "capture-pdf-rectangle": "PDF \u77E9\u5F62\u622A\u53D6\u5E76\u4FDD\u5B58\u56FE\u7247",
      "no file opened": "\u672A\u6253\u5F00\u4EFB\u4F55\u6587\u4EF6"
    };
  }
});

// src/i18n/index.ts
function t(key) {
  const locale = import_obsidian.moment.locale();
  const currentTranslations = locale.startsWith("zh") ? translations.zh : translations.en;
  const translation = currentTranslations[key];
  if (translation) {
    return translation;
  }
  return key;
}
var import_obsidian, translations;
var init_i18n = __esm({
  "src/i18n/index.ts"() {
    import_obsidian = require("obsidian");
    init_en();
    init_zh();
    translations = {
      en: en_default,
      zh: zh_default
    };
  }
});

// src/services/AttachmentService.ts
var AttachmentService_exports = {};
__export(AttachmentService_exports, {
  AttachmentService: () => AttachmentService
});
var import_obsidian8, AttachmentService;
var init_AttachmentService = __esm({
  "src/services/AttachmentService.ts"() {
    import_obsidian8 = require("obsidian");
    init_utils();
    init_i18n();
    AttachmentService = class {
      /**
       * 构造函数
       * @param app Obsidian应用实例
       */
      constructor(app) {
        this.app = app;
      }
      /**
       * 获取附件文件夹路径
       * @returns 附件文件夹路径，如果未设置则返回根目录
       */
      getAttachmentFolderPath() {
        let basePath = "";
        try {
          basePath = this.app.vault.config?.attachmentFolderPath || "";
        } catch (error2) {
          console.error("\u65E0\u6CD5\u83B7\u53D6\u9644\u4EF6\u6587\u4EF6\u5939\u8DEF\u5F84:", error2);
          basePath = "";
        }
        if (!basePath || basePath === "/" || basePath === "./" || basePath === ".") {
          return "/";
        }
        return basePath.startsWith("/") ? basePath : `/${basePath}`;
      }
      /**
       * 处理粘贴的图片数据
       * @param event 剪贴板事件
       * @returns Promise<string[]> 保存的图片路径数组
       */
      async handlePastedImages(event) {
        const savedPaths = [];
        if (!event.clipboardData) {
          return savedPaths;
        }
        const files = Array.from(event.clipboardData.files);
        const imageFiles = files.filter((file) => file.type.startsWith("image/"));
        if (imageFiles.length === 0) {
          return savedPaths;
        }
        const attachmentFolderPath = this.getAttachmentFolderPath();
        for (const file of imageFiles) {
          try {
            const fileExt = this.getFileExtFromMimeType(file.type);
            const fileName = `pasted-image-${generateHash()}-back${fileExt}`;
            const filePath = attachmentFolderPath === "/" ? fileName : `${attachmentFolderPath}/${fileName}`;
            await this.ensureFolderExists(attachmentFolderPath);
            const buffer = await file.arrayBuffer();
            await this.app.vault.createBinary(filePath, buffer);
            savedPaths.push(filePath);
          } catch (error2) {
            console.error("\u4FDD\u5B58\u7C98\u8D34\u7684\u56FE\u7247\u5931\u8D25:", error2);
            new import_obsidian8.Notice(t("save image failed") + ": " + error2.message);
          }
        }
        return savedPaths;
      }
      /**
       * 确保文件夹存在，如果不存在则创建
       * @param folderPath 文件夹路径
       */
      async ensureFolderExists(folderPath) {
        if (folderPath === "/" || await this.app.vault.adapter.exists(folderPath)) {
          return;
        }
        try {
          await this.app.vault.createFolder(folderPath);
        } catch (error2) {
          if (!error2.message.includes("already exists")) {
            throw error2;
          }
        }
      }
      /**
       * 根据MIME类型获取文件扩展名
       * @param mimeType MIME类型
       * @returns 文件扩展名（带点）
       */
      getFileExtFromMimeType(mimeType) {
        const mimeToExt = {
          "image/jpeg": ".jpg",
          "image/png": ".png",
          "image/gif": ".gif",
          "image/webp": ".webp",
          "image/svg+xml": ".svg",
          "image/bmp": ".bmp",
          "image/tiff": ".tiff"
        };
        return mimeToExt[mimeType] || ".png";
      }
      /**
       * 将任意二进制数据保存到用户配置的附件目录。
       *
       * 1. 自动解析 Obsidian 配置中的 `attachmentFolderPath`；
       * 2. 若目录不存在则自动创建；
       * 3. 最终返回相对 Vault 根目录的保存路径，供 Markdown 引用。
       *
       * @param fileName   文件名（不含目录）。由调用方负责保证其合法性和唯一性。
       * @param data       文件内容的 ArrayBuffer。
       * @returns          保存后的相对路径，例如 `assets/img.png` 或 `img.png`。
       */
      async saveBinaryAttachment(fileName, data) {
        if (!fileName)
          throw new Error("fileName is required");
        const attachmentFolderPath = this.getAttachmentFolderPath();
        const targetPath = attachmentFolderPath === "/" ? fileName : `${attachmentFolderPath}/${fileName}`;
        await this.ensureFolderExists(attachmentFolderPath);
        await this.app.vault.createBinary(targetPath, data);
        return targetPath;
      }
    };
  }
});

// src/services/fsrs/FSRSTypes.ts
var FSRS_RATING, DEFAULT_FSRS_PARAMETERS;
var init_FSRSTypes = __esm({
  "src/services/fsrs/FSRSTypes.ts"() {
    FSRS_RATING = {
      AGAIN: 1,
      HARD: 2,
      GOOD: 3,
      EASY: 4
    };
    DEFAULT_FSRS_PARAMETERS = {
      request_retention: 0.9,
      maximum_interval: 36500,
      w: [0.4872, 1.4003, 3.7145, 13.8206, 5.1618, 1.2298, 0.8975, 0.031, 1.6474, 0.1367, 1.0461, 2.1072, 0.0793, 0.3246, 1.587, 0.2272, 2.8755]
    };
  }
});

// src/components/SetSelectionBar.ts
var SetSelectionBar_exports = {};
__export(SetSelectionBar_exports, {
  SetSelectionBar: () => SetSelectionBar
});
var SetSelectionBar;
var init_SetSelectionBar = __esm({
  "src/components/SetSelectionBar.ts"() {
    SetSelectionBar = class {
      constructor(parent, plugin, service) {
        this.parent = parent;
        this.plugin = plugin;
        this.service = service;
        this.render();
        this.service.onChange(() => this.updateSelectedStyle());
      }
      /**
       * 创建容器并首次渲染。
       */
      render() {
        this.container = this.parent.createDiv("BetterNotes-set-selection-bar");
        this.container.style.display = "flex";
        this.container.style.flexWrap = "nowrap";
        this.container.style.gap = "8px";
        this.container.style.overflowX = "visible";
        this.container.style.marginBottom = "4px";
        this.renderBlocks();
      }
      /** 重新渲染色块列表 */
      renderBlocks() {
        this.container.empty();
        const sets = this.getSets();
        sets.forEach((set) => {
          const block = this.container.createDiv("BetterNotes-set-block");
          block.setAttr("title", set.name);
          block.style.backgroundColor = set.color;
          block.dataset.setName = set.name;
          block.addEventListener("click", () => {
            this.service.select(set.name);
            this.updateSelectedStyle();
          });
        });
        this.updateSelectedStyle();
      }
      /**
       * 获取所有 type === 'set' 的集合
       */
      getSets() {
        return this.plugin.dataManager.getAllCollections().filter((c2) => c2.type === "set");
      }
      /**
       * 根据当前选中状态更新样式
       */
      updateSelectedStyle() {
        const selected = this.service.getSelected();
        this.container.querySelectorAll(".BetterNotes-set-block").forEach((el) => {
          if (el.dataset.setName === selected) {
            el.classList.add("selected");
            el.style.outline = "2px solid #fff";
          } else {
            el.classList.remove("selected");
            el.style.outline = "none";
          }
        });
      }
      /** 提供外部调用，用于在集合变动后刷新视图 */
      refresh() {
        this.renderBlocks();
      }
    };
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p5 in source) {
          if (_has(source, p5)) {
            obj[p5] = source[p5];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i3, l4, len, pos, chunk, result;
        len = 0;
        for (i3 = 0, l4 = chunks.length; i3 < l4; i3++) {
          len += chunks[i3].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i3 = 0, l4 = chunks.length; i3 < l4; i3++) {
          chunk = chunks[i3];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on2) {
      if (on2) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s5, w6) {
      s5.pending_buf[s5.pending++] = w6 & 255;
      s5.pending_buf[s5.pending++] = w6 >>> 8 & 255;
    }
    function send_bits(s5, value, length) {
      if (s5.bi_valid > Buf_size - length) {
        s5.bi_buf |= value << s5.bi_valid & 65535;
        put_short(s5, s5.bi_buf);
        s5.bi_buf = value >> Buf_size - s5.bi_valid;
        s5.bi_valid += length - Buf_size;
      } else {
        s5.bi_buf |= value << s5.bi_valid & 65535;
        s5.bi_valid += length;
      }
    }
    function send_code(s5, c2, tree) {
      send_bits(
        s5,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s5) {
      if (s5.bi_valid === 16) {
        put_short(s5, s5.bi_buf);
        s5.bi_buf = 0;
        s5.bi_valid = 0;
      } else if (s5.bi_valid >= 8) {
        s5.pending_buf[s5.pending++] = s5.bi_buf & 255;
        s5.bi_buf >>= 8;
        s5.bi_valid -= 8;
      }
    }
    function gen_bitlen(s5, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h3;
      var n3, m5;
      var bits;
      var xbits;
      var f3;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s5.bl_count[bits] = 0;
      }
      tree[s5.heap[s5.heap_max] * 2 + 1] = 0;
      for (h3 = s5.heap_max + 1; h3 < HEAP_SIZE; h3++) {
        n3 = s5.heap[h3];
        bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n3 * 2 + 1] = bits;
        if (n3 > max_code) {
          continue;
        }
        s5.bl_count[bits]++;
        xbits = 0;
        if (n3 >= base) {
          xbits = extra[n3 - base];
        }
        f3 = tree[n3 * 2];
        s5.opt_len += f3 * (bits + xbits);
        if (has_stree) {
          s5.static_len += f3 * (stree[n3 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s5.bl_count[bits] === 0) {
          bits--;
        }
        s5.bl_count[bits]--;
        s5.bl_count[bits + 1] += 2;
        s5.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n3 = s5.bl_count[bits];
        while (n3 !== 0) {
          m5 = s5.heap[--h3];
          if (m5 > max_code) {
            continue;
          }
          if (tree[m5 * 2 + 1] !== bits) {
            s5.opt_len += (bits - tree[m5 * 2 + 1]) * tree[m5 * 2];
            tree[m5 * 2 + 1] = bits;
          }
          n3--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n3;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n3 = 0; n3 <= max_code; n3++) {
        var len = tree[n3 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n3 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n3;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n3 = 0;
      while (n3 <= 143) {
        static_ltree[n3 * 2 + 1] = 8;
        n3++;
        bl_count[8]++;
      }
      while (n3 <= 255) {
        static_ltree[n3 * 2 + 1] = 9;
        n3++;
        bl_count[9]++;
      }
      while (n3 <= 279) {
        static_ltree[n3 * 2 + 1] = 7;
        n3++;
        bl_count[7]++;
      }
      while (n3 <= 287) {
        static_ltree[n3 * 2 + 1] = 8;
        n3++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n3 = 0; n3 < D_CODES; n3++) {
        static_dtree[n3 * 2 + 1] = 5;
        static_dtree[n3 * 2] = bi_reverse(n3, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s5) {
      var n3;
      for (n3 = 0; n3 < L_CODES; n3++) {
        s5.dyn_ltree[n3 * 2] = 0;
      }
      for (n3 = 0; n3 < D_CODES; n3++) {
        s5.dyn_dtree[n3 * 2] = 0;
      }
      for (n3 = 0; n3 < BL_CODES; n3++) {
        s5.bl_tree[n3 * 2] = 0;
      }
      s5.dyn_ltree[END_BLOCK * 2] = 1;
      s5.opt_len = s5.static_len = 0;
      s5.last_lit = s5.matches = 0;
    }
    function bi_windup(s5) {
      if (s5.bi_valid > 8) {
        put_short(s5, s5.bi_buf);
      } else if (s5.bi_valid > 0) {
        s5.pending_buf[s5.pending++] = s5.bi_buf;
      }
      s5.bi_buf = 0;
      s5.bi_valid = 0;
    }
    function copy_block(s5, buf, len, header) {
      bi_windup(s5);
      if (header) {
        put_short(s5, len);
        put_short(s5, ~len);
      }
      utils.arraySet(s5.pending_buf, s5.window, buf, len, s5.pending);
      s5.pending += len;
    }
    function smaller(tree, n3, m5, depth) {
      var _n2 = n3 * 2;
      var _m2 = m5 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m5];
    }
    function pqdownheap(s5, tree, k5) {
      var v4 = s5.heap[k5];
      var j4 = k5 << 1;
      while (j4 <= s5.heap_len) {
        if (j4 < s5.heap_len && smaller(tree, s5.heap[j4 + 1], s5.heap[j4], s5.depth)) {
          j4++;
        }
        if (smaller(tree, v4, s5.heap[j4], s5.depth)) {
          break;
        }
        s5.heap[k5] = s5.heap[j4];
        k5 = j4;
        j4 <<= 1;
      }
      s5.heap[k5] = v4;
    }
    function compress_block(s5, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s5.last_lit !== 0) {
        do {
          dist = s5.pending_buf[s5.d_buf + lx * 2] << 8 | s5.pending_buf[s5.d_buf + lx * 2 + 1];
          lc = s5.pending_buf[s5.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s5, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s5, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s5, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s5, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s5, dist, extra);
            }
          }
        } while (lx < s5.last_lit);
      }
      send_code(s5, END_BLOCK, ltree);
    }
    function build_tree(s5, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n3, m5;
      var max_code = -1;
      var node;
      s5.heap_len = 0;
      s5.heap_max = HEAP_SIZE;
      for (n3 = 0; n3 < elems; n3++) {
        if (tree[n3 * 2] !== 0) {
          s5.heap[++s5.heap_len] = max_code = n3;
          s5.depth[n3] = 0;
        } else {
          tree[n3 * 2 + 1] = 0;
        }
      }
      while (s5.heap_len < 2) {
        node = s5.heap[++s5.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s5.depth[node] = 0;
        s5.opt_len--;
        if (has_stree) {
          s5.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n3 = s5.heap_len >> 1; n3 >= 1; n3--) {
        pqdownheap(s5, tree, n3);
      }
      node = elems;
      do {
        n3 = s5.heap[
          1
          /*SMALLEST*/
        ];
        s5.heap[
          1
          /*SMALLEST*/
        ] = s5.heap[s5.heap_len--];
        pqdownheap(
          s5,
          tree,
          1
          /*SMALLEST*/
        );
        m5 = s5.heap[
          1
          /*SMALLEST*/
        ];
        s5.heap[--s5.heap_max] = n3;
        s5.heap[--s5.heap_max] = m5;
        tree[node * 2] = tree[n3 * 2] + tree[m5 * 2];
        s5.depth[node] = (s5.depth[n3] >= s5.depth[m5] ? s5.depth[n3] : s5.depth[m5]) + 1;
        tree[n3 * 2 + 1] = tree[m5 * 2 + 1] = node;
        s5.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s5,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s5.heap_len >= 2);
      s5.heap[--s5.heap_max] = s5.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s5, desc);
      gen_codes(tree, max_code, s5.bl_count);
    }
    function scan_tree(s5, tree, max_code) {
      var n3;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n3 = 0; n3 <= max_code; n3++) {
        curlen = nextlen;
        nextlen = tree[(n3 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s5.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s5.bl_tree[curlen * 2]++;
          }
          s5.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s5.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s5.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s5, tree, max_code) {
      var n3;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n3 = 0; n3 <= max_code; n3++) {
        curlen = nextlen;
        nextlen = tree[(n3 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s5, curlen, s5.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s5, curlen, s5.bl_tree);
            count--;
          }
          send_code(s5, REP_3_6, s5.bl_tree);
          send_bits(s5, count - 3, 2);
        } else if (count <= 10) {
          send_code(s5, REPZ_3_10, s5.bl_tree);
          send_bits(s5, count - 3, 3);
        } else {
          send_code(s5, REPZ_11_138, s5.bl_tree);
          send_bits(s5, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s5) {
      var max_blindex;
      scan_tree(s5, s5.dyn_ltree, s5.l_desc.max_code);
      scan_tree(s5, s5.dyn_dtree, s5.d_desc.max_code);
      build_tree(s5, s5.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s5.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s5.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s5, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s5, lcodes - 257, 5);
      send_bits(s5, dcodes - 1, 5);
      send_bits(s5, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s5, s5.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s5, s5.dyn_ltree, lcodes - 1);
      send_tree(s5, s5.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s5) {
      var black_mask = 4093624447;
      var n3;
      for (n3 = 0; n3 <= 31; n3++, black_mask >>>= 1) {
        if (black_mask & 1 && s5.dyn_ltree[n3 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s5.dyn_ltree[9 * 2] !== 0 || s5.dyn_ltree[10 * 2] !== 0 || s5.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n3 = 32; n3 < LITERALS; n3++) {
        if (s5.dyn_ltree[n3 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s5) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s5.l_desc = new TreeDesc(s5.dyn_ltree, static_l_desc);
      s5.d_desc = new TreeDesc(s5.dyn_dtree, static_d_desc);
      s5.bl_desc = new TreeDesc(s5.bl_tree, static_bl_desc);
      s5.bi_buf = 0;
      s5.bi_valid = 0;
      init_block(s5);
    }
    function _tr_stored_block(s5, buf, stored_len, last2) {
      send_bits(s5, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
      copy_block(s5, buf, stored_len, true);
    }
    function _tr_align(s5) {
      send_bits(s5, STATIC_TREES << 1, 3);
      send_code(s5, END_BLOCK, static_ltree);
      bi_flush(s5);
    }
    function _tr_flush_block(s5, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s5.level > 0) {
        if (s5.strm.data_type === Z_UNKNOWN) {
          s5.strm.data_type = detect_data_type(s5);
        }
        build_tree(s5, s5.l_desc);
        build_tree(s5, s5.d_desc);
        max_blindex = build_bl_tree(s5);
        opt_lenb = s5.opt_len + 3 + 7 >>> 3;
        static_lenb = s5.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s5, buf, stored_len, last2);
      } else if (s5.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s5, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
        compress_block(s5, static_ltree, static_dtree);
      } else {
        send_bits(s5, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
        send_all_trees(s5, s5.l_desc.max_code + 1, s5.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s5, s5.dyn_ltree, s5.dyn_dtree);
      }
      init_block(s5);
      if (last2) {
        bi_windup(s5);
      }
    }
    function _tr_tally(s5, dist, lc) {
      s5.pending_buf[s5.d_buf + s5.last_lit * 2] = dist >>> 8 & 255;
      s5.pending_buf[s5.d_buf + s5.last_lit * 2 + 1] = dist & 255;
      s5.pending_buf[s5.l_buf + s5.last_lit] = lc & 255;
      s5.last_lit++;
      if (dist === 0) {
        s5.dyn_ltree[lc * 2]++;
      } else {
        s5.matches++;
        dist--;
        s5.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s5.dyn_dtree[d_code(dist) * 2]++;
      }
      return s5.last_lit === s5.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n3 = 0;
      while (len !== 0) {
        n3 = len > 2e3 ? 2e3 : len;
        len -= n3;
        do {
          s1 = s1 + buf[pos++] | 0;
          s22 = s22 + s1 | 0;
        } while (--n3);
        s1 %= 65521;
        s22 %= 65521;
      }
      return s1 | s22 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    function makeTable() {
      var c2, table = [];
      for (var n3 = 0; n3 < 256; n3++) {
        c2 = n3;
        for (var k5 = 0; k5 < 8; k5++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n3] = c2;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t2 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i3 = pos; i3 < end; i3++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i3]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err2(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f3) {
      return (f3 << 1) - (f3 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s5 = strm.state;
      var len = s5.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s5.pending_buf, s5.pending_out, len, strm.next_out);
      strm.next_out += len;
      s5.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s5.pending -= len;
      if (s5.pending === 0) {
        s5.pending_out = 0;
      }
    }
    function flush_block_only(s5, last2) {
      trees._tr_flush_block(s5, s5.block_start >= 0 ? s5.block_start : -1, s5.strstart - s5.block_start, last2);
      s5.block_start = s5.strstart;
      flush_pending(s5.strm);
    }
    function put_byte(s5, b4) {
      s5.pending_buf[s5.pending++] = b4;
    }
    function putShortMSB(s5, b4) {
      s5.pending_buf[s5.pending++] = b4 >>> 8 & 255;
      s5.pending_buf[s5.pending++] = b4 & 255;
    }
    function read_buf(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s5, cur_match) {
      var chain_length = s5.max_chain_length;
      var scan = s5.strstart;
      var match;
      var len;
      var best_len = s5.prev_length;
      var nice_match = s5.nice_match;
      var limit = s5.strstart > s5.w_size - MIN_LOOKAHEAD ? s5.strstart - (s5.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s5.window;
      var wmask = s5.w_mask;
      var prev = s5.prev;
      var strend = s5.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s5.prev_length >= s5.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s5.lookahead) {
        nice_match = s5.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s5.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s5.lookahead) {
        return best_len;
      }
      return s5.lookahead;
    }
    function fill_window(s5) {
      var _w_size = s5.w_size;
      var p5, n3, m5, more, str;
      do {
        more = s5.window_size - s5.lookahead - s5.strstart;
        if (s5.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s5.window, s5.window, _w_size, _w_size, 0);
          s5.match_start -= _w_size;
          s5.strstart -= _w_size;
          s5.block_start -= _w_size;
          n3 = s5.hash_size;
          p5 = n3;
          do {
            m5 = s5.head[--p5];
            s5.head[p5] = m5 >= _w_size ? m5 - _w_size : 0;
          } while (--n3);
          n3 = _w_size;
          p5 = n3;
          do {
            m5 = s5.prev[--p5];
            s5.prev[p5] = m5 >= _w_size ? m5 - _w_size : 0;
          } while (--n3);
          more += _w_size;
        }
        if (s5.strm.avail_in === 0) {
          break;
        }
        n3 = read_buf(s5.strm, s5.window, s5.strstart + s5.lookahead, more);
        s5.lookahead += n3;
        if (s5.lookahead + s5.insert >= MIN_MATCH) {
          str = s5.strstart - s5.insert;
          s5.ins_h = s5.window[str];
          s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[str + 1]) & s5.hash_mask;
          while (s5.insert) {
            s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[str + MIN_MATCH - 1]) & s5.hash_mask;
            s5.prev[str & s5.w_mask] = s5.head[s5.ins_h];
            s5.head[s5.ins_h] = str;
            str++;
            s5.insert--;
            if (s5.lookahead + s5.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s5.lookahead < MIN_LOOKAHEAD && s5.strm.avail_in !== 0);
    }
    function deflate_stored(s5, flush) {
      var max_block_size = 65535;
      if (max_block_size > s5.pending_buf_size - 5) {
        max_block_size = s5.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s5.lookahead <= 1) {
          fill_window(s5);
          if (s5.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s5.lookahead === 0) {
            break;
          }
        }
        s5.strstart += s5.lookahead;
        s5.lookahead = 0;
        var max_start = s5.block_start + max_block_size;
        if (s5.strstart === 0 || s5.strstart >= max_start) {
          s5.lookahead = s5.strstart - max_start;
          s5.strstart = max_start;
          flush_block_only(s5, false);
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s5.strstart - s5.block_start >= s5.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s5, false);
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s5.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s5, true);
        if (s5.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s5.strstart > s5.block_start) {
        flush_block_only(s5, false);
        if (s5.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s5, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s5.lookahead < MIN_LOOKAHEAD) {
          fill_window(s5);
          if (s5.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s5.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s5.lookahead >= MIN_MATCH) {
          s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[s5.strstart + MIN_MATCH - 1]) & s5.hash_mask;
          hash_head = s5.prev[s5.strstart & s5.w_mask] = s5.head[s5.ins_h];
          s5.head[s5.ins_h] = s5.strstart;
        }
        if (hash_head !== 0 && s5.strstart - hash_head <= s5.w_size - MIN_LOOKAHEAD) {
          s5.match_length = longest_match(s5, hash_head);
        }
        if (s5.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s5, s5.strstart - s5.match_start, s5.match_length - MIN_MATCH);
          s5.lookahead -= s5.match_length;
          if (s5.match_length <= s5.max_lazy_match && s5.lookahead >= MIN_MATCH) {
            s5.match_length--;
            do {
              s5.strstart++;
              s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[s5.strstart + MIN_MATCH - 1]) & s5.hash_mask;
              hash_head = s5.prev[s5.strstart & s5.w_mask] = s5.head[s5.ins_h];
              s5.head[s5.ins_h] = s5.strstart;
            } while (--s5.match_length !== 0);
            s5.strstart++;
          } else {
            s5.strstart += s5.match_length;
            s5.match_length = 0;
            s5.ins_h = s5.window[s5.strstart];
            s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[s5.strstart + 1]) & s5.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s5, 0, s5.window[s5.strstart]);
          s5.lookahead--;
          s5.strstart++;
        }
        if (bflush) {
          flush_block_only(s5, false);
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s5.insert = s5.strstart < MIN_MATCH - 1 ? s5.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s5, true);
        if (s5.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s5.last_lit) {
        flush_block_only(s5, false);
        if (s5.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s5, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s5.lookahead < MIN_LOOKAHEAD) {
          fill_window(s5);
          if (s5.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s5.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s5.lookahead >= MIN_MATCH) {
          s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[s5.strstart + MIN_MATCH - 1]) & s5.hash_mask;
          hash_head = s5.prev[s5.strstart & s5.w_mask] = s5.head[s5.ins_h];
          s5.head[s5.ins_h] = s5.strstart;
        }
        s5.prev_length = s5.match_length;
        s5.prev_match = s5.match_start;
        s5.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s5.prev_length < s5.max_lazy_match && s5.strstart - hash_head <= s5.w_size - MIN_LOOKAHEAD) {
          s5.match_length = longest_match(s5, hash_head);
          if (s5.match_length <= 5 && (s5.strategy === Z_FILTERED || s5.match_length === MIN_MATCH && s5.strstart - s5.match_start > 4096)) {
            s5.match_length = MIN_MATCH - 1;
          }
        }
        if (s5.prev_length >= MIN_MATCH && s5.match_length <= s5.prev_length) {
          max_insert = s5.strstart + s5.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s5, s5.strstart - 1 - s5.prev_match, s5.prev_length - MIN_MATCH);
          s5.lookahead -= s5.prev_length - 1;
          s5.prev_length -= 2;
          do {
            if (++s5.strstart <= max_insert) {
              s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[s5.strstart + MIN_MATCH - 1]) & s5.hash_mask;
              hash_head = s5.prev[s5.strstart & s5.w_mask] = s5.head[s5.ins_h];
              s5.head[s5.ins_h] = s5.strstart;
            }
          } while (--s5.prev_length !== 0);
          s5.match_available = 0;
          s5.match_length = MIN_MATCH - 1;
          s5.strstart++;
          if (bflush) {
            flush_block_only(s5, false);
            if (s5.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s5.match_available) {
          bflush = trees._tr_tally(s5, 0, s5.window[s5.strstart - 1]);
          if (bflush) {
            flush_block_only(s5, false);
          }
          s5.strstart++;
          s5.lookahead--;
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s5.match_available = 1;
          s5.strstart++;
          s5.lookahead--;
        }
      }
      if (s5.match_available) {
        bflush = trees._tr_tally(s5, 0, s5.window[s5.strstart - 1]);
        s5.match_available = 0;
      }
      s5.insert = s5.strstart < MIN_MATCH - 1 ? s5.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s5, true);
        if (s5.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s5.last_lit) {
        flush_block_only(s5, false);
        if (s5.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s5, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s5.window;
      for (; ; ) {
        if (s5.lookahead <= MAX_MATCH) {
          fill_window(s5);
          if (s5.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s5.lookahead === 0) {
            break;
          }
        }
        s5.match_length = 0;
        if (s5.lookahead >= MIN_MATCH && s5.strstart > 0) {
          scan = s5.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s5.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s5.match_length = MAX_MATCH - (strend - scan);
            if (s5.match_length > s5.lookahead) {
              s5.match_length = s5.lookahead;
            }
          }
        }
        if (s5.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s5, 1, s5.match_length - MIN_MATCH);
          s5.lookahead -= s5.match_length;
          s5.strstart += s5.match_length;
          s5.match_length = 0;
        } else {
          bflush = trees._tr_tally(s5, 0, s5.window[s5.strstart]);
          s5.lookahead--;
          s5.strstart++;
        }
        if (bflush) {
          flush_block_only(s5, false);
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s5.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s5, true);
        if (s5.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s5.last_lit) {
        flush_block_only(s5, false);
        if (s5.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s5, flush) {
      var bflush;
      for (; ; ) {
        if (s5.lookahead === 0) {
          fill_window(s5);
          if (s5.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s5.match_length = 0;
        bflush = trees._tr_tally(s5, 0, s5.window[s5.strstart]);
        s5.lookahead--;
        s5.strstart++;
        if (bflush) {
          flush_block_only(s5, false);
          if (s5.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s5.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s5, true);
        if (s5.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s5.last_lit) {
        flush_block_only(s5, false);
        if (s5.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func2) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func2;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s5) {
      s5.window_size = 2 * s5.w_size;
      zero(s5.head);
      s5.max_lazy_match = configuration_table[s5.level].max_lazy;
      s5.good_match = configuration_table[s5.level].good_length;
      s5.nice_match = configuration_table[s5.level].nice_length;
      s5.max_chain_length = configuration_table[s5.level].max_chain;
      s5.strstart = 0;
      s5.block_start = 0;
      s5.lookahead = 0;
      s5.insert = 0;
      s5.match_length = s5.prev_length = MIN_MATCH - 1;
      s5.match_available = 0;
      s5.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s5;
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s5 = strm.state;
      s5.pending = 0;
      s5.pending_out = 0;
      if (s5.wrap < 0) {
        s5.wrap = -s5.wrap;
      }
      s5.status = s5.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s5.wrap === 2 ? 0 : 1;
      s5.last_flush = Z_NO_FLUSH;
      trees._tr_init(s5);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err2(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s5 = new DeflateState();
      strm.state = s5;
      s5.strm = strm;
      s5.wrap = wrap;
      s5.gzhead = null;
      s5.w_bits = windowBits;
      s5.w_size = 1 << s5.w_bits;
      s5.w_mask = s5.w_size - 1;
      s5.hash_bits = memLevel + 7;
      s5.hash_size = 1 << s5.hash_bits;
      s5.hash_mask = s5.hash_size - 1;
      s5.hash_shift = ~~((s5.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s5.window = new utils.Buf8(s5.w_size * 2);
      s5.head = new utils.Buf16(s5.hash_size);
      s5.prev = new utils.Buf16(s5.w_size);
      s5.lit_bufsize = 1 << memLevel + 6;
      s5.pending_buf_size = s5.lit_bufsize * 4;
      s5.pending_buf = new utils.Buf8(s5.pending_buf_size);
      s5.d_buf = 1 * s5.lit_bufsize;
      s5.l_buf = (1 + 2) * s5.lit_bufsize;
      s5.level = level;
      s5.strategy = strategy;
      s5.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s5;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s5 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s5.status === FINISH_STATE && flush !== Z_FINISH) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s5.strm = strm;
      old_flush = s5.last_flush;
      s5.last_flush = flush;
      if (s5.status === INIT_STATE) {
        if (s5.wrap === 2) {
          strm.adler = 0;
          put_byte(s5, 31);
          put_byte(s5, 139);
          put_byte(s5, 8);
          if (!s5.gzhead) {
            put_byte(s5, 0);
            put_byte(s5, 0);
            put_byte(s5, 0);
            put_byte(s5, 0);
            put_byte(s5, 0);
            put_byte(s5, s5.level === 9 ? 2 : s5.strategy >= Z_HUFFMAN_ONLY || s5.level < 2 ? 4 : 0);
            put_byte(s5, OS_CODE);
            s5.status = BUSY_STATE;
          } else {
            put_byte(
              s5,
              (s5.gzhead.text ? 1 : 0) + (s5.gzhead.hcrc ? 2 : 0) + (!s5.gzhead.extra ? 0 : 4) + (!s5.gzhead.name ? 0 : 8) + (!s5.gzhead.comment ? 0 : 16)
            );
            put_byte(s5, s5.gzhead.time & 255);
            put_byte(s5, s5.gzhead.time >> 8 & 255);
            put_byte(s5, s5.gzhead.time >> 16 & 255);
            put_byte(s5, s5.gzhead.time >> 24 & 255);
            put_byte(s5, s5.level === 9 ? 2 : s5.strategy >= Z_HUFFMAN_ONLY || s5.level < 2 ? 4 : 0);
            put_byte(s5, s5.gzhead.os & 255);
            if (s5.gzhead.extra && s5.gzhead.extra.length) {
              put_byte(s5, s5.gzhead.extra.length & 255);
              put_byte(s5, s5.gzhead.extra.length >> 8 & 255);
            }
            if (s5.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending, 0);
            }
            s5.gzindex = 0;
            s5.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s5.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s5.strategy >= Z_HUFFMAN_ONLY || s5.level < 2) {
            level_flags = 0;
          } else if (s5.level < 6) {
            level_flags = 1;
          } else if (s5.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s5.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s5.status = BUSY_STATE;
          putShortMSB(s5, header);
          if (s5.strstart !== 0) {
            putShortMSB(s5, strm.adler >>> 16);
            putShortMSB(s5, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s5.status === EXTRA_STATE) {
        if (s5.gzhead.extra) {
          beg = s5.pending;
          while (s5.gzindex < (s5.gzhead.extra.length & 65535)) {
            if (s5.pending === s5.pending_buf_size) {
              if (s5.gzhead.hcrc && s5.pending > beg) {
                strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s5.pending;
              if (s5.pending === s5.pending_buf_size) {
                break;
              }
            }
            put_byte(s5, s5.gzhead.extra[s5.gzindex] & 255);
            s5.gzindex++;
          }
          if (s5.gzhead.hcrc && s5.pending > beg) {
            strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
          }
          if (s5.gzindex === s5.gzhead.extra.length) {
            s5.gzindex = 0;
            s5.status = NAME_STATE;
          }
        } else {
          s5.status = NAME_STATE;
        }
      }
      if (s5.status === NAME_STATE) {
        if (s5.gzhead.name) {
          beg = s5.pending;
          do {
            if (s5.pending === s5.pending_buf_size) {
              if (s5.gzhead.hcrc && s5.pending > beg) {
                strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s5.pending;
              if (s5.pending === s5.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s5.gzindex < s5.gzhead.name.length) {
              val = s5.gzhead.name.charCodeAt(s5.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s5, val);
          } while (val !== 0);
          if (s5.gzhead.hcrc && s5.pending > beg) {
            strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
          }
          if (val === 0) {
            s5.gzindex = 0;
            s5.status = COMMENT_STATE;
          }
        } else {
          s5.status = COMMENT_STATE;
        }
      }
      if (s5.status === COMMENT_STATE) {
        if (s5.gzhead.comment) {
          beg = s5.pending;
          do {
            if (s5.pending === s5.pending_buf_size) {
              if (s5.gzhead.hcrc && s5.pending > beg) {
                strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s5.pending;
              if (s5.pending === s5.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s5.gzindex < s5.gzhead.comment.length) {
              val = s5.gzhead.comment.charCodeAt(s5.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s5, val);
          } while (val !== 0);
          if (s5.gzhead.hcrc && s5.pending > beg) {
            strm.adler = crc32(strm.adler, s5.pending_buf, s5.pending - beg, beg);
          }
          if (val === 0) {
            s5.status = HCRC_STATE;
          }
        } else {
          s5.status = HCRC_STATE;
        }
      }
      if (s5.status === HCRC_STATE) {
        if (s5.gzhead.hcrc) {
          if (s5.pending + 2 > s5.pending_buf_size) {
            flush_pending(strm);
          }
          if (s5.pending + 2 <= s5.pending_buf_size) {
            put_byte(s5, strm.adler & 255);
            put_byte(s5, strm.adler >> 8 & 255);
            strm.adler = 0;
            s5.status = BUSY_STATE;
          }
        } else {
          s5.status = BUSY_STATE;
        }
      }
      if (s5.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s5.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err2(strm, Z_BUF_ERROR);
      }
      if (s5.status === FINISH_STATE && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s5.lookahead !== 0 || flush !== Z_NO_FLUSH && s5.status !== FINISH_STATE) {
        var bstate = s5.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s5, flush) : s5.strategy === Z_RLE ? deflate_rle(s5, flush) : configuration_table[s5.level].func(s5, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s5.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s5.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s5);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s5, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s5.head);
              if (s5.lookahead === 0) {
                s5.strstart = 0;
                s5.block_start = 0;
                s5.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s5.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s5.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s5.wrap === 2) {
        put_byte(s5, strm.adler & 255);
        put_byte(s5, strm.adler >> 8 & 255);
        put_byte(s5, strm.adler >> 16 & 255);
        put_byte(s5, strm.adler >> 24 & 255);
        put_byte(s5, strm.total_in & 255);
        put_byte(s5, strm.total_in >> 8 & 255);
        put_byte(s5, strm.total_in >> 16 & 255);
        put_byte(s5, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s5, strm.adler >>> 16);
        putShortMSB(s5, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s5.wrap > 0) {
        s5.wrap = -s5.wrap;
      }
      return s5.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err2(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err2(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s5;
      var str, n3;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s5 = strm.state;
      wrap = s5.wrap;
      if (wrap === 2 || wrap === 1 && s5.status !== INIT_STATE || s5.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s5.wrap = 0;
      if (dictLength >= s5.w_size) {
        if (wrap === 0) {
          zero(s5.head);
          s5.strstart = 0;
          s5.block_start = 0;
          s5.insert = 0;
        }
        tmpDict = new utils.Buf8(s5.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s5.w_size, s5.w_size, 0);
        dictionary = tmpDict;
        dictLength = s5.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s5);
      while (s5.lookahead >= MIN_MATCH) {
        str = s5.strstart;
        n3 = s5.lookahead - (MIN_MATCH - 1);
        do {
          s5.ins_h = (s5.ins_h << s5.hash_shift ^ s5.window[str + MIN_MATCH - 1]) & s5.hash_mask;
          s5.prev[str & s5.w_mask] = s5.head[s5.ins_h];
          s5.head[s5.ins_h] = str;
          str++;
        } while (--n3);
        s5.strstart = str;
        s5.lookahead = MIN_MATCH - 1;
        fill_window(s5);
      }
      s5.strstart += s5.lookahead;
      s5.block_start = s5.strstart;
      s5.insert = s5.lookahead;
      s5.lookahead = 0;
      s5.match_length = s5.prev_length = MIN_MATCH - 1;
      s5.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s5.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q4 = 0; q4 < 256; q4++) {
      _utf8len[q4] = q4 >= 252 ? 6 : q4 >= 248 ? 5 : q4 >= 240 ? 4 : q4 >= 224 ? 3 : q4 >= 192 ? 2 : 1;
    }
    var q4;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c2, c22, m_pos, i3, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i3++] = c2;
        } else if (c2 < 2048) {
          buf[i3++] = 192 | c2 >>> 6;
          buf[i3++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i3++] = 224 | c2 >>> 12;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        } else {
          buf[i3++] = 240 | c2 >>> 18;
          buf[i3++] = 128 | c2 >>> 12 & 63;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i3 = 0; i3 < len; i3++) {
        result += String.fromCharCode(buf[i3]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i3 = 0, len = buf.length; i3 < len; i3++) {
        buf[i3] = str.charCodeAt(i3);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i3, out2, c2, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out2 = 0, i3 = 0; i3 < len; ) {
        c2 = buf[i3++];
        if (c2 < 128) {
          utf16buf[out2++] = c2;
          continue;
        }
        c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out2++] = 65533;
          i3 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i3 < len) {
          c2 = c2 << 6 | buf[i3++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out2++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out2++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out2++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out2++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out2);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start2) {
      var state;
      var _in;
      var last2;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill2;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill2 = 1 << curr;
        min = fill2;
        do {
          fill2 -= incr;
          table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill2 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q4) {
      return (q4 >>> 24 & 255) + (q4 >>> 8 & 65280) + ((q4 & 65280) << 8) + ((q4 & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n3;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n3 = here_bits + 2;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n3 = here_bits + 3;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n3 = here_bits + 7;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n3 = state.extra;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n3 = state.extra;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c2 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c2.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c2.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
        if (status === c2.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c2.Z_BUF_ERROR && allowBufError === true) {
          status = c2.Z_OK;
          allowBufError = false;
        }
        if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
      if (status === c2.Z_STREAM_END) {
        _mode = c2.Z_FINISH;
      }
      if (_mode === c2.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c2.Z_OK;
      }
      if (_mode === c2.Z_SYNC_FLUSH) {
        this.onEnd(c2.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c2.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako5 = {};
    assign(pako5, deflate, inflate, constants);
    module2.exports = pako5;
  }
});

// node_modules/html2canvas/dist/html2canvas.js
var require_html2canvas = __commonJS({
  "node_modules/html2canvas/dist/html2canvas.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.html2canvas = factory());
    })(exports, function() {
      "use strict";
      var extendStatics2 = function(d3, b4) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
          d4.__proto__ = b5;
        } || function(d4, b5) {
          for (var p5 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p5))
              d4[p5] = b5[p5];
        };
        return extendStatics2(d3, b4);
      };
      function __extends2(d3, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics2(d3, b4);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      }
      var __assign2 = function() {
        __assign2 = Object.assign || function __assign3(t2) {
          for (var s5, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
            s5 = arguments[i4];
            for (var p5 in s5)
              if (Object.prototype.hasOwnProperty.call(s5, p5))
                t2[p5] = s5[p5];
          }
          return t2;
        };
        return __assign2.apply(this, arguments);
      };
      function __awaiter2(thisArg, _arguments, P6, generator) {
        function adopt(value) {
          return value instanceof P6 ? value : new P6(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P6 || (P6 = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator2(thisArg, body2) {
        var _3 = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f4, y4, t2, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n3) {
          return function(v4) {
            return step([n3, v4]);
          };
        }
        function step(op) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (_3)
            try {
              if (f4 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
                return t2;
              if (y4 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _3.label++;
                  return { value: op[1], done: false };
                case 5:
                  _3.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _3.ops.pop();
                  _3.trys.pop();
                  continue;
                default:
                  if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _3 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _3.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _3.label < t2[1]) {
                    _3.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _3.label < t2[2]) {
                    _3.label = t2[2];
                    _3.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _3.ops.pop();
                  _3.trys.pop();
                  continue;
              }
              op = body2.call(thisArg, _3);
            } catch (e2) {
              op = [6, e2];
              y4 = 0;
            } finally {
              f4 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __spreadArray(to, from, pack2) {
        if (pack2 || arguments.length === 2)
          for (var i4 = 0, l4 = from.length, ar2; i4 < l4; i4++) {
            if (ar2 || !(i4 in from)) {
              if (!ar2)
                ar2 = Array.prototype.slice.call(from, 0, i4);
              ar2[i4] = from[i4];
            }
          }
        return to.concat(ar2 || from);
      }
      var Bounds = (
        /** @class */
        function() {
          function Bounds2(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
          }
          Bounds2.prototype.add = function(x4, y4, w6, h3) {
            return new Bounds2(this.left + x4, this.top + y4, this.width + w6, this.height + h3);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = Array.from(domRectList).find(function(rect) {
              return rect.width !== 0;
            });
            return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }()
      );
      var parseBounds = function(context, node) {
        return Bounds.fromClientRect(context, node.getBoundingClientRect());
      };
      var parseDocumentSize = function(document2) {
        var body2 = document2.body;
        var documentElement = document2.documentElement;
        if (!body2 || !documentElement) {
          throw new Error("Unable to get document size");
        }
        var width = Math.max(Math.max(body2.scrollWidth, documentElement.scrollWidth), Math.max(body2.offsetWidth, documentElement.offsetWidth), Math.max(body2.clientWidth, documentElement.clientWidth));
        var height = Math.max(Math.max(body2.scrollHeight, documentElement.scrollHeight), Math.max(body2.offsetHeight, documentElement.offsetHeight), Math.max(body2.clientHeight, documentElement.clientHeight));
        return new Bounds(0, 0, width, height);
      };
      var toCodePoints$1 = function(str) {
        var codePoints = [];
        var i4 = 0;
        var length = str.length;
        while (i4 < length) {
          var value = str.charCodeAt(i4++);
          if (value >= 55296 && value <= 56319 && i4 < length) {
            var extra = str.charCodeAt(i4++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i4--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint$1 = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length = codePoints.length;
        if (!length) {
          return "";
        }
        var codeUnits = [];
        var index = -1;
        var result = "";
        while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index + 1 === length || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
      }
      var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
      }
      var decode$1 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i4, p5 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i4 = 0; i4 < len; i4 += 4) {
          encoded1 = lookup$1$1[base642.charCodeAt(i4)];
          encoded2 = lookup$1$1[base642.charCodeAt(i4 + 1)];
          encoded3 = lookup$1$1[base642.charCodeAt(i4 + 2)];
          encoded4 = lookup$1$1[base642.charCodeAt(i4 + 3)];
          bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array$1 = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 2) {
          bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var polyUint32Array$1 = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 4) {
          bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2$1 = 5;
      var UTRIE2_SHIFT_1$1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT$1 = 2;
      var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
      var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
      var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
      var slice16$1 = function(view, start2, end) {
        if (view.slice) {
          return view.slice(start2, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start2, end));
      };
      var slice32$1 = function(view, start2, end) {
        if (view.slice) {
          return view.slice(start2, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start2, end));
      };
      var createTrieFromBase64$1 = function(base642, _byteLength) {
        var buffer = decode$1(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
      };
      var Trie$1 = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
      }
      var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
      var LETTER_NUMBER_MODIFIER = 50;
      var BK = 1;
      var CR$1 = 2;
      var LF$1 = 3;
      var CM = 4;
      var NL = 5;
      var WJ = 7;
      var ZW = 8;
      var GL = 9;
      var SP = 10;
      var ZWJ$1 = 11;
      var B22 = 12;
      var BA = 13;
      var BB = 14;
      var HY = 15;
      var CB = 16;
      var CL = 17;
      var CP = 18;
      var EX = 19;
      var IN = 20;
      var NS = 21;
      var OP = 22;
      var QU = 23;
      var IS = 24;
      var NU = 25;
      var PO = 26;
      var PR = 27;
      var SY = 28;
      var AI = 29;
      var AL = 30;
      var CJ = 31;
      var EB = 32;
      var EM = 33;
      var H22 = 34;
      var H32 = 35;
      var HL = 36;
      var ID = 37;
      var JL = 38;
      var JV = 39;
      var JT = 40;
      var RI$1 = 41;
      var SA = 42;
      var XX = 43;
      var ea_OP = [9001, 65288];
      var BREAK_MANDATORY = "!";
      var BREAK_NOT_ALLOWED$1 = "\xD7";
      var BREAK_ALLOWED$1 = "\xF7";
      var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
      var ALPHABETICS = [AL, HL];
      var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
      var SPACE$1 = [SP, ZW];
      var PREFIX_POSTFIX = [PR, PO];
      var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
      var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H22, H32];
      var HYPHEN = [HY, BA];
      var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
        if (lineBreak2 === void 0) {
          lineBreak2 = "strict";
        }
        var types = [];
        var indices = [];
        var categories = [];
        codePoints.forEach(function(codePoint, index) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
          } else {
            categories.push(false);
          }
          if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
            if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
              indices.push(index);
              return types.push(CB);
            }
          }
          if (classType === CM || classType === ZWJ$1) {
            if (index === 0) {
              indices.push(index);
              return types.push(AL);
            }
            var prev = types[index - 1];
            if (LINE_BREAKS.indexOf(prev) === -1) {
              indices.push(indices[index - 1]);
              return types.push(prev);
            }
            indices.push(index);
            return types.push(AL);
          }
          indices.push(index);
          if (classType === CJ) {
            return types.push(lineBreak2 === "strict" ? NS : ID);
          }
          if (classType === SA) {
            return types.push(AL);
          }
          if (classType === AI) {
            return types.push(AL);
          }
          if (classType === XX) {
            if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
              return types.push(ID);
            } else {
              return types.push(AL);
            }
          }
          types.push(classType);
        });
        return [indices, types, categories];
      };
      var isAdjacentWithSpaceIgnored = function(a3, b4, currentIndex, classTypes) {
        var current = classTypes[currentIndex];
        if (Array.isArray(a3) ? a3.indexOf(current) !== -1 : a3 === current) {
          var i4 = currentIndex;
          while (i4 <= classTypes.length) {
            i4++;
            var next = classTypes[i4];
            if (next === b4) {
              return true;
            }
            if (next !== SP) {
              break;
            }
          }
        }
        if (current === SP) {
          var i4 = currentIndex;
          while (i4 > 0) {
            i4--;
            var prev = classTypes[i4];
            if (Array.isArray(a3) ? a3.indexOf(prev) !== -1 : a3 === prev) {
              var n3 = currentIndex;
              while (n3 <= classTypes.length) {
                n3++;
                var next = classTypes[n3];
                if (next === b4) {
                  return true;
                }
                if (next !== SP) {
                  break;
                }
              }
            }
            if (prev !== SP) {
              break;
            }
          }
        }
        return false;
      };
      var previousNonSpaceClassType = function(currentIndex, classTypes) {
        var i4 = currentIndex;
        while (i4 >= 0) {
          var type = classTypes[i4];
          if (type === SP) {
            i4--;
          } else {
            return type;
          }
        }
        return 0;
      };
      var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
        if (indicies[index] === 0) {
          return BREAK_NOT_ALLOWED$1;
        }
        var currentIndex = index - 1;
        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
        }
        var beforeIndex = currentIndex - 1;
        var afterIndex = currentIndex + 1;
        var current = classTypes[currentIndex];
        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
        var next = classTypes[afterIndex];
        if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
        }
        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
        }
        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(B22, B22, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SP) {
          return BREAK_ALLOWED$1;
        }
        if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
        }
        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (before === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (
          // (PR | PO) × ( OP | HY )? NU
          [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
          [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
          current === NU && [NU, SY, IS].indexOf(next) !== -1
        ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if (JL === current && [JL, JV, H22, H32].indexOf(next) !== -1 || [JV, H22].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H32].indexOf(current) !== -1 && next === JT) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === RI$1 && next === RI$1) {
          var i4 = indicies[currentIndex];
          var count = 1;
          while (i4 > 0) {
            i4--;
            if (classTypes[i4] === RI$1) {
              count++;
            } else {
              break;
            }
          }
          if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED$1;
          }
        }
        if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
        }
        return BREAK_ALLOWED$1;
      };
      var cssFormattedClasses = function(codePoints, options) {
        if (!options) {
          options = { lineBreak: "normal", wordBreak: "normal" };
        }
        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
        if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
          classTypes = classTypes.map(function(type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
          });
        }
        var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i4) {
          return letterNumber && codePoints[i4] >= 19968 && codePoints[i4] <= 40959;
        }) : void 0;
        return [indicies, classTypes, forbiddenBreakpoints];
      };
      var Break = (
        /** @class */
        function() {
          function Break2(codePoints, lineBreak2, start2, end) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start2;
            this.end = end;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }()
      );
      var LineBreaker = function(str, options) {
        var codePoints = toCodePoints$1(str);
        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
        var length = codePoints.length;
        var lastEnd = 0;
        var nextIndex = 0;
        return {
          next: function() {
            if (nextIndex >= length) {
              return { done: true, value: null };
            }
            var lineBreak2 = BREAK_NOT_ALLOWED$1;
            while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
            }
            if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
              var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
              lastEnd = nextIndex;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var FLAG_UNRESTRICTED = 1 << 0;
      var FLAG_ID = 1 << 1;
      var FLAG_INTEGER = 1 << 2;
      var FLAG_NUMBER = 1 << 3;
      var LINE_FEED = 10;
      var SOLIDUS = 47;
      var REVERSE_SOLIDUS = 92;
      var CHARACTER_TABULATION = 9;
      var SPACE = 32;
      var QUOTATION_MARK = 34;
      var EQUALS_SIGN = 61;
      var NUMBER_SIGN = 35;
      var DOLLAR_SIGN = 36;
      var PERCENTAGE_SIGN = 37;
      var APOSTROPHE = 39;
      var LEFT_PARENTHESIS = 40;
      var RIGHT_PARENTHESIS = 41;
      var LOW_LINE = 95;
      var HYPHEN_MINUS = 45;
      var EXCLAMATION_MARK = 33;
      var LESS_THAN_SIGN = 60;
      var GREATER_THAN_SIGN = 62;
      var COMMERCIAL_AT = 64;
      var LEFT_SQUARE_BRACKET = 91;
      var RIGHT_SQUARE_BRACKET = 93;
      var CIRCUMFLEX_ACCENT = 61;
      var LEFT_CURLY_BRACKET = 123;
      var QUESTION_MARK = 63;
      var RIGHT_CURLY_BRACKET = 125;
      var VERTICAL_LINE = 124;
      var TILDE = 126;
      var CONTROL = 128;
      var REPLACEMENT_CHARACTER = 65533;
      var ASTERISK = 42;
      var PLUS_SIGN = 43;
      var COMMA = 44;
      var COLON = 58;
      var SEMICOLON = 59;
      var FULL_STOP = 46;
      var NULL = 0;
      var BACKSPACE = 8;
      var LINE_TABULATION = 11;
      var SHIFT_OUT = 14;
      var INFORMATION_SEPARATOR_ONE = 31;
      var DELETE = 127;
      var EOF = -1;
      var ZERO = 48;
      var a2 = 97;
      var e = 101;
      var f3 = 102;
      var u4 = 117;
      var z4 = 122;
      var A4 = 65;
      var E2 = 69;
      var F5 = 70;
      var U4 = 85;
      var Z4 = 90;
      var isDigit = function(codePoint) {
        return codePoint >= ZERO && codePoint <= 57;
      };
      var isSurrogateCodePoint = function(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343;
      };
      var isHex = function(codePoint) {
        return isDigit(codePoint) || codePoint >= A4 && codePoint <= F5 || codePoint >= a2 && codePoint <= f3;
      };
      var isLowerCaseLetter = function(codePoint) {
        return codePoint >= a2 && codePoint <= z4;
      };
      var isUpperCaseLetter = function(codePoint) {
        return codePoint >= A4 && codePoint <= Z4;
      };
      var isLetter = function(codePoint) {
        return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
      };
      var isNonASCIICodePoint = function(codePoint) {
        return codePoint >= CONTROL;
      };
      var isWhiteSpace = function(codePoint) {
        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
      };
      var isNameStartCodePoint = function(codePoint) {
        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
      };
      var isNameCodePoint = function(codePoint) {
        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
      };
      var isNonPrintableCodePoint = function(codePoint) {
        return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
      };
      var isValidEscape = function(c1, c2) {
        if (c1 !== REVERSE_SOLIDUS) {
          return false;
        }
        return c2 !== LINE_FEED;
      };
      var isIdentifierStart = function(c1, c2, c3) {
        if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
        } else if (isNameStartCodePoint(c1)) {
          return true;
        } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
          return true;
        }
        return false;
      };
      var isNumberStart = function(c1, c2, c3) {
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c2)) {
            return true;
          }
          return c2 === FULL_STOP && isDigit(c3);
        }
        if (c1 === FULL_STOP) {
          return isDigit(c2);
        }
        return isDigit(c1);
      };
      var stringToNumber = function(codePoints) {
        var c2 = 0;
        var sign = 1;
        if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
          if (codePoints[c2] === HYPHEN_MINUS) {
            sign = -1;
          }
          c2++;
        }
        var integers = [];
        while (isDigit(codePoints[c2])) {
          integers.push(codePoints[c2++]);
        }
        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
        if (codePoints[c2] === FULL_STOP) {
          c2++;
        }
        var fraction = [];
        while (isDigit(codePoints[c2])) {
          fraction.push(codePoints[c2++]);
        }
        var fracd = fraction.length;
        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
        if (codePoints[c2] === E2 || codePoints[c2] === e) {
          c2++;
        }
        var expsign = 1;
        if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
          if (codePoints[c2] === HYPHEN_MINUS) {
            expsign = -1;
          }
          c2++;
        }
        var exponent = [];
        while (isDigit(codePoints[c2])) {
          exponent.push(codePoints[c2++]);
        }
        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
      };
      var LEFT_PARENTHESIS_TOKEN = {
        type: 2
        /* LEFT_PARENTHESIS_TOKEN */
      };
      var RIGHT_PARENTHESIS_TOKEN = {
        type: 3
        /* RIGHT_PARENTHESIS_TOKEN */
      };
      var COMMA_TOKEN = {
        type: 4
        /* COMMA_TOKEN */
      };
      var SUFFIX_MATCH_TOKEN = {
        type: 13
        /* SUFFIX_MATCH_TOKEN */
      };
      var PREFIX_MATCH_TOKEN = {
        type: 8
        /* PREFIX_MATCH_TOKEN */
      };
      var COLUMN_TOKEN = {
        type: 21
        /* COLUMN_TOKEN */
      };
      var DASH_MATCH_TOKEN = {
        type: 9
        /* DASH_MATCH_TOKEN */
      };
      var INCLUDE_MATCH_TOKEN = {
        type: 10
        /* INCLUDE_MATCH_TOKEN */
      };
      var LEFT_CURLY_BRACKET_TOKEN = {
        type: 11
        /* LEFT_CURLY_BRACKET_TOKEN */
      };
      var RIGHT_CURLY_BRACKET_TOKEN = {
        type: 12
        /* RIGHT_CURLY_BRACKET_TOKEN */
      };
      var SUBSTRING_MATCH_TOKEN = {
        type: 14
        /* SUBSTRING_MATCH_TOKEN */
      };
      var BAD_URL_TOKEN = {
        type: 23
        /* BAD_URL_TOKEN */
      };
      var BAD_STRING_TOKEN = {
        type: 1
        /* BAD_STRING_TOKEN */
      };
      var CDO_TOKEN = {
        type: 25
        /* CDO_TOKEN */
      };
      var CDC_TOKEN = {
        type: 24
        /* CDC_TOKEN */
      };
      var COLON_TOKEN = {
        type: 26
        /* COLON_TOKEN */
      };
      var SEMICOLON_TOKEN = {
        type: 27
        /* SEMICOLON_TOKEN */
      };
      var LEFT_SQUARE_BRACKET_TOKEN = {
        type: 28
        /* LEFT_SQUARE_BRACKET_TOKEN */
      };
      var RIGHT_SQUARE_BRACKET_TOKEN = {
        type: 29
        /* RIGHT_SQUARE_BRACKET_TOKEN */
      };
      var WHITESPACE_TOKEN = {
        type: 31
        /* WHITESPACE_TOKEN */
      };
      var EOF_TOKEN = {
        type: 32
        /* EOF_TOKEN */
      };
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c2 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                  var flags2 = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return { type: 5, value, flags: flags2 };
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e2 = this.peekCodePoint(0);
                var e3 = this.peekCodePoint(1);
                if (isNumberStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c4 = this.consumeCodePoint();
                    if (c4 === ASTERISK) {
                      c4 = this.consumeCodePoint();
                      if (c4 === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c4 === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a22 = this.peekCodePoint(1);
                var a3 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a22, a3)) {
                  var value = this.consumeName();
                  return { type: 7, value };
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u4:
              case U4:
                var u1 = this.peekCodePoint(0);
                var u22 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex(u22) || u22 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return { type: 6, value: fromCodePoint$1(codePoint) };
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F5 : digit;
              })), 16);
              return { type: 30, start: start_1, end };
            }
            var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30, start: start2, end };
            } else {
              return { type: 30, start: start2, end: start2 };
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19, value };
            }
            return { type: 20, value };
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return { type: 22, value: "" };
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: stringToken.value };
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 5e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i4 = 0;
            do {
              var codePoint = this._value[i4];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i4);
                return { type: 0, value };
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i4);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next = this._value[i4 + 1];
                if (next !== EOF && next !== void 0) {
                  if (next === LINE_FEED) {
                    value += this.consumeStringSlice(i4);
                    i4 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next)) {
                    value += this.consumeStringSlice(i4);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i4 = -1;
                  }
                }
              }
              i4++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if ((c1 === E2 || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a = this.consumeNumber(), number = _a[0], flags2 = _a[1];
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return { type: 15, number, flags: flags2, unit };
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16, number, flags: flags2 };
            }
            return { type: 17, number, flags: flags2 };
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }()
      );
      var Parser = (
        /** @class */
        function() {
          function Parser2(tokens) {
            this._tokens = tokens;
          }
          Parser2.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser2(tokenizer.read());
          };
          Parser2.parseValue = function(value) {
            return Parser2.create(value).parseComponentValue();
          };
          Parser2.parseValues = function(value) {
            return Parser2.create(value).parseComponentValues();
          };
          Parser2.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser2.prototype.parseComponentValues = function() {
            var values2 = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values2;
              }
              values2.push(value);
              values2.push();
            }
          };
          Parser2.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser2.prototype.consumeSimpleBlock = function(type) {
            var block = { type, values: [] };
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser2.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
              /* FUNCTION */
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser2.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser2.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser2;
        }()
      );
      var isDimensionToken = function(token) {
        return token.type === 15;
      };
      var isNumberToken = function(token) {
        return token.type === 17;
      };
      var isIdentToken = function(token) {
        return token.type === 20;
      };
      var isStringToken = function(token) {
        return token.type === 0;
      };
      var isIdentWithValue = function(token, value) {
        return isIdentToken(token) && token.value === value;
      };
      var nonWhiteSpace = function(token) {
        return token.type !== 31;
      };
      var nonFunctionArgSeparator = function(token) {
        return token.type !== 31 && token.type !== 4;
      };
      var parseFunctionArgs = function(tokens) {
        var args2 = [];
        var arg = [];
        tokens.forEach(function(token) {
          if (token.type === 4) {
            if (arg.length === 0) {
              throw new Error("Error parsing function args, zero tokens for arg");
            }
            args2.push(arg);
            arg = [];
            return;
          }
          if (token.type !== 31) {
            arg.push(token);
          }
        });
        if (arg.length) {
          args2.push(arg);
        }
        return args2;
      };
      var isEndingTokenFor = function(token, type) {
        if (type === 11 && token.type === 12) {
          return true;
        }
        if (type === 28 && token.type === 29) {
          return true;
        }
        return type === 2 && token.type === 3;
      };
      var isLength = function(token) {
        return token.type === 17 || token.type === 15;
      };
      var isLengthPercentage = function(token) {
        return token.type === 16 || isLength(token);
      };
      var parseLengthPercentageTuple = function(tokens) {
        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
      };
      var ZERO_LENGTH = {
        type: 17,
        number: 0,
        flags: FLAG_INTEGER
      };
      var FIFTY_PERCENT = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var HUNDRED_PERCENT = {
        type: 16,
        number: 100,
        flags: FLAG_INTEGER
      };
      var getAbsoluteValueForTuple = function(tuple, width, height) {
        var x4 = tuple[0], y4 = tuple[1];
        return [getAbsoluteValue(x4, width), getAbsoluteValue(typeof y4 !== "undefined" ? y4 : x4, height)];
      };
      var getAbsoluteValue = function(token, parent) {
        if (token.type === 16) {
          return token.number / 100 * parent;
        }
        if (isDimensionToken(token)) {
          switch (token.unit) {
            case "rem":
            case "em":
              return 16 * token.number;
            case "px":
            default:
              return token.number;
          }
        }
        return token.number;
      };
      var DEG = "deg";
      var GRAD = "grad";
      var RAD = "rad";
      var TURN = "turn";
      var angle = {
        name: "angle",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit) {
              case DEG:
                return Math.PI * value.number / 180;
              case GRAD:
                return Math.PI / 200 * value.number;
              case RAD:
                return value.number;
              case TURN:
                return Math.PI * 2 * value.number;
            }
          }
          throw new Error("Unsupported angle type");
        }
      };
      var isAngle = function(value) {
        if (value.type === 15) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
            return true;
          }
        }
        return false;
      };
      var parseNamedSide = function(tokens) {
        var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
          return ident.value;
        }).join(" ");
        switch (sideOrCorner) {
          case "to bottom right":
          case "to right bottom":
          case "left top":
          case "top left":
            return [ZERO_LENGTH, ZERO_LENGTH];
          case "to top":
          case "bottom":
            return deg(0);
          case "to bottom left":
          case "to left bottom":
          case "right top":
          case "top right":
            return [ZERO_LENGTH, HUNDRED_PERCENT];
          case "to right":
          case "left":
            return deg(90);
          case "to top left":
          case "to left top":
          case "right bottom":
          case "bottom right":
            return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case "to bottom":
          case "top":
            return deg(180);
          case "to top right":
          case "to right top":
          case "left bottom":
          case "bottom left":
            return [HUNDRED_PERCENT, ZERO_LENGTH];
          case "to left":
          case "right":
            return deg(270);
        }
        return 0;
      };
      var deg = function(deg2) {
        return Math.PI * deg2 / 180;
      };
      var color$1 = {
        name: "color",
        parse: function(context, value) {
          if (value.type === 18) {
            var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
            if (typeof colorFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
            }
            return colorFunction(context, value.values);
          }
          if (value.type === 5) {
            if (value.value.length === 3) {
              var r = value.value.substring(0, 1);
              var g5 = value.value.substring(1, 2);
              var b4 = value.value.substring(2, 3);
              return pack(parseInt(r + r, 16), parseInt(g5 + g5, 16), parseInt(b4 + b4, 16), 1);
            }
            if (value.value.length === 4) {
              var r = value.value.substring(0, 1);
              var g5 = value.value.substring(1, 2);
              var b4 = value.value.substring(2, 3);
              var a3 = value.value.substring(3, 4);
              return pack(parseInt(r + r, 16), parseInt(g5 + g5, 16), parseInt(b4 + b4, 16), parseInt(a3 + a3, 16) / 255);
            }
            if (value.value.length === 6) {
              var r = value.value.substring(0, 2);
              var g5 = value.value.substring(2, 4);
              var b4 = value.value.substring(4, 6);
              return pack(parseInt(r, 16), parseInt(g5, 16), parseInt(b4, 16), 1);
            }
            if (value.value.length === 8) {
              var r = value.value.substring(0, 2);
              var g5 = value.value.substring(2, 4);
              var b4 = value.value.substring(4, 6);
              var a3 = value.value.substring(6, 8);
              return pack(parseInt(r, 16), parseInt(g5, 16), parseInt(b4, 16), parseInt(a3, 16) / 255);
            }
          }
          if (value.type === 20) {
            var namedColor = COLORS[value.value.toUpperCase()];
            if (typeof namedColor !== "undefined") {
              return namedColor;
            }
          }
          return COLORS.TRANSPARENT;
        }
      };
      var isTransparent = function(color2) {
        return (255 & color2) === 0;
      };
      var asString = function(color2) {
        var alpha = 255 & color2;
        var blue = 255 & color2 >> 8;
        var green = 255 & color2 >> 16;
        var red = 255 & color2 >> 24;
        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
      };
      var pack = function(r, g5, b4, a3) {
        return (r << 24 | g5 << 16 | b4 << 8 | Math.round(a3 * 255) << 0) >>> 0;
      };
      var getTokenColorValue = function(token, i4) {
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 16) {
          var max = i4 === 3 ? 1 : 255;
          return i4 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
        }
        return 0;
      };
      var rgb2 = function(_context, args2) {
        var tokens = args2.filter(nonFunctionArgSeparator);
        if (tokens.length === 3) {
          var _a = tokens.map(getTokenColorValue), r = _a[0], g5 = _a[1], b4 = _a[2];
          return pack(r, g5, b4, 1);
        }
        if (tokens.length === 4) {
          var _b = tokens.map(getTokenColorValue), r = _b[0], g5 = _b[1], b4 = _b[2], a3 = _b[3];
          return pack(r, g5, b4, a3);
        }
        return 0;
      };
      function hue2rgb(t1, t2, hue) {
        if (hue < 0) {
          hue += 1;
        }
        if (hue >= 1) {
          hue -= 1;
        }
        if (hue < 1 / 6) {
          return (t2 - t1) * hue * 6 + t1;
        } else if (hue < 1 / 2) {
          return t2;
        } else if (hue < 2 / 3) {
          return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
        } else {
          return t1;
        }
      }
      var hsl = function(context, args2) {
        var tokens = args2.filter(nonFunctionArgSeparator);
        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
        var h3 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
        var s5 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
        var l4 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
        var a3 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
        if (s5 === 0) {
          return pack(l4 * 255, l4 * 255, l4 * 255, 1);
        }
        var t2 = l4 <= 0.5 ? l4 * (s5 + 1) : l4 + s5 - l4 * s5;
        var t1 = l4 * 2 - t2;
        var r = hue2rgb(t1, t2, h3 + 1 / 3);
        var g5 = hue2rgb(t1, t2, h3);
        var b4 = hue2rgb(t1, t2, h3 - 1 / 3);
        return pack(r * 255, g5 * 255, b4 * 255, a3);
      };
      var SUPPORTED_COLOR_FUNCTIONS = {
        hsl,
        hsla: hsl,
        rgb: rgb2,
        rgba: rgb2
      };
      var parseColor = function(context, value) {
        return color$1.parse(context, Parser.create(value).parseComponentValue());
      };
      var COLORS = {
        ALICEBLUE: 4042850303,
        ANTIQUEWHITE: 4209760255,
        AQUA: 16777215,
        AQUAMARINE: 2147472639,
        AZURE: 4043309055,
        BEIGE: 4126530815,
        BISQUE: 4293182719,
        BLACK: 255,
        BLANCHEDALMOND: 4293643775,
        BLUE: 65535,
        BLUEVIOLET: 2318131967,
        BROWN: 2771004159,
        BURLYWOOD: 3736635391,
        CADETBLUE: 1604231423,
        CHARTREUSE: 2147418367,
        CHOCOLATE: 3530104575,
        CORAL: 4286533887,
        CORNFLOWERBLUE: 1687547391,
        CORNSILK: 4294499583,
        CRIMSON: 3692313855,
        CYAN: 16777215,
        DARKBLUE: 35839,
        DARKCYAN: 9145343,
        DARKGOLDENROD: 3095837695,
        DARKGRAY: 2846468607,
        DARKGREEN: 6553855,
        DARKGREY: 2846468607,
        DARKKHAKI: 3182914559,
        DARKMAGENTA: 2332068863,
        DARKOLIVEGREEN: 1433087999,
        DARKORANGE: 4287365375,
        DARKORCHID: 2570243327,
        DARKRED: 2332033279,
        DARKSALMON: 3918953215,
        DARKSEAGREEN: 2411499519,
        DARKSLATEBLUE: 1211993087,
        DARKSLATEGRAY: 793726975,
        DARKSLATEGREY: 793726975,
        DARKTURQUOISE: 13554175,
        DARKVIOLET: 2483082239,
        DEEPPINK: 4279538687,
        DEEPSKYBLUE: 12582911,
        DIMGRAY: 1768516095,
        DIMGREY: 1768516095,
        DODGERBLUE: 512819199,
        FIREBRICK: 2988581631,
        FLORALWHITE: 4294635775,
        FORESTGREEN: 579543807,
        FUCHSIA: 4278255615,
        GAINSBORO: 3705462015,
        GHOSTWHITE: 4177068031,
        GOLD: 4292280575,
        GOLDENROD: 3668254975,
        GRAY: 2155905279,
        GREEN: 8388863,
        GREENYELLOW: 2919182335,
        GREY: 2155905279,
        HONEYDEW: 4043305215,
        HOTPINK: 4285117695,
        INDIANRED: 3445382399,
        INDIGO: 1258324735,
        IVORY: 4294963455,
        KHAKI: 4041641215,
        LAVENDER: 3873897215,
        LAVENDERBLUSH: 4293981695,
        LAWNGREEN: 2096890111,
        LEMONCHIFFON: 4294626815,
        LIGHTBLUE: 2916673279,
        LIGHTCORAL: 4034953471,
        LIGHTCYAN: 3774873599,
        LIGHTGOLDENRODYELLOW: 4210742015,
        LIGHTGRAY: 3553874943,
        LIGHTGREEN: 2431553791,
        LIGHTGREY: 3553874943,
        LIGHTPINK: 4290167295,
        LIGHTSALMON: 4288707327,
        LIGHTSEAGREEN: 548580095,
        LIGHTSKYBLUE: 2278488831,
        LIGHTSLATEGRAY: 2005441023,
        LIGHTSLATEGREY: 2005441023,
        LIGHTSTEELBLUE: 2965692159,
        LIGHTYELLOW: 4294959359,
        LIME: 16711935,
        LIMEGREEN: 852308735,
        LINEN: 4210091775,
        MAGENTA: 4278255615,
        MAROON: 2147483903,
        MEDIUMAQUAMARINE: 1724754687,
        MEDIUMBLUE: 52735,
        MEDIUMORCHID: 3126187007,
        MEDIUMPURPLE: 2473647103,
        MEDIUMSEAGREEN: 1018393087,
        MEDIUMSLATEBLUE: 2070474495,
        MEDIUMSPRINGGREEN: 16423679,
        MEDIUMTURQUOISE: 1221709055,
        MEDIUMVIOLETRED: 3340076543,
        MIDNIGHTBLUE: 421097727,
        MINTCREAM: 4127193855,
        MISTYROSE: 4293190143,
        MOCCASIN: 4293178879,
        NAVAJOWHITE: 4292783615,
        NAVY: 33023,
        OLDLACE: 4260751103,
        OLIVE: 2155872511,
        OLIVEDRAB: 1804477439,
        ORANGE: 4289003775,
        ORANGERED: 4282712319,
        ORCHID: 3664828159,
        PALEGOLDENROD: 4008225535,
        PALEGREEN: 2566625535,
        PALETURQUOISE: 2951671551,
        PALEVIOLETRED: 3681588223,
        PAPAYAWHIP: 4293907967,
        PEACHPUFF: 4292524543,
        PERU: 3448061951,
        PINK: 4290825215,
        PLUM: 3718307327,
        POWDERBLUE: 2967529215,
        PURPLE: 2147516671,
        REBECCAPURPLE: 1714657791,
        RED: 4278190335,
        ROSYBROWN: 3163525119,
        ROYALBLUE: 1097458175,
        SADDLEBROWN: 2336560127,
        SALMON: 4202722047,
        SANDYBROWN: 4104413439,
        SEAGREEN: 780883967,
        SEASHELL: 4294307583,
        SIENNA: 2689740287,
        SILVER: 3233857791,
        SKYBLUE: 2278484991,
        SLATEBLUE: 1784335871,
        SLATEGRAY: 1887473919,
        SLATEGREY: 1887473919,
        SNOW: 4294638335,
        SPRINGGREEN: 16744447,
        STEELBLUE: 1182971135,
        TAN: 3535047935,
        TEAL: 8421631,
        THISTLE: 3636451583,
        TOMATO: 4284696575,
        TRANSPARENT: 0,
        TURQUOISE: 1088475391,
        VIOLET: 4001558271,
        WHEAT: 4125012991,
        WHITE: 4294967295,
        WHITESMOKE: 4126537215,
        YELLOW: 4294902015,
        YELLOWGREEN: 2597139199
      };
      var backgroundClip = {
        name: "background-clip",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundColor = {
        name: "background-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var parseColorStop = function(context, args2) {
        var color2 = color$1.parse(context, args2[0]);
        var stop2 = args2[1];
        return stop2 && isLengthPercentage(stop2) ? { color: color2, stop: stop2 } : { color: color2, stop: null };
      };
      var processColorStops = function(stops, lineLength) {
        var first = stops[0];
        var last2 = stops[stops.length - 1];
        if (first.stop === null) {
          first.stop = ZERO_LENGTH;
        }
        if (last2.stop === null) {
          last2.stop = HUNDRED_PERCENT;
        }
        var processStops = [];
        var previous = 0;
        for (var i4 = 0; i4 < stops.length; i4++) {
          var stop_1 = stops[i4].stop;
          if (stop_1 !== null) {
            var absoluteValue = getAbsoluteValue(stop_1, lineLength);
            if (absoluteValue > previous) {
              processStops.push(absoluteValue);
            } else {
              processStops.push(previous);
            }
            previous = absoluteValue;
          } else {
            processStops.push(null);
          }
        }
        var gapBegin = null;
        for (var i4 = 0; i4 < processStops.length; i4++) {
          var stop_2 = processStops[i4];
          if (stop_2 === null) {
            if (gapBegin === null) {
              gapBegin = i4;
            }
          } else if (gapBegin !== null) {
            var gapLength = i4 - gapBegin;
            var beforeGap = processStops[gapBegin - 1];
            var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
            for (var g5 = 1; g5 <= gapLength; g5++) {
              processStops[gapBegin + g5 - 1] = gapValue * g5;
            }
            gapBegin = null;
          }
        }
        return stops.map(function(_a, i5) {
          var color2 = _a.color;
          return { color: color2, stop: Math.max(Math.min(1, processStops[i5] / lineLength), 0) };
        });
      };
      var getAngleFromCorner = function(corner, width, height) {
        var centerX = width / 2;
        var centerY = height / 2;
        var x4 = getAbsoluteValue(corner[0], width) - centerX;
        var y4 = centerY - getAbsoluteValue(corner[1], height);
        return (Math.atan2(y4, x4) + Math.PI * 2) % (Math.PI * 2);
      };
      var calculateGradientDirection = function(angle2, width, height) {
        var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfLineLength = lineLength / 2;
        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
      };
      var distance = function(a3, b4) {
        return Math.sqrt(a3 * a3 + b4 * b4);
      };
      var findCorner = function(width, height, x4, y4, closest) {
        var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
        ];
        return corners.reduce(function(stat, corner) {
          var cx2 = corner[0], cy2 = corner[1];
          var d3 = distance(x4 - cx2, y4 - cy2);
          if (closest ? d3 < stat.optimumDistance : d3 > stat.optimumDistance) {
            return {
              optimumCorner: corner,
              optimumDistance: d3
            };
          }
          return stat;
        }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
        }).optimumCorner;
      };
      var calculateRadius = function(gradient, x4, y4, width, height) {
        var rx = 0;
        var ry = 0;
        switch (gradient.size) {
          case 0:
            if (gradient.shape === 0) {
              rx = ry = Math.min(Math.abs(x4), Math.abs(x4 - width), Math.abs(y4), Math.abs(y4 - height));
            } else if (gradient.shape === 1) {
              rx = Math.min(Math.abs(x4), Math.abs(x4 - width));
              ry = Math.min(Math.abs(y4), Math.abs(y4 - height));
            }
            break;
          case 2:
            if (gradient.shape === 0) {
              rx = ry = Math.min(distance(x4, y4), distance(x4, y4 - height), distance(x4 - width, y4), distance(x4 - width, y4 - height));
            } else if (gradient.shape === 1) {
              var c2 = Math.min(Math.abs(y4), Math.abs(y4 - height)) / Math.min(Math.abs(x4), Math.abs(x4 - width));
              var _a = findCorner(width, height, x4, y4, true), cx2 = _a[0], cy2 = _a[1];
              rx = distance(cx2 - x4, (cy2 - y4) / c2);
              ry = c2 * rx;
            }
            break;
          case 1:
            if (gradient.shape === 0) {
              rx = ry = Math.max(Math.abs(x4), Math.abs(x4 - width), Math.abs(y4), Math.abs(y4 - height));
            } else if (gradient.shape === 1) {
              rx = Math.max(Math.abs(x4), Math.abs(x4 - width));
              ry = Math.max(Math.abs(y4), Math.abs(y4 - height));
            }
            break;
          case 3:
            if (gradient.shape === 0) {
              rx = ry = Math.max(distance(x4, y4), distance(x4, y4 - height), distance(x4 - width, y4), distance(x4 - width, y4 - height));
            } else if (gradient.shape === 1) {
              var c2 = Math.max(Math.abs(y4), Math.abs(y4 - height)) / Math.max(Math.abs(x4), Math.abs(x4 - width));
              var _b = findCorner(width, height, x4, y4, false), cx2 = _b[0], cy2 = _b[1];
              rx = distance(cx2 - x4, (cy2 - y4) / c2);
              ry = c2 * rx;
            }
            break;
        }
        if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
        }
        return [rx, ry];
      };
      var linearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          if (i4 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && firstToken.value === "to") {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = angle.parse(context, firstToken);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var prefixLinearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          if (i4 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var webkitGradient = function(context, tokens) {
        var angle2 = deg(180);
        var stops = [];
        var type = 1;
        var shape = 0;
        var size = 3;
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var firstToken = arg[0];
          if (i4 === 0) {
            if (isIdentToken(firstToken) && firstToken.value === "linear") {
              type = 1;
              return;
            } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
              type = 2;
              return;
            }
          }
          if (firstToken.type === 18) {
            if (firstToken.name === "from") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: ZERO_LENGTH, color: color2 });
            } else if (firstToken.name === "to") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: HUNDRED_PERCENT, color: color2 });
            } else if (firstToken.name === "color-stop") {
              var values2 = firstToken.values.filter(nonFunctionArgSeparator);
              if (values2.length === 2) {
                var color2 = color$1.parse(context, values2[1]);
                var stop_1 = values2[0];
                if (isNumberToken(stop_1)) {
                  stops.push({
                    stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                    color: color2
                  });
                }
              }
            }
          }
        });
        return type === 1 ? {
          angle: (angle2 + deg(180)) % deg(360),
          stops,
          type
        } : { size, shape, stops, position: position2, type };
      };
      var CLOSEST_SIDE = "closest-side";
      var FARTHEST_SIDE = "farthest-side";
      var CLOSEST_CORNER = "closest-corner";
      var FARTHEST_CORNER = "farthest-corner";
      var CIRCLE = "circle";
      var ELLIPSE = "ellipse";
      var COVER = "cover";
      var CONTAIN = "contain";
      var radialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var isColorStop = true;
          if (i4 === 0) {
            var isAtPosition_1 = false;
            isColorStop = arg.reduce(function(acc, token) {
              if (isAtPosition_1) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return acc;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return acc;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return acc;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                }
              } else if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case "at":
                    isAtPosition_1 = true;
                    return false;
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case COVER:
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var prefixRadialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var isColorStop = true;
          if (i4 === 0) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return false;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return false;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return false;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          } else if (i4 === 1) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case COVER:
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var isLinearGradient = function(background) {
        return background.type === 1;
      };
      var isRadialGradient = function(background) {
        return background.type === 2;
      };
      var image = {
        name: "image",
        parse: function(context, value) {
          if (value.type === 22) {
            var image_1 = {
              url: value.value,
              type: 0
              /* URL */
            };
            context.cache.addImage(value.value);
            return image_1;
          }
          if (value.type === 18) {
            var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
            if (typeof imageFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
            }
            return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
        }
      };
      function isSupportedImage(value) {
        return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
      }
      var SUPPORTED_IMAGE_FUNCTIONS = {
        "linear-gradient": linearGradient,
        "-moz-linear-gradient": prefixLinearGradient,
        "-ms-linear-gradient": prefixLinearGradient,
        "-o-linear-gradient": prefixLinearGradient,
        "-webkit-linear-gradient": prefixLinearGradient,
        "radial-gradient": radialGradient,
        "-moz-radial-gradient": prefixRadialGradient,
        "-ms-radial-gradient": prefixRadialGradient,
        "-o-radial-gradient": prefixRadialGradient,
        "-webkit-radial-gradient": prefixRadialGradient,
        "-webkit-gradient": webkitGradient
      };
      var backgroundImage = {
        name: "background-image",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens.filter(function(value) {
            return nonFunctionArgSeparator(value) && isSupportedImage(value);
          }).map(function(value) {
            return image.parse(context, value);
          });
        }
      };
      var backgroundOrigin = {
        name: "background-origin",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundPosition = {
        name: "background-position",
        initialValue: "0% 0%",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values2) {
            return values2.filter(isLengthPercentage);
          }).map(parseLengthPercentageTuple);
        }
      };
      var backgroundRepeat = {
        name: "background-repeat",
        initialValue: "repeat",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values2) {
            return values2.filter(isIdentToken).map(function(token) {
              return token.value;
            }).join(" ");
          }).map(parseBackgroundRepeat);
        }
      };
      var parseBackgroundRepeat = function(value) {
        switch (value) {
          case "no-repeat":
            return 1;
          case "repeat-x":
          case "repeat no-repeat":
            return 2;
          case "repeat-y":
          case "no-repeat repeat":
            return 3;
          case "repeat":
          default:
            return 0;
        }
      };
      var BACKGROUND_SIZE;
      (function(BACKGROUND_SIZE2) {
        BACKGROUND_SIZE2["AUTO"] = "auto";
        BACKGROUND_SIZE2["CONTAIN"] = "contain";
        BACKGROUND_SIZE2["COVER"] = "cover";
      })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
      var backgroundSize = {
        name: "background-size",
        initialValue: "0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values2) {
            return values2.filter(isBackgroundSizeInfoToken);
          });
        }
      };
      var isBackgroundSizeInfoToken = function(value) {
        return isIdentToken(value) || isLengthPercentage(value);
      };
      var borderColorForSide = function(side) {
        return {
          name: "border-" + side + "-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
      };
      var borderTopColor = borderColorForSide("top");
      var borderRightColor = borderColorForSide("right");
      var borderBottomColor = borderColorForSide("bottom");
      var borderLeftColor = borderColorForSide("left");
      var borderRadiusForSide = function(side) {
        return {
          name: "border-radius-" + side,
          initialValue: "0 0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
          }
        };
      };
      var borderTopLeftRadius = borderRadiusForSide("top-left");
      var borderTopRightRadius = borderRadiusForSide("top-right");
      var borderBottomRightRadius = borderRadiusForSide("bottom-right");
      var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
      var borderStyleForSide = function(side) {
        return {
          name: "border-" + side + "-style",
          initialValue: "solid",
          prefix: false,
          type: 2,
          parse: function(_context, style) {
            switch (style) {
              case "none":
                return 0;
              case "dashed":
                return 2;
              case "dotted":
                return 3;
              case "double":
                return 4;
            }
            return 1;
          }
        };
      };
      var borderTopStyle = borderStyleForSide("top");
      var borderRightStyle = borderStyleForSide("right");
      var borderBottomStyle = borderStyleForSide("bottom");
      var borderLeftStyle = borderStyleForSide("left");
      var borderWidthForSide = function(side) {
        return {
          name: "border-" + side + "-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
      };
      var borderTopWidth = borderWidthForSide("top");
      var borderRightWidth = borderWidthForSide("right");
      var borderBottomWidth = borderWidthForSide("bottom");
      var borderLeftWidth = borderWidthForSide("left");
      var color = {
        name: "color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var direction = {
        name: "direction",
        initialValue: "ltr",
        prefix: false,
        type: 2,
        parse: function(_context, direction2) {
          switch (direction2) {
            case "rtl":
              return 1;
            case "ltr":
            default:
              return 0;
          }
        }
      };
      var display = {
        name: "display",
        initialValue: "inline-block",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).reduce(
            function(bit, token) {
              return bit | parseDisplayValue(token.value);
            },
            0
            /* NONE */
          );
        }
      };
      var parseDisplayValue = function(display2) {
        switch (display2) {
          case "block":
          case "-webkit-box":
            return 2;
          case "inline":
            return 4;
          case "run-in":
            return 8;
          case "flow":
            return 16;
          case "flow-root":
            return 32;
          case "table":
            return 64;
          case "flex":
          case "-webkit-flex":
            return 128;
          case "grid":
          case "-ms-grid":
            return 256;
          case "ruby":
            return 512;
          case "subgrid":
            return 1024;
          case "list-item":
            return 2048;
          case "table-row-group":
            return 4096;
          case "table-header-group":
            return 8192;
          case "table-footer-group":
            return 16384;
          case "table-row":
            return 32768;
          case "table-cell":
            return 65536;
          case "table-column-group":
            return 131072;
          case "table-column":
            return 262144;
          case "table-caption":
            return 524288;
          case "ruby-base":
            return 1048576;
          case "ruby-text":
            return 2097152;
          case "ruby-base-container":
            return 4194304;
          case "ruby-text-container":
            return 8388608;
          case "contents":
            return 16777216;
          case "inline-block":
            return 33554432;
          case "inline-list-item":
            return 67108864;
          case "inline-table":
            return 134217728;
          case "inline-flex":
            return 268435456;
          case "inline-grid":
            return 536870912;
        }
        return 0;
      };
      var float = {
        name: "float",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, float2) {
          switch (float2) {
            case "left":
              return 1;
            case "right":
              return 2;
            case "inline-start":
              return 3;
            case "inline-end":
              return 4;
          }
          return 0;
        }
      };
      var letterSpacing = {
        name: "letter-spacing",
        initialValue: "0",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "normal") {
            return 0;
          }
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 15) {
            return token.number;
          }
          return 0;
        }
      };
      var LINE_BREAK;
      (function(LINE_BREAK2) {
        LINE_BREAK2["NORMAL"] = "normal";
        LINE_BREAK2["STRICT"] = "strict";
      })(LINE_BREAK || (LINE_BREAK = {}));
      var lineBreak = {
        name: "line-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, lineBreak2) {
          switch (lineBreak2) {
            case "strict":
              return LINE_BREAK.STRICT;
            case "normal":
            default:
              return LINE_BREAK.NORMAL;
          }
        }
      };
      var lineHeight = {
        name: "line-height",
        initialValue: "normal",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
      var computeLineHeight = function(token, fontSize2) {
        if (isIdentToken(token) && token.value === "normal") {
          return 1.2 * fontSize2;
        } else if (token.type === 17) {
          return fontSize2 * token.number;
        } else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize2);
        }
        return fontSize2;
      };
      var listStyleImage = {
        name: "list-style-image",
        initialValue: "none",
        type: 0,
        prefix: false,
        parse: function(context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          return image.parse(context, token);
        }
      };
      var listStylePosition = {
        name: "list-style-position",
        initialValue: "outside",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "inside":
              return 0;
            case "outside":
            default:
              return 1;
          }
        }
      };
      var listStyleType = {
        name: "list-style-type",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, type) {
          switch (type) {
            case "disc":
              return 0;
            case "circle":
              return 1;
            case "square":
              return 2;
            case "decimal":
              return 3;
            case "cjk-decimal":
              return 4;
            case "decimal-leading-zero":
              return 5;
            case "lower-roman":
              return 6;
            case "upper-roman":
              return 7;
            case "lower-greek":
              return 8;
            case "lower-alpha":
              return 9;
            case "upper-alpha":
              return 10;
            case "arabic-indic":
              return 11;
            case "armenian":
              return 12;
            case "bengali":
              return 13;
            case "cambodian":
              return 14;
            case "cjk-earthly-branch":
              return 15;
            case "cjk-heavenly-stem":
              return 16;
            case "cjk-ideographic":
              return 17;
            case "devanagari":
              return 18;
            case "ethiopic-numeric":
              return 19;
            case "georgian":
              return 20;
            case "gujarati":
              return 21;
            case "gurmukhi":
              return 22;
            case "hebrew":
              return 22;
            case "hiragana":
              return 23;
            case "hiragana-iroha":
              return 24;
            case "japanese-formal":
              return 25;
            case "japanese-informal":
              return 26;
            case "kannada":
              return 27;
            case "katakana":
              return 28;
            case "katakana-iroha":
              return 29;
            case "khmer":
              return 30;
            case "korean-hangul-formal":
              return 31;
            case "korean-hanja-formal":
              return 32;
            case "korean-hanja-informal":
              return 33;
            case "lao":
              return 34;
            case "lower-armenian":
              return 35;
            case "malayalam":
              return 36;
            case "mongolian":
              return 37;
            case "myanmar":
              return 38;
            case "oriya":
              return 39;
            case "persian":
              return 40;
            case "simp-chinese-formal":
              return 41;
            case "simp-chinese-informal":
              return 42;
            case "tamil":
              return 43;
            case "telugu":
              return 44;
            case "thai":
              return 45;
            case "tibetan":
              return 46;
            case "trad-chinese-formal":
              return 47;
            case "trad-chinese-informal":
              return 48;
            case "upper-armenian":
              return 49;
            case "disclosure-open":
              return 50;
            case "disclosure-closed":
              return 51;
            case "none":
            default:
              return -1;
          }
        }
      };
      var marginForSide = function(side) {
        return {
          name: "margin-" + side,
          initialValue: "0",
          prefix: false,
          type: 4
          /* TOKEN_VALUE */
        };
      };
      var marginTop = marginForSide("top");
      var marginRight = marginForSide("right");
      var marginBottom = marginForSide("bottom");
      var marginLeft = marginForSide("left");
      var overflow = {
        name: "overflow",
        initialValue: "visible",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(overflow2) {
            switch (overflow2.value) {
              case "hidden":
                return 1;
              case "scroll":
                return 2;
              case "clip":
                return 3;
              case "auto":
                return 4;
              case "visible":
              default:
                return 0;
            }
          });
        }
      };
      var overflowWrap = {
        name: "overflow-wrap",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "break-word":
              return "break-word";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var paddingForSide = function(side) {
        return {
          name: "padding-" + side,
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length-percentage"
        };
      };
      var paddingTop = paddingForSide("top");
      var paddingRight = paddingForSide("right");
      var paddingBottom = paddingForSide("bottom");
      var paddingLeft = paddingForSide("left");
      var textAlign = {
        name: "text-align",
        initialValue: "left",
        prefix: false,
        type: 2,
        parse: function(_context, textAlign2) {
          switch (textAlign2) {
            case "right":
              return 2;
            case "center":
            case "justify":
              return 1;
            case "left":
            default:
              return 0;
          }
        }
      };
      var position = {
        name: "position",
        initialValue: "static",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "relative":
              return 1;
            case "absolute":
              return 2;
            case "fixed":
              return 3;
            case "sticky":
              return 4;
          }
          return 0;
        }
      };
      var textShadow = {
        name: "text-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values2) {
            var shadow = {
              color: COLORS.TRANSPARENT,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH
            };
            var c2 = 0;
            for (var i4 = 0; i4 < values2.length; i4++) {
              var token = values2[i4];
              if (isLength(token)) {
                if (c2 === 0) {
                  shadow.offsetX = token;
                } else if (c2 === 1) {
                  shadow.offsetY = token;
                } else {
                  shadow.blur = token;
                }
                c2++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var textTransform = {
        name: "text-transform",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, textTransform2) {
          switch (textTransform2) {
            case "uppercase":
              return 2;
            case "lowercase":
              return 1;
            case "capitalize":
              return 3;
          }
          return 0;
        }
      };
      var transform$1 = {
        name: "transform",
        initialValue: "none",
        prefix: true,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          if (token.type === 18) {
            var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
            if (typeof transformFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
            }
            return transformFunction(token.values);
          }
          return null;
        }
      };
      var matrix = function(args2) {
        var values2 = args2.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        return values2.length === 6 ? values2 : null;
      };
      var matrix3d = function(args2) {
        var values2 = args2.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        var a1 = values2[0], b1 = values2[1];
        values2[2];
        values2[3];
        var a22 = values2[4], b22 = values2[5];
        values2[6];
        values2[7];
        values2[8];
        values2[9];
        values2[10];
        values2[11];
        var a4 = values2[12], b4 = values2[13];
        values2[14];
        values2[15];
        return values2.length === 16 ? [a1, b1, a22, b22, a4, b4] : null;
      };
      var SUPPORTED_TRANSFORM_FUNCTIONS = {
        matrix,
        matrix3d
      };
      var DEFAULT_VALUE = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
      var transformOrigin = {
        name: "transform-origin",
        initialValue: "50% 50%",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
            return DEFAULT;
          }
          return [origins[0], origins[1]];
        }
      };
      var visibility = {
        name: "visible",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, visibility2) {
          switch (visibility2) {
            case "hidden":
              return 1;
            case "collapse":
              return 2;
            case "visible":
            default:
              return 0;
          }
        }
      };
      var WORD_BREAK;
      (function(WORD_BREAK2) {
        WORD_BREAK2["NORMAL"] = "normal";
        WORD_BREAK2["BREAK_ALL"] = "break-all";
        WORD_BREAK2["KEEP_ALL"] = "keep-all";
      })(WORD_BREAK || (WORD_BREAK = {}));
      var wordBreak = {
        name: "word-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, wordBreak2) {
          switch (wordBreak2) {
            case "break-all":
              return WORD_BREAK.BREAK_ALL;
            case "keep-all":
              return WORD_BREAK.KEEP_ALL;
            case "normal":
            default:
              return WORD_BREAK.NORMAL;
          }
        }
      };
      var zIndex = {
        name: "z-index",
        initialValue: "auto",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20) {
            return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
            return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
        }
      };
      var time = {
        name: "time",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit.toLowerCase()) {
              case "s":
                return 1e3 * value.number;
              case "ms":
                return value.number;
            }
          }
          throw new Error("Unsupported time type");
        }
      };
      var opacity = {
        name: "opacity",
        initialValue: "1",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          return 1;
        }
      };
      var textDecorationColor = {
        name: "text-decoration-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var textDecorationLine = {
        name: "text-decoration-line",
        initialValue: "none",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            switch (token.value) {
              case "underline":
                return 1;
              case "overline":
                return 2;
              case "line-through":
                return 3;
              case "none":
                return 4;
            }
            return 0;
          }).filter(function(line) {
            return line !== 0;
          });
        }
      };
      var fontFamily = {
        name: "font-family",
        initialValue: "",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function(token) {
            switch (token.type) {
              case 20:
              case 0:
                accumulator.push(token.value);
                break;
              case 17:
                accumulator.push(token.number.toString());
                break;
              case 4:
                results.push(accumulator.join(" "));
                accumulator.length = 0;
                break;
            }
          });
          if (accumulator.length) {
            results.push(accumulator.join(" "));
          }
          return results.map(function(result) {
            return result.indexOf(" ") === -1 ? result : "'" + result + "'";
          });
        }
      };
      var fontSize = {
        name: "font-size",
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length"
      };
      var fontWeight = {
        name: "font-weight",
        initialValue: "normal",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          if (isIdentToken(token)) {
            switch (token.value) {
              case "bold":
                return 700;
              case "normal":
              default:
                return 400;
            }
          }
          return 400;
        }
      };
      var fontVariant = {
        name: "font-variant",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            return token.value;
          });
        }
      };
      var fontStyle = {
        name: "font-style",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "oblique":
              return "oblique";
            case "italic":
              return "italic";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var contains = function(bit, value) {
        return (bit & value) !== 0;
      };
      var content = {
        name: "content",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens;
        }
      };
      var counterIncrement = {
        name: "counter-increment",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i4 = 0; i4 < filtered.length; i4++) {
            var counter = filtered[i4];
            var next = filtered[i4 + 1];
            if (counter.type === 20) {
              var increment = next && isNumberToken(next) ? next.number : 1;
              increments.push({ counter: counter.value, increment });
            }
          }
          return increments;
        }
      };
      var counterReset = {
        name: "counter-reset",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i4 = 0; i4 < filtered.length; i4++) {
            var counter = filtered[i4];
            var next = filtered[i4 + 1];
            if (isIdentToken(counter) && counter.value !== "none") {
              var reset = next && isNumberToken(next) ? next.number : 0;
              resets.push({ counter: counter.value, reset });
            }
          }
          return resets;
        }
      };
      var duration = {
        name: "duration",
        initialValue: "0s",
        prefix: false,
        type: 1,
        parse: function(context, tokens) {
          return tokens.filter(isDimensionToken).map(function(token) {
            return time.parse(context, token);
          });
        }
      };
      var quotes = {
        name: "quotes",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var quotes2 = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
            return null;
          }
          for (var i4 = 0; i4 < filtered.length; i4 += 2) {
            var open_1 = filtered[i4].value;
            var close_1 = filtered[i4 + 1].value;
            quotes2.push({ open: open_1, close: close_1 });
          }
          return quotes2;
        }
      };
      var getQuote = function(quotes2, depth, open) {
        if (!quotes2) {
          return "";
        }
        var quote = quotes2[Math.min(depth, quotes2.length - 1)];
        if (!quote) {
          return "";
        }
        return open ? quote.open : quote.close;
      };
      var boxShadow = {
        name: "box-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values2) {
            var shadow = {
              color: 255,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH,
              spread: ZERO_LENGTH,
              inset: false
            };
            var c2 = 0;
            for (var i4 = 0; i4 < values2.length; i4++) {
              var token = values2[i4];
              if (isIdentWithValue(token, "inset")) {
                shadow.inset = true;
              } else if (isLength(token)) {
                if (c2 === 0) {
                  shadow.offsetX = token;
                } else if (c2 === 1) {
                  shadow.offsetY = token;
                } else if (c2 === 2) {
                  shadow.blur = token;
                } else {
                  shadow.spread = token;
                }
                c2++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var paintOrder = {
        name: "paint-order",
        initialValue: "normal",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var DEFAULT_VALUE2 = [
            0,
            1,
            2
            /* MARKERS */
          ];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function(token) {
            switch (token.value) {
              case "stroke":
                layers.push(
                  1
                  /* STROKE */
                );
                break;
              case "fill":
                layers.push(
                  0
                  /* FILL */
                );
                break;
              case "markers":
                layers.push(
                  2
                  /* MARKERS */
                );
                break;
            }
          });
          DEFAULT_VALUE2.forEach(function(value) {
            if (layers.indexOf(value) === -1) {
              layers.push(value);
            }
          });
          return layers;
        }
      };
      var webkitTextStrokeColor = {
        name: "-webkit-text-stroke-color",
        initialValue: "currentcolor",
        prefix: false,
        type: 3,
        format: "color"
      };
      var webkitTextStrokeWidth = {
        name: "-webkit-text-stroke-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
      var CSSParsedDeclaration = (
        /** @class */
        function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a, _b;
            this.animationDuration = parse3(context, duration, declaration.animationDuration);
            this.backgroundClip = parse3(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse3(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse3(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse3(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse3(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse3(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse3(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse3(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse3(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse3(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse3(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse3(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse3(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse3(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse3(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse3(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse3(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse3(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse3(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse3(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse3(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse3(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse3(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse3(context, boxShadow, declaration.boxShadow);
            this.color = parse3(context, color, declaration.color);
            this.direction = parse3(context, direction, declaration.direction);
            this.display = parse3(context, display, declaration.display);
            this.float = parse3(context, float, declaration.cssFloat);
            this.fontFamily = parse3(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse3(context, fontSize, declaration.fontSize);
            this.fontStyle = parse3(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse3(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse3(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse3(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse3(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse3(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse3(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse3(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse3(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse3(context, marginTop, declaration.marginTop);
            this.marginRight = parse3(context, marginRight, declaration.marginRight);
            this.marginBottom = parse3(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse3(context, marginLeft, declaration.marginLeft);
            this.opacity = parse3(context, opacity, declaration.opacity);
            var overflowTuple = parse3(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse3(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse3(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse3(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse3(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse3(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse3(context, paintOrder, declaration.paintOrder);
            this.position = parse3(context, position, declaration.position);
            this.textAlign = parse3(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse3(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
            this.textDecorationLine = parse3(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
            this.textShadow = parse3(context, textShadow, declaration.textShadow);
            this.textTransform = parse3(context, textTransform, declaration.textTransform);
            this.transform = parse3(context, transform$1, declaration.transform);
            this.transformOrigin = parse3(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse3(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse3(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse3(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse3(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse3(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === 0;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== 0;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== 0;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains(
              this.display,
              4
              /* INLINE */
            ) || contains(
              this.display,
              33554432
              /* INLINE_BLOCK */
            ) || contains(
              this.display,
              268435456
              /* INLINE_FLEX */
            ) || contains(
              this.display,
              536870912
              /* INLINE_GRID */
            ) || contains(
              this.display,
              67108864
              /* INLINE_LIST_ITEM */
            ) || contains(
              this.display,
              134217728
              /* INLINE_TABLE */
            );
          };
          return CSSParsedDeclaration2;
        }()
      );
      var CSSParsedPseudoDeclaration = (
        /** @class */
        function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse3(context, content, declaration.content);
            this.quotes = parse3(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }()
      );
      var CSSParsedCounterDeclaration = (
        /** @class */
        function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse3(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse3(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }()
      );
      var parse3 = function(context, descriptor, style) {
        var tokenizer = new Tokenizer();
        var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
        tokenizer.write(value);
        var parser = new Parser(tokenizer.read());
        switch (descriptor.type) {
          case 2:
            var token = parser.parseComponentValue();
            return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0:
            return descriptor.parse(context, parser.parseComponentValue());
          case 1:
            return descriptor.parse(context, parser.parseComponentValues());
          case 4:
            return parser.parseComponentValue();
          case 3:
            switch (descriptor.format) {
              case "angle":
                return angle.parse(context, parser.parseComponentValue());
              case "color":
                return color$1.parse(context, parser.parseComponentValue());
              case "image":
                return image.parse(context, parser.parseComponentValue());
              case "length":
                var length_1 = parser.parseComponentValue();
                return isLength(length_1) ? length_1 : ZERO_LENGTH;
              case "length-percentage":
                var value_1 = parser.parseComponentValue();
                return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
              case "time":
                return time.parse(context, parser.parseComponentValue());
            }
            break;
        }
      };
      var elementDebuggerAttribute = "data-html2canvas-debug";
      var getElementDebugType = function(element) {
        var attribute = element.getAttribute(elementDebuggerAttribute);
        switch (attribute) {
          case "all":
            return 1;
          case "clone":
            return 2;
          case "parse":
            return 3;
          case "render":
            return 4;
          default:
            return 0;
        }
      };
      var isDebugging = function(element, type) {
        var elementType = getElementDebugType(element);
        return elementType === 1 || type === elementType;
      };
      var ElementContainer = (
        /** @class */
        function() {
          function ElementContainer2(context, element) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(
              element,
              3
              /* PARSE */
            )) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
            if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element);
            if (isDebugging(
              element,
              4
              /* RENDER */
            )) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }()
      );
      var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
      var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
      }
      var decode = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i4, p5 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i4 = 0; i4 < len; i4 += 4) {
          encoded1 = lookup$1[base642.charCodeAt(i4)];
          encoded2 = lookup$1[base642.charCodeAt(i4 + 1)];
          encoded3 = lookup$1[base642.charCodeAt(i4 + 2)];
          encoded4 = lookup$1[base642.charCodeAt(i4 + 3)];
          bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 2) {
          bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var polyUint32Array = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 4) {
          bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2 = 5;
      var UTRIE2_SHIFT_1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT = 2;
      var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
      var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
      var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
      var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
      var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
      var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
      var slice16 = function(view, start2, end) {
        if (view.slice) {
          return view.slice(start2, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start2, end));
      };
      var slice32 = function(view, start2, end) {
        if (view.slice) {
          return view.slice(start2, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start2, end));
      };
      var createTrieFromBase64 = function(base642, _byteLength) {
        var buffer = decode(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index = slice16(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
      };
      var Trie = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i3 = 0; i3 < chars3.length; i3++) {
        lookup3[chars3.charCodeAt(i3)] = i3;
      }
      var Prepend = 1;
      var CR = 2;
      var LF = 3;
      var Control = 4;
      var Extend = 5;
      var SpacingMark = 7;
      var L7 = 8;
      var V3 = 9;
      var T4 = 10;
      var LV = 11;
      var LVT = 12;
      var ZWJ = 13;
      var Extended_Pictographic = 14;
      var RI = 15;
      var toCodePoints = function(str) {
        var codePoints = [];
        var i4 = 0;
        var length = str.length;
        while (i4 < length) {
          var value = str.charCodeAt(i4++);
          if (value >= 55296 && value <= 56319 && i4 < length) {
            var extra = str.charCodeAt(i4++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i4--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length = codePoints.length;
        if (!length) {
          return "";
        }
        var codeUnits = [];
        var index = -1;
        var result = "";
        while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index + 1 === length || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var UnicodeTrie = createTrieFromBase64(base64);
      var BREAK_NOT_ALLOWED = "\xD7";
      var BREAK_ALLOWED = "\xF7";
      var codePointToClass = function(codePoint) {
        return UnicodeTrie.get(codePoint);
      };
      var _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
        var prevIndex = index - 2;
        var prev = classTypes[prevIndex];
        var current = classTypes[index - 1];
        var next = classTypes[index];
        if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
        }
        if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
        }
        if (current === L7 && [L7, V3, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LV || current === V3) && (next === V3 || next === T4)) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LVT || current === T4) && next === T4) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
            prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
            return BREAK_NOT_ALLOWED;
          }
        }
        if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
            countRI++;
            prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
            return BREAK_NOT_ALLOWED;
          }
        }
        return BREAK_ALLOWED;
      };
      var GraphemeBreaker = function(str) {
        var codePoints = toCodePoints(str);
        var length = codePoints.length;
        var index = 0;
        var lastEnd = 0;
        var classTypes = codePoints.map(codePointToClass);
        return {
          next: function() {
            if (index >= length) {
              return { done: true, value: null };
            }
            var graphemeBreak = BREAK_NOT_ALLOWED;
            while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {
            }
            if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
              var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
              lastEnd = index;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var splitGraphemes = function(str) {
        var breaker = GraphemeBreaker(str);
        var graphemes = [];
        var bk;
        while (!(bk = breaker.next()).done) {
          if (bk.value) {
            graphemes.push(bk.value.slice());
          }
        }
        return graphemes;
      };
      var testRangeBounds = function(document2) {
        var TEST_HEIGHT = 123;
        if (document2.createRange) {
          var range2 = document2.createRange();
          if (range2.getBoundingClientRect) {
            var testElement = document2.createElement("boundtest");
            testElement.style.height = TEST_HEIGHT + "px";
            testElement.style.display = "block";
            document2.body.appendChild(testElement);
            range2.selectNode(testElement);
            var rangeBounds = range2.getBoundingClientRect();
            var rangeHeight = Math.round(rangeBounds.height);
            document2.body.removeChild(testElement);
            if (rangeHeight === TEST_HEIGHT) {
              return true;
            }
          }
        }
        return false;
      };
      var testIOSLineBreak = function(document2) {
        var testElement = document2.createElement("boundtest");
        testElement.style.width = "50px";
        testElement.style.display = "block";
        testElement.style.fontSize = "12px";
        testElement.style.letterSpacing = "0px";
        testElement.style.wordSpacing = "0px";
        document2.body.appendChild(testElement);
        var range2 = document2.createRange();
        testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
        var node = testElement.firstChild;
        var textList = toCodePoints$1(node.data).map(function(i4) {
          return fromCodePoint$1(i4);
        });
        var offset = 0;
        var prev = {};
        var supports = textList.every(function(text, i4) {
          range2.setStart(node, offset);
          range2.setEnd(node, offset + text.length);
          var rect = range2.getBoundingClientRect();
          offset += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i4 === 0) {
            return true;
          }
          return boundAhead;
        });
        document2.body.removeChild(testElement);
        return supports;
      };
      var testCORS = function() {
        return typeof new Image().crossOrigin !== "undefined";
      };
      var testResponseType = function() {
        return typeof new XMLHttpRequest().responseType === "string";
      };
      var testSVG = function(document2) {
        var img = new Image();
        var canvas = document2.createElement("canvas");
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return false;
        }
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
        } catch (e2) {
          return false;
        }
        return true;
      };
      var isGreenPixel = function(data) {
        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
      };
      var testForeignObject = function(document2) {
        var canvas = document2.createElement("canvas");
        var size = 100;
        canvas.width = size;
        canvas.height = size;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return Promise.reject(false);
        }
        ctx.fillStyle = "rgb(0, 255, 0)";
        ctx.fillRect(0, 0, size, size);
        var img = new Image();
        var greenImageSrc = canvas.toDataURL();
        img.src = greenImageSrc;
        var svg = createForeignObjectSVG(size, size, 0, 0, img);
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size, size);
        return loadSerializedSVG$1(svg).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          var node = document2.createElement("div");
          node.style.backgroundImage = "url(" + greenImageSrc + ")";
          node.style.height = size + "px";
          return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
        }).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
        }).catch(function() {
          return false;
        });
      };
      var createForeignObjectSVG = function(width, height, x4, y4, node) {
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(xmlns, "svg");
        var foreignObject = document.createElementNS(xmlns, "foreignObject");
        svg.setAttributeNS(null, "width", width.toString());
        svg.setAttributeNS(null, "height", height.toString());
        foreignObject.setAttributeNS(null, "width", "100%");
        foreignObject.setAttributeNS(null, "height", "100%");
        foreignObject.setAttributeNS(null, "x", x4.toString());
        foreignObject.setAttributeNS(null, "y", y4.toString());
        foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node);
        return svg;
      };
      var loadSerializedSVG$1 = function(svg) {
        return new Promise(function(resolve2, reject) {
          var img = new Image();
          img.onload = function() {
            return resolve2(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var FEATURES = {
        get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
          return value;
        },
        get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
          return value;
        },
        get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
          return value;
        },
        get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
          Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
          return value;
        },
        get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
          return value;
        },
        get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
          return value;
        },
        get SUPPORT_CORS_XHR() {
          var value = "withCredentials" in new XMLHttpRequest();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
          return value;
        },
        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
          Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
          return value;
        }
      };
      var TextBounds = (
        /** @class */
        function() {
          function TextBounds2(text, bounds) {
            this.text = text;
            this.bounds = bounds;
          }
          return TextBounds2;
        }()
      );
      var parseTextBounds = function(context, value, styles, node) {
        var textList = breakText(value, styles);
        var textBounds = [];
        var offset = 0;
        textList.forEach(function(text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
            if (FEATURES.SUPPORT_RANGE_BOUNDS) {
              var clientRects = createRange(node, offset, text.length).getClientRects();
              if (clientRects.length > 1) {
                var subSegments = segmentGraphemes(text);
                var subOffset_1 = 0;
                subSegments.forEach(function(subSegment) {
                  textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                  subOffset_1 += subSegment.length;
                });
              } else {
                textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
              }
            } else {
              var replacementNode = node.splitText(text.length);
              textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
              node = replacementNode;
            }
          } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
            node = node.splitText(text.length);
          }
          offset += text.length;
        });
        return textBounds;
      };
      var getWrapperBounds = function(context, node) {
        var ownerDocument = node.ownerDocument;
        if (ownerDocument) {
          var wrapper = ownerDocument.createElement("html2canvaswrapper");
          wrapper.appendChild(node.cloneNode(true));
          var parentNode = node.parentNode;
          if (parentNode) {
            parentNode.replaceChild(wrapper, node);
            var bounds = parseBounds(context, wrapper);
            if (wrapper.firstChild) {
              parentNode.replaceChild(wrapper.firstChild, wrapper);
            }
            return bounds;
          }
        }
        return Bounds.EMPTY;
      };
      var createRange = function(node, offset, length) {
        var ownerDocument = node.ownerDocument;
        if (!ownerDocument) {
          throw new Error("Node has no owner document");
        }
        var range2 = ownerDocument.createRange();
        range2.setStart(node, offset);
        range2.setEnd(node, offset + length);
        return range2;
      };
      var segmentGraphemes = function(value) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return splitGraphemes(value);
      };
      var segmentWords = function(value, styles) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, {
            granularity: "word"
          });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return breakWords(value, styles);
      };
      var breakText = function(value, styles) {
        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
      };
      var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
      var breakWords = function(str, styles) {
        var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
        });
        var words = [];
        var bk;
        var _loop_1 = function() {
          if (bk.value) {
            var value = bk.value.slice();
            var codePoints = toCodePoints$1(value);
            var word_1 = "";
            codePoints.forEach(function(codePoint) {
              if (wordSeparators.indexOf(codePoint) === -1) {
                word_1 += fromCodePoint$1(codePoint);
              } else {
                if (word_1.length) {
                  words.push(word_1);
                }
                words.push(fromCodePoint$1(codePoint));
                word_1 = "";
              }
            });
            if (word_1.length) {
              words.push(word_1);
            }
          }
        };
        while (!(bk = breaker.next()).done) {
          _loop_1();
        }
        return words;
      };
      var TextContainer = (
        /** @class */
        function() {
          function TextContainer2(context, node, styles) {
            this.text = transform(node.data, styles.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles, node);
          }
          return TextContainer2;
        }()
      );
      var transform = function(text, transform2) {
        switch (transform2) {
          case 1:
            return text.toLowerCase();
          case 3:
            return text.replace(CAPITALIZE, capitalize);
          case 2:
            return text.toUpperCase();
          default:
            return text;
        }
      };
      var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
      var capitalize = function(m5, p1, p22) {
        if (m5.length > 0) {
          return p1 + p22.toUpperCase();
        }
        return m5;
      };
      var ImageElementContainer = (
        /** @class */
        function(_super) {
          __extends2(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer)
      );
      var CanvasElementContainer = (
        /** @class */
        function(_super) {
          __extends2(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer)
      );
      var SVGElementContainer = (
        /** @class */
        function(_super) {
          __extends2(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s5 = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s5.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer)
      );
      var LIElementContainer = (
        /** @class */
        function(_super) {
          __extends2(LIElementContainer2, _super);
          function LIElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer)
      );
      var OLElementContainer = (
        /** @class */
        function(_super) {
          __extends2(OLElementContainer2, _super);
          function OLElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.start = element.start;
            _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer)
      );
      var CHECKBOX_BORDER_RADIUS = [
        {
          type: 15,
          flags: 0,
          unit: "px",
          number: 3
        }
      ];
      var RADIO_BORDER_RADIUS = [
        {
          type: 16,
          flags: 0,
          number: 50
        }
      ];
      var reformatInputBounds = function(bounds) {
        if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
        } else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
        }
        return bounds;
      };
      var getInputValue = function(node) {
        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
        return value.length === 0 ? node.placeholder || "" : value;
      };
      var CHECKBOX = "checkbox";
      var RADIO = "radio";
      var PASSWORD = "password";
      var INPUT_COLOR = 707406591;
      var InputElementContainer = (
        /** @class */
        function(_super) {
          __extends2(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
              _this.styles.backgroundClip = [
                0
                /* BORDER_BOX */
              ];
              _this.styles.backgroundOrigin = [
                0
                /* BORDER_BOX */
              ];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer)
      );
      var SelectElementContainer = (
        /** @class */
        function(_super) {
          __extends2(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            var option = element.options[element.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer)
      );
      var TextareaElementContainer = (
        /** @class */
        function(_super) {
          __extends2(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer)
      );
      var IFrameElementContainer = (
        /** @class */
        function(_super) {
          __extends2(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e2) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer)
      );
      var LIST_OWNERS = ["OL", "UL", "MENU"];
      var parseNodeTree = function(context, node, parent, root) {
        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
            parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          } else if (isElementNode(childNode)) {
            if (isSlotElement(childNode) && childNode.assignedNodes) {
              childNode.assignedNodes().forEach(function(childNode2) {
                return parseNodeTree(context, childNode2, parent, root);
              });
            } else {
              var container = createContainer(context, childNode);
              if (container.styles.isVisible()) {
                if (createsRealStackingContext(childNode, container, root)) {
                  container.flags |= 4;
                } else if (createsStackingContext(container.styles)) {
                  container.flags |= 2;
                }
                if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                  container.flags |= 8;
                }
                parent.elements.push(container);
                childNode.slot;
                if (childNode.shadowRoot) {
                  parseNodeTree(context, childNode.shadowRoot, container, root);
                } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                  parseNodeTree(context, childNode, container, root);
                }
              }
            }
          }
        }
      };
      var createContainer = function(context, element) {
        if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
        }
        if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
        }
        if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
        }
        if (isLIElement(element)) {
          return new LIElementContainer(context, element);
        }
        if (isOLElement(element)) {
          return new OLElementContainer(context, element);
        }
        if (isInputElement(element)) {
          return new InputElementContainer(context, element);
        }
        if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
        }
        if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
        }
        if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
        }
        return new ElementContainer(context, element);
      };
      var parseTree = function(context, element) {
        var container = createContainer(context, element);
        container.flags |= 4;
        parseNodeTree(context, element, container, container);
        return container;
      };
      var createsRealStackingContext = function(node, container, root) {
        return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
      };
      var createsStackingContext = function(styles) {
        return styles.isPositioned() || styles.isFloating();
      };
      var isTextNode = function(node) {
        return node.nodeType === Node.TEXT_NODE;
      };
      var isElementNode = function(node) {
        return node.nodeType === Node.ELEMENT_NODE;
      };
      var isHTMLElementNode = function(node) {
        return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
      };
      var isSVGElementNode = function(element) {
        return typeof element.className === "object";
      };
      var isLIElement = function(node) {
        return node.tagName === "LI";
      };
      var isOLElement = function(node) {
        return node.tagName === "OL";
      };
      var isInputElement = function(node) {
        return node.tagName === "INPUT";
      };
      var isHTMLElement = function(node) {
        return node.tagName === "HTML";
      };
      var isSVGElement = function(node) {
        return node.tagName === "svg";
      };
      var isBodyElement = function(node) {
        return node.tagName === "BODY";
      };
      var isCanvasElement = function(node) {
        return node.tagName === "CANVAS";
      };
      var isVideoElement = function(node) {
        return node.tagName === "VIDEO";
      };
      var isImageElement = function(node) {
        return node.tagName === "IMG";
      };
      var isIFrameElement = function(node) {
        return node.tagName === "IFRAME";
      };
      var isStyleElement = function(node) {
        return node.tagName === "STYLE";
      };
      var isScriptElement = function(node) {
        return node.tagName === "SCRIPT";
      };
      var isTextareaElement = function(node) {
        return node.tagName === "TEXTAREA";
      };
      var isSelectElement = function(node) {
        return node.tagName === "SELECT";
      };
      var isSlotElement = function(node) {
        return node.tagName === "SLOT";
      };
      var isCustomElement = function(node) {
        return node.tagName.indexOf("-") > 0;
      };
      var CounterState = (
        /** @class */
        function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name2) {
            var counter = this.counters[name2];
            if (counter && counter.length) {
              return counter[counter.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name2) {
            var counter = this.counters[name2];
            return counter ? counter : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter) {
              return _this.counters[counter].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                if (counter && entry.increment !== 0) {
                  canReset = false;
                  if (!counter.length) {
                    counter.push(1);
                  }
                  counter[Math.max(0, counter.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter) {
                  counter = _this.counters[entry.counter] = [];
                }
                counter.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }()
      );
      var ROMAN_UPPER = {
        integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
        values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
      };
      var ARMENIAN = {
        integers: [
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u0554",
          "\u0553",
          "\u0552",
          "\u0551",
          "\u0550",
          "\u054F",
          "\u054E",
          "\u054D",
          "\u054C",
          "\u054B",
          "\u054A",
          "\u0549",
          "\u0548",
          "\u0547",
          "\u0546",
          "\u0545",
          "\u0544",
          "\u0543",
          "\u0542",
          "\u0541",
          "\u0540",
          "\u053F",
          "\u053E",
          "\u053D",
          "\u053C",
          "\u053B",
          "\u053A",
          "\u0539",
          "\u0538",
          "\u0537",
          "\u0536",
          "\u0535",
          "\u0534",
          "\u0533",
          "\u0532",
          "\u0531"
        ]
      };
      var HEBREW = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          19,
          18,
          17,
          16,
          15,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u05D9\u05F3",
          "\u05D8\u05F3",
          "\u05D7\u05F3",
          "\u05D6\u05F3",
          "\u05D5\u05F3",
          "\u05D4\u05F3",
          "\u05D3\u05F3",
          "\u05D2\u05F3",
          "\u05D1\u05F3",
          "\u05D0\u05F3",
          "\u05EA",
          "\u05E9",
          "\u05E8",
          "\u05E7",
          "\u05E6",
          "\u05E4",
          "\u05E2",
          "\u05E1",
          "\u05E0",
          "\u05DE",
          "\u05DC",
          "\u05DB",
          "\u05D9\u05D8",
          "\u05D9\u05D7",
          "\u05D9\u05D6",
          "\u05D8\u05D6",
          "\u05D8\u05D5",
          "\u05D9",
          "\u05D8",
          "\u05D7",
          "\u05D6",
          "\u05D5",
          "\u05D4",
          "\u05D3",
          "\u05D2",
          "\u05D1",
          "\u05D0"
        ]
      };
      var GEORGIAN = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u10F5",
          "\u10F0",
          "\u10EF",
          "\u10F4",
          "\u10EE",
          "\u10ED",
          "\u10EC",
          "\u10EB",
          "\u10EA",
          "\u10E9",
          "\u10E8",
          "\u10E7",
          "\u10E6",
          "\u10E5",
          "\u10E4",
          "\u10F3",
          "\u10E2",
          "\u10E1",
          "\u10E0",
          "\u10DF",
          "\u10DE",
          "\u10DD",
          "\u10F2",
          "\u10DC",
          "\u10DB",
          "\u10DA",
          "\u10D9",
          "\u10D8",
          "\u10D7",
          "\u10F1",
          "\u10D6",
          "\u10D5",
          "\u10D4",
          "\u10D3",
          "\u10D2",
          "\u10D1",
          "\u10D0"
        ]
      };
      var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
        if (value < min || value > max) {
          return createCounterText(value, fallback, suffix.length > 0);
        }
        return symbols.integers.reduce(function(string, integer, index) {
          while (value >= integer) {
            value -= integer;
            string += symbols.values[index];
          }
          return string;
        }, "") + suffix;
      };
      var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
        var string = "";
        do {
          if (!isNumeric) {
            value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
        } while (value * codePointRangeLength >= codePointRangeLength);
        return string;
      };
      var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
        return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
          return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
        }) + suffix);
      };
      var createCounterStyleFromSymbols = function(value, symbols, suffix) {
        if (suffix === void 0) {
          suffix = ". ";
        }
        var codePointRangeLength = symbols.length;
        return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
          return symbols[Math.floor(codePoint % codePointRangeLength)];
        }) + suffix;
      };
      var CJK_ZEROS = 1 << 0;
      var CJK_TEN_COEFFICIENTS = 1 << 1;
      var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
      var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
      var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags2) {
        if (value < -9999 || value > 9999) {
          return createCounterText(value, 4, suffix.length > 0);
        }
        var tmp = Math.abs(value);
        var string = suffix;
        if (tmp === 0) {
          return numbers[0] + string;
        }
        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags2, CJK_ZEROS) && string !== "") {
            string = numbers[coefficient] + string;
          } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags2, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags2, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags2, CJK_HUNDRED_COEFFICIENTS)) {
            string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
          } else if (coefficient === 1 && digit > 0) {
            string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
        }
        return (value < 0 ? negativeSign : "") + string;
      };
      var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
      var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
      var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
      var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
      var createCounterText = function(value, type, appendSuffix) {
        var defaultSuffix = appendSuffix ? ". " : "";
        var cjkSuffix = appendSuffix ? "\u3001" : "";
        var koreanSuffix = appendSuffix ? ", " : "";
        var spaceSuffix = appendSuffix ? " " : "";
        switch (type) {
          case 0:
            return "\u2022" + spaceSuffix;
          case 1:
            return "\u25E6" + spaceSuffix;
          case 2:
            return "\u25FE" + spaceSuffix;
          case 5:
            var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            return string.length < 4 ? "0" + string : string;
          case 4:
            return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
          case 6:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
          case 7:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
          case 8:
            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9:
            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10:
            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11:
            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12:
          case 49:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
          case 35:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
          case 13:
            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14:
          case 30:
            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15:
            return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
          case 16:
            return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
          case 17:
          case 48:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41:
            return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26:
            return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25:
            return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31:
            return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18:
            return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
          case 20:
            return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
          case 21:
            return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
          case 22:
            return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
          case 22:
            return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
          case 23:
            return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
          case 24:
            return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
          case 27:
            return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
          case 28:
            return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
          case 29:
            return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
          case 34:
            return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
          case 37:
            return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
          case 38:
            return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
          case 39:
            return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
          case 40:
            return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
          case 43:
            return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
          case 44:
            return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
          case 45:
            return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
          case 46:
            return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
          case 3:
          default:
            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        }
      };
      var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
      var DocumentCloner = (
        /** @class */
        function() {
          function DocumentCloner2(context, element, options) {
            this.context = context;
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter2(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator2(this, function(_a) {
                  switch (_a.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a.sent();
                      _a.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a.sent();
                      _a.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node) {
            if (isDebugging(
              node,
              2
              /* CLONE */
            )) {
              debugger;
            }
            if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
            }
            if (isVideoElement(node)) {
              return this.createVideoClone(node);
            }
            if (isStyleElement(node)) {
              return this.createStyleClone(node);
            }
            var clone = node.cloneNode(false);
            if (isImageElement(clone)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                clone.src = node.currentSrc;
                clone.srcset = "";
              }
              if (clone.loading === "lazy") {
                clone.loading = "eager";
              }
            }
            if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
            }
            return clone;
          };
          DocumentCloner2.prototype.createCustomElementClone = function(node) {
            var clone = document.createElement("html2canvascustomelement");
            copyCSSStyles(node.style, clone);
            return clone;
          };
          DocumentCloner2.prototype.createStyleClone = function(node) {
            try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css2 + rule.cssText;
                  }
                  return css2;
                }, "");
                var style = node.cloneNode(false);
                style.textContent = css;
                return style;
              }
            } catch (e2) {
              this.context.logger.error("Unable to access cssRules property", e2);
              if (e2.name !== "SecurityError") {
                throw e2;
              }
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e2) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a = canvas.getContext("webgl2")) !== null && _a !== void 0 ? _a : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e2) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.createVideoClone = function(video) {
            var canvas = video.ownerDocument.createElement("canvas");
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            var ctx = canvas.getContext("2d");
            try {
              if (ctx) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (!this.options.allowTaint) {
                  ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
              }
              return canvas;
            } catch (e2) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
            }
            var blankCanvas = video.ownerDocument.createElement("canvas");
            blankCanvas.width = video.offsetWidth;
            blankCanvas.height = video.offsetHeight;
            return blankCanvas;
          };
          DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
            if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                clone.appendChild(this.cloneNode(child, copyStyles));
              }
            }
          };
          DocumentCloner2.prototype.cloneChildNodes = function(node, clone, copyStyles) {
            var _this = this;
            for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
                var assignedNodes = child.assignedNodes();
                if (assignedNodes.length) {
                  assignedNodes.forEach(function(assignedNode) {
                    return _this.appendChildNode(clone, assignedNode, copyStyles);
                  });
                }
              } else {
                this.appendChildNode(clone, child, copyStyles);
              }
            }
          };
          DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
            if (isTextNode(node)) {
              return document.createTextNode(node.data);
            }
            if (!node.ownerDocument) {
              return node.cloneNode(false);
            }
            var window2 = node.ownerDocument.defaultView;
            if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone = this.createElementClone(node);
              clone.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node);
              var styleBefore = window2.getComputedStyle(node, ":before");
              var styleAfter = window2.getComputedStyle(node, ":after");
              if (this.referenceElement === node && isHTMLElementNode(clone)) {
                this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node)) {
                copyStyles = true;
              }
              if (!isVideoElement(node)) {
                this.cloneChildNodes(node, clone, copyStyles);
              }
              if (before) {
                clone.insertBefore(before, clone.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
              if (after) {
                clone.appendChild(after);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
                copyCSSStyles(style, clone);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone) || isSelectElement(clone))) {
                clone.value = node.value;
              }
              return clone;
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node, clone, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document2 = clone.ownerDocument;
            if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document2.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr = token.values.filter(isIdentToken);
                  if (attr.length) {
                    anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
                  if (counter && isIdentToken(counter)) {
                    var counterState = _this.counters.getCounterValue(counter.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                  if (counter && isIdentToken(counter)) {
                    var counterStates = _this.counters.getCounterValues(counter.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document2.createTextNode(text));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
            } else {
              clone.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }()
      );
      var PseudoElementType;
      (function(PseudoElementType2) {
        PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
        PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
      })(PseudoElementType || (PseudoElementType = {}));
      var createIFrameContainer = function(ownerDocument, bounds) {
        var cloneIframeContainer = ownerDocument.createElement("iframe");
        cloneIframeContainer.className = "html2canvas-container";
        cloneIframeContainer.style.visibility = "hidden";
        cloneIframeContainer.style.position = "fixed";
        cloneIframeContainer.style.left = "-10000px";
        cloneIframeContainer.style.top = "0px";
        cloneIframeContainer.style.border = "0";
        cloneIframeContainer.width = bounds.width.toString();
        cloneIframeContainer.height = bounds.height.toString();
        cloneIframeContainer.scrolling = "no";
        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
        ownerDocument.body.appendChild(cloneIframeContainer);
        return cloneIframeContainer;
      };
      var imageReady = function(img) {
        return new Promise(function(resolve2) {
          if (img.complete) {
            resolve2();
            return;
          }
          if (!img.src) {
            resolve2();
            return;
          }
          img.onload = resolve2;
          img.onerror = resolve2;
        });
      };
      var imagesReady = function(document2) {
        return Promise.all([].slice.call(document2.images, 0).map(imageReady));
      };
      var iframeLoader = function(iframe) {
        return new Promise(function(resolve2, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
            return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function() {
            cloneWindow.onload = iframe.onload = null;
            var interval = setInterval(function() {
              if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                clearInterval(interval);
                resolve2(iframe);
              }
            }, 50);
          };
        });
      };
      var ignoredStyleProperties = [
        "all",
        "d",
        "content"
        // Safari shows pseudoelements if content is set
      ];
      var copyCSSStyles = function(style, target) {
        for (var i4 = style.length - 1; i4 >= 0; i4--) {
          var property = style.item(i4);
          if (ignoredStyleProperties.indexOf(property) === -1) {
            target.style.setProperty(property, style.getPropertyValue(property));
          }
        }
        return target;
      };
      var serializeDoctype = function(doctype) {
        var str = "";
        if (doctype) {
          str += "<!DOCTYPE ";
          if (doctype.name) {
            str += doctype.name;
          }
          if (doctype.internalSubset) {
            str += doctype.internalSubset;
          }
          if (doctype.publicId) {
            str += '"' + doctype.publicId + '"';
          }
          if (doctype.systemId) {
            str += '"' + doctype.systemId + '"';
          }
          str += ">";
        }
        return str;
      };
      var restoreOwnerScroll = function(ownerDocument, x4, y4) {
        if (ownerDocument && ownerDocument.defaultView && (x4 !== ownerDocument.defaultView.pageXOffset || y4 !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x4, y4);
        }
      };
      var restoreNodeScroll = function(_a) {
        var element = _a[0], x4 = _a[1], y4 = _a[2];
        element.scrollLeft = x4;
        element.scrollTop = y4;
      };
      var PSEUDO_BEFORE = ":before";
      var PSEUDO_AFTER = ":after";
      var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
      var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
      var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
      var createPseudoHideStyles = function(body2) {
        createStyles(body2, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
      };
      var createStyles = function(body2, styles) {
        var document2 = body2.ownerDocument;
        if (document2) {
          var style = document2.createElement("style");
          style.textContent = styles;
          body2.appendChild(style);
        }
      };
      var CacheStorage = (
        /** @class */
        function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url) {
            var link = CacheStorage2._link;
            if (!link) {
              return "about:blank";
            }
            link.href = url;
            link.href = link.href;
            return link.protocol + link.hostname + link.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }()
      );
      var Cache2 = (
        /** @class */
        function() {
          function Cache3(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache3.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache3.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache3.prototype.loadImage = function(key) {
            return __awaiter2(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a.sent();
                    _a.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve2, reject) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve2(img);
                      };
                      img.onerror = reject;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve2(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Cache3.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache3.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache3.prototype.proxy = function(src) {
            var _this = this;
            var proxy2 = this._options.proxy;
            if (!proxy2) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve2, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr = new XMLHttpRequest();
              xhr.onload = function() {
                if (xhr.status === 200) {
                  if (responseType === "text") {
                    resolve2(xhr.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve2(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e2) {
                      return reject(e2);
                    }, false);
                    reader_1.readAsDataURL(xhr.response);
                  }
                } else {
                  reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                }
              };
              xhr.onerror = reject;
              var queryString = proxy2.indexOf("?") > -1 ? "&" : "?";
              xhr.open("GET", "" + proxy2 + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
                xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr.timeout = timeout_1;
                xhr.ontimeout = function() {
                  return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr.send();
            });
          };
          return Cache3;
        }()
      );
      var INLINE_SVG = /^data:image\/svg\+xml/i;
      var INLINE_BASE64 = /^data:image\/.*;base64,/i;
      var INLINE_IMG = /^data:image\/.*/i;
      var isRenderable = function(src) {
        return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
      };
      var isInlineImage = function(src) {
        return INLINE_IMG.test(src);
      };
      var isInlineBase64Image = function(src) {
        return INLINE_BASE64.test(src);
      };
      var isBlobImage = function(src) {
        return src.substr(0, 4) === "blob";
      };
      var isSVG = function(src) {
        return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
      };
      var Vector = (
        /** @class */
        function() {
          function Vector2(x4, y4) {
            this.type = 0;
            this.x = x4;
            this.y = y4;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }()
      );
      var lerp = function(a3, b4, t2) {
        return new Vector(a3.x + (b4.x - a3.x) * t2, a3.y + (b4.y - a3.y) * t2);
      };
      var BezierCurve = (
        /** @class */
        function() {
          function BezierCurve2(start2, startControl, endControl, end) {
            this.type = 1;
            this.start = start2;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
          }
          BezierCurve2.prototype.subdivide = function(t2, firstHalf) {
            var ab = lerp(this.start, this.startControl, t2);
            var bc = lerp(this.startControl, this.endControl, t2);
            var cd = lerp(this.endControl, this.end, t2);
            var abbc = lerp(ab, bc, t2);
            var bccd = lerp(bc, cd, t2);
            var dest = lerp(abbc, bccd, t2);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }()
      );
      var isBezierCurve = function(path2) {
        return path2.type === 1;
      };
      var BoundCurves = (
        /** @class */
        function() {
          function BoundCurves2(element) {
            var styles = element.styles;
            var bounds = element.bounds;
            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles.borderTopWidth;
            var borderRightWidth2 = styles.borderRightWidth;
            var borderBottomWidth2 = styles.borderBottomWidth;
            var borderLeftWidth2 = styles.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }()
      );
      var CORNER;
      (function(CORNER2) {
        CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
        CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
        CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
        CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
      })(CORNER || (CORNER = {}));
      var getCurvePoints = function(x4, y4, r1, r2, position2) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = r1 * kappa;
        var oy = r2 * kappa;
        var xm = x4 + r1;
        var ym = y4 + r2;
        switch (position2) {
          case CORNER.TOP_LEFT:
            return new BezierCurve(new Vector(x4, ym), new Vector(x4, ym - oy), new Vector(xm - ox, y4), new Vector(xm, y4));
          case CORNER.TOP_RIGHT:
            return new BezierCurve(new Vector(x4, y4), new Vector(x4 + ox, y4), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
            return new BezierCurve(new Vector(xm, y4), new Vector(xm, y4 + oy), new Vector(x4 + ox, ym), new Vector(x4, ym));
          case CORNER.BOTTOM_LEFT:
          default:
            return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x4, y4 + oy), new Vector(x4, y4));
        }
      };
      var calculateBorderBoxPath = function(curves) {
        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
      };
      var calculateContentBoxPath = function(curves) {
        return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
        ];
      };
      var calculatePaddingBoxPath = function(curves) {
        return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
        ];
      };
      var TransformEffect = (
        /** @class */
        function() {
          function TransformEffect2(offsetX, offsetY, matrix2) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix2;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }()
      );
      var ClipEffect = (
        /** @class */
        function() {
          function ClipEffect2(path2, target) {
            this.path = path2;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }()
      );
      var OpacityEffect = (
        /** @class */
        function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }()
      );
      var isTransformEffect = function(effect) {
        return effect.type === 0;
      };
      var isClipEffect = function(effect) {
        return effect.type === 1;
      };
      var isOpacityEffect = function(effect) {
        return effect.type === 2;
      };
      var equalPath = function(a3, b4) {
        if (a3.length === b4.length) {
          return a3.some(function(v4, i4) {
            return v4 === b4[i4];
          });
        }
        return false;
      };
      var transformPath = function(path2, deltaX, deltaY, deltaW, deltaH) {
        return path2.map(function(point, index) {
          switch (index) {
            case 0:
              return point.add(deltaX, deltaY);
            case 1:
              return point.add(deltaX + deltaW, deltaY);
            case 2:
              return point.add(deltaX + deltaW, deltaY + deltaH);
            case 3:
              return point.add(deltaX, deltaY + deltaH);
          }
          return point;
        });
      };
      var StackingContext = (
        /** @class */
        function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }()
      );
      var ElementPaint = (
        /** @class */
        function() {
          function ElementPaint2(container, parent) {
            this.container = container;
            this.parent = parent;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix2 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
            }
            if (this.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2 | 4
                  /* CONTENT */
                ));
              } else {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2
                  /* BACKGROUND_BORDERS */
                ));
                this.effects.push(new ClipEffect(
                  paddingBox2,
                  4
                  /* CONTENT */
                ));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(this.container.styles.position) === -1;
            var parent = this.parent;
            var effects = this.effects.slice(0);
            while (parent) {
              var croplessEffects = parent.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [
                  2,
                  3
                  /* FIXED */
                ].indexOf(parent.container.styles.position) === -1;
                if (parent.container.styles.overflowX !== 0) {
                  var borderBox = calculateBorderBoxPath(parent.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(
                      paddingBox2,
                      2 | 4
                      /* CONTENT */
                    ));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
            }
            return effects.filter(function(effect) {
              return contains(effect.target, target);
            });
          };
          return ElementPaint2;
        }()
      );
      var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
        parent.container.elements.forEach(function(child) {
          var treatAsRealStackingContext = contains(
            child.flags,
            4
            /* CREATES_REAL_STACKING_CONTEXT */
          );
          var createsStackingContext2 = contains(
            child.flags,
            2
            /* CREATES_STACKING_CONTEXT */
          );
          var paintContainer = new ElementPaint(child, parent);
          if (contains(
            child.styles.display,
            2048
            /* LIST_ITEM */
          )) {
            listItems.push(paintContainer);
          }
          var listOwnerItems = contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          ) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext2) {
            var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
            var stack = new StackingContext(paintContainer);
            if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
              var order_1 = child.styles.zIndex.order;
              if (order_1 < 0) {
                var index_1 = 0;
                parentStack.negativeZIndex.some(function(current, i4) {
                  if (order_1 > current.element.container.styles.zIndex.order) {
                    index_1 = i4;
                    return false;
                  } else if (index_1 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.negativeZIndex.splice(index_1, 0, stack);
              } else if (order_1 > 0) {
                var index_2 = 0;
                parentStack.positiveZIndex.some(function(current, i4) {
                  if (order_1 >= current.element.container.styles.zIndex.order) {
                    index_2 = i4 + 1;
                    return false;
                  } else if (index_2 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.positiveZIndex.splice(index_2, 0, stack);
              } else {
                parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
              }
            } else {
              if (child.styles.isFloating()) {
                parentStack.nonPositionedFloats.push(stack);
              } else {
                parentStack.nonPositionedInlineLevel.push(stack);
              }
            }
            parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          } else {
            if (child.styles.isInlineLevel()) {
              stackingContext.inlineLevel.push(paintContainer);
            } else {
              stackingContext.nonInlineLevel.push(paintContainer);
            }
            parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          )) {
            processListItems(child, listOwnerItems);
          }
        });
      };
      var processListItems = function(owner, elements) {
        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
        for (var i4 = 0; i4 < elements.length; i4++) {
          var item = elements[i4];
          if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
            numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
        }
      };
      var parseStackingContexts = function(container) {
        var paintContainer = new ElementPaint(container, null);
        var root = new StackingContext(paintContainer);
        var listItems = [];
        parseStackTree(paintContainer, root, root, listItems);
        processListItems(paintContainer.container, listItems);
        return root;
      };
      var parsePathForBorder = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderDoubleOuter = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
        }
      };
      var parsePathForBorderDoubleInner = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderStroke = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
            return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
            return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
            return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
        }
      };
      var createStrokePathFromCurves = function(outer1, outer2) {
        var path2 = [];
        if (isBezierCurve(outer1)) {
          path2.push(outer1.subdivide(0.5, false));
        } else {
          path2.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path2.push(outer2.subdivide(0.5, true));
        } else {
          path2.push(outer2);
        }
        return path2;
      };
      var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
        var path2 = [];
        if (isBezierCurve(outer1)) {
          path2.push(outer1.subdivide(0.5, false));
        } else {
          path2.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path2.push(outer2.subdivide(0.5, true));
        } else {
          path2.push(outer2);
        }
        if (isBezierCurve(inner2)) {
          path2.push(inner2.subdivide(0.5, true).reverse());
        } else {
          path2.push(inner2);
        }
        if (isBezierCurve(inner1)) {
          path2.push(inner1.subdivide(0.5, false).reverse());
        } else {
          path2.push(inner1);
        }
        return path2;
      };
      var paddingBox = function(element) {
        var bounds = element.bounds;
        var styles = element.styles;
        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
      };
      var contentBox = function(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
        return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
      };
      var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
        if (backgroundOrigin2 === 0) {
          return element.bounds;
        }
        if (backgroundOrigin2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
        if (backgroundClip2 === 0) {
          return element.bounds;
        }
        if (backgroundClip2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundRendering = function(container, index, intrinsicSize) {
        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
        var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
        var path2 = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
        var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
        var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
        return [path2, offsetX, offsetY, sizeWidth, sizeHeight];
      };
      var isAuto = function(token) {
        return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
      };
      var hasIntrinsicValue = function(value) {
        return typeof value === "number";
      };
      var calculateBackgroundSize = function(size, _a, bounds) {
        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
        var first = size[0], second = size[1];
        if (!first) {
          return [0, 0];
        }
        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
        }
        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
            var targetRatio = bounds.width / bounds.height;
            return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
        }
        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
        if (isAuto(first) && (!second || isAuto(second))) {
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
            return [intrinsicWidth, intrinsicHeight];
          }
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
            return [bounds.width, bounds.height];
          }
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
            var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
            var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
            return [width_1, height_1];
          }
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
        }
        if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
            width_3 = getAbsoluteValue(first, bounds.width);
          } else if (isLengthPercentage(second)) {
            height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
            width_3 = height_3 * intrinsicProportion;
          } else if (!second || isAuto(second)) {
            height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
        }
        var width = null;
        var height = null;
        if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
        } else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
        }
        if (width !== null && (!second || isAuto(second))) {
          height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
        }
        if (height !== null && isAuto(first)) {
          width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
        }
        if (width !== null && height !== null) {
          return [width, height];
        }
        throw new Error("Unable to calculate background-size for element");
      };
      var getBackgroundValueForIndex = function(values2, index) {
        var value = values2[index];
        if (typeof value === "undefined") {
          return values2[0];
        }
        return value;
      };
      var calculateBackgroundRepeatPath = function(repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
        var x4 = _a[0], y4 = _a[1];
        var width = _b[0], height = _b[1];
        switch (repeat) {
          case 2:
            return [
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y4)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y4)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y4)),
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y4))
            ];
          case 3:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x4), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x4 + width), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x4 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x4), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
            ];
          case 1:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x4), Math.round(backgroundPositioningArea.top + y4)),
              new Vector(Math.round(backgroundPositioningArea.left + x4 + width), Math.round(backgroundPositioningArea.top + y4)),
              new Vector(Math.round(backgroundPositioningArea.left + x4 + width), Math.round(backgroundPositioningArea.top + y4 + height)),
              new Vector(Math.round(backgroundPositioningArea.left + x4), Math.round(backgroundPositioningArea.top + y4 + height))
            ];
          default:
            return [
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
            ];
        }
      };
      var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      var SAMPLE_TEXT = "Hidden Text";
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(document2) {
            this._data = {};
            this._document = document2;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body2 = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            container.style.whiteSpace = "nowrap";
            body2.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body2.removeChild(container);
            return { baseline, middle };
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }()
      );
      var Renderer = (
        /** @class */
        function() {
          function Renderer2(context, options) {
            this.context = context;
            this.options = options;
          }
          return Renderer2;
        }()
      );
      var MASK_OFFSET = 1e4;
      var CanvasRenderer = (
        /** @class */
        function(_super) {
          __extends2(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this._activeEffects = [];
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter2(this, void 0, void 0, function() {
              var styles;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    styles = stack.element.container.styles;
                    if (!styles.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (contains(
                      paint.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a.sent();
                    _a.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
            } else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles) {
            var fontVariant2 = styles.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
            var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
            return [
              [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
            return __awaiter2(this, void 0, void 0, function() {
              var _a, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
              var _this = this;
              return __generator2(this, function(_c) {
                _a = this.createFontStyle(styles), font = _a[0], fontFamily2 = _a[1], fontSize2 = _a[2];
                this.ctx.font = font;
                this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
                paintOrder2 = styles.paintOrder;
                text.textBounds.forEach(function(text2) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case 0:
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text2.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                          styles.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case 1:
                        if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path2 = calculatePaddingBoxPath(curves);
              this.path(path2);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter2(this, void 0, void 0, function() {
              var container, curves, styles, _i, _a, child, image2, image2, iframeRenderer, canvas, size, _b, fontFamily2, fontSize2, baseline, bounds, x4, textBounds, img, image2, url, fontFamily2, bounds;
              return __generator2(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      4
                      /* CONTENT */
                    ));
                    container = paint.container;
                    curves = paint.curves;
                    styles = container.styles;
                    _i = 0, _a = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a.length))
                      return [3, 4];
                    child = _a[_i];
                    return [4, this.renderTextNode(child, styles)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x4 = 0;
                      switch (container.styles.textAlign) {
                        case 1:
                          x4 += bounds.width / 2;
                          break;
                        case 2:
                          x4 += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x4, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains(
                      container.styles.display,
                      2048
                      /* LIST_ITEM */
                    ))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === 0))
                      return [3, 18];
                    image2 = void 0;
                    url = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== -1) {
                      fontFamily2 = this.createFontStyle(styles)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter2(this, void 0, void 0, function() {
              var _i, _a, child, _b, _c, child, _d, _e2, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator2(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains(
                      stack.element.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a.length))
                      return [3, 5];
                    child = _a[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b < _c.length))
                      return [3, 10];
                    child = _c[_b];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e2 = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e2.length))
                      return [3, 14];
                    child = _e2[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point, index) {
              var start2 = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                _this.ctx.moveTo(start2.x, start2.y);
              } else {
                _this.ctx.lineTo(start2.x, start2.y);
              }
              if (isBezierCurve(point)) {
                _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path2, pattern, offsetX, offsetY) {
            this.path(path2);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
            var _a;
            if (image2.width === width && image2.height === height) {
              return image2;
            }
            var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width);
            canvas.height = Math.max(1, height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter2(this, void 0, void 0, function() {
              var index, _loop_1, this_1, _i, _a, backgroundImage2;
              return __generator2(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    index = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url, _c, path2, x4, y4, width, height, pattern, _d, path2, x4, y4, width, height, _e2, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path2, left, top_1, width, height, position2, x4, y4, _g, rx, ry, radialGradient_1, midX, midY, f4, invF;
                      return __generator2(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === 0))
                              return [3, 5];
                            image2 = void 0;
                            url = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path2 = _c[0], x4 = _c[1], y4 = _c[2], width = _c[3], height = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                              this_1.renderRepeat(path2, pattern, x4, y4);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path2 = _d[0], x4 = _d[1], y4 = _d[2], width = _d[3], height = _d[4];
                              _e2 = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e2[0], x0 = _e2[1], x1 = _e2[2], y0 = _e2[3], y1 = _e2[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width;
                              canvas.height = height;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width, height);
                              if (width > 0 && height > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path2, pattern, x4, y4);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index, [
                                null,
                                null,
                                null
                              ]), path2 = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                              position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x4 = getAbsoluteValue(position2[0], width);
                              y4 = getAbsoluteValue(position2[position2.length - 1], height);
                              _g = calculateRadius(backgroundImage3, x4, y4, width, height), rx = _g[0], ry = _g[1];
                              if (rx > 0 && ry > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x4, top_1 + y4, 0, left + x4, top_1 + y4, rx);
                                processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path2);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx !== ry) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f4 = ry / rx;
                                  invF = 1 / f4;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f4, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index--;
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                    _b.label = 1;
                  case 1:
                    if (!(_i < _a.length))
                      return [3, 4];
                    backgroundImage2 = _a[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
            return __awaiter2(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!(width < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter2(this, void 0, void 0, function() {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      2
                      /* BACKGROUND_BORDERS */
                    ));
                    styles = paint.container.styles;
                    hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                    borders = [
                      { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                      { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                      { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                      { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent(styles.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a.sent();
                    this.ctx.restore();
                    styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === 2))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      2
                      /* DASHED */
                    )];
                  case 4:
                    _a.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === 3))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      3
                      /* DOTTED */
                    )];
                  case 6:
                    _a.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === 4))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a.sent();
                    _a.label = 11;
                  case 11:
                    side++;
                    _a.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
            return __awaiter2(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator2(this, function(_a) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === 2) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length = Math.abs(startX - endX);
                } else {
                  length = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === 3) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width < 3 ? width * 3 : width * 2;
                spaceLength = width < 3 ? width * 2 : width;
                if (style === 3) {
                  dashLength = width;
                  spaceLength = width;
                }
                useLineDash = true;
                if (length <= dashLength * 2) {
                  useLineDash = false;
                } else if (length <= dashLength * 2 + spaceLength) {
                  multiplier = length / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === 3) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === 3) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width;
                } else {
                  this.ctx.lineWidth = width * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === 2) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element) {
            return __awaiter2(this, void 0, void 0, function() {
              var stack;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer)
      );
      var isTextInputElement = function(container) {
        if (container instanceof TextareaElementContainer) {
          return true;
        } else if (container instanceof SelectElementContainer) {
          return true;
        } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
        }
        return false;
      };
      var calculateBackgroundCurvedPaintingArea = function(clip2, curves) {
        switch (clip2) {
          case 0:
            return calculateBorderBoxPath(curves);
          case 2:
            return calculateContentBoxPath(curves);
          case 1:
          default:
            return calculatePaddingBoxPath(curves);
        }
      };
      var canvasTextAlign = function(textAlign2) {
        switch (textAlign2) {
          case 1:
            return "center";
          case 2:
            return "right";
          case 0:
          default:
            return "left";
        }
      };
      var iOSBrokenFonts = ["-apple-system", "system-ui"];
      var fixIOSSystemFonts = function(fontFamilies) {
        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
          return iOSBrokenFonts.indexOf(fontFamily2) === -1;
        }) : fontFamilies;
      };
      var ForeignObjectRenderer = (
        /** @class */
        function(_super) {
          __extends2(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options;
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element) {
            return __awaiter2(this, void 0, void 0, function() {
              var svg, img;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                    return [4, loadSerializedSVG(svg)];
                  case 1:
                    img = _a.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer)
      );
      var loadSerializedSVG = function(svg) {
        return new Promise(function(resolve2, reject) {
          var img = new Image();
          img.onload = function() {
            resolve2(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var Logger = (
        /** @class */
        function() {
          function Logger2(_a) {
            var id = _a.id, enabled = _a.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args2));
              } else {
                this.info.apply(this, args2);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args2));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args2));
              } else {
                this.info.apply(this, args2);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args2));
              } else {
                this.info.apply(this, args2);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }()
      );
      var Context = (
        /** @class */
        function() {
          function Context2(options, windowBounds) {
            var _a;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
            this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache2(this, options);
          }
          Context2.instanceCount = 1;
          return Context2;
        }()
      );
      var html2canvas2 = function(element, options) {
        if (options === void 0) {
          options = {};
        }
        return renderElement(element, options);
      };
      if (typeof window !== "undefined") {
        CacheStorage.setContext(window);
      }
      var renderElement = function(element, opts) {
        return __awaiter2(void 0, void 0, void 0, function() {
          var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
          var _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t3;
          return __generator2(this, function(_u) {
            switch (_u.label) {
              case 0:
                if (!element || typeof element !== "object") {
                  return [2, Promise.reject("Invalid element provided as first argument")];
                }
                ownerDocument = element.ownerDocument;
                if (!ownerDocument) {
                  throw new Error("Element is not attached to a Document");
                }
                defaultView = ownerDocument.defaultView;
                if (!defaultView) {
                  throw new Error("Document is not attached to a Window");
                }
                resourceOptions = {
                  allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                  imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                  proxy: opts.proxy,
                  useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                };
                contextOptions = __assign2({ logging: (_e2 = opts.logging) !== null && _e2 !== void 0 ? _e2 : true, cache: opts.cache }, resourceOptions);
                windowOptions = {
                  windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                  windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                  scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                  scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                };
                windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                context = new Context(contextOptions, windowBounds);
                foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                cloneOptions = {
                  allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                  onclone: opts.onclone,
                  ignoreElements: opts.ignoreElements,
                  inlineImages: foreignObjectRendering,
                  copyStyles: foreignObjectRendering
                };
                context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                documentCloner = new DocumentCloner(context, element, cloneOptions);
                clonedElement = documentCloner.clonedReferenceElement;
                if (!clonedElement) {
                  return [2, Promise.reject("Unable to find element in cloned iframe")];
                }
                return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                container = _u.sent();
                _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                renderOptions = {
                  canvas: opts.canvas,
                  backgroundColor: backgroundColor2,
                  scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                  x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                  y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                  width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                  height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                };
                if (!foreignObjectRendering)
                  return [3, 3];
                context.logger.debug("Document cloned, using foreign object rendering");
                renderer = new ForeignObjectRenderer(context, renderOptions);
                return [4, renderer.render(clonedElement)];
              case 2:
                canvas = _u.sent();
                return [3, 5];
              case 3:
                context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                context.logger.debug("Starting DOM parsing");
                root = parseTree(context, clonedElement);
                if (backgroundColor2 === root.styles.backgroundColor) {
                  root.styles.backgroundColor = COLORS.TRANSPARENT;
                }
                context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                renderer = new CanvasRenderer(context, renderOptions);
                return [4, renderer.render(root)];
              case 4:
                canvas = _u.sent();
                _u.label = 5;
              case 5:
                if ((_t3 = opts.removeContainer) !== null && _t3 !== void 0 ? _t3 : true) {
                  if (!DocumentCloner.destroy(container)) {
                    context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                  }
                }
                context.logger.debug("Finished rendering");
                return [2, canvas];
            }
          });
        });
      };
      var parseBackgroundColor = function(context, element, backgroundColorOverride) {
        var ownerDocument = element.ownerDocument;
        var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
        var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
        return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
      };
      return html2canvas2;
    });
  }
});

// src/services/AI/functionSchemas.ts
var FUNCTION_SCHEMAS;
var init_functionSchemas = __esm({
  "src/services/AI/functionSchemas.ts"() {
    FUNCTION_SCHEMAS = [
      {
        type: "function",
        function: {
          name: "getCurFile",
          description: "Return path and full text of the file currently in focus in the editor.",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      },
      {
        type: "function",
        function: {
          name: "getCurFileNotes",
          description: "Return all BetterNotes entries that belong to the current file.",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      },
      {
        type: "function",
        function: {
          name: "getAllNotes",
          description: "Return every BetterNotes entry in the vault (may be large).",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      },
      {
        type: "function",
        function: {
          name: "notesSearch",
          description: "Search all BetterNotes entries using semantic-vector similarity and return the most relevant snippets. Use this when the user asks questions that rely on the BetterNotes entry database rather than raw vault files.",
          parameters: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "Natural language query used to retrieve relevant entry snippets."
              },
              top_k: {
                type: "integer",
                description: "Number of snippets to return (default 8, max 20)"
              },
              min_similarity: {
                type: "number",
                description: "Similarity threshold between 0 and 1 (default configured in plugin)."
              }
            },
            required: ["query"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "searchVault",
          description: "Search the whole vault using semantic-vector similarity and return the most relevant note snippets. Use this when the user asks questions that may require retrieving existing knowledge from their notes.",
          parameters: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "Natural language search query used to retrieve relevant note chunks."
              },
              scope: {
                type: "object",
                description: "You are not allowed to use this parameter.",
                properties: {
                  files: {
                    type: "array",
                    items: { type: "string" },
                    description: "You are not allowed to use this parameter."
                  },
                  folders: {
                    type: "array",
                    items: { type: "string" },
                    description: "You are not allowed to use this parameter."
                  }
                }
              },
              top_k: {
                type: "integer",
                description: "7 at start, when failed, you can retry with 15"
              },
              min_similarity: {
                type: "number",
                description: "0.20 at start, when failed, you can retry with 0.10"
              }
            },
            required: ["query"]
          }
        }
      }
    ];
  }
});

// src/services/AI/toolExecutors.ts
var TOOL_EXECUTORS;
var init_toolExecutors = __esm({
  "src/services/AI/toolExecutors.ts"() {
    TOOL_EXECUTORS = {
      async getCurFile({ plugin }) {
        const file = plugin.app.workspace.getActiveFile();
        if (!file)
          throw new Error("No active file");
        return {
          path: file.path,
          content: await plugin.app.vault.read(file)
        };
      },
      async getCurFileNotes({ plugin }) {
        const file = plugin.app.workspace.getActiveFile();
        if (!file)
          throw new Error("No active file");
        return plugin.dataManager.getEntriesBySourceFile(file.path);
      },
      async getAllNotes({ plugin }) {
        return plugin.dataManager.getAllEntries();
      },
      // ---------------------------
      // searchVault: semantic search over user vault via RAG engine
      // ---------------------------
      // notesSearch: semantic search over BetterNotes entries
      // ---------------------------
      /**
       * notesSearch
       * --------------------------------------------------
       * Perform vector-similarity search over every BetterNotes entry.
       * 参数同 searchVault。
       */
      async notesSearch({ plugin }, args2) {
        const { query, top_k, min_similarity } = args2 || {};
        if (!query || typeof query !== "string") {
          throw new Error('notesSearch: "query" is required and must be a string');
        }
        const maxResults = typeof top_k === "number" && top_k > 0 ? Math.min(top_k, 20) : 8;
        const minSim = typeof min_similarity === "number" && min_similarity >= 0 && min_similarity <= 1 ? min_similarity : void 0;
        const ragEngine = await plugin.ragService.getQueryEngine();
        const rawResults = await ragEngine.processNotesQuery({ query }, plugin.dataManager);
        let filtered = rawResults;
        if (typeof minSim === "number") {
          filtered = filtered.filter((r) => r.similarity >= minSim);
        }
        if (filtered.length > maxResults) {
          filtered = filtered.slice(0, maxResults);
        }
        const snippets = filtered.map((r) => {
          const metadata2 = (typeof r.metadata === "string" ? JSON.parse(r.metadata) : r.metadata) || {};
          return {
            hash: metadata2.hash || "",
            value: metadata2.value || "",
            comment: metadata2.comment || "",
            similarity: Number(r.similarity.toFixed(3)),
            links: metadata2.link || [],
            sourcepath: metadata2.sourceFile || ""
          };
        });
        return { snippets };
      },
      /**
       * searchVault
       * --------------------------------------------------
       * Perform vector-similarity search over the whole vault.
       * @param args.query  Natural-language query (required)
       * @param args.scope  Optional scope restriction: { files?: string[]; folders?: string[] }
       * @param args.top_k  Max number of snippets to return (default 8)
       * @param args.min_similarity  Per-call similarity threshold (0-1). If provided, will further filter results.
       *
       * The executor reuses RagQueryEngine.processQuery() to ensure the latest incremental index,
       * then post-filters / truncates the snippets before returning a small, JSON-serialisable payload.
       */
      async searchVault({ plugin }, args2) {
        const { query, scope, top_k, min_similarity } = args2 || {};
        if (!query || typeof query !== "string") {
          throw new Error('searchVault: "query" is required and must be a string');
        }
        const maxResults = typeof top_k === "number" && top_k > 0 ? Math.min(top_k, 20) : 8;
        const minSim = typeof min_similarity === "number" && min_similarity >= 0 && min_similarity <= 1 ? min_similarity : void 0;
        const ragEngine = await plugin.ragService.getQueryEngine();
        const rawResults = await ragEngine.processQuery({ query, scope });
        let filtered = rawResults.filter((r) => !r.path.startsWith("note:"));
        if (typeof minSim === "number") {
          filtered = filtered.filter((r) => r.similarity >= minSim);
        }
        if (filtered.length > maxResults) {
          filtered = filtered.slice(0, maxResults);
        }
        const snippets = filtered.map((r) => ({
          content: r.content,
          sourcePath: r.path,
          similarity: Number(r.similarity.toFixed(3))
        }));
        return { snippets };
      }
    };
  }
});

// src/services/AI/FunctionCallRunner.ts
var FunctionCallRunner_exports = {};
__export(FunctionCallRunner_exports, {
  FunctionCallRunner: () => FunctionCallRunner
});
var FunctionCallRunner;
var init_FunctionCallRunner = __esm({
  "src/services/AI/FunctionCallRunner.ts"() {
    init_functionSchemas();
    init_toolExecutors();
    FunctionCallRunner = class {
      constructor(plugin, session, callbacks = {}) {
        this.plugin = plugin;
        this.session = session;
        this.onToolCall = callbacks.onToolCall;
      }
      /**
       * 处理一条用户输入：可能触发多轮函数调用。
       * @returns 最终 assistant.content
       */
      async run() {
        const ctx = { plugin: this.plugin };
        const ai = this.plugin.aiService;
        let withTools = true;
        for (let round = 0; round < 3; round++) {
          const resp = await ai.chat(this.session.history(), withTools ? FUNCTION_SCHEMAS : void 0);
          withTools = false;
          if (resp.content) {
            return resp.content;
          }
          const calls = resp.tool_calls || [];
          if (!Array.isArray(calls) || !calls.length) {
            return "[empty response]";
          }
          this.session.addRawMessage({ role: "assistant", content: null, tool_calls: calls });
          for (const call of calls) {
            try {
              const name2 = call.function.name;
              const rawArgs = call.function.arguments || "{}";
              const args2 = JSON.parse(rawArgs);
              if (this.onToolCall) {
                try {
                  this.onToolCall(name2, args2);
                } catch (cbErr) {
                  console.error("onToolCall callback error", cbErr);
                }
              }
              const exec = TOOL_EXECUTORS[name2];
              if (!exec) {
                this.session.addToolMessage(name2, JSON.stringify({ error: "Unknown function" }), call.id);
                continue;
              }
              const result = await exec(ctx, args2);
              this.session.addToolMessage(name2, JSON.stringify(result), call.id);
            } catch (err2) {
              this.session.addToolMessage("error", JSON.stringify({ message: err2.message || String(err2) }), call.id);
            }
          }
        }
        return "Function call loop exceeded limit.";
      }
    };
  }
});

// src/services/rag/constants.ts
var VECTOR_DIMENSION, MAX_TOKENS_PER_CHUNK, MAX_CHUNK_OVERLAP, MAX_FILE_BYTES, MAX_CONCURRENCY, DEFAULT_MIN_SIMILARITY, DEFAULT_TOP_K, DB_PATH, NOTES_LAST_INDEX_TIME, DEFAULT_RAG_CONFIG;
var init_constants = __esm({
  "src/services/rag/constants.ts"() {
    VECTOR_DIMENSION = 1536;
    MAX_TOKENS_PER_CHUNK = 300;
    MAX_CHUNK_OVERLAP = 50;
    MAX_FILE_BYTES = 300 * 1e3;
    MAX_CONCURRENCY = 20;
    DEFAULT_MIN_SIMILARITY = 0.1;
    DEFAULT_TOP_K = 10;
    DB_PATH = ".BetterNotes_db.tar.gz";
    NOTES_LAST_INDEX_TIME = "notes_last_index_time";
    DEFAULT_RAG_CONFIG = {
      embeddingModel: "text-embedding-3-small",
      embeddingEndpoint: "",
      apiKey: "",
      minSimilarity: DEFAULT_MIN_SIMILARITY
    };
  }
});

// node_modules/@electric-sql/pglite/dist/chunk-Y3AVQXKT.js
var p2, i2, c, f, l2, s, a, _, u2, D2, d2, F2, n, g2, L2, h, P2, R2, x;
var init_chunk_Y3AVQXKT = __esm({
  "node_modules/@electric-sql/pglite/dist/chunk-Y3AVQXKT.js"() {
    p2 = Object.create;
    i2 = Object.defineProperty;
    c = Object.getOwnPropertyDescriptor;
    f = Object.getOwnPropertyNames;
    l2 = Object.getPrototypeOf;
    s = Object.prototype.hasOwnProperty;
    a = (t2) => {
      throw TypeError(t2);
    };
    _ = (t2, e) => () => (t2 && (e = t2(t2 = 0)), e);
    u2 = (t2, e) => () => (e || t2((e = { exports: {} }).exports, e), e.exports);
    D2 = (t2, e) => {
      for (var o5 in e)
        i2(t2, o5, { get: e[o5], enumerable: true });
    };
    d2 = (t2, e, o5, m5) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let r of f(e))
          !s.call(t2, r) && r !== o5 && i2(t2, r, { get: () => e[r], enumerable: !(m5 = c(e, r)) || m5.enumerable });
      return t2;
    };
    F2 = (t2, e, o5) => (o5 = t2 != null ? p2(l2(t2)) : {}, d2(e || !t2 || !t2.__esModule ? i2(o5, "default", { value: t2, enumerable: true }) : o5, t2));
    n = (t2, e, o5) => e.has(t2) || a("Cannot " + o5);
    g2 = (t2, e, o5) => (n(t2, e, "read from private field"), o5 ? o5.call(t2) : e.get(t2));
    L2 = (t2, e, o5) => e.has(t2) ? a("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t2) : e.set(t2, o5);
    h = (t2, e, o5, m5) => (n(t2, e, "write to private field"), m5 ? m5.call(t2, o5) : e.set(t2, o5), o5);
    P2 = (t2, e, o5) => (n(t2, e, "access private method"), o5);
    R2 = (t2, e, o5, m5) => ({ set _(r) {
      h(t2, e, r, o5);
    }, get _() {
      return g2(t2, e, m5);
    } });
    x = _(() => {
      "use strict";
    });
  }
});

// node_modules/@electric-sql/pglite/dist/chunk-RBN4KMJ6.js
async function H2(r, e, t2 = "pgdata", s5 = "auto") {
  let o5 = jr(r, e), [n3, a2] = await Br(o5, s5), i3 = t2 + (a2 ? ".tar.gz" : ".tar"), u4 = a2 ? "application/x-gzip" : "application/x-tar";
  return typeof File < "u" ? new File([n3], i3, { type: u4 }) : new Blob([n3], { type: u4 });
}
async function ce(r, e, t2) {
  let s5 = new Uint8Array(await e.arrayBuffer()), o5 = typeof File < "u" && e instanceof File ? e.name : void 0;
  (Gr.includes(e.type) || o5?.endsWith(".tgz") || o5?.endsWith(".tar.gz")) && (s5 = await Wr(s5));
  let a2 = (0, h2.untar)(s5);
  for (let i3 of a2) {
    let u4 = t2 + i3.name, c2 = u4.split("/").slice(0, -1);
    for (let m5 = 1; m5 <= c2.length; m5++) {
      let y4 = c2.slice(0, m5).join("/");
      r.analyzePath(y4).exists || r.mkdir(y4);
    }
    i3.type === h2.REGTYPE ? (r.writeFile(u4, i3.data), r.utime(u4, ar(i3.modifyTime), ar(i3.modifyTime))) : i3.type === h2.DIRTYPE && r.mkdir(u4);
  }
}
function Hr(r, e) {
  let t2 = [], s5 = (o5) => {
    r.readdir(o5).forEach((a2) => {
      if (a2 === "." || a2 === "..")
        return;
      let i3 = o5 + "/" + a2, u4 = r.stat(i3), c2 = r.isFile(u4.mode) ? r.readFile(i3, { encoding: "binary" }) : new Uint8Array(0);
      t2.push({ name: i3.substring(e.length), mode: u4.mode, size: u4.size, type: r.isFile(u4.mode) ? h2.REGTYPE : h2.DIRTYPE, modifyTime: u4.mtime, data: c2 }), r.isDir(u4.mode) && s5(i3);
    });
  };
  return s5(e), t2;
}
function jr(r, e) {
  let t2 = Hr(r, e);
  return (0, h2.tar)(t2);
}
async function Br(r, e = "auto") {
  if (e === "none")
    return [r, false];
  if (typeof CompressionStream < "u")
    return [await qr(r), true];
  if (typeof process2 < "u" && process2.versions && process2.versions.node)
    return [await Yr(r), true];
  if (e === "auto")
    return [r, false];
  throw new Error("Compression not supported in this environment");
}
async function qr(r) {
  let e = new CompressionStream("gzip"), t2 = e.writable.getWriter(), s5 = e.readable.getReader();
  t2.write(r), t2.close();
  let o5 = [];
  for (; ; ) {
    let { value: i3, done: u4 } = await s5.read();
    if (u4)
      break;
    i3 && o5.push(i3);
  }
  let n3 = new Uint8Array(o5.reduce((i3, u4) => i3 + u4.length, 0)), a2 = 0;
  return o5.forEach((i3) => {
    n3.set(i3, a2), a2 += i3.length;
  }), n3;
}
async function Yr(r) {
  let { promisify: e } = await import("util"), { gzip: t2 } = await import("zlib");
  return await e(t2)(r);
}
async function Wr(r) {
  if (typeof CompressionStream < "u")
    return await Xr(r);
  if (typeof process2 < "u" && process2.versions && process2.versions.node)
    return await Kr(r);
  throw new Error("Unsupported environment for decompression");
}
async function Xr(r) {
  let e = new DecompressionStream("gzip"), t2 = e.writable.getWriter(), s5 = e.readable.getReader();
  t2.write(r), t2.close();
  let o5 = [];
  for (; ; ) {
    let { value: i3, done: u4 } = await s5.read();
    if (u4)
      break;
    i3 && o5.push(i3);
  }
  let n3 = new Uint8Array(o5.reduce((i3, u4) => i3 + u4.length, 0)), a2 = 0;
  return o5.forEach((i3) => {
    n3.set(i3, a2), a2 += i3.length;
  }), n3;
}
async function Kr(r) {
  let { promisify: e } = await import("util"), { gunzip: t2 } = await import("zlib");
  return await e(t2)(r);
}
function ar(r) {
  return r ? typeof r == "number" ? r : Math.floor(r.getTime() / 1e3) : Math.floor(Date.now() / 1e3);
}
var process2, w, x2, L3, er, nr, or, h2, Gr, Vr, C2, sr, ur, cr, Zr;
var init_chunk_RBN4KMJ6 = __esm({
  "node_modules/@electric-sql/pglite/dist/chunk-RBN4KMJ6.js"() {
    init_chunk_Y3AVQXKT();
    process2 = {};
    w = u2(($r, l4) => {
      "use strict";
      x();
      var j4 = 9007199254740991, B3 = function(r) {
        return r;
      }();
      function dr(r) {
        return r === B3;
      }
      function q4(r) {
        return typeof r == "string" || Object.prototype.toString.call(r) == "[object String]";
      }
      function mr(r) {
        return Object.prototype.toString.call(r) == "[object Date]";
      }
      function N4(r) {
        return r !== null && typeof r == "object";
      }
      function U4(r) {
        return typeof r == "function";
      }
      function lr(r) {
        return typeof r == "number" && r > -1 && r % 1 == 0 && r <= j4;
      }
      function fr(r) {
        return Object.prototype.toString.call(r) == "[object Array]";
      }
      function Y4(r) {
        return N4(r) && !U4(r) && lr(r.length);
      }
      function D6(r) {
        return Object.prototype.toString.call(r) == "[object ArrayBuffer]";
      }
      function yr(r, e) {
        return Array.prototype.map.call(r, e);
      }
      function gr(r, e) {
        var t2 = B3;
        return U4(e) && Array.prototype.every.call(r, function(s5, o5, n3) {
          var a2 = e(s5, o5, n3);
          return a2 && (t2 = s5), !a2;
        }), t2;
      }
      function hr(r) {
        return Object.assign.apply(null, arguments);
      }
      function W5(r) {
        var e, t2, s5;
        if (q4(r)) {
          for (t2 = r.length, s5 = new Uint8Array(t2), e = 0; e < t2; e++)
            s5[e] = r.charCodeAt(e) & 255;
          return s5;
        }
        return D6(r) ? new Uint8Array(r) : N4(r) && D6(r.buffer) ? new Uint8Array(r.buffer) : Y4(r) ? new Uint8Array(r) : N4(r) && U4(r.toString) ? W5(r.toString()) : new Uint8Array();
      }
      l4.exports.MAX_SAFE_INTEGER = j4;
      l4.exports.isUndefined = dr;
      l4.exports.isString = q4;
      l4.exports.isObject = N4;
      l4.exports.isDateTime = mr;
      l4.exports.isFunction = U4;
      l4.exports.isArray = fr;
      l4.exports.isArrayLike = Y4;
      l4.exports.isArrayBuffer = D6;
      l4.exports.map = yr;
      l4.exports.find = gr;
      l4.exports.extend = hr;
      l4.exports.toUint8Array = W5;
    });
    x2 = u2((Qr, X4) => {
      "use strict";
      x();
      var M4 = "\0";
      X4.exports = { NULL_CHAR: M4, TMAGIC: "ustar" + M4 + "00", OLDGNU_MAGIC: "ustar  " + M4, REGTYPE: 0, LNKTYPE: 1, SYMTYPE: 2, CHRTYPE: 3, BLKTYPE: 4, DIRTYPE: 5, FIFOTYPE: 6, CONTTYPE: 7, TSUID: parseInt("4000", 8), TSGID: parseInt("2000", 8), TSVTX: parseInt("1000", 8), TUREAD: parseInt("0400", 8), TUWRITE: parseInt("0200", 8), TUEXEC: parseInt("0100", 8), TGREAD: parseInt("0040", 8), TGWRITE: parseInt("0020", 8), TGEXEC: parseInt("0010", 8), TOREAD: parseInt("0004", 8), TOWRITE: parseInt("0002", 8), TOEXEC: parseInt("0001", 8), TPERMALL: parseInt("0777", 8), TPERMMASK: parseInt("0777", 8) };
    });
    L3 = u2((ee3, f3) => {
      "use strict";
      x();
      var K4 = w(), p5 = x2(), Sr = 512, I4 = p5.TPERMALL, V3 = 0, Z4 = 0, _3 = [["name", 100, 0, function(r, e) {
        return v4(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return A4(r.slice(e, e + t2[1]));
      }], ["mode", 8, 100, function(r, e) {
        var t2 = r[e[0]] || I4;
        return t2 = t2 & p5.TPERMMASK, P6(t2, e[1], I4);
      }, function(r, e, t2) {
        var s5 = S4(r.slice(e, e + t2[1]));
        return s5 &= p5.TPERMMASK, s5;
      }], ["uid", 8, 108, function(r, e) {
        return P6(r[e[0]], e[1], V3);
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["gid", 8, 116, function(r, e) {
        return P6(r[e[0]], e[1], Z4);
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["size", 12, 124, function(r, e) {
        return P6(r.data.length, e[1]);
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["modifyTime", 12, 136, function(r, e) {
        return k5(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return z4(r.slice(e, e + t2[1]));
      }], ["checksum", 8, 148, function(r, e) {
        return "        ";
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["type", 1, 156, function(r, e) {
        return "" + (parseInt(r[e[0]], 10) || 0) % 8;
      }, function(r, e, t2) {
        return (parseInt(String.fromCharCode(r[e]), 10) || 0) % 8;
      }], ["linkName", 100, 157, function(r, e) {
        return "";
      }, function(r, e, t2) {
        return A4(r.slice(e, e + t2[1]));
      }], ["ustar", 8, 257, function(r, e) {
        return p5.TMAGIC;
      }, function(r, e, t2) {
        return Fr(A4(r.slice(e, e + t2[1]), true));
      }, function(r, e) {
        return r[e[0]] == p5.TMAGIC || r[e[0]] == p5.OLDGNU_MAGIC;
      }], ["owner", 32, 265, function(r, e) {
        return v4(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return A4(r.slice(e, e + t2[1]));
      }], ["group", 32, 297, function(r, e) {
        return v4(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return A4(r.slice(e, e + t2[1]));
      }], ["majorNumber", 8, 329, function(r, e) {
        return "";
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["minorNumber", 8, 337, function(r, e) {
        return "";
      }, function(r, e, t2) {
        return S4(r.slice(e, e + t2[1]));
      }], ["prefix", 131, 345, function(r, e) {
        return v4(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return A4(r.slice(e, e + t2[1]));
      }], ["accessTime", 12, 476, function(r, e) {
        return k5(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return z4(r.slice(e, e + t2[1]));
      }], ["createTime", 12, 488, function(r, e) {
        return k5(r[e[0]], e[1]);
      }, function(r, e, t2) {
        return z4(r.slice(e, e + t2[1]));
      }]], $5 = function(r) {
        var e = r[r.length - 1];
        return e[2] + e[1];
      }(_3);
      function Fr(r) {
        if (r.length == 8) {
          var e = r.split("");
          if (e[5] == p5.NULL_CHAR)
            return (e[6] == " " || e[6] == p5.NULL_CHAR) && (e[6] = "0"), (e[7] == " " || e[7] == p5.NULL_CHAR) && (e[7] = "0"), e = e.join(""), e == p5.TMAGIC ? e : r;
          if (e[7] == p5.NULL_CHAR)
            return e[5] == p5.NULL_CHAR && (e[5] = " "), e[6] == p5.NULL_CHAR && (e[6] = " "), e == p5.OLDGNU_MAGIC ? e : r;
        }
        return r;
      }
      function v4(r, e) {
        return e -= 1, K4.isUndefined(r) && (r = ""), r = ("" + r).substr(0, e), r + p5.NULL_CHAR;
      }
      function P6(r, e, t2) {
        for (t2 = parseInt(t2) || 0, e -= 1, r = (parseInt(r) || t2).toString(8).substr(-e, e); r.length < e; )
          r = "0" + r;
        return r + p5.NULL_CHAR;
      }
      function k5(r, e) {
        if (K4.isDateTime(r))
          r = Math.floor(1 * r / 1e3);
        else if (r = parseInt(r, 10), isFinite(r)) {
          if (r <= 0)
            return "";
        } else
          r = Math.floor(1 * new Date() / 1e3);
        return P6(r, e, 0);
      }
      function A4(r, e) {
        var t2 = String.fromCharCode.apply(null, r);
        if (e)
          return t2;
        var s5 = t2.indexOf(p5.NULL_CHAR);
        return s5 >= 0 ? t2.substr(0, s5) : t2;
      }
      function S4(r) {
        var e = String.fromCharCode.apply(null, r);
        return parseInt(e.replace(/^0+$/g, ""), 8) || 0;
      }
      function z4(r) {
        return r.length == 0 || r[0] == 0 ? null : new Date(1e3 * S4(r));
      }
      function br(r, e, t2) {
        var s5 = parseInt(e, 10) || 0, o5 = Math.min(s5 + $5, r.length), n3 = 0, a2 = 0, i3 = 0;
        t2 && _3.every(function(y4) {
          return y4[0] == "checksum" ? (a2 = s5 + y4[2], i3 = a2 + y4[1], false) : true;
        });
        for (var u4 = 32, c2 = s5; c2 < o5; c2++) {
          var m5 = c2 >= a2 && c2 < i3 ? u4 : r[c2];
          n3 = (n3 + m5) % 262144;
        }
        return n3;
      }
      f3.exports.recordSize = Sr;
      f3.exports.defaultFileMode = I4;
      f3.exports.defaultUid = V3;
      f3.exports.defaultGid = Z4;
      f3.exports.posixHeader = _3;
      f3.exports.effectiveHeaderSize = $5;
      f3.exports.calculateChecksum = br;
      f3.exports.formatTarString = v4;
      f3.exports.formatTarNumber = P6;
      f3.exports.formatTarDateTime = k5;
      f3.exports.parseTarString = A4;
      f3.exports.parseTarNumber = S4;
      f3.exports.parseTarDateTime = z4;
    });
    er = u2((ne2, rr) => {
      "use strict";
      x();
      var Tr = x2(), O5 = w(), F5 = L3();
      function J3(r) {
        return F5.recordSize;
      }
      function Q4(r) {
        return Math.ceil(r.data.length / F5.recordSize) * F5.recordSize;
      }
      function Ar(r) {
        var e = 0;
        return r.forEach(function(t2) {
          e += J3(t2) + Q4(t2);
        }), e += F5.recordSize * 2, new Uint8Array(e);
      }
      function Er2(r, e, t2) {
        t2 = parseInt(t2) || 0;
        var s5 = t2;
        F5.posixHeader.forEach(function(u4) {
          for (var c2 = u4[3](e, u4), m5 = c2.length, y4 = 0; y4 < m5; y4 += 1)
            r[s5 + y4] = c2.charCodeAt(y4) & 255;
          s5 += u4[1];
        });
        var o5 = O5.find(F5.posixHeader, function(u4) {
          return u4[0] == "checksum";
        });
        if (o5) {
          var n3 = F5.calculateChecksum(r, t2, true), a2 = F5.formatTarNumber(n3, o5[1] - 2) + Tr.NULL_CHAR + " ";
          s5 = t2 + o5[2];
          for (var i3 = 0; i3 < a2.length; i3 += 1)
            r[s5] = a2.charCodeAt(i3) & 255, s5++;
        }
        return t2 + J3(e);
      }
      function Pr2(r, e, t2) {
        return t2 = parseInt(t2, 10) || 0, r.set(e.data, t2), t2 + Q4(e);
      }
      function wr(r) {
        r = O5.map(r, function(s5) {
          return O5.extend({}, s5, { data: O5.toUint8Array(s5.data) });
        });
        var e = Ar(r), t2 = 0;
        return r.forEach(function(s5) {
          t2 = Er2(e, s5, t2), t2 = Pr2(e, s5, t2);
        }), e;
      }
      rr.exports.tar = wr;
    });
    nr = u2((oe, tr) => {
      "use strict";
      x();
      var xr = x2(), G4 = w(), g5 = L3(), vr = { extractData: true, checkHeader: true, checkChecksum: true, checkFileSize: true }, Nr2 = { size: true, checksum: true, ustar: true }, R6 = { unexpectedEndOfFile: "Unexpected end of file.", fileCorrupted: "File is corrupted.", checksumCheckFailed: "Checksum check failed." };
      function Ur2(r) {
        return g5.recordSize;
      }
      function kr(r) {
        return Math.ceil(r / g5.recordSize) * g5.recordSize;
      }
      function zr(r, e) {
        for (var t2 = e, s5 = Math.min(r.length, e + g5.recordSize * 2), o5 = t2; o5 < s5; o5++)
          if (r[o5] != 0)
            return false;
        return true;
      }
      function Or(r, e, t2) {
        if (r.length - e < g5.recordSize) {
          if (t2.checkFileSize)
            throw new Error(R6.unexpectedEndOfFile);
          return null;
        }
        e = parseInt(e) || 0;
        var s5 = {}, o5 = e;
        if (g5.posixHeader.forEach(function(i3) {
          s5[i3[0]] = i3[4](r, o5, i3), o5 += i3[1];
        }), s5.type != 0 && (s5.size = 0), t2.checkHeader && g5.posixHeader.forEach(function(i3) {
          if (G4.isFunction(i3[5]) && !i3[5](s5, i3)) {
            var u4 = new Error(R6.fileCorrupted);
            throw u4.data = { offset: e + i3[2], field: i3[0] }, u4;
          }
        }), t2.checkChecksum) {
          var n3 = g5.calculateChecksum(r, e, true);
          if (n3 != s5.checksum) {
            var a2 = new Error(R6.checksumCheckFailed);
            throw a2.data = { offset: e, header: s5, checksum: n3 }, a2;
          }
        }
        return s5;
      }
      function Cr2(r, e, t2, s5) {
        return s5.extractData ? t2.size <= 0 ? new Uint8Array() : r.slice(e, e + t2.size) : null;
      }
      function Dr(r, e) {
        var t2 = {};
        return g5.posixHeader.forEach(function(s5) {
          var o5 = s5[0];
          Nr2[o5] || (t2[o5] = r[o5]);
        }), t2.isOldGNUFormat = r.ustar == xr.OLDGNU_MAGIC, e && (t2.data = e), t2;
      }
      function Mr(r, e) {
        e = G4.extend({}, vr, e);
        for (var t2 = [], s5 = 0, o5 = r.length; o5 - s5 >= g5.recordSize; ) {
          r = G4.toUint8Array(r);
          var n3 = Or(r, s5, e);
          if (!n3)
            break;
          s5 += Ur2(n3);
          var a2 = Cr2(r, s5, n3, e);
          if (t2.push(Dr(n3, a2)), s5 += kr(n3.size), zr(r, s5))
            break;
        }
        return t2;
      }
      tr.exports.untar = Mr;
    });
    or = u2((se2, ir) => {
      "use strict";
      x();
      var Ir = w(), _r = x2(), Lr = er(), Rr = nr();
      Ir.extend(ir.exports, Lr, Rr, _r);
    });
    x();
    x();
    h2 = F2(or(), 1);
    Gr = ["application/x-gtar", "application/x-tar+gzip", "application/x-gzip", "application/gzip"];
    Vr = "/tmp/pglite";
    C2 = Vr + "/base";
    sr = class {
      constructor(e) {
        this.dataDir = e;
      }
      async init(e, t2) {
        return this.pg = e, { emscriptenOpts: t2 };
      }
      async syncToFs(e) {
      }
      async initialSyncFs() {
      }
      async closeFs() {
      }
      async dumpTar(e, t2) {
        return H2(this.pg.Module.FS, C2, e, t2);
      }
    };
    ur = class {
      constructor(e, { debug: t2 = false } = {}) {
        this.dataDir = e, this.debug = t2;
      }
      async syncToFs(e) {
      }
      async initialSyncFs() {
      }
      async closeFs() {
      }
      async dumpTar(e, t2) {
        return H2(this.pg.Module.FS, C2, e, t2);
      }
      async init(e, t2) {
        return this.pg = e, { emscriptenOpts: { ...t2, preRun: [...t2.preRun || [], (o5) => {
          let n3 = Zr(o5, this);
          o5.FS.mkdir(C2), o5.FS.mount(n3, {}, C2);
        }] } };
      }
    };
    cr = { EBADF: 8, EBADFD: 127, EEXIST: 20, EINVAL: 28, EISDIR: 31, ENODEV: 43, ENOENT: 44, ENOTDIR: 54, ENOTEMPTY: 55 };
    Zr = (r, e) => {
      let t2 = r.FS, s5 = e.debug ? console.log : null, o5 = { tryFSOperation(n3) {
        try {
          return n3();
        } catch (a2) {
          throw a2.code ? a2.code === "UNKNOWN" ? new t2.ErrnoError(cr.EINVAL) : new t2.ErrnoError(a2.code) : a2;
        }
      }, mount(n3) {
        return o5.createNode(null, "/", 16895, 0);
      }, syncfs(n3, a2, i3) {
      }, createNode(n3, a2, i3, u4) {
        if (!t2.isDir(i3) && !t2.isFile(i3))
          throw new t2.ErrnoError(28);
        let c2 = t2.createNode(n3, a2, i3);
        return c2.node_ops = o5.node_ops, c2.stream_ops = o5.stream_ops, c2;
      }, getMode: function(n3) {
        return s5?.("getMode", n3), o5.tryFSOperation(() => e.lstat(n3).mode);
      }, realPath: function(n3) {
        let a2 = [];
        for (; n3.parent !== n3; )
          a2.push(n3.name), n3 = n3.parent;
        return a2.push(n3.mount.opts.root), a2.reverse(), a2.join("/");
      }, node_ops: { getattr(n3) {
        s5?.("getattr", o5.realPath(n3));
        let a2 = o5.realPath(n3);
        return o5.tryFSOperation(() => {
          let i3 = e.lstat(a2);
          return { ...i3, dev: 0, ino: n3.id, nlink: 1, rdev: n3.rdev, atime: new Date(i3.atime), mtime: new Date(i3.mtime), ctime: new Date(i3.ctime) };
        });
      }, setattr(n3, a2) {
        s5?.("setattr", o5.realPath(n3), a2);
        let i3 = o5.realPath(n3);
        o5.tryFSOperation(() => {
          a2.mode !== void 0 && e.chmod(i3, a2.mode), a2.size !== void 0 && e.truncate(i3, a2.size), a2.timestamp !== void 0 && e.utimes(i3, a2.timestamp, a2.timestamp), a2.size !== void 0 && e.truncate(i3, a2.size);
        });
      }, lookup(n3, a2) {
        s5?.("lookup", o5.realPath(n3), a2);
        let i3 = [o5.realPath(n3), a2].join("/"), u4 = o5.getMode(i3);
        return o5.createNode(n3, a2, u4);
      }, mknod(n3, a2, i3, u4) {
        s5?.("mknod", o5.realPath(n3), a2, i3, u4);
        let c2 = o5.createNode(n3, a2, i3, u4), m5 = o5.realPath(c2);
        return o5.tryFSOperation(() => (t2.isDir(c2.mode) ? e.mkdir(m5, { mode: i3 }) : e.writeFile(m5, "", { mode: i3 }), c2));
      }, rename(n3, a2, i3) {
        s5?.("rename", o5.realPath(n3), o5.realPath(a2), i3);
        let u4 = o5.realPath(n3), c2 = [o5.realPath(a2), i3].join("/");
        o5.tryFSOperation(() => {
          e.rename(u4, c2);
        }), n3.name = i3;
      }, unlink(n3, a2) {
        s5?.("unlink", o5.realPath(n3), a2);
        let i3 = [o5.realPath(n3), a2].join("/");
        try {
          e.unlink(i3);
        } catch {
        }
      }, rmdir(n3, a2) {
        s5?.("rmdir", o5.realPath(n3), a2);
        let i3 = [o5.realPath(n3), a2].join("/");
        return o5.tryFSOperation(() => {
          e.rmdir(i3);
        });
      }, readdir(n3) {
        s5?.("readdir", o5.realPath(n3));
        let a2 = o5.realPath(n3);
        return o5.tryFSOperation(() => e.readdir(a2));
      }, symlink(n3, a2, i3) {
        throw s5?.("symlink", o5.realPath(n3), a2, i3), new t2.ErrnoError(63);
      }, readlink(n3) {
        throw s5?.("readlink", o5.realPath(n3)), new t2.ErrnoError(63);
      } }, stream_ops: { open(n3) {
        s5?.("open stream", o5.realPath(n3.node));
        let a2 = o5.realPath(n3.node);
        return o5.tryFSOperation(() => {
          t2.isFile(n3.node.mode) && (n3.shared.refcount = 1, n3.nfd = e.open(a2));
        });
      }, close(n3) {
        return s5?.("close stream", o5.realPath(n3.node)), o5.tryFSOperation(() => {
          t2.isFile(n3.node.mode) && n3.nfd && --n3.shared.refcount === 0 && e.close(n3.nfd);
        });
      }, dup(n3) {
        s5?.("dup stream", o5.realPath(n3.node)), n3.shared.refcount++;
      }, read(n3, a2, i3, u4, c2) {
        return s5?.("read stream", o5.realPath(n3.node), i3, u4, c2), u4 === 0 ? 0 : o5.tryFSOperation(() => e.read(n3.nfd, a2, i3, u4, c2));
      }, write(n3, a2, i3, u4, c2) {
        return s5?.("write stream", o5.realPath(n3.node), i3, u4, c2), o5.tryFSOperation(() => e.write(n3.nfd, a2.buffer, i3, u4, c2));
      }, llseek(n3, a2, i3) {
        s5?.("llseek stream", o5.realPath(n3.node), a2, i3);
        let u4 = a2;
        if (i3 === 1 ? u4 += n3.position : i3 === 2 && t2.isFile(n3.node.mode) && o5.tryFSOperation(() => {
          let c2 = e.fstat(n3.nfd);
          u4 += c2.size;
        }), u4 < 0)
          throw new t2.ErrnoError(28);
        return u4;
      }, mmap(n3, a2, i3, u4, c2) {
        if (s5?.("mmap stream", o5.realPath(n3.node), a2, i3, u4, c2), !t2.isFile(n3.node.mode))
          throw new t2.ErrnoError(cr.ENODEV);
        let m5 = r.mmapAlloc(a2);
        return o5.stream_ops.read(n3, r.HEAP8, m5, a2, i3), { ptr: m5, allocated: true };
      }, msync(n3, a2, i3, u4, c2) {
        return s5?.("msync stream", o5.realPath(n3.node), i3, u4, c2), o5.stream_ops.write(n3, a2, 0, u4, i3), 0;
      } } };
      return o5;
    };
  }
});

// node_modules/@electric-sql/pglite/dist/fs/nodefs.js
var nodefs_exports = {};
__export(nodefs_exports, {
  NodeFS: () => m3
});
var s4, o4, m3;
var init_nodefs = __esm({
  "node_modules/@electric-sql/pglite/dist/fs/nodefs.js"() {
    init_chunk_RBN4KMJ6();
    init_chunk_Y3AVQXKT();
    s4 = __toESM(require("fs"), 1);
    o4 = __toESM(require("path"), 1);
    x();
    m3 = class extends sr {
      constructor(t2) {
        super(t2), this.rootDir = o4.resolve(t2), s4.existsSync(o4.join(this.rootDir)) || s4.mkdirSync(this.rootDir);
      }
      async init(t2, e) {
        return this.pg = t2, { emscriptenOpts: { ...e, preRun: [...e.preRun || [], (r) => {
          let c2 = r.FS.filesystems.NODEFS;
          r.FS.mkdir(C2), r.FS.mount(c2, { root: this.rootDir }, C2);
        }] } };
      }
      async closeFs() {
        this.pg.Module.FS.quit();
      }
    };
  }
});

// node_modules/@electric-sql/pglite/dist/fs/opfs-ahp.js
var opfs_ahp_exports = {};
__export(opfs_ahp_exports, {
  OpfsAhpFS: () => L5
});
var $3, G3, T3, H4, v3, O3, M2, y3, b3, m4, x3, F3, P4, S3, n2, C4, D4, k3, w4, f2, I2, W3, j3, L5, p4;
var init_opfs_ahp = __esm({
  "node_modules/@electric-sql/pglite/dist/fs/opfs-ahp.js"() {
    init_chunk_RBN4KMJ6();
    init_chunk_Y3AVQXKT();
    x();
    $3 = "state.txt";
    G3 = "data";
    T3 = { DIR: 16384, FILE: 32768 };
    L5 = class extends ur {
      constructor(e, { initialPoolSize: t2 = 1e3, maintainedPoolSize: o5 = 100, debug: i3 = false } = {}) {
        super(e, { debug: i3 });
        L2(this, n2);
        L2(this, H4);
        L2(this, v3);
        L2(this, O3);
        L2(this, M2);
        L2(this, y3);
        L2(this, b3, /* @__PURE__ */ new Map());
        L2(this, m4, /* @__PURE__ */ new Map());
        L2(this, x3, 0);
        L2(this, F3, /* @__PURE__ */ new Map());
        L2(this, P4, /* @__PURE__ */ new Map());
        this.lastCheckpoint = 0;
        this.checkpointInterval = 1e3 * 60;
        this.poolCounter = 0;
        L2(this, S3, /* @__PURE__ */ new Set());
        this.initialPoolSize = t2, this.maintainedPoolSize = o5;
      }
      async init(e, t2) {
        return await P2(this, n2, C4).call(this), super.init(e, t2);
      }
      async syncToFs(e = false) {
        await this.maybeCheckpointState(), await this.maintainPool(), e || this.flush();
      }
      async closeFs() {
        for (let e of g2(this, m4).values())
          e.close();
        g2(this, y3).flush(), g2(this, y3).close(), this.pg.Module.FS.quit();
      }
      async maintainPool(e) {
        e = e || this.maintainedPoolSize;
        let t2 = e - this.state.pool.length, o5 = [];
        for (let i3 = 0; i3 < t2; i3++)
          o5.push(new Promise(async (c2) => {
            ++this.poolCounter;
            let a2 = `${(Date.now() - 1704063600).toString(16).padStart(8, "0")}-${this.poolCounter.toString(16).padStart(8, "0")}`, h3 = await g2(this, O3).getFileHandle(a2, { create: true }), d3 = await h3.createSyncAccessHandle();
            g2(this, b3).set(a2, h3), g2(this, m4).set(a2, d3), P2(this, n2, k3).call(this, { opp: "createPoolFile", args: [a2] }), this.state.pool.push(a2), c2();
          }));
        for (let i3 = 0; i3 > t2; i3--)
          o5.push(new Promise(async (c2) => {
            let a2 = this.state.pool.pop();
            P2(this, n2, k3).call(this, { opp: "deletePoolFile", args: [a2] });
            let h3 = g2(this, b3).get(a2);
            g2(this, m4).get(a2)?.close(), await h3.remove().then(() => {
              g2(this, b3).delete(a2), g2(this, m4).delete(a2), c2();
            });
          }));
        await Promise.all(o5);
      }
      _createPoolFileState(e) {
        this.state.pool.push(e);
      }
      _deletePoolFileState(e) {
        let t2 = this.state.pool.indexOf(e);
        t2 > -1 && this.state.pool.splice(t2, 1);
      }
      async maybeCheckpointState() {
        Date.now() - this.lastCheckpoint > this.checkpointInterval && await this.checkpointState();
      }
      async checkpointState() {
        let e = new TextEncoder().encode(JSON.stringify(this.state));
        g2(this, y3).truncate(0), g2(this, y3).write(e, { at: 0 }), g2(this, y3).flush(), this.lastCheckpoint = Date.now();
      }
      flush() {
        for (let e of g2(this, S3))
          try {
            e.flush();
          } catch {
          }
        g2(this, S3).clear();
      }
      chmod(e, t2) {
        P2(this, n2, D4).call(this, { opp: "chmod", args: [e, t2] }, () => {
          this._chmodState(e, t2);
        });
      }
      _chmodState(e, t2) {
        let o5 = P2(this, n2, f2).call(this, e);
        o5.mode = t2;
      }
      close(e) {
        let t2 = P2(this, n2, I2).call(this, e);
        g2(this, F3).delete(e), g2(this, P4).delete(t2);
      }
      fstat(e) {
        let t2 = P2(this, n2, I2).call(this, e);
        return this.lstat(t2);
      }
      lstat(e) {
        let t2 = P2(this, n2, f2).call(this, e), o5 = t2.type === "file" ? g2(this, m4).get(t2.backingFilename).getSize() : 0, i3 = 4096;
        return { dev: 0, ino: 0, mode: t2.mode, nlink: 1, uid: 0, gid: 0, rdev: 0, size: o5, blksize: i3, blocks: Math.ceil(o5 / i3), atime: t2.lastModified, mtime: t2.lastModified, ctime: t2.lastModified };
      }
      mkdir(e, t2) {
        P2(this, n2, D4).call(this, { opp: "mkdir", args: [e, t2] }, () => {
          this._mkdirState(e, t2);
        });
      }
      _mkdirState(e, t2) {
        let o5 = P2(this, n2, w4).call(this, e), i3 = o5.pop(), c2 = [], a2 = this.state.root;
        for (let d3 of o5) {
          if (c2.push(e), !Object.prototype.hasOwnProperty.call(a2.children, d3))
            if (t2?.recursive)
              this.mkdir(c2.join("/"));
            else
              throw new p4("ENOENT", "No such file or directory");
          if (a2.children[d3].type !== "directory")
            throw new p4("ENOTDIR", "Not a directory");
          a2 = a2.children[d3];
        }
        if (Object.prototype.hasOwnProperty.call(a2.children, i3))
          throw new p4("EEXIST", "File exists");
        let h3 = { type: "directory", lastModified: Date.now(), mode: t2?.mode || T3.DIR, children: {} };
        a2.children[i3] = h3;
      }
      open(e, t2, o5) {
        if (P2(this, n2, f2).call(this, e).type !== "file")
          throw new p4("EISDIR", "Is a directory");
        let c2 = P2(this, n2, W3).call(this);
        return g2(this, F3).set(c2, e), g2(this, P4).set(e, c2), c2;
      }
      readdir(e) {
        let t2 = P2(this, n2, f2).call(this, e);
        if (t2.type !== "directory")
          throw new p4("ENOTDIR", "Not a directory");
        return Object.keys(t2.children);
      }
      read(e, t2, o5, i3, c2) {
        let a2 = P2(this, n2, I2).call(this, e), h3 = P2(this, n2, f2).call(this, a2);
        if (h3.type !== "file")
          throw new p4("EISDIR", "Is a directory");
        return g2(this, m4).get(h3.backingFilename).read(new Uint8Array(t2.buffer, o5, i3), { at: c2 });
      }
      rename(e, t2) {
        P2(this, n2, D4).call(this, { opp: "rename", args: [e, t2] }, () => {
          this._renameState(e, t2, true);
        });
      }
      _renameState(e, t2, o5 = false) {
        let i3 = P2(this, n2, w4).call(this, e), c2 = i3.pop(), a2 = P2(this, n2, f2).call(this, i3.join("/"));
        if (!Object.prototype.hasOwnProperty.call(a2.children, c2))
          throw new p4("ENOENT", "No such file or directory");
        let h3 = P2(this, n2, w4).call(this, t2), d3 = h3.pop(), l4 = P2(this, n2, f2).call(this, h3.join("/"));
        if (o5 && Object.prototype.hasOwnProperty.call(l4.children, d3)) {
          let u4 = l4.children[d3];
          g2(this, m4).get(u4.backingFilename).truncate(0), this.state.pool.push(u4.backingFilename);
        }
        l4.children[d3] = a2.children[c2], delete a2.children[c2];
      }
      rmdir(e) {
        P2(this, n2, D4).call(this, { opp: "rmdir", args: [e] }, () => {
          this._rmdirState(e);
        });
      }
      _rmdirState(e) {
        let t2 = P2(this, n2, w4).call(this, e), o5 = t2.pop(), i3 = P2(this, n2, f2).call(this, t2.join("/"));
        if (!Object.prototype.hasOwnProperty.call(i3.children, o5))
          throw new p4("ENOENT", "No such file or directory");
        let c2 = i3.children[o5];
        if (c2.type !== "directory")
          throw new p4("ENOTDIR", "Not a directory");
        if (Object.keys(c2.children).length > 0)
          throw new p4("ENOTEMPTY", "Directory not empty");
        delete i3.children[o5];
      }
      truncate(e, t2 = 0) {
        let o5 = P2(this, n2, f2).call(this, e);
        if (o5.type !== "file")
          throw new p4("EISDIR", "Is a directory");
        let i3 = g2(this, m4).get(o5.backingFilename);
        if (!i3)
          throw new p4("ENOENT", "No such file or directory");
        i3.truncate(t2), g2(this, S3).add(i3);
      }
      unlink(e) {
        P2(this, n2, D4).call(this, { opp: "unlink", args: [e] }, () => {
          this._unlinkState(e, true);
        });
      }
      _unlinkState(e, t2 = false) {
        let o5 = P2(this, n2, w4).call(this, e), i3 = o5.pop(), c2 = P2(this, n2, f2).call(this, o5.join("/"));
        if (!Object.prototype.hasOwnProperty.call(c2.children, i3))
          throw new p4("ENOENT", "No such file or directory");
        let a2 = c2.children[i3];
        if (a2.type !== "file")
          throw new p4("EISDIR", "Is a directory");
        if (delete c2.children[i3], t2) {
          let h3 = g2(this, m4).get(a2.backingFilename);
          h3?.truncate(0), g2(this, S3).add(h3), g2(this, P4).has(e) && (g2(this, F3).delete(g2(this, P4).get(e)), g2(this, P4).delete(e));
        }
        this.state.pool.push(a2.backingFilename);
      }
      utimes(e, t2, o5) {
        P2(this, n2, D4).call(this, { opp: "utimes", args: [e, t2, o5] }, () => {
          this._utimesState(e, t2, o5);
        });
      }
      _utimesState(e, t2, o5) {
        let i3 = P2(this, n2, f2).call(this, e);
        i3.lastModified = o5;
      }
      writeFile(e, t2, o5) {
        let i3 = P2(this, n2, w4).call(this, e), c2 = i3.pop(), a2 = P2(this, n2, f2).call(this, i3.join("/"));
        if (Object.prototype.hasOwnProperty.call(a2.children, c2)) {
          let l4 = a2.children[c2];
          l4.lastModified = Date.now(), P2(this, n2, k3).call(this, { opp: "setLastModified", args: [e, l4.lastModified] });
        } else {
          if (this.state.pool.length === 0)
            throw new Error("No more file handles available in the pool");
          let l4 = { type: "file", lastModified: Date.now(), mode: o5?.mode || T3.FILE, backingFilename: this.state.pool.pop() };
          a2.children[c2] = l4, P2(this, n2, k3).call(this, { opp: "createFileNode", args: [e, l4] });
        }
        let h3 = a2.children[c2], d3 = g2(this, m4).get(h3.backingFilename);
        t2.length > 0 && (d3.write(typeof t2 == "string" ? new TextEncoder().encode(t2) : new Uint8Array(t2), { at: 0 }), e.startsWith("/pg_wal") && g2(this, S3).add(d3));
      }
      _createFileNodeState(e, t2) {
        let o5 = P2(this, n2, w4).call(this, e), i3 = o5.pop(), c2 = P2(this, n2, f2).call(this, o5.join("/"));
        c2.children[i3] = t2;
        let a2 = this.state.pool.indexOf(t2.backingFilename);
        return a2 > -1 && this.state.pool.splice(a2, 1), t2;
      }
      _setLastModifiedState(e, t2) {
        let o5 = P2(this, n2, f2).call(this, e);
        o5.lastModified = t2;
      }
      write(e, t2, o5, i3, c2) {
        let a2 = P2(this, n2, I2).call(this, e), h3 = P2(this, n2, f2).call(this, a2);
        if (h3.type !== "file")
          throw new p4("EISDIR", "Is a directory");
        let d3 = g2(this, m4).get(h3.backingFilename);
        if (!d3)
          throw new p4("EBADF", "Bad file descriptor");
        let l4 = d3.write(new Uint8Array(t2, o5, i3), { at: c2 });
        return a2.startsWith("/pg_wal") && g2(this, S3).add(d3), l4;
      }
    };
    H4 = /* @__PURE__ */ new WeakMap(), v3 = /* @__PURE__ */ new WeakMap(), O3 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), y3 = /* @__PURE__ */ new WeakMap(), b3 = /* @__PURE__ */ new WeakMap(), m4 = /* @__PURE__ */ new WeakMap(), x3 = /* @__PURE__ */ new WeakMap(), F3 = /* @__PURE__ */ new WeakMap(), P4 = /* @__PURE__ */ new WeakMap(), S3 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakSet(), C4 = async function() {
      h(this, H4, await navigator.storage.getDirectory()), h(this, v3, await P2(this, n2, j3).call(this, this.dataDir, { create: true })), h(this, O3, await P2(this, n2, j3).call(this, G3, { from: g2(this, v3), create: true })), h(this, M2, await g2(this, v3).getFileHandle($3, { create: true })), h(this, y3, await g2(this, M2).createSyncAccessHandle());
      let e = new ArrayBuffer(g2(this, y3).getSize());
      g2(this, y3).read(e, { at: 0 });
      let t2, o5 = new TextDecoder().decode(e).split(`
`), i3 = false;
      try {
        t2 = JSON.parse(o5[0]);
      } catch {
        t2 = { root: { type: "directory", lastModified: Date.now(), mode: T3.DIR, children: {} }, pool: [] }, g2(this, y3).truncate(0), g2(this, y3).write(new TextEncoder().encode(JSON.stringify(t2)), { at: 0 }), i3 = true;
      }
      this.state = t2;
      let c2 = o5.slice(1).filter(Boolean).map((l4) => JSON.parse(l4));
      for (let l4 of c2) {
        let u4 = `_${l4.opp}State`;
        if (typeof this[u4] == "function")
          try {
            this[u4].bind(this)(...l4.args);
          } catch (N4) {
            console.warn("Error applying OPFS AHP WAL entry", l4, N4);
          }
      }
      let a2 = [], h3 = async (l4) => {
        if (l4.type === "file")
          try {
            let u4 = await g2(this, O3).getFileHandle(l4.backingFilename), N4 = await u4.createSyncAccessHandle();
            g2(this, b3).set(l4.backingFilename, u4), g2(this, m4).set(l4.backingFilename, N4);
          } catch (u4) {
            console.error("Error opening file handle for node", l4, u4);
          }
        else
          for (let u4 of Object.values(l4.children))
            a2.push(h3(u4));
      };
      await h3(this.state.root);
      let d3 = [];
      for (let l4 of this.state.pool)
        d3.push(new Promise(async (u4) => {
          g2(this, b3).has(l4) && console.warn("File handle already exists for pool file", l4);
          let N4 = await g2(this, O3).getFileHandle(l4), U4 = await N4.createSyncAccessHandle();
          g2(this, b3).set(l4, N4), g2(this, m4).set(l4, U4), u4();
        }));
      await Promise.all([...a2, ...d3]), await this.maintainPool(i3 ? this.initialPoolSize : this.maintainedPoolSize);
    }, D4 = function(e, t2) {
      let o5 = P2(this, n2, k3).call(this, e);
      try {
        t2();
      } catch (i3) {
        throw g2(this, y3).truncate(o5), i3;
      }
    }, k3 = function(e) {
      let t2 = JSON.stringify(e), o5 = new TextEncoder().encode(`
${t2}`), i3 = g2(this, y3).getSize();
      return g2(this, y3).write(o5, { at: i3 }), g2(this, S3).add(g2(this, y3)), i3;
    }, w4 = function(e) {
      return e.split("/").filter(Boolean);
    }, f2 = function(e, t2) {
      let o5 = P2(this, n2, w4).call(this, e), i3 = t2 || this.state.root;
      for (let c2 of o5) {
        if (i3.type !== "directory")
          throw new p4("ENOTDIR", "Not a directory");
        if (!Object.prototype.hasOwnProperty.call(i3.children, c2))
          throw new p4("ENOENT", "No such file or directory");
        i3 = i3.children[c2];
      }
      return i3;
    }, I2 = function(e) {
      let t2 = g2(this, F3).get(e);
      if (!t2)
        throw new p4("EBADF", "Bad file descriptor");
      return t2;
    }, W3 = function() {
      let e = ++R2(this, x3)._;
      for (; g2(this, F3).has(e); )
        R2(this, x3)._++;
      return e;
    }, j3 = async function(e, t2) {
      let o5 = P2(this, n2, w4).call(this, e), i3 = t2?.from || g2(this, H4);
      for (let c2 of o5)
        i3 = await i3.getDirectoryHandle(c2, { create: t2?.create });
      return i3;
    };
    p4 = class extends Error {
      constructor(A4, e) {
        super(e), typeof A4 == "number" ? this.code = A4 : typeof A4 == "string" && (this.code = cr[A4]);
      }
    };
  }
});

// node_modules/exponential-backoff/dist/options.js
var require_options = __commonJS({
  "node_modules/exponential-backoff/dist/options.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t2) {
        for (var s5, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s5 = arguments[i3];
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5))
              t2[p5] = s5[p5];
        }
        return t2;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOptions = {
      delayFirstAttempt: false,
      jitter: "none",
      maxDelay: Infinity,
      numOfAttempts: 10,
      retry: function() {
        return true;
      },
      startingDelay: 100,
      timeMultiple: 2
    };
    function getSanitizedOptions(options) {
      var sanitized = __assign2(__assign2({}, defaultOptions), options);
      if (sanitized.numOfAttempts < 1) {
        sanitized.numOfAttempts = 1;
      }
      return sanitized;
    }
    exports.getSanitizedOptions = getSanitizedOptions;
  }
});

// node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
var require_full_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fullJitter(delay) {
      var jitteredDelay = Math.random() * delay;
      return Math.round(jitteredDelay);
    }
    exports.fullJitter = fullJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
var require_no_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noJitter(delay) {
      return delay;
    }
    exports.noJitter = noJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/jitter.factory.js
var require_jitter_factory = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var full_jitter_1 = require_full_jitter();
    var no_jitter_1 = require_no_jitter();
    function JitterFactory(options) {
      switch (options.jitter) {
        case "full":
          return full_jitter_1.fullJitter;
        case "none":
        default:
          return no_jitter_1.noJitter;
      }
    }
    exports.JitterFactory = JitterFactory;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.base.js
var require_delay_base = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jitter_factory_1 = require_jitter_factory();
    var Delay = (
      /** @class */
      function() {
        function Delay2(options) {
          this.options = options;
          this.attempt = 0;
        }
        Delay2.prototype.apply = function() {
          var _this = this;
          return new Promise(function(resolve2) {
            return setTimeout(resolve2, _this.jitteredDelay);
          });
        };
        Delay2.prototype.setAttemptNumber = function(attempt) {
          this.attempt = attempt;
        };
        Object.defineProperty(Delay2.prototype, "jitteredDelay", {
          get: function() {
            var jitter = jitter_factory_1.JitterFactory(this.options);
            return jitter(this.delay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "delay", {
          get: function() {
            var constant = this.options.startingDelay;
            var base = this.options.timeMultiple;
            var power = this.numOfDelayedAttempts;
            var delay = constant * Math.pow(base, power);
            return Math.min(delay, this.options.maxDelay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt;
          },
          enumerable: true,
          configurable: true
        });
        return Delay2;
      }()
    );
    exports.Delay = Delay;
  }
});

// node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
var require_skip_first_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d3, b4) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
          d4.__proto__ = b5;
        } || function(d4, b5) {
          for (var p5 in b5)
            if (b5.hasOwnProperty(p5))
              d4[p5] = b5[p5];
        };
        return extendStatics2(d3, b4);
      };
      return function(d3, b4) {
        extendStatics2(d3, b4);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P6, generator) {
      function adopt(value) {
        return value instanceof P6 ? value : new P6(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P6 || (P6 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body2) {
      var _3 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f3, y4, t2, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v4) {
          return step([n3, v4]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_3)
          try {
            if (f3 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
              return t2;
            if (y4 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t2[1]) {
                  _3.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _3.label < t2[2]) {
                  _3.label = t2[2];
                  _3.ops.push(op);
                  break;
                }
                if (t2[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body2.call(thisArg, _3);
          } catch (e) {
            op = [6, e];
            y4 = 0;
          } finally {
            f3 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var SkipFirstDelay = (
      /** @class */
      function(_super) {
        __extends2(SkipFirstDelay2, _super);
        function SkipFirstDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SkipFirstDelay2.prototype.apply = function() {
          return __awaiter2(this, void 0, void 0, function() {
            return __generator2(this, function(_a) {
              return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
            });
          });
        };
        Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
          get: function() {
            return this.attempt === 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt - 1;
          },
          enumerable: true,
          configurable: true
        });
        return SkipFirstDelay2;
      }(delay_base_1.Delay)
    );
    exports.SkipFirstDelay = SkipFirstDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/always/always.delay.js
var require_always_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d3, b4) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
          d4.__proto__ = b5;
        } || function(d4, b5) {
          for (var p5 in b5)
            if (b5.hasOwnProperty(p5))
              d4[p5] = b5[p5];
        };
        return extendStatics2(d3, b4);
      };
      return function(d3, b4) {
        extendStatics2(d3, b4);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var AlwaysDelay = (
      /** @class */
      function(_super) {
        __extends2(AlwaysDelay2, _super);
        function AlwaysDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return AlwaysDelay2;
      }(delay_base_1.Delay)
    );
    exports.AlwaysDelay = AlwaysDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.factory.js
var require_delay_factory = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var skip_first_delay_1 = require_skip_first_delay();
    var always_delay_1 = require_always_delay();
    function DelayFactory(options, attempt) {
      var delay = initDelayClass(options);
      delay.setAttemptNumber(attempt);
      return delay;
    }
    exports.DelayFactory = DelayFactory;
    function initDelayClass(options) {
      if (!options.delayFirstAttempt) {
        return new skip_first_delay_1.SkipFirstDelay(options);
      }
      return new always_delay_1.AlwaysDelay(options);
    }
  }
});

// node_modules/exponential-backoff/dist/backoff.js
var require_backoff = __commonJS({
  "node_modules/exponential-backoff/dist/backoff.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P6, generator) {
      function adopt(value) {
        return value instanceof P6 ? value : new P6(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P6 || (P6 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body2) {
      var _3 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f3, y4, t2, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v4) {
          return step([n3, v4]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_3)
          try {
            if (f3 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
              return t2;
            if (y4 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t2[1]) {
                  _3.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _3.label < t2[2]) {
                  _3.label = t2[2];
                  _3.ops.push(op);
                  break;
                }
                if (t2[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body2.call(thisArg, _3);
          } catch (e) {
            op = [6, e];
            y4 = 0;
          } finally {
            f3 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var options_1 = require_options();
    var delay_factory_1 = require_delay_factory();
    function backOff2(request, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var sanitizedOptions, backOff3;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              sanitizedOptions = options_1.getSanitizedOptions(options);
              backOff3 = new BackOff(request, sanitizedOptions);
              return [4, backOff3.execute()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    exports.backOff = backOff2;
    var BackOff = (
      /** @class */
      function() {
        function BackOff2(request, options) {
          this.request = request;
          this.options = options;
          this.attemptNumber = 0;
        }
        BackOff2.prototype.execute = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var e_1, shouldRetry;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.attemptLimitReached)
                    return [3, 7];
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 6]);
                  return [4, this.applyDelay()];
                case 2:
                  _a.sent();
                  return [4, this.request()];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  e_1 = _a.sent();
                  this.attemptNumber++;
                  return [4, this.options.retry(e_1, this.attemptNumber)];
                case 5:
                  shouldRetry = _a.sent();
                  if (!shouldRetry || this.attemptLimitReached) {
                    throw e_1;
                  }
                  return [3, 6];
                case 6:
                  return [3, 0];
                case 7:
                  throw new Error("Something went wrong.");
              }
            });
          });
        };
        Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
          get: function() {
            return this.attemptNumber >= this.options.numOfAttempts;
          },
          enumerable: true,
          configurable: true
        });
        BackOff2.prototype.applyDelay = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var delay;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                  return [4, delay.apply()];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return BackOff2;
      }()
    );
  }
});

// src/services/rag/query/VectorRepository.ts
var VectorRepository;
var init_VectorRepository = __esm({
  "src/services/rag/query/VectorRepository.ts"() {
    VectorRepository = class {
      constructor(db) {
        this.db = db;
      }
      /**
       * 执行相似度检索
       * @param queryVector 查询向量 (长度需等于 dimension)
       * @param modelId     嵌入模型 id
       * @param dimension   向量维度（用于命中部分索引）
       * @param options     搜索参数
       */
      async performSimilaritySearch(queryVector, modelId, dimension, options) {
        const vectorLiteral = `[${queryVector.join(",")}]`;
        const scopeSQL = this.buildScopeCondition(options.scope);
        const sql = `
      SELECT
        id, path, mtime, content, model, dimension, metadata,
        1 - (embedding <=> $1::vector) AS similarity
      FROM embeddings
      WHERE
        model = $2
        AND dimension = $3
        AND 1 - (embedding <=> $1::vector) > $4
        ${scopeSQL ? `AND (${scopeSQL})` : ""}
      ORDER BY similarity DESC
      LIMIT $5;
    `;
        const res = await this.db.query(sql, [
          vectorLiteral,
          modelId,
          dimension,
          options.minSimilarity,
          options.limit
        ]);
        return res?.rows ?? [];
      }
      /**
       * 生成文件 / 文件夹范围过滤 SQL（已做基本转义）
       */
      buildScopeCondition(scope) {
        if (!scope)
          return "";
        const conds = [];
        if (scope.files && scope.files.length) {
          for (const p5 of scope.files) {
            conds.push(`path = '${this.escape(p5)}'`);
          }
        }
        if (scope.folders && scope.folders.length) {
          for (const f3 of scope.folders) {
            conds.push(`path LIKE '${this.escape(f3)}/%'`);
          }
        }
        return conds.join(" OR ");
      }
      /** 极简 SQL 字符串转义 */
      escape(str) {
        return str.replace(/'/g, "''");
      }
    };
  }
});

// src/services/rag/query/VectorManager.ts
var VectorManager;
var init_VectorManager = __esm({
  "src/services/rag/query/VectorManager.ts"() {
    VectorManager = class {
      constructor(repo) {
        this.repo = repo;
      }
      /**
       * 进行相似度检索
       */
      async performSimilaritySearch(queryVector, modelId, dimension, options) {
        return this.repo.performSimilaritySearch(queryVector, modelId, dimension, options);
      }
    };
  }
});

// src/services/rag/query/RagQueryEngine.ts
var RagQueryEngine_exports = {};
__export(RagQueryEngine_exports, {
  RagQueryEngine: () => RagQueryEngine
});
var RagQueryEngine;
var init_RagQueryEngine = __esm({
  "src/services/rag/query/RagQueryEngine.ts"() {
    init_constants();
    init_VectorRepository();
    init_VectorManager();
    RagQueryEngine = class {
      constructor(app, ragService) {
        this.app = app;
        this.ragService = ragService;
        const repo = new VectorRepository(this.ragService.getDb().getClient());
        this.vecManager = new VectorManager(repo);
      }
      /**
       * 处理查询流程：索引 -> embed -> 相似度检索
       * @param params.query   用户纯文本查询
       * @param params.scope   可选范围限定
       * @param onProgress     进度回调
       */
      async processQuery(params, onProgress) {
        onProgress?.({ type: "indexing", percent: 0 });
        await this.ragService.indexVault(false, (done, total) => {
          const percent = total === 0 ? 100 : Math.floor(done / total * 100);
          onProgress?.({ type: "indexing", percent });
        });
        const embedder = this.ragService.getEmbedder();
        const queryVector = await embedder.embed(params.query);
        onProgress?.({ type: "querying" });
        const modelId = embedder.getModelId();
        const dimension = queryVector.length;
        const minSim = this.ragService.getConfig().minSimilarity ?? DEFAULT_MIN_SIMILARITY;
        const results = await this.vecManager.performSimilaritySearch(queryVector, modelId, dimension, {
          minSimilarity: minSim,
          limit: DEFAULT_TOP_K,
          scope: params.scope
        });
        onProgress?.({ type: "querying-done", queryResult: results });
        return results;
      }
      /**
       * 针对 BetterNotes 条目库执行检索。
       * 会先进行条目索引（增量）再做向量相似度查询，只返回 path 以 `note:` 开头的结果。
       */
      async processNotesQuery(params, dataManager, onProgress) {
        onProgress?.({ type: "indexing", percent: 0 });
        await this.ragService.indexNotes(dataManager, false, (done, total) => {
          const percent = total === 0 ? 100 : Math.floor(done / total * 100);
          onProgress?.({ type: "indexing", percent });
        });
        const embedder = this.ragService.getEmbedder();
        const queryVector = await embedder.embed(params.query);
        onProgress?.({ type: "querying" });
        const modelId = embedder.getModelId();
        const dimension = queryVector.length;
        const minSim = this.ragService.getConfig().minSimilarity ?? DEFAULT_MIN_SIMILARITY;
        const rawResults = await this.vecManager.performSimilaritySearch(
          queryVector,
          modelId,
          dimension,
          {
            minSimilarity: minSim,
            limit: DEFAULT_TOP_K
          }
        );
        const results = rawResults.filter((r) => r.path.startsWith("note:"));
        onProgress?.({ type: "querying-done", queryResult: results });
        return results;
      }
    };
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s5(a2, o5, h3) {
        function u4(r, e2) {
          if (!o5[r]) {
            if (!a2[r]) {
              var t2 = "function" == typeof require && require;
              if (!e2 && t2)
                return t2(r, true);
              if (l4)
                return l4(r, true);
              var n3 = new Error("Cannot find module '" + r + "'");
              throw n3.code = "MODULE_NOT_FOUND", n3;
            }
            var i3 = o5[r] = { exports: {} };
            a2[r][0].call(i3.exports, function(e3) {
              var t3 = a2[r][1][e3];
              return u4(t3 || e3);
            }, i3, i3.exports, s5, a2, o5, h3);
          }
          return o5[r].exports;
        }
        for (var l4 = "function" == typeof require && require, e = 0; e < h3.length; e++)
          u4(h3[e]);
        return u4;
      }({ 1: [function(e, t2, r) {
        "use strict";
        var d3 = e("./utils"), c2 = e("./support"), p5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t3, r2, n3, i3, s5, a2, o5, h3 = [], u4 = 0, l4 = e2.length, f3 = l4, c3 = "string" !== d3.getTypeOf(e2); u4 < e2.length; )
            f3 = l4 - u4, n3 = c3 ? (t3 = e2[u4++], r2 = u4 < l4 ? e2[u4++] : 0, u4 < l4 ? e2[u4++] : 0) : (t3 = e2.charCodeAt(u4++), r2 = u4 < l4 ? e2.charCodeAt(u4++) : 0, u4 < l4 ? e2.charCodeAt(u4++) : 0), i3 = t3 >> 2, s5 = (3 & t3) << 4 | r2 >> 4, a2 = 1 < f3 ? (15 & r2) << 2 | n3 >> 6 : 64, o5 = 2 < f3 ? 63 & n3 : 64, h3.push(p5.charAt(i3) + p5.charAt(s5) + p5.charAt(a2) + p5.charAt(o5));
          return h3.join("");
        }, r.decode = function(e2) {
          var t3, r2, n3, i3, s5, a2, o5 = 0, h3 = 0, u4 = "data:";
          if (e2.substr(0, u4.length) === u4)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l4, f3 = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p5.charAt(64) && f3--, e2.charAt(e2.length - 2) === p5.charAt(64) && f3--, f3 % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l4 = c2.uint8array ? new Uint8Array(0 | f3) : new Array(0 | f3); o5 < e2.length; )
            t3 = p5.indexOf(e2.charAt(o5++)) << 2 | (i3 = p5.indexOf(e2.charAt(o5++))) >> 4, r2 = (15 & i3) << 4 | (s5 = p5.indexOf(e2.charAt(o5++))) >> 2, n3 = (3 & s5) << 6 | (a2 = p5.indexOf(e2.charAt(o5++))), l4[h3++] = t3, 64 !== s5 && (l4[h3++] = r2), 64 !== a2 && (l4[h3++] = n3);
          return l4;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t2, r) {
        "use strict";
        var n3 = e("./external"), i3 = e("./stream/DataWorker"), s5 = e("./stream/Crc32Probe"), a2 = e("./stream/DataLengthProbe");
        function o5(e2, t3, r2, n4, i4) {
          this.compressedSize = e2, this.uncompressedSize = t3, this.crc32 = r2, this.compression = n4, this.compressedContent = i4;
        }
        o5.prototype = { getContentWorker: function() {
          var e2 = new i3(n3.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t3 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i3(n3.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o5.createWorkerFrom = function(e2, t3, r2) {
          return e2.pipe(new s5()).pipe(new a2("uncompressedSize")).pipe(t3.compressWorker(r2)).pipe(new a2("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o5;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t2, r) {
        "use strict";
        var n3 = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n3("STORE compression");
        }, uncompressWorker: function() {
          return new n3("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t2, r) {
        "use strict";
        var n3 = e("./utils");
        var o5 = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n4 = 0; n4 < 8; n4++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3) {
          return void 0 !== e2 && e2.length ? "string" !== n3.getTypeOf(e2) ? function(e3, t4, r2, n4) {
            var i3 = o5, s5 = n4 + r2;
            e3 ^= -1;
            for (var a2 = n4; a2 < s5; a2++)
              e3 = e3 >>> 8 ^ i3[255 & (e3 ^ t4[a2])];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : function(e3, t4, r2, n4) {
            var i3 = o5, s5 = n4 + r2;
            e3 ^= -1;
            for (var a2 = n4; a2 < s5; a2++)
              e3 = e3 >>> 8 ^ i3[255 & (e3 ^ t4.charCodeAt(a2))];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t2, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t2, r) {
        "use strict";
        var n3 = null;
        n3 = "undefined" != typeof Promise ? Promise : e("lie"), t2.exports = { Promise: n3 };
      }, { lie: 37 }], 7: [function(e, t2, r) {
        "use strict";
        var n3 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i3 = e("pako"), s5 = e("./utils"), a2 = e("./stream/GenericWorker"), o5 = n3 ? "uint8array" : "array";
        function h3(e2, t3) {
          a2.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t3, this.meta = {};
        }
        r.magic = "\b\0", s5.inherits(h3, a2), h3.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s5.transformTo(o5, e2.data), false);
        }, h3.prototype.flush = function() {
          a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h3.prototype.cleanUp = function() {
          a2.prototype.cleanUp.call(this), this._pako = null;
        }, h3.prototype._createPako = function() {
          this._pako = new i3[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e2) {
            t3.push({ data: e2, meta: t3.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h3("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h3("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t2, r) {
        "use strict";
        function A4(e2, t3) {
          var r2, n4 = "";
          for (r2 = 0; r2 < t3; r2++)
            n4 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n4;
        }
        function n3(e2, t3, r2, n4, i4, s6) {
          var a2, o5, h3 = e2.file, u4 = e2.compression, l4 = s6 !== O5.utf8encode, f3 = I4.transformTo("string", s6(h3.name)), c2 = I4.transformTo("string", O5.utf8encode(h3.name)), d3 = h3.comment, p5 = I4.transformTo("string", s6(d3)), m5 = I4.transformTo("string", O5.utf8encode(d3)), _3 = c2.length !== h3.name.length, g5 = m5.length !== d3.length, b4 = "", v4 = "", y4 = "", w6 = h3.dir, k5 = h3.date, x4 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r2 || (x4.crc32 = e2.crc32, x4.compressedSize = e2.compressedSize, x4.uncompressedSize = e2.uncompressedSize);
          var S4 = 0;
          t3 && (S4 |= 8), l4 || !_3 && !g5 || (S4 |= 2048);
          var z4 = 0, C6 = 0;
          w6 && (z4 |= 16), "UNIX" === i4 ? (C6 = 798, z4 |= function(e3, t4) {
            var r3 = e3;
            return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16;
          }(h3.unixPermissions, w6)) : (C6 = 20, z4 |= function(e3) {
            return 63 & (e3 || 0);
          }(h3.dosPermissions)), a2 = k5.getUTCHours(), a2 <<= 6, a2 |= k5.getUTCMinutes(), a2 <<= 5, a2 |= k5.getUTCSeconds() / 2, o5 = k5.getUTCFullYear() - 1980, o5 <<= 4, o5 |= k5.getUTCMonth() + 1, o5 <<= 5, o5 |= k5.getUTCDate(), _3 && (v4 = A4(1, 1) + A4(B3(f3), 4) + c2, b4 += "up" + A4(v4.length, 2) + v4), g5 && (y4 = A4(1, 1) + A4(B3(p5), 4) + m5, b4 += "uc" + A4(y4.length, 2) + y4);
          var E2 = "";
          return E2 += "\n\0", E2 += A4(S4, 2), E2 += u4.magic, E2 += A4(a2, 2), E2 += A4(o5, 2), E2 += A4(x4.crc32, 4), E2 += A4(x4.compressedSize, 4), E2 += A4(x4.uncompressedSize, 4), E2 += A4(f3.length, 2), E2 += A4(b4.length, 2), { fileRecord: R6.LOCAL_FILE_HEADER + E2 + f3 + b4, dirRecord: R6.CENTRAL_FILE_HEADER + A4(C6, 2) + E2 + A4(p5.length, 2) + "\0\0\0\0" + A4(z4, 4) + A4(n4, 4) + f3 + b4 + p5 };
        }
        var I4 = e("../utils"), i3 = e("../stream/GenericWorker"), O5 = e("../utf8"), B3 = e("../crc32"), R6 = e("../signature");
        function s5(e2, t3, r2, n4) {
          i3.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r2, this.encodeFileName = n4, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I4.inherits(s5, i3), s5.prototype.push = function(e2) {
          var t3 = e2.meta.percent || 0, r2 = this.entriesCount, n4 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i3.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n4 - 1)) / r2 : 100 } }));
        }, s5.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t3 = this.streamFiles && !e2.file.dir;
          if (t3) {
            var r2 = n3(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s5.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e2.file.dir, r2 = n3(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t3)
            this.push({ data: function(e3) {
              return R6.DATA_DESCRIPTOR + A4(e3.crc32, 4) + A4(e3.compressedSize, 4) + A4(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s5.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
            this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n4 = function(e3, t4, r3, n5, i4) {
            var s6 = I4.transformTo("string", i4(n5));
            return R6.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A4(e3, 2) + A4(e3, 2) + A4(t4, 4) + A4(r3, 4) + A4(s6.length, 2) + s6;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n4, meta: { percent: 100 } });
        }, s5.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s5.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, s5.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s5.prototype.error = function(e2) {
          var t3 = this._sources;
          if (!i3.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t3.length; r2++)
            try {
              t3[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s5.prototype.lock = function() {
          i3.prototype.lock.call(this);
          for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++)
            e2[t3].lock();
        }, t2.exports = s5;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t2, r) {
        "use strict";
        var u4 = e("../compressions"), n3 = e("./ZipFileWorker");
        r.generateWorker = function(e2, a2, t3) {
          var o5 = new n3(a2.streamFiles, t3, a2.platform, a2.encodeFileName), h3 = 0;
          try {
            e2.forEach(function(e3, t4) {
              h3++;
              var r2 = function(e4, t5) {
                var r3 = e4 || t5, n5 = u4[r3];
                if (!n5)
                  throw new Error(r3 + " is not a valid compression method !");
                return n5;
              }(t4.options.compression, a2.compression), n4 = t4.options.compressionOptions || a2.compressionOptions || {}, i3 = t4.dir, s5 = t4.date;
              t4._compressWorker(r2, n4).withStreamInfo("file", { name: e3, dir: i3, date: s5, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o5);
            }), o5.entriesCount = h3;
          } catch (e3) {
            o5.error(e3);
          }
          return o5;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t2, r) {
        "use strict";
        function n3() {
          if (!(this instanceof n3))
            return new n3();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n3();
            for (var t3 in this)
              "function" != typeof this[t3] && (e2[t3] = this[t3]);
            return e2;
          };
        }
        (n3.prototype = e("./object")).loadAsync = e("./load"), n3.support = e("./support"), n3.defaults = e("./defaults"), n3.version = "3.10.1", n3.loadAsync = function(e2, t3) {
          return new n3().loadAsync(e2, t3);
        }, n3.external = e("./external"), t2.exports = n3;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t2, r) {
        "use strict";
        var u4 = e("./utils"), i3 = e("./external"), n3 = e("./utf8"), s5 = e("./zipEntries"), a2 = e("./stream/Crc32Probe"), l4 = e("./nodejsUtils");
        function f3(n4) {
          return new i3.Promise(function(e2, t3) {
            var r2 = n4.decompressed.getContentWorker().pipe(new a2());
            r2.on("error", function(e3) {
              t3(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n4.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t2.exports = function(e2, o5) {
          var h3 = this;
          return o5 = u4.extend(o5 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n3.utf8decode }), l4.isNode && l4.isStream(e2) ? i3.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u4.prepareContent("the loaded zip file", e2, true, o5.optimizedBinaryString, o5.base64).then(function(e3) {
            var t3 = new s5(o5);
            return t3.load(e3), t3;
          }).then(function(e3) {
            var t3 = [i3.Promise.resolve(e3)], r2 = e3.files;
            if (o5.checkCRC32)
              for (var n4 = 0; n4 < r2.length; n4++)
                t3.push(f3(r2[n4]));
            return i3.Promise.all(t3);
          }).then(function(e3) {
            for (var t3 = e3.shift(), r2 = t3.files, n4 = 0; n4 < r2.length; n4++) {
              var i4 = r2[n4], s6 = i4.fileNameStr, a3 = u4.resolve(i4.fileNameStr);
              h3.file(a3, i4.decompressed, { binary: true, optimizedBinaryString: true, date: i4.date, dir: i4.dir, comment: i4.fileCommentStr.length ? i4.fileCommentStr : null, unixPermissions: i4.unixPermissions, dosPermissions: i4.dosPermissions, createFolders: o5.createFolders }), i4.dir || (h3.file(a3).unsafeOriginalName = s6);
            }
            return t3.zipComment.length && (h3.comment = t3.zipComment), h3;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t2, r) {
        "use strict";
        var n3 = e("../utils"), i3 = e("../stream/GenericWorker");
        function s5(e2, t3) {
          i3.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t3);
        }
        n3.inherits(s5, i3), s5.prototype._bindStream = function(e2) {
          var t3 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t3.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t3.isPaused ? this.generatedError = e3 : t3.error(e3);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s5.prototype.pause = function() {
          return !!i3.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s5.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s5;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t2, r) {
        "use strict";
        var i3 = e("readable-stream").Readable;
        function n3(e2, t3, r2) {
          i3.call(this, t3), this._helper = e2;
          var n4 = this;
          e2.on("data", function(e3, t4) {
            n4.push(e3) || n4._helper.pause(), r2 && r2(t4);
          }).on("error", function(e3) {
            n4.emit("error", e3);
          }).on("end", function() {
            n4.push(null);
          });
        }
        e("../utils").inherits(n3, i3), n3.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n3;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t2, r) {
        "use strict";
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t3);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t3);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t3 = new Buffer(e2);
          return t3.fill(0), t3;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t2, r) {
        "use strict";
        function s5(e2, t3, r2) {
          var n4, i4 = u4.getTypeOf(t3), s6 = u4.extend(r2 || {}, f3);
          s6.date = s6.date || new Date(), null !== s6.compression && (s6.compression = s6.compression.toUpperCase()), "string" == typeof s6.unixPermissions && (s6.unixPermissions = parseInt(s6.unixPermissions, 8)), s6.unixPermissions && 16384 & s6.unixPermissions && (s6.dir = true), s6.dosPermissions && 16 & s6.dosPermissions && (s6.dir = true), s6.dir && (e2 = g5(e2)), s6.createFolders && (n4 = _3(e2)) && b4.call(this, n4, true);
          var a3 = "string" === i4 && false === s6.binary && false === s6.base64;
          r2 && void 0 !== r2.binary || (s6.binary = !a3), (t3 instanceof c2 && 0 === t3.uncompressedSize || s6.dir || !t3 || 0 === t3.length) && (s6.base64 = false, s6.binary = true, t3 = "", s6.compression = "STORE", i4 = "string");
          var o6 = null;
          o6 = t3 instanceof c2 || t3 instanceof l4 ? t3 : p5.isNode && p5.isStream(t3) ? new m5(e2, t3) : u4.prepareContent(e2, t3, s6.binary, s6.optimizedBinaryString, s6.base64);
          var h4 = new d3(e2, o6, s6);
          this.files[e2] = h4;
        }
        var i3 = e("./utf8"), u4 = e("./utils"), l4 = e("./stream/GenericWorker"), a2 = e("./stream/StreamHelper"), f3 = e("./defaults"), c2 = e("./compressedObject"), d3 = e("./zipObject"), o5 = e("./generate"), p5 = e("./nodejsUtils"), m5 = e("./nodejs/NodejsStreamInputAdapter"), _3 = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t3 = e2.lastIndexOf("/");
          return 0 < t3 ? e2.substring(0, t3) : "";
        }, g5 = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b4 = function(e2, t3) {
          return t3 = void 0 !== t3 ? t3 : f3.createFolders, e2 = g5(e2), this.files[e2] || s5.call(this, e2, null, { dir: true, createFolders: t3 }), this.files[e2];
        };
        function h3(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n3 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t3, r2, n4;
          for (t3 in this.files)
            n4 = this.files[t3], (r2 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e2(r2, n4);
        }, filter: function(r2) {
          var n4 = [];
          return this.forEach(function(e2, t3) {
            r2(e2, t3) && n4.push(t3);
          }), n4;
        }, file: function(e2, t3, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s5.call(this, e2, t3, r2), this;
          if (h3(e2)) {
            var n4 = e2;
            return this.filter(function(e3, t4) {
              return !t4.dir && n4.test(e3);
            });
          }
          var i4 = this.files[this.root + e2];
          return i4 && !i4.dir ? i4 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h3(r2))
            return this.filter(function(e3, t4) {
              return t4.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t3 = b4.call(this, e2), n4 = this.clone();
          return n4.root = t3.name, n4;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t3 = this.filter(function(e3, t4) {
              return t4.name.slice(0, r2.length) === r2;
            }), n4 = 0; n4 < t3.length; n4++)
              delete this.files[t3[n4].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t3, r2 = {};
          try {
            if ((r2 = u4.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i3.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u4.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n4 = r2.comment || this.comment || "";
            t3 = o5.generateWorker(this, r2, n4);
          } catch (e3) {
            (t3 = new l4("error")).error(e3);
          }
          return new a2(t3, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t3) {
          return this.generateInternalStream(e2).accumulate(t3);
        }, generateNodeStream: function(e2, t3) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t3);
        } };
        t2.exports = n3;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t2, r) {
        "use strict";
        t2.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t2, r) {
        "use strict";
        var n3 = e("./DataReader");
        function i3(e2) {
          n3.call(this, e2);
          for (var t3 = 0; t3 < this.data.length; t3++)
            e2[t3] = 255 & e2[t3];
        }
        e("../utils").inherits(i3, n3), i3.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i3.prototype.lastIndexOfSignature = function(e2) {
          for (var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n4 = e2.charCodeAt(2), i4 = e2.charCodeAt(3), s5 = this.length - 4; 0 <= s5; --s5)
            if (this.data[s5] === t3 && this.data[s5 + 1] === r2 && this.data[s5 + 2] === n4 && this.data[s5 + 3] === i4)
              return s5 - this.zero;
          return -1;
        }, i3.prototype.readAndCheckSignature = function(e2) {
          var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n4 = e2.charCodeAt(2), i4 = e2.charCodeAt(3), s5 = this.readData(4);
          return t3 === s5[0] && r2 === s5[1] && n4 === s5[2] && i4 === s5[3];
        }, i3.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t2, r) {
        "use strict";
        var n3 = e("../utils");
        function i3(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i3.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t3, r2 = 0;
          for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--)
            r2 = (r2 << 8) + this.byteAt(t3);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n3.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t2.exports = i3;
      }, { "../utils": 32 }], 19: [function(e, t2, r) {
        "use strict";
        var n3 = e("./Uint8ArrayReader");
        function i3(e2) {
          n3.call(this, e2);
        }
        e("../utils").inherits(i3, n3), i3.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t2, r) {
        "use strict";
        var n3 = e("./DataReader");
        function i3(e2) {
          n3.call(this, e2);
        }
        e("../utils").inherits(i3, n3), i3.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i3.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i3.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i3.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t2, r) {
        "use strict";
        var n3 = e("./ArrayReader");
        function i3(e2) {
          n3.call(this, e2);
        }
        e("../utils").inherits(i3, n3), i3.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t2, r) {
        "use strict";
        var n3 = e("../utils"), i3 = e("../support"), s5 = e("./ArrayReader"), a2 = e("./StringReader"), o5 = e("./NodeBufferReader"), h3 = e("./Uint8ArrayReader");
        t2.exports = function(e2) {
          var t3 = n3.getTypeOf(e2);
          return n3.checkSupport(t3), "string" !== t3 || i3.uint8array ? "nodebuffer" === t3 ? new o5(e2) : i3.uint8array ? new h3(n3.transformTo("uint8array", e2)) : new s5(n3.transformTo("array", e2)) : new a2(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t2, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t2, r) {
        "use strict";
        var n3 = e("./GenericWorker"), i3 = e("../utils");
        function s5(e2) {
          n3.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i3.inherits(s5, n3), s5.prototype.processChunk = function(e2) {
          this.push({ data: i3.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t2.exports = s5;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t2, r) {
        "use strict";
        var n3 = e("./GenericWorker"), i3 = e("../crc32");
        function s5() {
          n3.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s5, n3), s5.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i3(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t2.exports = s5;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t2, r) {
        "use strict";
        var n3 = e("../utils"), i3 = e("./GenericWorker");
        function s5(e2) {
          i3.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n3.inherits(s5, i3), s5.prototype.processChunk = function(e2) {
          if (e2) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e2.data.length;
          }
          i3.prototype.processChunk.call(this, e2);
        }, t2.exports = s5;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t2, r) {
        "use strict";
        var n3 = e("../utils"), i3 = e("./GenericWorker");
        function s5(e2) {
          i3.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t3.dataIsReady = true, t3.data = e3, t3.max = e3 && e3.length || 0, t3.type = n3.getTypeOf(e3), t3.isPaused || t3._tickAndRepeat();
          }, function(e3) {
            t3.error(e3);
          });
        }
        n3.inherits(s5, i3), s5.prototype.cleanUp = function() {
          i3.prototype.cleanUp.call(this), this.data = null;
        }, s5.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n3.delay(this._tickAndRepeat, [], this)), true);
        }, s5.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n3.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s5.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s5;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t2, r) {
        "use strict";
        function n3(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n3.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t3) {
          return this._listeners[e2].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t3) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t3);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t3) {
          return this.extraStreamInfo[e2] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t2.exports = n3;
      }, {}], 29: [function(e, t2, r) {
        "use strict";
        var h3 = e("../utils"), i3 = e("./ConvertWorker"), s5 = e("./GenericWorker"), u4 = e("../base64"), n3 = e("../support"), a2 = e("../external"), o5 = null;
        if (n3.nodestream)
          try {
            o5 = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l4(e2, o6) {
          return new a2.Promise(function(t3, r2) {
            var n4 = [], i4 = e2._internalType, s6 = e2._outputType, a3 = e2._mimeType;
            e2.on("data", function(e3, t4) {
              n4.push(e3), o6 && o6(t4);
            }).on("error", function(e3) {
              n4 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t4, r3) {
                  switch (e4) {
                    case "blob":
                      return h3.newBlob(h3.transformTo("arraybuffer", t4), r3);
                    case "base64":
                      return u4.encode(t4);
                    default:
                      return h3.transformTo(e4, t4);
                  }
                }(s6, function(e4, t4) {
                  var r3, n5 = 0, i5 = null, s7 = 0;
                  for (r3 = 0; r3 < t4.length; r3++)
                    s7 += t4[r3].length;
                  switch (e4) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i5 = new Uint8Array(s7), r3 = 0; r3 < t4.length; r3++)
                        i5.set(t4[r3], n5), n5 += t4[r3].length;
                      return i5;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i4, n4), a3);
                t3(e3);
              } catch (e4) {
                r2(e4);
              }
              n4 = [];
            }).resume();
          });
        }
        function f3(e2, t3, r2) {
          var n4 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n4 = "uint8array";
              break;
            case "base64":
              n4 = "string";
          }
          try {
            this._internalType = n4, this._outputType = t3, this._mimeType = r2, h3.checkSupport(n4), this._worker = e2.pipe(new i3(n4)), e2.lock();
          } catch (e3) {
            this._worker = new s5("error"), this._worker.error(e3);
          }
        }
        f3.prototype = { accumulate: function(e2) {
          return l4(this, e2);
        }, on: function(e2, t3) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t3.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h3.delay(t3, arguments, r2);
          }), this;
        }, resume: function() {
          return h3.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h3.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o5(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t2.exports = f3;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t2, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n3 = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n3], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i3.append(n3), r.blob = 0 === i3.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t2, s5) {
        "use strict";
        for (var o5 = e("./utils"), h3 = e("./support"), r = e("./nodejsUtils"), n3 = e("./stream/GenericWorker"), u4 = new Array(256), i3 = 0; i3 < 256; i3++)
          u4[i3] = 252 <= i3 ? 6 : 248 <= i3 ? 5 : 240 <= i3 ? 4 : 224 <= i3 ? 3 : 192 <= i3 ? 2 : 1;
        u4[254] = u4[254] = 1;
        function a2() {
          n3.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l4() {
          n3.call(this, "utf-8 encode");
        }
        s5.utf8encode = function(e2) {
          return h3.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t3, r2, n4, i4, s6, a3 = e3.length, o6 = 0;
            for (i4 = 0; i4 < a3; i4++)
              55296 == (64512 & (r2 = e3.charCodeAt(i4))) && i4 + 1 < a3 && 56320 == (64512 & (n4 = e3.charCodeAt(i4 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n4 - 56320), i4++), o6 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t3 = h3.uint8array ? new Uint8Array(o6) : new Array(o6), i4 = s6 = 0; s6 < o6; i4++)
              55296 == (64512 & (r2 = e3.charCodeAt(i4))) && i4 + 1 < a3 && 56320 == (64512 & (n4 = e3.charCodeAt(i4 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n4 - 56320), i4++), r2 < 128 ? t3[s6++] = r2 : (r2 < 2048 ? t3[s6++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s6++] = 224 | r2 >>> 12 : (t3[s6++] = 240 | r2 >>> 18, t3[s6++] = 128 | r2 >>> 12 & 63), t3[s6++] = 128 | r2 >>> 6 & 63), t3[s6++] = 128 | 63 & r2);
            return t3;
          }(e2);
        }, s5.utf8decode = function(e2) {
          return h3.nodebuffer ? o5.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t3, r2, n4, i4, s6 = e3.length, a3 = new Array(2 * s6);
            for (t3 = r2 = 0; t3 < s6; )
              if ((n4 = e3[t3++]) < 128)
                a3[r2++] = n4;
              else if (4 < (i4 = u4[n4]))
                a3[r2++] = 65533, t3 += i4 - 1;
              else {
                for (n4 &= 2 === i4 ? 31 : 3 === i4 ? 15 : 7; 1 < i4 && t3 < s6; )
                  n4 = n4 << 6 | 63 & e3[t3++], i4--;
                1 < i4 ? a3[r2++] = 65533 : n4 < 65536 ? a3[r2++] = n4 : (n4 -= 65536, a3[r2++] = 55296 | n4 >> 10 & 1023, a3[r2++] = 56320 | 1023 & n4);
              }
            return a3.length !== r2 && (a3.subarray ? a3 = a3.subarray(0, r2) : a3.length = r2), o5.applyFromCharCode(a3);
          }(e2 = o5.transformTo(h3.uint8array ? "uint8array" : "array", e2));
        }, o5.inherits(a2, n3), a2.prototype.processChunk = function(e2) {
          var t3 = o5.transformTo(h3.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h3.uint8array) {
              var r2 = t3;
              (t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r2, this.leftOver.length);
            } else
              t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n4 = function(e3, t4) {
            var r3;
            for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t4 : 0 === r3 ? t4 : r3 + u4[e3[r3]] > t4 ? r3 : t4;
          }(t3), i4 = t3;
          n4 !== t3.length && (h3.uint8array ? (i4 = t3.subarray(0, n4), this.leftOver = t3.subarray(n4, t3.length)) : (i4 = t3.slice(0, n4), this.leftOver = t3.slice(n4, t3.length))), this.push({ data: s5.utf8decode(i4), meta: e2.meta });
        }, a2.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s5.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s5.Utf8DecodeWorker = a2, o5.inherits(l4, n3), l4.prototype.processChunk = function(e2) {
          this.push({ data: s5.utf8encode(e2.data), meta: e2.meta });
        }, s5.Utf8EncodeWorker = l4;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t2, a2) {
        "use strict";
        var o5 = e("./support"), h3 = e("./base64"), r = e("./nodejsUtils"), u4 = e("./external");
        function n3(e2) {
          return e2;
        }
        function l4(e2, t3) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t3[r2] = 255 & e2.charCodeAt(r2);
          return t3;
        }
        e("setimmediate"), a2.newBlob = function(t3, r2) {
          a2.checkSupport("blob");
          try {
            return new Blob([t3], { type: r2 });
          } catch (e2) {
            try {
              var n4 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n4.append(t3), n4.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i3 = { stringifyByChunk: function(e2, t3, r2) {
          var n4 = [], i4 = 0, s6 = e2.length;
          if (s6 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i4 < s6; )
            "array" === t3 || "nodebuffer" === t3 ? n4.push(String.fromCharCode.apply(null, e2.slice(i4, Math.min(i4 + r2, s6)))) : n4.push(String.fromCharCode.apply(null, e2.subarray(i4, Math.min(i4 + r2, s6)))), i4 += r2;
          return n4.join("");
        }, stringifyByChar: function(e2) {
          for (var t3 = "", r2 = 0; r2 < e2.length; r2++)
            t3 += String.fromCharCode(e2[r2]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o5.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o5.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s5(e2) {
          var t3 = 65536, r2 = a2.getTypeOf(e2), n4 = true;
          if ("uint8array" === r2 ? n4 = i3.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n4 = i3.applyCanBeUsed.nodebuffer), n4)
            for (; 1 < t3; )
              try {
                return i3.stringifyByChunk(e2, r2, t3);
              } catch (e3) {
                t3 = Math.floor(t3 / 2);
              }
          return i3.stringifyByChar(e2);
        }
        function f3(e2, t3) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t3[r2] = e2[r2];
          return t3;
        }
        a2.applyFromCharCode = s5;
        var c2 = {};
        c2.string = { string: n3, array: function(e2) {
          return l4(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c2.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l4(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l4(e2, r.allocBuffer(e2.length));
        } }, c2.array = { string: s5, array: n3, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c2.arraybuffer = { string: function(e2) {
          return s5(new Uint8Array(e2));
        }, array: function(e2) {
          return f3(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n3, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c2.uint8array = { string: s5, array: function(e2) {
          return f3(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n3, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c2.nodebuffer = { string: s5, array: function(e2) {
          return f3(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c2.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f3(e2, new Uint8Array(e2.length));
        }, nodebuffer: n3 }, a2.transformTo = function(e2, t3) {
          if (t3 = t3 || "", !e2)
            return t3;
          a2.checkSupport(e2);
          var r2 = a2.getTypeOf(t3);
          return c2[r2][e2](t3);
        }, a2.resolve = function(e2) {
          for (var t3 = e2.split("/"), r2 = [], n4 = 0; n4 < t3.length; n4++) {
            var i4 = t3[n4];
            "." === i4 || "" === i4 && 0 !== n4 && n4 !== t3.length - 1 || (".." === i4 ? r2.pop() : r2.push(i4));
          }
          return r2.join("/");
        }, a2.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o5.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o5.uint8array && e2 instanceof Uint8Array ? "uint8array" : o5.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a2.checkSupport = function(e2) {
          if (!o5[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e2) {
          var t3, r2, n4 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n4 += "\\x" + ((t3 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n4;
        }, a2.delay = function(e2, t3, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t3 || []);
          });
        }, a2.inherits = function(e2, t3) {
          function r2() {
          }
          r2.prototype = t3.prototype, e2.prototype = new r2();
        }, a2.extend = function() {
          var e2, t3, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t3 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t3) && void 0 === r2[t3] && (r2[t3] = arguments[e2][t3]);
          return r2;
        }, a2.prepareContent = function(r2, e2, n4, i4, s6) {
          return u4.Promise.resolve(e2).then(function(n5) {
            return o5.blob && (n5 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n5))) && "undefined" != typeof FileReader ? new u4.Promise(function(t3, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t3(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n5);
            }) : n5;
          }).then(function(e3) {
            var t3 = a2.getTypeOf(e3);
            return t3 ? ("arraybuffer" === t3 ? e3 = a2.transformTo("uint8array", e3) : "string" === t3 && (s6 ? e3 = h3.decode(e3) : n4 && true !== i4 && (e3 = function(e4) {
              return l4(e4, o5.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u4.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t2, r) {
        "use strict";
        var n3 = e("./reader/readerFor"), i3 = e("./utils"), s5 = e("./signature"), a2 = e("./zipEntry"), o5 = e("./support");
        function h3(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h3.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i3.pretty(t3) + ", expected " + i3.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t3) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n4 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r2), n4;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t3 = o5.uint8array ? "uint8array" : "array", r2 = i3.transformTo(t3, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t3, r2, n4 = this.zip64EndOfCentralSize - 44; 0 < n4; )
            e2 = this.reader.readInt(2), t3 = this.reader.readInt(4), r2 = this.reader.readData(t3), this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t3;
          for (e2 = 0; e2 < this.files.length; e2++)
            t3 = this.files[e2], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s5.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s5.CENTRAL_FILE_HEADER); )
            (e2 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s5.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s5.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t3 = e2;
          if (this.checkSignature(s5.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i3.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i3.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i3.MAX_VALUE_16BITS || this.centralDirRecords === i3.MAX_VALUE_16BITS || this.centralDirSize === i3.MAX_VALUE_32BITS || this.centralDirOffset === i3.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s5.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s5.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s5.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s5.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s5.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n4 = t3 - r2;
          if (0 < n4)
            this.isSignature(t3, s5.CENTRAL_FILE_HEADER) || (this.reader.zero = n4);
          else if (n4 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n4) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n3(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h3;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t2, r) {
        "use strict";
        var n3 = e("./reader/readerFor"), s5 = e("./utils"), i3 = e("./compressedObject"), a2 = e("./crc32"), o5 = e("./utf8"), h3 = e("./compressions"), u4 = e("./support");
        function l4(e2, t3) {
          this.options = e2, this.loadOptions = t3;
        }
        l4.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t3, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e3) {
            for (var t4 in h3)
              if (Object.prototype.hasOwnProperty.call(h3, t4) && h3[t4].magic === e3)
                return h3[t4];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s5.pretty(this.compressionMethod) + " unknown (inner file : " + s5.transformTo("string", this.fileName) + ")");
          this.decompressed = new i3(this.compressedSize, this.uncompressedSize, this.crc32, t3, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t3 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t3), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n3(this.extraFields[1].value);
            this.uncompressedSize === s5.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s5.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s5.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s5.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t3, r2, n4, i4 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i4; )
            t3 = e2.readInt(2), r2 = e2.readInt(2), n4 = e2.readData(r2), this.extraFields[t3] = { id: t3, length: r2, value: n4 };
          e2.setIndex(i4);
        }, handleUTF8: function() {
          var e2 = u4.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o5.utf8decode(this.fileName), this.fileCommentStr = o5.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3)
              this.fileNameStr = t3;
            else {
              var r2 = s5.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n4 = this.findExtraFieldUnicodeComment();
            if (null !== n4)
              this.fileCommentStr = n4;
            else {
              var i4 = s5.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i4);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t3 = n3(e2.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileName) !== t3.readInt(4) ? null : o5.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t3 = n3(e2.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileComment) !== t3.readInt(4) ? null : o5.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        } }, t2.exports = l4;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t2, r) {
        "use strict";
        function n3(e2, t3, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t3, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s5 = e("./stream/StreamHelper"), i3 = e("./stream/DataWorker"), a2 = e("./utf8"), o5 = e("./compressedObject"), h3 = e("./stream/GenericWorker");
        n3.prototype = { internalStream: function(e2) {
          var t3 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n4 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t3 = this._decompressWorker();
            var i4 = !this._dataBinary;
            i4 && !n4 && (t3 = t3.pipe(new a2.Utf8EncodeWorker())), !i4 && n4 && (t3 = t3.pipe(new a2.Utf8DecodeWorker()));
          } catch (e3) {
            (t3 = new h3("error")).error(e3);
          }
          return new s5(t3, r2, "");
        }, async: function(e2, t3) {
          return this.internalStream(e2).accumulate(t3);
        }, nodeStream: function(e2, t3) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e2, t3) {
          if (this._data instanceof o5 && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a2.Utf8EncodeWorker())), o5.createWorkerFrom(r2, e2, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o5 ? this._data.getContentWorker() : this._data instanceof h3 ? this._data : new i3(this._data);
        } };
        for (var u4 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l4 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f3 = 0; f3 < u4.length; f3++)
          n3.prototype[u4[f3]] = l4;
        t2.exports = n3;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l4, t2) {
        (function(t3) {
          "use strict";
          var r, n3, e2 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e2) {
            var i3 = 0, s5 = new e2(u4), a2 = t3.document.createTextNode("");
            s5.observe(a2, { characterData: true }), r = function() {
              a2.data = i3 = ++i3 % 2;
            };
          } else if (t3.setImmediate || void 0 === t3.MessageChannel)
            r = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e3 = t3.document.createElement("script");
              e3.onreadystatechange = function() {
                u4(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t3.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u4, 0);
            };
          else {
            var o5 = new t3.MessageChannel();
            o5.port1.onmessage = u4, r = function() {
              o5.port2.postMessage(0);
            };
          }
          var h3 = [];
          function u4() {
            var e3, t4;
            n3 = true;
            for (var r2 = h3.length; r2; ) {
              for (t4 = h3, h3 = [], e3 = -1; ++e3 < r2; )
                t4[e3]();
              r2 = h3.length;
            }
            n3 = false;
          }
          l4.exports = function(e3) {
            1 !== h3.push(e3) || n3 || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t2, r) {
        "use strict";
        var i3 = e("immediate");
        function u4() {
        }
        var l4 = {}, s5 = ["REJECTED"], a2 = ["FULFILLED"], n3 = ["PENDING"];
        function o5(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n3, this.queue = [], this.outcome = void 0, e2 !== u4 && d3(this, e2);
        }
        function h3(e2, t3, r2) {
          this.promise = e2, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f3(t3, r2, n4) {
          i3(function() {
            var e2;
            try {
              e2 = r2(n4);
            } catch (e3) {
              return l4.reject(t3, e3);
            }
            e2 === t3 ? l4.reject(t3, new TypeError("Cannot resolve promise with itself")) : l4.resolve(t3, e2);
          });
        }
        function c2(e2) {
          var t3 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t3)
            return function() {
              t3.apply(e2, arguments);
            };
        }
        function d3(t3, e2) {
          var r2 = false;
          function n4(e3) {
            r2 || (r2 = true, l4.reject(t3, e3));
          }
          function i4(e3) {
            r2 || (r2 = true, l4.resolve(t3, e3));
          }
          var s6 = p5(function() {
            e2(i4, n4);
          });
          "error" === s6.status && n4(s6.value);
        }
        function p5(e2, t3) {
          var r2 = {};
          try {
            r2.value = e2(t3), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t2.exports = o5).prototype.finally = function(t3) {
          if ("function" != typeof t3)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t3()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t3()).then(function() {
              throw e2;
            });
          });
        }, o5.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o5.prototype.then = function(e2, t3) {
          if ("function" != typeof e2 && this.state === a2 || "function" != typeof t3 && this.state === s5)
            return this;
          var r2 = new this.constructor(u4);
          this.state !== n3 ? f3(r2, this.state === a2 ? e2 : t3, this.outcome) : this.queue.push(new h3(r2, e2, t3));
          return r2;
        }, h3.prototype.callFulfilled = function(e2) {
          l4.resolve(this.promise, e2);
        }, h3.prototype.otherCallFulfilled = function(e2) {
          f3(this.promise, this.onFulfilled, e2);
        }, h3.prototype.callRejected = function(e2) {
          l4.reject(this.promise, e2);
        }, h3.prototype.otherCallRejected = function(e2) {
          f3(this.promise, this.onRejected, e2);
        }, l4.resolve = function(e2, t3) {
          var r2 = p5(c2, t3);
          if ("error" === r2.status)
            return l4.reject(e2, r2.value);
          var n4 = r2.value;
          if (n4)
            d3(e2, n4);
          else {
            e2.state = a2, e2.outcome = t3;
            for (var i4 = -1, s6 = e2.queue.length; ++i4 < s6; )
              e2.queue[i4].callFulfilled(t3);
          }
          return e2;
        }, l4.reject = function(e2, t3) {
          e2.state = s5, e2.outcome = t3;
          for (var r2 = -1, n4 = e2.queue.length; ++r2 < n4; )
            e2.queue[r2].callRejected(t3);
          return e2;
        }, o5.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l4.resolve(new this(u4), e2);
        }, o5.reject = function(e2) {
          var t3 = new this(u4);
          return l4.reject(t3, e2);
        }, o5.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n4 = e2.length, i4 = false;
          if (!n4)
            return this.resolve([]);
          var s6 = new Array(n4), a3 = 0, t3 = -1, o6 = new this(u4);
          for (; ++t3 < n4; )
            h4(e2[t3], t3);
          return o6;
          function h4(e3, t4) {
            r2.resolve(e3).then(function(e4) {
              s6[t4] = e4, ++a3 !== n4 || i4 || (i4 = true, l4.resolve(o6, s6));
            }, function(e4) {
              i4 || (i4 = true, l4.reject(o6, e4));
            });
          }
        }, o5.race = function(e2) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n4 = false;
          if (!r2)
            return this.resolve([]);
          var i4 = -1, s6 = new this(u4);
          for (; ++i4 < r2; )
            a3 = e2[i4], t3.resolve(a3).then(function(e3) {
              n4 || (n4 = true, l4.resolve(s6, e3));
            }, function(e3) {
              n4 || (n4 = true, l4.reject(s6, e3));
            });
          var a3;
          return s6;
        };
      }, { immediate: 36 }], 38: [function(e, t2, r) {
        "use strict";
        var n3 = {};
        (0, e("./lib/utils/common").assign)(n3, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t2.exports = n3;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t2, r) {
        "use strict";
        var a2 = e("./zlib/deflate"), o5 = e("./utils/common"), h3 = e("./utils/strings"), i3 = e("./zlib/messages"), s5 = e("./zlib/zstream"), u4 = Object.prototype.toString, l4 = 0, f3 = -1, c2 = 0, d3 = 8;
        function p5(e2) {
          if (!(this instanceof p5))
            return new p5(e2);
          this.options = o5.assign({ level: f3, method: d3, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s5(), this.strm.avail_out = 0;
          var r2 = a2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r2 !== l4)
            throw new Error(i3[r2]);
          if (t3.header && a2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n4;
            if (n4 = "string" == typeof t3.dictionary ? h3.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u4.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r2 = a2.deflateSetDictionary(this.strm, n4)) !== l4)
              throw new Error(i3[r2]);
            this._dict_set = true;
          }
        }
        function n3(e2, t3) {
          var r2 = new p5(t3);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i3[r2.err];
          return r2.result;
        }
        p5.prototype.push = function(e2, t3) {
          var r2, n4, i4 = this.strm, s6 = this.options.chunkSize;
          if (this.ended)
            return false;
          n4 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e2 ? i4.input = h3.string2buf(e2) : "[object ArrayBuffer]" === u4.call(e2) ? i4.input = new Uint8Array(e2) : i4.input = e2, i4.next_in = 0, i4.avail_in = i4.input.length;
          do {
            if (0 === i4.avail_out && (i4.output = new o5.Buf8(s6), i4.next_out = 0, i4.avail_out = s6), 1 !== (r2 = a2.deflate(i4, n4)) && r2 !== l4)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i4.avail_out && (0 !== i4.avail_in || 4 !== n4 && 2 !== n4) || ("string" === this.options.to ? this.onData(h3.buf2binstring(o5.shrinkBuf(i4.output, i4.next_out))) : this.onData(o5.shrinkBuf(i4.output, i4.next_out)));
          } while ((0 < i4.avail_in || 0 === i4.avail_out) && 1 !== r2);
          return 4 === n4 ? (r2 = a2.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l4) : 2 !== n4 || (this.onEnd(l4), !(i4.avail_out = 0));
        }, p5.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p5.prototype.onEnd = function(e2) {
          e2 === l4 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o5.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p5, r.deflate = n3, r.deflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, n3(e2, t3);
        }, r.gzip = function(e2, t3) {
          return (t3 = t3 || {}).gzip = true, n3(e2, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t2, r) {
        "use strict";
        var c2 = e("./zlib/inflate"), d3 = e("./utils/common"), p5 = e("./utils/strings"), m5 = e("./zlib/constants"), n3 = e("./zlib/messages"), i3 = e("./zlib/zstream"), s5 = e("./zlib/gzheader"), _3 = Object.prototype.toString;
        function a2(e2) {
          if (!(this instanceof a2))
            return new a2(e2);
          this.options = d3.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i3(), this.strm.avail_out = 0;
          var r2 = c2.inflateInit2(this.strm, t3.windowBits);
          if (r2 !== m5.Z_OK)
            throw new Error(n3[r2]);
          this.header = new s5(), c2.inflateGetHeader(this.strm, this.header);
        }
        function o5(e2, t3) {
          var r2 = new a2(t3);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n3[r2.err];
          return r2.result;
        }
        a2.prototype.push = function(e2, t3) {
          var r2, n4, i4, s6, a3, o6, h3 = this.strm, u4 = this.options.chunkSize, l4 = this.options.dictionary, f3 = false;
          if (this.ended)
            return false;
          n4 = t3 === ~~t3 ? t3 : true === t3 ? m5.Z_FINISH : m5.Z_NO_FLUSH, "string" == typeof e2 ? h3.input = p5.binstring2buf(e2) : "[object ArrayBuffer]" === _3.call(e2) ? h3.input = new Uint8Array(e2) : h3.input = e2, h3.next_in = 0, h3.avail_in = h3.input.length;
          do {
            if (0 === h3.avail_out && (h3.output = new d3.Buf8(u4), h3.next_out = 0, h3.avail_out = u4), (r2 = c2.inflate(h3, m5.Z_NO_FLUSH)) === m5.Z_NEED_DICT && l4 && (o6 = "string" == typeof l4 ? p5.string2buf(l4) : "[object ArrayBuffer]" === _3.call(l4) ? new Uint8Array(l4) : l4, r2 = c2.inflateSetDictionary(this.strm, o6)), r2 === m5.Z_BUF_ERROR && true === f3 && (r2 = m5.Z_OK, f3 = false), r2 !== m5.Z_STREAM_END && r2 !== m5.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h3.next_out && (0 !== h3.avail_out && r2 !== m5.Z_STREAM_END && (0 !== h3.avail_in || n4 !== m5.Z_FINISH && n4 !== m5.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i4 = p5.utf8border(h3.output, h3.next_out), s6 = h3.next_out - i4, a3 = p5.buf2string(h3.output, i4), h3.next_out = s6, h3.avail_out = u4 - s6, s6 && d3.arraySet(h3.output, h3.output, i4, s6, 0), this.onData(a3)) : this.onData(d3.shrinkBuf(h3.output, h3.next_out)))), 0 === h3.avail_in && 0 === h3.avail_out && (f3 = true);
          } while ((0 < h3.avail_in || 0 === h3.avail_out) && r2 !== m5.Z_STREAM_END);
          return r2 === m5.Z_STREAM_END && (n4 = m5.Z_FINISH), n4 === m5.Z_FINISH ? (r2 = c2.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m5.Z_OK) : n4 !== m5.Z_SYNC_FLUSH || (this.onEnd(m5.Z_OK), !(h3.avail_out = 0));
        }, a2.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a2.prototype.onEnd = function(e2) {
          e2 === m5.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d3.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a2, r.inflate = o5, r.inflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, o5(e2, t3);
        }, r.ungzip = o5;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t2, r) {
        "use strict";
        var n3 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r2 = t3.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n4 in r2)
                r2.hasOwnProperty(n4) && (e2[n4] = r2[n4]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t3) {
          return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : (e2.length = t3, e2);
        };
        var i3 = { arraySet: function(e2, t3, r2, n4, i4) {
          if (t3.subarray && e2.subarray)
            e2.set(t3.subarray(r2, r2 + n4), i4);
          else
            for (var s6 = 0; s6 < n4; s6++)
              e2[i4 + s6] = t3[r2 + s6];
        }, flattenChunks: function(e2) {
          var t3, r2, n4, i4, s6, a2;
          for (t3 = n4 = 0, r2 = e2.length; t3 < r2; t3++)
            n4 += e2[t3].length;
          for (a2 = new Uint8Array(n4), t3 = i4 = 0, r2 = e2.length; t3 < r2; t3++)
            s6 = e2[t3], a2.set(s6, i4), i4 += s6.length;
          return a2;
        } }, s5 = { arraySet: function(e2, t3, r2, n4, i4) {
          for (var s6 = 0; s6 < n4; s6++)
            e2[i4 + s6] = t3[r2 + s6];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i3)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s5));
        }, r.setTyped(n3);
      }, {}], 42: [function(e, t2, r) {
        "use strict";
        var h3 = e("./common"), i3 = true, s5 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i3 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s5 = false;
        }
        for (var u4 = new h3.Buf8(256), n3 = 0; n3 < 256; n3++)
          u4[n3] = 252 <= n3 ? 6 : 248 <= n3 ? 5 : 240 <= n3 ? 4 : 224 <= n3 ? 3 : 192 <= n3 ? 2 : 1;
        function l4(e2, t3) {
          if (t3 < 65537 && (e2.subarray && s5 || !e2.subarray && i3))
            return String.fromCharCode.apply(null, h3.shrinkBuf(e2, t3));
          for (var r2 = "", n4 = 0; n4 < t3; n4++)
            r2 += String.fromCharCode(e2[n4]);
          return r2;
        }
        u4[254] = u4[254] = 1, r.string2buf = function(e2) {
          var t3, r2, n4, i4, s6, a2 = e2.length, o5 = 0;
          for (i4 = 0; i4 < a2; i4++)
            55296 == (64512 & (r2 = e2.charCodeAt(i4))) && i4 + 1 < a2 && 56320 == (64512 & (n4 = e2.charCodeAt(i4 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n4 - 56320), i4++), o5 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t3 = new h3.Buf8(o5), i4 = s6 = 0; s6 < o5; i4++)
            55296 == (64512 & (r2 = e2.charCodeAt(i4))) && i4 + 1 < a2 && 56320 == (64512 & (n4 = e2.charCodeAt(i4 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n4 - 56320), i4++), r2 < 128 ? t3[s6++] = r2 : (r2 < 2048 ? t3[s6++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s6++] = 224 | r2 >>> 12 : (t3[s6++] = 240 | r2 >>> 18, t3[s6++] = 128 | r2 >>> 12 & 63), t3[s6++] = 128 | r2 >>> 6 & 63), t3[s6++] = 128 | 63 & r2);
          return t3;
        }, r.buf2binstring = function(e2) {
          return l4(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t3 = new h3.Buf8(e2.length), r2 = 0, n4 = t3.length; r2 < n4; r2++)
            t3[r2] = e2.charCodeAt(r2);
          return t3;
        }, r.buf2string = function(e2, t3) {
          var r2, n4, i4, s6, a2 = t3 || e2.length, o5 = new Array(2 * a2);
          for (r2 = n4 = 0; r2 < a2; )
            if ((i4 = e2[r2++]) < 128)
              o5[n4++] = i4;
            else if (4 < (s6 = u4[i4]))
              o5[n4++] = 65533, r2 += s6 - 1;
            else {
              for (i4 &= 2 === s6 ? 31 : 3 === s6 ? 15 : 7; 1 < s6 && r2 < a2; )
                i4 = i4 << 6 | 63 & e2[r2++], s6--;
              1 < s6 ? o5[n4++] = 65533 : i4 < 65536 ? o5[n4++] = i4 : (i4 -= 65536, o5[n4++] = 55296 | i4 >> 10 & 1023, o5[n4++] = 56320 | 1023 & i4);
            }
          return l4(o5, n4);
        }, r.utf8border = function(e2, t3) {
          var r2;
          for ((t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t3 : 0 === r2 ? t3 : r2 + u4[e2[r2]] > t3 ? r2 : t3;
        };
      }, { "./common": 41 }], 43: [function(e, t2, r) {
        "use strict";
        t2.exports = function(e2, t3, r2, n3) {
          for (var i3 = 65535 & e2 | 0, s5 = e2 >>> 16 & 65535 | 0, a2 = 0; 0 !== r2; ) {
            for (r2 -= a2 = 2e3 < r2 ? 2e3 : r2; s5 = s5 + (i3 = i3 + t3[n3++] | 0) | 0, --a2; )
              ;
            i3 %= 65521, s5 %= 65521;
          }
          return i3 | s5 << 16 | 0;
        };
      }, {}], 44: [function(e, t2, r) {
        "use strict";
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t2, r) {
        "use strict";
        var o5 = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n3 = 0; n3 < 8; n3++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3, r2, n3) {
          var i3 = o5, s5 = n3 + r2;
          e2 ^= -1;
          for (var a2 = n3; a2 < s5; a2++)
            e2 = e2 >>> 8 ^ i3[255 & (e2 ^ t3[a2])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t2, r) {
        "use strict";
        var h3, c2 = e("../utils/common"), u4 = e("./trees"), d3 = e("./adler32"), p5 = e("./crc32"), n3 = e("./messages"), l4 = 0, f3 = 4, m5 = 0, _3 = -2, g5 = -1, b4 = 4, i3 = 2, v4 = 8, y4 = 9, s5 = 286, a2 = 30, o5 = 19, w6 = 2 * s5 + 1, k5 = 15, x4 = 3, S4 = 258, z4 = S4 + x4 + 1, C6 = 42, E2 = 113, A4 = 1, I4 = 2, O5 = 3, B3 = 4;
        function R6(e2, t3) {
          return e2.msg = n3[t3], t3;
        }
        function T4(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D6(e2) {
          for (var t3 = e2.length; 0 <= --t3; )
            e2[t3] = 0;
        }
        function F5(e2) {
          var t3 = e2.state, r2 = t3.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c2.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out), e2.next_out += r2, t3.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t3.pending -= r2, 0 === t3.pending && (t3.pending_out = 0));
        }
        function N4(e2, t3) {
          u4._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, F5(e2.strm);
        }
        function U4(e2, t3) {
          e2.pending_buf[e2.pending++] = t3;
        }
        function P6(e2, t3) {
          e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
        }
        function L7(e2, t3) {
          var r2, n4, i4 = e2.max_chain_length, s6 = e2.strstart, a3 = e2.prev_length, o6 = e2.nice_match, h4 = e2.strstart > e2.w_size - z4 ? e2.strstart - (e2.w_size - z4) : 0, u5 = e2.window, l5 = e2.w_mask, f4 = e2.prev, c3 = e2.strstart + S4, d4 = u5[s6 + a3 - 1], p6 = u5[s6 + a3];
          e2.prev_length >= e2.good_match && (i4 >>= 2), o6 > e2.lookahead && (o6 = e2.lookahead);
          do {
            if (u5[(r2 = t3) + a3] === p6 && u5[r2 + a3 - 1] === d4 && u5[r2] === u5[s6] && u5[++r2] === u5[s6 + 1]) {
              s6 += 2, r2++;
              do {
              } while (u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && u5[++s6] === u5[++r2] && s6 < c3);
              if (n4 = S4 - (c3 - s6), s6 = c3 - S4, a3 < n4) {
                if (e2.match_start = t3, o6 <= (a3 = n4))
                  break;
                d4 = u5[s6 + a3 - 1], p6 = u5[s6 + a3];
              }
            }
          } while ((t3 = f4[t3 & l5]) > h4 && 0 != --i4);
          return a3 <= e2.lookahead ? a3 : e2.lookahead;
        }
        function j4(e2) {
          var t3, r2, n4, i4, s6, a3, o6, h4, u5, l5, f4 = e2.w_size;
          do {
            if (i4 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f4 + (f4 - z4)) {
              for (c2.arraySet(e2.window, e2.window, f4, f4, 0), e2.match_start -= f4, e2.strstart -= f4, e2.block_start -= f4, t3 = r2 = e2.hash_size; n4 = e2.head[--t3], e2.head[t3] = f4 <= n4 ? n4 - f4 : 0, --r2; )
                ;
              for (t3 = r2 = f4; n4 = e2.prev[--t3], e2.prev[t3] = f4 <= n4 ? n4 - f4 : 0, --r2; )
                ;
              i4 += f4;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a3 = e2.strm, o6 = e2.window, h4 = e2.strstart + e2.lookahead, u5 = i4, l5 = void 0, l5 = a3.avail_in, u5 < l5 && (l5 = u5), r2 = 0 === l5 ? 0 : (a3.avail_in -= l5, c2.arraySet(o6, a3.input, a3.next_in, l5, h4), 1 === a3.state.wrap ? a3.adler = d3(a3.adler, o6, l5, h4) : 2 === a3.state.wrap && (a3.adler = p5(a3.adler, o6, l5, h4)), a3.next_in += l5, a3.total_in += l5, l5), e2.lookahead += r2, e2.lookahead + e2.insert >= x4)
              for (s6 = e2.strstart - e2.insert, e2.ins_h = e2.window[s6], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s6 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s6 + x4 - 1]) & e2.hash_mask, e2.prev[s6 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s6, s6++, e2.insert--, !(e2.lookahead + e2.insert < x4)); )
                ;
          } while (e2.lookahead < z4 && 0 !== e2.strm.avail_in);
        }
        function Z4(e2, t3) {
          for (var r2, n4; ; ) {
            if (e2.lookahead < z4) {
              if (j4(e2), e2.lookahead < z4 && t3 === l4)
                return A4;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x4 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x4 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z4 && (e2.match_length = L7(e2, r2)), e2.match_length >= x4)
              if (n4 = u4._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x4), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x4) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x4 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n4 = u4._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n4 && (N4(e2, false), 0 === e2.strm.avail_out))
              return A4;
          }
          return e2.insert = e2.strstart < x4 - 1 ? e2.strstart : x4 - 1, t3 === f3 ? (N4(e2, true), 0 === e2.strm.avail_out ? O5 : B3) : e2.last_lit && (N4(e2, false), 0 === e2.strm.avail_out) ? A4 : I4;
        }
        function W5(e2, t3) {
          for (var r2, n4, i4; ; ) {
            if (e2.lookahead < z4) {
              if (j4(e2), e2.lookahead < z4 && t3 === l4)
                return A4;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x4 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x4 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x4 - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z4 && (e2.match_length = L7(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x4 && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x4 - 1)), e2.prev_length >= x4 && e2.match_length <= e2.prev_length) {
              for (i4 = e2.strstart + e2.lookahead - x4, n4 = u4._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x4), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i4 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x4 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x4 - 1, e2.strstart++, n4 && (N4(e2, false), 0 === e2.strm.avail_out))
                return A4;
            } else if (e2.match_available) {
              if ((n4 = u4._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N4(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A4;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n4 = u4._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x4 - 1 ? e2.strstart : x4 - 1, t3 === f3 ? (N4(e2, true), 0 === e2.strm.avail_out ? O5 : B3) : e2.last_lit && (N4(e2, false), 0 === e2.strm.avail_out) ? A4 : I4;
        }
        function M4(e2, t3, r2, n4, i4) {
          this.good_length = e2, this.max_lazy = t3, this.nice_length = r2, this.max_chain = n4, this.func = i4;
        }
        function H5() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v4, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w6), this.dyn_dtree = new c2.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o5 + 1)), D6(this.dyn_ltree), D6(this.dyn_dtree), D6(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k5 + 1), this.heap = new c2.Buf16(2 * s5 + 1), D6(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s5 + 1), D6(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G4(e2) {
          var t3;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i3, (t3 = e2.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C6 : E2, e2.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l4, u4._tr_init(t3), m5) : R6(e2, _3);
        }
        function K4(e2) {
          var t3 = G4(e2);
          return t3 === m5 && function(e3) {
            e3.window_size = 2 * e3.w_size, D6(e3.head), e3.max_lazy_match = h3[e3.level].max_lazy, e3.good_match = h3[e3.level].good_length, e3.nice_match = h3[e3.level].nice_length, e3.max_chain_length = h3[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x4 - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t3;
        }
        function Y4(e2, t3, r2, n4, i4, s6) {
          if (!e2)
            return _3;
          var a3 = 1;
          if (t3 === g5 && (t3 = 6), n4 < 0 ? (a3 = 0, n4 = -n4) : 15 < n4 && (a3 = 2, n4 -= 16), i4 < 1 || y4 < i4 || r2 !== v4 || n4 < 8 || 15 < n4 || t3 < 0 || 9 < t3 || s6 < 0 || b4 < s6)
            return R6(e2, _3);
          8 === n4 && (n4 = 9);
          var o6 = new H5();
          return (e2.state = o6).strm = e2, o6.wrap = a3, o6.gzhead = null, o6.w_bits = n4, o6.w_size = 1 << o6.w_bits, o6.w_mask = o6.w_size - 1, o6.hash_bits = i4 + 7, o6.hash_size = 1 << o6.hash_bits, o6.hash_mask = o6.hash_size - 1, o6.hash_shift = ~~((o6.hash_bits + x4 - 1) / x4), o6.window = new c2.Buf8(2 * o6.w_size), o6.head = new c2.Buf16(o6.hash_size), o6.prev = new c2.Buf16(o6.w_size), o6.lit_bufsize = 1 << i4 + 6, o6.pending_buf_size = 4 * o6.lit_bufsize, o6.pending_buf = new c2.Buf8(o6.pending_buf_size), o6.d_buf = 1 * o6.lit_bufsize, o6.l_buf = 3 * o6.lit_bufsize, o6.level = t3, o6.strategy = s6, o6.method = r2, K4(e2);
        }
        h3 = [new M4(0, 0, 0, 0, function(e2, t3) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j4(e2), 0 === e2.lookahead && t3 === l4)
                return A4;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n4 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n4) && (e2.lookahead = e2.strstart - n4, e2.strstart = n4, N4(e2, false), 0 === e2.strm.avail_out))
              return A4;
            if (e2.strstart - e2.block_start >= e2.w_size - z4 && (N4(e2, false), 0 === e2.strm.avail_out))
              return A4;
          }
          return e2.insert = 0, t3 === f3 ? (N4(e2, true), 0 === e2.strm.avail_out ? O5 : B3) : (e2.strstart > e2.block_start && (N4(e2, false), e2.strm.avail_out), A4);
        }), new M4(4, 4, 8, 4, Z4), new M4(4, 5, 16, 8, Z4), new M4(4, 6, 32, 32, Z4), new M4(4, 4, 16, 16, W5), new M4(8, 16, 32, 32, W5), new M4(8, 16, 128, 128, W5), new M4(8, 32, 128, 256, W5), new M4(32, 128, 258, 1024, W5), new M4(32, 258, 258, 4096, W5)], r.deflateInit = function(e2, t3) {
          return Y4(e2, t3, v4, 15, 8, 0);
        }, r.deflateInit2 = Y4, r.deflateReset = K4, r.deflateResetKeep = G4, r.deflateSetHeader = function(e2, t3) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _3 : (e2.state.gzhead = t3, m5) : _3;
        }, r.deflate = function(e2, t3) {
          var r2, n4, i4, s6;
          if (!e2 || !e2.state || 5 < t3 || t3 < 0)
            return e2 ? R6(e2, _3) : _3;
          if (n4 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n4.status && t3 !== f3)
            return R6(e2, 0 === e2.avail_out ? -5 : _3);
          if (n4.strm = e2, r2 = n4.last_flush, n4.last_flush = t3, n4.status === C6)
            if (2 === n4.wrap)
              e2.adler = 0, U4(n4, 31), U4(n4, 139), U4(n4, 8), n4.gzhead ? (U4(n4, (n4.gzhead.text ? 1 : 0) + (n4.gzhead.hcrc ? 2 : 0) + (n4.gzhead.extra ? 4 : 0) + (n4.gzhead.name ? 8 : 0) + (n4.gzhead.comment ? 16 : 0)), U4(n4, 255 & n4.gzhead.time), U4(n4, n4.gzhead.time >> 8 & 255), U4(n4, n4.gzhead.time >> 16 & 255), U4(n4, n4.gzhead.time >> 24 & 255), U4(n4, 9 === n4.level ? 2 : 2 <= n4.strategy || n4.level < 2 ? 4 : 0), U4(n4, 255 & n4.gzhead.os), n4.gzhead.extra && n4.gzhead.extra.length && (U4(n4, 255 & n4.gzhead.extra.length), U4(n4, n4.gzhead.extra.length >> 8 & 255)), n4.gzhead.hcrc && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending, 0)), n4.gzindex = 0, n4.status = 69) : (U4(n4, 0), U4(n4, 0), U4(n4, 0), U4(n4, 0), U4(n4, 0), U4(n4, 9 === n4.level ? 2 : 2 <= n4.strategy || n4.level < 2 ? 4 : 0), U4(n4, 3), n4.status = E2);
            else {
              var a3 = v4 + (n4.w_bits - 8 << 4) << 8;
              a3 |= (2 <= n4.strategy || n4.level < 2 ? 0 : n4.level < 6 ? 1 : 6 === n4.level ? 2 : 3) << 6, 0 !== n4.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n4.status = E2, P6(n4, a3), 0 !== n4.strstart && (P6(n4, e2.adler >>> 16), P6(n4, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n4.status)
            if (n4.gzhead.extra) {
              for (i4 = n4.pending; n4.gzindex < (65535 & n4.gzhead.extra.length) && (n4.pending !== n4.pending_buf_size || (n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), F5(e2), i4 = n4.pending, n4.pending !== n4.pending_buf_size)); )
                U4(n4, 255 & n4.gzhead.extra[n4.gzindex]), n4.gzindex++;
              n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), n4.gzindex === n4.gzhead.extra.length && (n4.gzindex = 0, n4.status = 73);
            } else
              n4.status = 73;
          if (73 === n4.status)
            if (n4.gzhead.name) {
              i4 = n4.pending;
              do {
                if (n4.pending === n4.pending_buf_size && (n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), F5(e2), i4 = n4.pending, n4.pending === n4.pending_buf_size)) {
                  s6 = 1;
                  break;
                }
                s6 = n4.gzindex < n4.gzhead.name.length ? 255 & n4.gzhead.name.charCodeAt(n4.gzindex++) : 0, U4(n4, s6);
              } while (0 !== s6);
              n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), 0 === s6 && (n4.gzindex = 0, n4.status = 91);
            } else
              n4.status = 91;
          if (91 === n4.status)
            if (n4.gzhead.comment) {
              i4 = n4.pending;
              do {
                if (n4.pending === n4.pending_buf_size && (n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), F5(e2), i4 = n4.pending, n4.pending === n4.pending_buf_size)) {
                  s6 = 1;
                  break;
                }
                s6 = n4.gzindex < n4.gzhead.comment.length ? 255 & n4.gzhead.comment.charCodeAt(n4.gzindex++) : 0, U4(n4, s6);
              } while (0 !== s6);
              n4.gzhead.hcrc && n4.pending > i4 && (e2.adler = p5(e2.adler, n4.pending_buf, n4.pending - i4, i4)), 0 === s6 && (n4.status = 103);
            } else
              n4.status = 103;
          if (103 === n4.status && (n4.gzhead.hcrc ? (n4.pending + 2 > n4.pending_buf_size && F5(e2), n4.pending + 2 <= n4.pending_buf_size && (U4(n4, 255 & e2.adler), U4(n4, e2.adler >> 8 & 255), e2.adler = 0, n4.status = E2)) : n4.status = E2), 0 !== n4.pending) {
            if (F5(e2), 0 === e2.avail_out)
              return n4.last_flush = -1, m5;
          } else if (0 === e2.avail_in && T4(t3) <= T4(r2) && t3 !== f3)
            return R6(e2, -5);
          if (666 === n4.status && 0 !== e2.avail_in)
            return R6(e2, -5);
          if (0 !== e2.avail_in || 0 !== n4.lookahead || t3 !== l4 && 666 !== n4.status) {
            var o6 = 2 === n4.strategy ? function(e3, t4) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j4(e3), 0 === e3.lookahead)) {
                  if (t4 === l4)
                    return A4;
                  break;
                }
                if (e3.match_length = 0, r3 = u4._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N4(e3, false), 0 === e3.strm.avail_out))
                  return A4;
              }
              return e3.insert = 0, t4 === f3 ? (N4(e3, true), 0 === e3.strm.avail_out ? O5 : B3) : e3.last_lit && (N4(e3, false), 0 === e3.strm.avail_out) ? A4 : I4;
            }(n4, t3) : 3 === n4.strategy ? function(e3, t4) {
              for (var r3, n5, i5, s7, a4 = e3.window; ; ) {
                if (e3.lookahead <= S4) {
                  if (j4(e3), e3.lookahead <= S4 && t4 === l4)
                    return A4;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x4 && 0 < e3.strstart && (n5 = a4[i5 = e3.strstart - 1]) === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5]) {
                  s7 = e3.strstart + S4;
                  do {
                  } while (n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && n5 === a4[++i5] && i5 < s7);
                  e3.match_length = S4 - (s7 - i5), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x4 ? (r3 = u4._tr_tally(e3, 1, e3.match_length - x4), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u4._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N4(e3, false), 0 === e3.strm.avail_out))
                  return A4;
              }
              return e3.insert = 0, t4 === f3 ? (N4(e3, true), 0 === e3.strm.avail_out ? O5 : B3) : e3.last_lit && (N4(e3, false), 0 === e3.strm.avail_out) ? A4 : I4;
            }(n4, t3) : h3[n4.level].func(n4, t3);
            if (o6 !== O5 && o6 !== B3 || (n4.status = 666), o6 === A4 || o6 === O5)
              return 0 === e2.avail_out && (n4.last_flush = -1), m5;
            if (o6 === I4 && (1 === t3 ? u4._tr_align(n4) : 5 !== t3 && (u4._tr_stored_block(n4, 0, 0, false), 3 === t3 && (D6(n4.head), 0 === n4.lookahead && (n4.strstart = 0, n4.block_start = 0, n4.insert = 0))), F5(e2), 0 === e2.avail_out))
              return n4.last_flush = -1, m5;
          }
          return t3 !== f3 ? m5 : n4.wrap <= 0 ? 1 : (2 === n4.wrap ? (U4(n4, 255 & e2.adler), U4(n4, e2.adler >> 8 & 255), U4(n4, e2.adler >> 16 & 255), U4(n4, e2.adler >> 24 & 255), U4(n4, 255 & e2.total_in), U4(n4, e2.total_in >> 8 & 255), U4(n4, e2.total_in >> 16 & 255), U4(n4, e2.total_in >> 24 & 255)) : (P6(n4, e2.adler >>> 16), P6(n4, 65535 & e2.adler)), F5(e2), 0 < n4.wrap && (n4.wrap = -n4.wrap), 0 !== n4.pending ? m5 : 1);
        }, r.deflateEnd = function(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state.status) !== C6 && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E2 && 666 !== t3 ? R6(e2, _3) : (e2.state = null, t3 === E2 ? R6(e2, -3) : m5) : _3;
        }, r.deflateSetDictionary = function(e2, t3) {
          var r2, n4, i4, s6, a3, o6, h4, u5, l5 = t3.length;
          if (!e2 || !e2.state)
            return _3;
          if (2 === (s6 = (r2 = e2.state).wrap) || 1 === s6 && r2.status !== C6 || r2.lookahead)
            return _3;
          for (1 === s6 && (e2.adler = d3(e2.adler, t3, l5, 0)), r2.wrap = 0, l5 >= r2.w_size && (0 === s6 && (D6(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u5 = new c2.Buf8(r2.w_size), c2.arraySet(u5, t3, l5 - r2.w_size, r2.w_size, 0), t3 = u5, l5 = r2.w_size), a3 = e2.avail_in, o6 = e2.next_in, h4 = e2.input, e2.avail_in = l5, e2.next_in = 0, e2.input = t3, j4(r2); r2.lookahead >= x4; ) {
            for (n4 = r2.strstart, i4 = r2.lookahead - (x4 - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n4 + x4 - 1]) & r2.hash_mask, r2.prev[n4 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n4, n4++, --i4; )
              ;
            r2.strstart = n4, r2.lookahead = x4 - 1, j4(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x4 - 1, r2.match_available = 0, e2.next_in = o6, e2.input = h4, e2.avail_in = a3, r2.wrap = s6, m5;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t2, r) {
        "use strict";
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t2, r) {
        "use strict";
        t2.exports = function(e2, t3) {
          var r2, n3, i3, s5, a2, o5, h3, u4, l4, f3, c2, d3, p5, m5, _3, g5, b4, v4, y4, w6, k5, x4, S4, z4, C6;
          r2 = e2.state, n3 = e2.next_in, z4 = e2.input, i3 = n3 + (e2.avail_in - 5), s5 = e2.next_out, C6 = e2.output, a2 = s5 - (t3 - e2.avail_out), o5 = s5 + (e2.avail_out - 257), h3 = r2.dmax, u4 = r2.wsize, l4 = r2.whave, f3 = r2.wnext, c2 = r2.window, d3 = r2.hold, p5 = r2.bits, m5 = r2.lencode, _3 = r2.distcode, g5 = (1 << r2.lenbits) - 1, b4 = (1 << r2.distbits) - 1;
          e:
            do {
              p5 < 15 && (d3 += z4[n3++] << p5, p5 += 8, d3 += z4[n3++] << p5, p5 += 8), v4 = m5[d3 & g5];
              t:
                for (; ; ) {
                  if (d3 >>>= y4 = v4 >>> 24, p5 -= y4, 0 === (y4 = v4 >>> 16 & 255))
                    C6[s5++] = 65535 & v4;
                  else {
                    if (!(16 & y4)) {
                      if (0 == (64 & y4)) {
                        v4 = m5[(65535 & v4) + (d3 & (1 << y4) - 1)];
                        continue t;
                      }
                      if (32 & y4) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w6 = 65535 & v4, (y4 &= 15) && (p5 < y4 && (d3 += z4[n3++] << p5, p5 += 8), w6 += d3 & (1 << y4) - 1, d3 >>>= y4, p5 -= y4), p5 < 15 && (d3 += z4[n3++] << p5, p5 += 8, d3 += z4[n3++] << p5, p5 += 8), v4 = _3[d3 & b4];
                    r:
                      for (; ; ) {
                        if (d3 >>>= y4 = v4 >>> 24, p5 -= y4, !(16 & (y4 = v4 >>> 16 & 255))) {
                          if (0 == (64 & y4)) {
                            v4 = _3[(65535 & v4) + (d3 & (1 << y4) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k5 = 65535 & v4, p5 < (y4 &= 15) && (d3 += z4[n3++] << p5, (p5 += 8) < y4 && (d3 += z4[n3++] << p5, p5 += 8)), h3 < (k5 += d3 & (1 << y4) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d3 >>>= y4, p5 -= y4, (y4 = s5 - a2) < k5) {
                          if (l4 < (y4 = k5 - y4) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S4 = c2, (x4 = 0) === f3) {
                            if (x4 += u4 - y4, y4 < w6) {
                              for (w6 -= y4; C6[s5++] = c2[x4++], --y4; )
                                ;
                              x4 = s5 - k5, S4 = C6;
                            }
                          } else if (f3 < y4) {
                            if (x4 += u4 + f3 - y4, (y4 -= f3) < w6) {
                              for (w6 -= y4; C6[s5++] = c2[x4++], --y4; )
                                ;
                              if (x4 = 0, f3 < w6) {
                                for (w6 -= y4 = f3; C6[s5++] = c2[x4++], --y4; )
                                  ;
                                x4 = s5 - k5, S4 = C6;
                              }
                            }
                          } else if (x4 += f3 - y4, y4 < w6) {
                            for (w6 -= y4; C6[s5++] = c2[x4++], --y4; )
                              ;
                            x4 = s5 - k5, S4 = C6;
                          }
                          for (; 2 < w6; )
                            C6[s5++] = S4[x4++], C6[s5++] = S4[x4++], C6[s5++] = S4[x4++], w6 -= 3;
                          w6 && (C6[s5++] = S4[x4++], 1 < w6 && (C6[s5++] = S4[x4++]));
                        } else {
                          for (x4 = s5 - k5; C6[s5++] = C6[x4++], C6[s5++] = C6[x4++], C6[s5++] = C6[x4++], 2 < (w6 -= 3); )
                            ;
                          w6 && (C6[s5++] = C6[x4++], 1 < w6 && (C6[s5++] = C6[x4++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n3 < i3 && s5 < o5);
          n3 -= w6 = p5 >> 3, d3 &= (1 << (p5 -= w6 << 3)) - 1, e2.next_in = n3, e2.next_out = s5, e2.avail_in = n3 < i3 ? i3 - n3 + 5 : 5 - (n3 - i3), e2.avail_out = s5 < o5 ? o5 - s5 + 257 : 257 - (s5 - o5), r2.hold = d3, r2.bits = p5;
        };
      }, {}], 49: [function(e, t2, r) {
        "use strict";
        var I4 = e("../utils/common"), O5 = e("./adler32"), B3 = e("./crc32"), R6 = e("./inffast"), T4 = e("./inftrees"), D6 = 1, F5 = 2, N4 = 0, U4 = -2, P6 = 1, n3 = 852, i3 = 592;
        function L7(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s5() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I4.Buf16(320), this.work = new I4.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a2(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state, e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = P6, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I4.Buf32(n3), t3.distcode = t3.distdyn = new I4.Buf32(i3), t3.sane = 1, t3.back = -1, N4) : U4;
        }
        function o5(e2) {
          var t3;
          return e2 && e2.state ? ((t3 = e2.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a2(e2)) : U4;
        }
        function h3(e2, t3) {
          var r2, n4;
          return e2 && e2.state ? (n4 = e2.state, t3 < 0 ? (r2 = 0, t3 = -t3) : (r2 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U4 : (null !== n4.window && n4.wbits !== t3 && (n4.window = null), n4.wrap = r2, n4.wbits = t3, o5(e2))) : U4;
        }
        function u4(e2, t3) {
          var r2, n4;
          return e2 ? (n4 = new s5(), (e2.state = n4).window = null, (r2 = h3(e2, t3)) !== N4 && (e2.state = null), r2) : U4;
        }
        var l4, f3, c2 = true;
        function j4(e2) {
          if (c2) {
            var t3;
            for (l4 = new I4.Buf32(512), f3 = new I4.Buf32(32), t3 = 0; t3 < 144; )
              e2.lens[t3++] = 8;
            for (; t3 < 256; )
              e2.lens[t3++] = 9;
            for (; t3 < 280; )
              e2.lens[t3++] = 7;
            for (; t3 < 288; )
              e2.lens[t3++] = 8;
            for (T4(D6, e2.lens, 0, 288, l4, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e2.lens[t3++] = 5;
            T4(F5, e2.lens, 0, 32, f3, 0, e2.work, { bits: 5 }), c2 = false;
          }
          e2.lencode = l4, e2.lenbits = 9, e2.distcode = f3, e2.distbits = 5;
        }
        function Z4(e2, t3, r2, n4) {
          var i4, s6 = e2.state;
          return null === s6.window && (s6.wsize = 1 << s6.wbits, s6.wnext = 0, s6.whave = 0, s6.window = new I4.Buf8(s6.wsize)), n4 >= s6.wsize ? (I4.arraySet(s6.window, t3, r2 - s6.wsize, s6.wsize, 0), s6.wnext = 0, s6.whave = s6.wsize) : (n4 < (i4 = s6.wsize - s6.wnext) && (i4 = n4), I4.arraySet(s6.window, t3, r2 - n4, i4, s6.wnext), (n4 -= i4) ? (I4.arraySet(s6.window, t3, r2 - n4, n4, 0), s6.wnext = n4, s6.whave = s6.wsize) : (s6.wnext += i4, s6.wnext === s6.wsize && (s6.wnext = 0), s6.whave < s6.wsize && (s6.whave += i4))), 0;
        }
        r.inflateReset = o5, r.inflateReset2 = h3, r.inflateResetKeep = a2, r.inflateInit = function(e2) {
          return u4(e2, 15);
        }, r.inflateInit2 = u4, r.inflate = function(e2, t3) {
          var r2, n4, i4, s6, a3, o6, h4, u5, l5, f4, c3, d3, p5, m5, _3, g5, b4, v4, y4, w6, k5, x4, S4, z4, C6 = 0, E2 = new I4.Buf8(4), A4 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U4;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a3 = e2.next_out, i4 = e2.output, h4 = e2.avail_out, s6 = e2.next_in, n4 = e2.input, o6 = e2.avail_in, u5 = r2.hold, l5 = r2.bits, f4 = o6, c3 = h4, x4 = N4;
          e:
            for (; ; )
              switch (r2.mode) {
                case P6:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l5 < 16; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u5) {
                    E2[r2.check = 0] = 255 & u5, E2[1] = u5 >>> 8 & 255, r2.check = B3(r2.check, E2, 2, 0), l5 = u5 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u5) << 8) + (u5 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u5)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l5 -= 4, k5 = 8 + (15 & (u5 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k5;
                  else if (k5 > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k5, e2.adler = r2.check = 1, r2.mode = 512 & u5 ? 10 : 12, l5 = u5 = 0;
                  break;
                case 2:
                  for (; l5 < 16; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if (r2.flags = u5, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u5 >> 8 & 1), 512 & r2.flags && (E2[0] = 255 & u5, E2[1] = u5 >>> 8 & 255, r2.check = B3(r2.check, E2, 2, 0)), l5 = u5 = 0, r2.mode = 3;
                case 3:
                  for (; l5 < 32; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  r2.head && (r2.head.time = u5), 512 & r2.flags && (E2[0] = 255 & u5, E2[1] = u5 >>> 8 & 255, E2[2] = u5 >>> 16 & 255, E2[3] = u5 >>> 24 & 255, r2.check = B3(r2.check, E2, 4, 0)), l5 = u5 = 0, r2.mode = 4;
                case 4:
                  for (; l5 < 16; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u5, r2.head.os = u5 >> 8), 512 & r2.flags && (E2[0] = 255 & u5, E2[1] = u5 >>> 8 & 255, r2.check = B3(r2.check, E2, 2, 0)), l5 = u5 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l5 < 16; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    r2.length = u5, r2.head && (r2.head.extra_len = u5), 512 & r2.flags && (E2[0] = 255 & u5, E2[1] = u5 >>> 8 & 255, r2.check = B3(r2.check, E2, 2, 0)), l5 = u5 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o6 < (d3 = r2.length) && (d3 = o6), d3 && (r2.head && (k5 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I4.arraySet(r2.head.extra, n4, s6, d3, k5)), 512 & r2.flags && (r2.check = B3(r2.check, n4, d3, s6)), o6 -= d3, s6 += d3, r2.length -= d3), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o6)
                      break e;
                    for (d3 = 0; k5 = n4[s6 + d3++], r2.head && k5 && r2.length < 65536 && (r2.head.name += String.fromCharCode(k5)), k5 && d3 < o6; )
                      ;
                    if (512 & r2.flags && (r2.check = B3(r2.check, n4, d3, s6)), o6 -= d3, s6 += d3, k5)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o6)
                      break e;
                    for (d3 = 0; k5 = n4[s6 + d3++], r2.head && k5 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k5)), k5 && d3 < o6; )
                      ;
                    if (512 & r2.flags && (r2.check = B3(r2.check, n4, d3, s6)), o6 -= d3, s6 += d3, k5)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l5 < 16; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    if (u5 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l5 = u5 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l5 < 32; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  e2.adler = r2.check = L7(u5), l5 = u5 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a3, e2.avail_out = h4, e2.next_in = s6, e2.avail_in = o6, r2.hold = u5, r2.bits = l5, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (r2.last) {
                    u5 >>>= 7 & l5, l5 -= 7 & l5, r2.mode = 27;
                    break;
                  }
                  for (; l5 < 3; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  switch (r2.last = 1 & u5, l5 -= 1, 3 & (u5 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j4(r2), r2.mode = 20, 6 !== t3)
                        break;
                      u5 >>>= 2, l5 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u5 >>>= 2, l5 -= 2;
                  break;
                case 14:
                  for (u5 >>>= 7 & l5, l5 -= 7 & l5; l5 < 32; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if ((65535 & u5) != (u5 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u5, l5 = u5 = 0, r2.mode = 15, 6 === t3)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d3 = r2.length) {
                    if (o6 < d3 && (d3 = o6), h4 < d3 && (d3 = h4), 0 === d3)
                      break e;
                    I4.arraySet(i4, n4, s6, d3, a3), o6 -= d3, s6 += d3, h4 -= d3, a3 += d3, r2.length -= d3;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l5 < 14; ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u5), u5 >>>= 5, l5 -= 5, r2.ndist = 1 + (31 & u5), u5 >>>= 5, l5 -= 5, r2.ncode = 4 + (15 & u5), u5 >>>= 4, l5 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l5 < 3; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    r2.lens[A4[r2.have++]] = 7 & u5, u5 >>>= 3, l5 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A4[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S4 = { bits: r2.lenbits }, x4 = T4(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S4), r2.lenbits = S4.bits, x4) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g5 = (C6 = r2.lencode[u5 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b4 = 65535 & C6, !((_3 = C6 >>> 24) <= l5); ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    if (b4 < 16)
                      u5 >>>= _3, l5 -= _3, r2.lens[r2.have++] = b4;
                    else {
                      if (16 === b4) {
                        for (z4 = _3 + 2; l5 < z4; ) {
                          if (0 === o6)
                            break e;
                          o6--, u5 += n4[s6++] << l5, l5 += 8;
                        }
                        if (u5 >>>= _3, l5 -= _3, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k5 = r2.lens[r2.have - 1], d3 = 3 + (3 & u5), u5 >>>= 2, l5 -= 2;
                      } else if (17 === b4) {
                        for (z4 = _3 + 3; l5 < z4; ) {
                          if (0 === o6)
                            break e;
                          o6--, u5 += n4[s6++] << l5, l5 += 8;
                        }
                        l5 -= _3, k5 = 0, d3 = 3 + (7 & (u5 >>>= _3)), u5 >>>= 3, l5 -= 3;
                      } else {
                        for (z4 = _3 + 7; l5 < z4; ) {
                          if (0 === o6)
                            break e;
                          o6--, u5 += n4[s6++] << l5, l5 += 8;
                        }
                        l5 -= _3, k5 = 0, d3 = 11 + (127 & (u5 >>>= _3)), u5 >>>= 7, l5 -= 7;
                      }
                      if (r2.have + d3 > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d3--; )
                        r2.lens[r2.have++] = k5;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S4 = { bits: r2.lenbits }, x4 = T4(D6, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S4), r2.lenbits = S4.bits, x4) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S4 = { bits: r2.distbits }, x4 = T4(F5, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S4), r2.distbits = S4.bits, x4) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t3)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o6 && 258 <= h4) {
                    e2.next_out = a3, e2.avail_out = h4, e2.next_in = s6, e2.avail_in = o6, r2.hold = u5, r2.bits = l5, R6(e2, c3), a3 = e2.next_out, i4 = e2.output, h4 = e2.avail_out, s6 = e2.next_in, n4 = e2.input, o6 = e2.avail_in, u5 = r2.hold, l5 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g5 = (C6 = r2.lencode[u5 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b4 = 65535 & C6, !((_3 = C6 >>> 24) <= l5); ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if (g5 && 0 == (240 & g5)) {
                    for (v4 = _3, y4 = g5, w6 = b4; g5 = (C6 = r2.lencode[w6 + ((u5 & (1 << v4 + y4) - 1) >> v4)]) >>> 16 & 255, b4 = 65535 & C6, !(v4 + (_3 = C6 >>> 24) <= l5); ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    u5 >>>= v4, l5 -= v4, r2.back += v4;
                  }
                  if (u5 >>>= _3, l5 -= _3, r2.back += _3, r2.length = b4, 0 === g5) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g5) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g5) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g5, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z4 = r2.extra; l5 < z4; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    r2.length += u5 & (1 << r2.extra) - 1, u5 >>>= r2.extra, l5 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g5 = (C6 = r2.distcode[u5 & (1 << r2.distbits) - 1]) >>> 16 & 255, b4 = 65535 & C6, !((_3 = C6 >>> 24) <= l5); ) {
                    if (0 === o6)
                      break e;
                    o6--, u5 += n4[s6++] << l5, l5 += 8;
                  }
                  if (0 == (240 & g5)) {
                    for (v4 = _3, y4 = g5, w6 = b4; g5 = (C6 = r2.distcode[w6 + ((u5 & (1 << v4 + y4) - 1) >> v4)]) >>> 16 & 255, b4 = 65535 & C6, !(v4 + (_3 = C6 >>> 24) <= l5); ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    u5 >>>= v4, l5 -= v4, r2.back += v4;
                  }
                  if (u5 >>>= _3, l5 -= _3, r2.back += _3, 64 & g5) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b4, r2.extra = 15 & g5, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z4 = r2.extra; l5 < z4; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    r2.offset += u5 & (1 << r2.extra) - 1, u5 >>>= r2.extra, l5 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h4)
                    break e;
                  if (d3 = c3 - h4, r2.offset > d3) {
                    if ((d3 = r2.offset - d3) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p5 = d3 > r2.wnext ? (d3 -= r2.wnext, r2.wsize - d3) : r2.wnext - d3, d3 > r2.length && (d3 = r2.length), m5 = r2.window;
                  } else
                    m5 = i4, p5 = a3 - r2.offset, d3 = r2.length;
                  for (h4 < d3 && (d3 = h4), h4 -= d3, r2.length -= d3; i4[a3++] = m5[p5++], --d3; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h4)
                    break e;
                  i4[a3++] = r2.length, h4--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l5 < 32; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 |= n4[s6++] << l5, l5 += 8;
                    }
                    if (c3 -= h4, e2.total_out += c3, r2.total += c3, c3 && (e2.adler = r2.check = r2.flags ? B3(r2.check, i4, c3, a3 - c3) : O5(r2.check, i4, c3, a3 - c3)), c3 = h4, (r2.flags ? u5 : L7(u5)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l5 = u5 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l5 < 32; ) {
                      if (0 === o6)
                        break e;
                      o6--, u5 += n4[s6++] << l5, l5 += 8;
                    }
                    if (u5 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l5 = u5 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x4 = 1;
                  break e;
                case 30:
                  x4 = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U4;
              }
          return e2.next_out = a3, e2.avail_out = h4, e2.next_in = s6, e2.avail_in = o6, r2.hold = u5, r2.bits = l5, (r2.wsize || c3 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t3)) && Z4(e2, e2.output, e2.next_out, c3 - e2.avail_out) ? (r2.mode = 31, -4) : (f4 -= e2.avail_in, c3 -= e2.avail_out, e2.total_in += f4, e2.total_out += c3, r2.total += c3, r2.wrap && c3 && (e2.adler = r2.check = r2.flags ? B3(r2.check, i4, c3, e2.next_out - c3) : O5(r2.check, i4, c3, e2.next_out - c3)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f4 && 0 === c3 || 4 === t3) && x4 === N4 && (x4 = -5), x4);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U4;
          var t3 = e2.state;
          return t3.window && (t3.window = null), e2.state = null, N4;
        }, r.inflateGetHeader = function(e2, t3) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U4 : ((r2.head = t3).done = false, N4) : U4;
        }, r.inflateSetDictionary = function(e2, t3) {
          var r2, n4 = t3.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U4 : 11 === r2.mode && O5(1, t3, n4, 0) !== r2.check ? -3 : Z4(e2, t3, n4, n4) ? (r2.mode = 31, -4) : (r2.havedict = 1, N4) : U4;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t2, r) {
        "use strict";
        var D6 = e("../utils/common"), F5 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N4 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U4 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P6 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e2, t3, r2, n3, i3, s5, a2, o5) {
          var h3, u4, l4, f3, c2, d3, p5, m5, _3, g5 = o5.bits, b4 = 0, v4 = 0, y4 = 0, w6 = 0, k5 = 0, x4 = 0, S4 = 0, z4 = 0, C6 = 0, E2 = 0, A4 = null, I4 = 0, O5 = new D6.Buf16(16), B3 = new D6.Buf16(16), R6 = null, T4 = 0;
          for (b4 = 0; b4 <= 15; b4++)
            O5[b4] = 0;
          for (v4 = 0; v4 < n3; v4++)
            O5[t3[r2 + v4]]++;
          for (k5 = g5, w6 = 15; 1 <= w6 && 0 === O5[w6]; w6--)
            ;
          if (w6 < k5 && (k5 = w6), 0 === w6)
            return i3[s5++] = 20971520, i3[s5++] = 20971520, o5.bits = 1, 0;
          for (y4 = 1; y4 < w6 && 0 === O5[y4]; y4++)
            ;
          for (k5 < y4 && (k5 = y4), b4 = z4 = 1; b4 <= 15; b4++)
            if (z4 <<= 1, (z4 -= O5[b4]) < 0)
              return -1;
          if (0 < z4 && (0 === e2 || 1 !== w6))
            return -1;
          for (B3[1] = 0, b4 = 1; b4 < 15; b4++)
            B3[b4 + 1] = B3[b4] + O5[b4];
          for (v4 = 0; v4 < n3; v4++)
            0 !== t3[r2 + v4] && (a2[B3[t3[r2 + v4]]++] = v4);
          if (d3 = 0 === e2 ? (A4 = R6 = a2, 19) : 1 === e2 ? (A4 = F5, I4 -= 257, R6 = N4, T4 -= 257, 256) : (A4 = U4, R6 = P6, -1), b4 = y4, c2 = s5, S4 = v4 = E2 = 0, l4 = -1, f3 = (C6 = 1 << (x4 = k5)) - 1, 1 === e2 && 852 < C6 || 2 === e2 && 592 < C6)
            return 1;
          for (; ; ) {
            for (p5 = b4 - S4, _3 = a2[v4] < d3 ? (m5 = 0, a2[v4]) : a2[v4] > d3 ? (m5 = R6[T4 + a2[v4]], A4[I4 + a2[v4]]) : (m5 = 96, 0), h3 = 1 << b4 - S4, y4 = u4 = 1 << x4; i3[c2 + (E2 >> S4) + (u4 -= h3)] = p5 << 24 | m5 << 16 | _3 | 0, 0 !== u4; )
              ;
            for (h3 = 1 << b4 - 1; E2 & h3; )
              h3 >>= 1;
            if (0 !== h3 ? (E2 &= h3 - 1, E2 += h3) : E2 = 0, v4++, 0 == --O5[b4]) {
              if (b4 === w6)
                break;
              b4 = t3[r2 + a2[v4]];
            }
            if (k5 < b4 && (E2 & f3) !== l4) {
              for (0 === S4 && (S4 = k5), c2 += y4, z4 = 1 << (x4 = b4 - S4); x4 + S4 < w6 && !((z4 -= O5[x4 + S4]) <= 0); )
                x4++, z4 <<= 1;
              if (C6 += 1 << x4, 1 === e2 && 852 < C6 || 2 === e2 && 592 < C6)
                return 1;
              i3[l4 = E2 & f3] = k5 << 24 | x4 << 16 | c2 - s5 | 0;
            }
          }
          return 0 !== E2 && (i3[c2 + E2] = b4 - S4 << 24 | 64 << 16 | 0), o5.bits = k5, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t2, r) {
        "use strict";
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t2, r) {
        "use strict";
        var i3 = e("../utils/common"), o5 = 0, h3 = 1;
        function n3(e2) {
          for (var t3 = e2.length; 0 <= --t3; )
            e2[t3] = 0;
        }
        var s5 = 0, a2 = 29, u4 = 256, l4 = u4 + 1 + a2, f3 = 30, c2 = 19, _3 = 2 * l4 + 1, g5 = 15, d3 = 16, p5 = 7, m5 = 256, b4 = 16, v4 = 17, y4 = 18, w6 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k5 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S4 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z4 = new Array(2 * (l4 + 2));
        n3(z4);
        var C6 = new Array(2 * f3);
        n3(C6);
        var E2 = new Array(512);
        n3(E2);
        var A4 = new Array(256);
        n3(A4);
        var I4 = new Array(a2);
        n3(I4);
        var O5, B3, R6, T4 = new Array(f3);
        function D6(e2, t3, r2, n4, i4) {
          this.static_tree = e2, this.extra_bits = t3, this.extra_base = r2, this.elems = n4, this.max_length = i4, this.has_stree = e2 && e2.length;
        }
        function F5(e2, t3) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
        }
        function N4(e2) {
          return e2 < 256 ? E2[e2] : E2[256 + (e2 >>> 7)];
        }
        function U4(e2, t3) {
          e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
        }
        function P6(e2, t3, r2) {
          e2.bi_valid > d3 - r2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, U4(e2, e2.bi_buf), e2.bi_buf = t3 >> d3 - e2.bi_valid, e2.bi_valid += r2 - d3) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L7(e2, t3, r2) {
          P6(e2, r2[2 * t3], r2[2 * t3 + 1]);
        }
        function j4(e2, t3) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t3; )
            ;
          return r2 >>> 1;
        }
        function Z4(e2, t3, r2) {
          var n4, i4, s6 = new Array(g5 + 1), a3 = 0;
          for (n4 = 1; n4 <= g5; n4++)
            s6[n4] = a3 = a3 + r2[n4 - 1] << 1;
          for (i4 = 0; i4 <= t3; i4++) {
            var o6 = e2[2 * i4 + 1];
            0 !== o6 && (e2[2 * i4] = j4(s6[o6]++, o6));
          }
        }
        function W5(e2) {
          var t3;
          for (t3 = 0; t3 < l4; t3++)
            e2.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f3; t3++)
            e2.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c2; t3++)
            e2.bl_tree[2 * t3] = 0;
          e2.dyn_ltree[2 * m5] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M4(e2) {
          8 < e2.bi_valid ? U4(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H5(e2, t3, r2, n4) {
          var i4 = 2 * t3, s6 = 2 * r2;
          return e2[i4] < e2[s6] || e2[i4] === e2[s6] && n4[t3] <= n4[r2];
        }
        function G4(e2, t3, r2) {
          for (var n4 = e2.heap[r2], i4 = r2 << 1; i4 <= e2.heap_len && (i4 < e2.heap_len && H5(t3, e2.heap[i4 + 1], e2.heap[i4], e2.depth) && i4++, !H5(t3, n4, e2.heap[i4], e2.depth)); )
            e2.heap[r2] = e2.heap[i4], r2 = i4, i4 <<= 1;
          e2.heap[r2] = n4;
        }
        function K4(e2, t3, r2) {
          var n4, i4, s6, a3, o6 = 0;
          if (0 !== e2.last_lit)
            for (; n4 = e2.pending_buf[e2.d_buf + 2 * o6] << 8 | e2.pending_buf[e2.d_buf + 2 * o6 + 1], i4 = e2.pending_buf[e2.l_buf + o6], o6++, 0 === n4 ? L7(e2, i4, t3) : (L7(e2, (s6 = A4[i4]) + u4 + 1, t3), 0 !== (a3 = w6[s6]) && P6(e2, i4 -= I4[s6], a3), L7(e2, s6 = N4(--n4), r2), 0 !== (a3 = k5[s6]) && P6(e2, n4 -= T4[s6], a3)), o6 < e2.last_lit; )
              ;
          L7(e2, m5, t3);
        }
        function Y4(e2, t3) {
          var r2, n4, i4, s6 = t3.dyn_tree, a3 = t3.stat_desc.static_tree, o6 = t3.stat_desc.has_stree, h4 = t3.stat_desc.elems, u5 = -1;
          for (e2.heap_len = 0, e2.heap_max = _3, r2 = 0; r2 < h4; r2++)
            0 !== s6[2 * r2] ? (e2.heap[++e2.heap_len] = u5 = r2, e2.depth[r2] = 0) : s6[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s6[2 * (i4 = e2.heap[++e2.heap_len] = u5 < 2 ? ++u5 : 0)] = 1, e2.depth[i4] = 0, e2.opt_len--, o6 && (e2.static_len -= a3[2 * i4 + 1]);
          for (t3.max_code = u5, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G4(e2, s6, r2);
          for (i4 = h4; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G4(e2, s6, 1), n4 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n4, s6[2 * i4] = s6[2 * r2] + s6[2 * n4], e2.depth[i4] = (e2.depth[r2] >= e2.depth[n4] ? e2.depth[r2] : e2.depth[n4]) + 1, s6[2 * r2 + 1] = s6[2 * n4 + 1] = i4, e2.heap[1] = i4++, G4(e2, s6, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t4) {
            var r3, n5, i5, s7, a4, o7, h5 = t4.dyn_tree, u6 = t4.max_code, l5 = t4.stat_desc.static_tree, f4 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d4 = t4.stat_desc.extra_base, p6 = t4.stat_desc.max_length, m6 = 0;
            for (s7 = 0; s7 <= g5; s7++)
              e3.bl_count[s7] = 0;
            for (h5[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _3; r3++)
              p6 < (s7 = h5[2 * h5[2 * (n5 = e3.heap[r3]) + 1] + 1] + 1) && (s7 = p6, m6++), h5[2 * n5 + 1] = s7, u6 < n5 || (e3.bl_count[s7]++, a4 = 0, d4 <= n5 && (a4 = c3[n5 - d4]), o7 = h5[2 * n5], e3.opt_len += o7 * (s7 + a4), f4 && (e3.static_len += o7 * (l5[2 * n5 + 1] + a4)));
            if (0 !== m6) {
              do {
                for (s7 = p6 - 1; 0 === e3.bl_count[s7]; )
                  s7--;
                e3.bl_count[s7]--, e3.bl_count[s7 + 1] += 2, e3.bl_count[p6]--, m6 -= 2;
              } while (0 < m6);
              for (s7 = p6; 0 !== s7; s7--)
                for (n5 = e3.bl_count[s7]; 0 !== n5; )
                  u6 < (i5 = e3.heap[--r3]) || (h5[2 * i5 + 1] !== s7 && (e3.opt_len += (s7 - h5[2 * i5 + 1]) * h5[2 * i5], h5[2 * i5 + 1] = s7), n5--);
            }
          }(e2, t3), Z4(s6, u5, e2.bl_count);
        }
        function X4(e2, t3, r2) {
          var n4, i4, s6 = -1, a3 = t3[1], o6 = 0, h4 = 7, u5 = 4;
          for (0 === a3 && (h4 = 138, u5 = 3), t3[2 * (r2 + 1) + 1] = 65535, n4 = 0; n4 <= r2; n4++)
            i4 = a3, a3 = t3[2 * (n4 + 1) + 1], ++o6 < h4 && i4 === a3 || (o6 < u5 ? e2.bl_tree[2 * i4] += o6 : 0 !== i4 ? (i4 !== s6 && e2.bl_tree[2 * i4]++, e2.bl_tree[2 * b4]++) : o6 <= 10 ? e2.bl_tree[2 * v4]++ : e2.bl_tree[2 * y4]++, s6 = i4, u5 = (o6 = 0) === a3 ? (h4 = 138, 3) : i4 === a3 ? (h4 = 6, 3) : (h4 = 7, 4));
        }
        function V3(e2, t3, r2) {
          var n4, i4, s6 = -1, a3 = t3[1], o6 = 0, h4 = 7, u5 = 4;
          for (0 === a3 && (h4 = 138, u5 = 3), n4 = 0; n4 <= r2; n4++)
            if (i4 = a3, a3 = t3[2 * (n4 + 1) + 1], !(++o6 < h4 && i4 === a3)) {
              if (o6 < u5)
                for (; L7(e2, i4, e2.bl_tree), 0 != --o6; )
                  ;
              else
                0 !== i4 ? (i4 !== s6 && (L7(e2, i4, e2.bl_tree), o6--), L7(e2, b4, e2.bl_tree), P6(e2, o6 - 3, 2)) : o6 <= 10 ? (L7(e2, v4, e2.bl_tree), P6(e2, o6 - 3, 3)) : (L7(e2, y4, e2.bl_tree), P6(e2, o6 - 11, 7));
              s6 = i4, u5 = (o6 = 0) === a3 ? (h4 = 138, 3) : i4 === a3 ? (h4 = 6, 3) : (h4 = 7, 4);
            }
        }
        n3(T4);
        var q4 = false;
        function J3(e2, t3, r2, n4) {
          P6(e2, (s5 << 1) + (n4 ? 1 : 0), 3), function(e3, t4, r3, n5) {
            M4(e3), n5 && (U4(e3, r3), U4(e3, ~r3)), i3.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending), e3.pending += r3;
          }(e2, t3, r2, true);
        }
        r._tr_init = function(e2) {
          q4 || (function() {
            var e3, t3, r2, n4, i4, s6 = new Array(g5 + 1);
            for (n4 = r2 = 0; n4 < a2 - 1; n4++)
              for (I4[n4] = r2, e3 = 0; e3 < 1 << w6[n4]; e3++)
                A4[r2++] = n4;
            for (A4[r2 - 1] = n4, n4 = i4 = 0; n4 < 16; n4++)
              for (T4[n4] = i4, e3 = 0; e3 < 1 << k5[n4]; e3++)
                E2[i4++] = n4;
            for (i4 >>= 7; n4 < f3; n4++)
              for (T4[n4] = i4 << 7, e3 = 0; e3 < 1 << k5[n4] - 7; e3++)
                E2[256 + i4++] = n4;
            for (t3 = 0; t3 <= g5; t3++)
              s6[t3] = 0;
            for (e3 = 0; e3 <= 143; )
              z4[2 * e3 + 1] = 8, e3++, s6[8]++;
            for (; e3 <= 255; )
              z4[2 * e3 + 1] = 9, e3++, s6[9]++;
            for (; e3 <= 279; )
              z4[2 * e3 + 1] = 7, e3++, s6[7]++;
            for (; e3 <= 287; )
              z4[2 * e3 + 1] = 8, e3++, s6[8]++;
            for (Z4(z4, l4 + 1, s6), e3 = 0; e3 < f3; e3++)
              C6[2 * e3 + 1] = 5, C6[2 * e3] = j4(e3, 5);
            O5 = new D6(z4, w6, u4 + 1, l4, g5), B3 = new D6(C6, k5, 0, f3, g5), R6 = new D6(new Array(0), x4, 0, c2, p5);
          }(), q4 = true), e2.l_desc = new F5(e2.dyn_ltree, O5), e2.d_desc = new F5(e2.dyn_dtree, B3), e2.bl_desc = new F5(e2.bl_tree, R6), e2.bi_buf = 0, e2.bi_valid = 0, W5(e2);
        }, r._tr_stored_block = J3, r._tr_flush_block = function(e2, t3, r2, n4) {
          var i4, s6, a3 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t4, r3 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t4])
                return o5;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h3;
            for (t4 = 32; t4 < u4; t4++)
              if (0 !== e3.dyn_ltree[2 * t4])
                return h3;
            return o5;
          }(e2)), Y4(e2, e2.l_desc), Y4(e2, e2.d_desc), a3 = function(e3) {
            var t4;
            for (X4(e3, e3.dyn_ltree, e3.l_desc.max_code), X4(e3, e3.dyn_dtree, e3.d_desc.max_code), Y4(e3, e3.bl_desc), t4 = c2 - 1; 3 <= t4 && 0 === e3.bl_tree[2 * S4[t4] + 1]; t4--)
              ;
            return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e2), i4 = e2.opt_len + 3 + 7 >>> 3, (s6 = e2.static_len + 3 + 7 >>> 3) <= i4 && (i4 = s6)) : i4 = s6 = r2 + 5, r2 + 4 <= i4 && -1 !== t3 ? J3(e2, t3, r2, n4) : 4 === e2.strategy || s6 === i4 ? (P6(e2, 2 + (n4 ? 1 : 0), 3), K4(e2, z4, C6)) : (P6(e2, 4 + (n4 ? 1 : 0), 3), function(e3, t4, r3, n5) {
            var i5;
            for (P6(e3, t4 - 257, 5), P6(e3, r3 - 1, 5), P6(e3, n5 - 4, 4), i5 = 0; i5 < n5; i5++)
              P6(e3, e3.bl_tree[2 * S4[i5] + 1], 3);
            V3(e3, e3.dyn_ltree, t4 - 1), V3(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a3 + 1), K4(e2, e2.dyn_ltree, e2.dyn_dtree)), W5(e2), n4 && M4(e2);
        }, r._tr_tally = function(e2, t3, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t3 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t3 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (A4[r2] + u4 + 1)]++, e2.dyn_dtree[2 * N4(t3)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P6(e2, 2, 3), L7(e2, m5, z4), function(e3) {
            16 === e3.bi_valid ? (U4(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t2, r) {
        "use strict";
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t2, r) {
        (function(e2) {
          !function(r2, n3) {
            "use strict";
            if (!r2.setImmediate) {
              var i3, s5, t3, a2, o5 = 1, h3 = {}, u4 = false, l4 = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i3 = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c2(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t4 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t4, e4;
                }
              }() ? (a2 = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d3, false) : r2.attachEvent("onmessage", d3), function(e4) {
                r2.postMessage(a2 + e4, "*");
              }) : r2.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e4) {
                c2(e4.data);
              }, function(e4) {
                t3.port2.postMessage(e4);
              }) : l4 && "onreadystatechange" in l4.createElement("script") ? (s5 = l4.documentElement, function(e4) {
                var t4 = l4.createElement("script");
                t4.onreadystatechange = function() {
                  c2(e4), t4.onreadystatechange = null, s5.removeChild(t4), t4 = null;
                }, s5.appendChild(t4);
              }) : function(e4) {
                setTimeout(c2, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++)
                  t4[r3] = arguments[r3 + 1];
                var n4 = { callback: e4, args: t4 };
                return h3[o5] = n4, i3(o5), o5++;
              }, e3.clearImmediate = f3;
            }
            function f3(e4) {
              delete h3[e4];
            }
            function c2(e4) {
              if (u4)
                setTimeout(c2, 0, e4);
              else {
                var t4 = h3[e4];
                if (t4) {
                  u4 = true;
                  try {
                    !function(e5) {
                      var t5 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r3[0]);
                          break;
                        case 2:
                          t5(r3[0], r3[1]);
                          break;
                        case 3:
                          t5(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t5.apply(n3, r3);
                      }
                    }(t4);
                  } finally {
                    f3(e4), u4 = false;
                  }
                }
              }
            }
            function d3(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a2) && c2(+e4.data.slice(a2.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// src/components/FSRSWeightModal.ts
var FSRSWeightModal_exports = {};
__export(FSRSWeightModal_exports, {
  FSRSWeightModal: () => FSRSWeightModal
});
var import_obsidian40, FSRSWeightModal;
var init_FSRSWeightModal = __esm({
  "src/components/FSRSWeightModal.ts"() {
    import_obsidian40 = require("obsidian");
    init_FSRSTypes();
    init_i18n();
    FSRSWeightModal = class extends import_obsidian40.Modal {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
        const cur = plugin.settings.fsrsParams.w;
        this.weights = cur && cur.length === 17 ? [...cur] : [...DEFAULT_FSRS_PARAMETERS.w];
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("div", { text: t("FSRS 17 weights adjustment") });
        contentEl.createEl("p", { text: t("each item corresponds to w0-w16 in the paper. click save to take effect immediately.") });
        const table = contentEl.createEl("table");
        table.style.width = "100%";
        table.style.borderSpacing = "8px 6px";
        const cols = 3;
        for (let i3 = 0; i3 < this.weights.length; i3 += cols) {
          const row = table.createEl("tr");
          for (let j4 = 0; j4 < cols; j4++) {
            const idx = i3 + j4;
            const cell = row.createEl("td");
            if (idx >= this.weights.length)
              continue;
            const label = cell.createEl("div", { text: `w${idx}` });
            label.style.marginBottom = "4px";
            const input = cell.createEl("input", { type: "number", value: String(this.weights[idx]) });
            input.style.width = "100%";
            input.addEventListener("change", () => {
              const num = parseFloat(input.value);
              if (!isNaN(num))
                this.weights[idx] = num;
            });
          }
        }
        new import_obsidian40.Setting(contentEl).addButton((b4) => b4.setButtonText(t("reset default")).onClick(() => {
          this.weights = [...DEFAULT_FSRS_PARAMETERS.w];
          this.onOpen();
        })).addButton((b4) => b4.setButtonText(t("save")).setCta().onClick(() => {
          this.plugin.settings.fsrsParams.w = [...this.weights];
          this.plugin.fsrsService.setParameters({ w: this.weights });
          this.plugin.saveData(this.plugin.settings);
          this.close();
        })).addButton((b4) => b4.setButtonText(t("cancel")).onClick(() => this.close()));
      }
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/components/PresetModal.ts
var PresetModal_exports = {};
__export(PresetModal_exports, {
  default: () => PresetModal
});
var import_obsidian41, PresetModal;
var init_PresetModal = __esm({
  "src/components/PresetModal.ts"() {
    import_obsidian41 = require("obsidian");
    init_i18n();
    PresetModal = class extends import_obsidian41.Modal {
      constructor(plugin) {
        super(plugin.app);
        this.currentPresetIndex = -1;
        /** 是否在关闭时跳过自动保存 */
        this.skipSaveOnClose = false;
        this.plugin = plugin;
        this.presets = [...this.plugin.dataManager.getAllPresets()];
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("BetterNotes-preset-modal");
        this.createHeader(contentEl);
        this.contentArea = contentEl.createDiv("BetterNotes-preset-content");
        this.createPresetList();
        this.createPresetEditor();
        this.createFooter(contentEl);
        if (this.presets.length > 0) {
          this.selectPreset(0);
        } else {
          this.disableEditor();
        }
      }
      /**
       * 创建模态框标题区域
       * @param parentEl - 父元素
       */
      createHeader(parentEl) {
        const headerEl = parentEl.createDiv("BetterNotes-preset-header");
        const titleContainer = headerEl.createDiv("BetterNotes-preset-title-container");
        const titleIcon = titleContainer.createDiv("BetterNotes-preset-title-icon");
        (0, import_obsidian41.setIcon)(titleIcon, "message-square");
        titleContainer.createEl("div", {
          text: t("AI preset prompt"),
          cls: "BetterNotes-preset-title"
        });
        const subtitle = headerEl.createEl("p", {
          text: t("create and manage your AI conversation preset prompts"),
          cls: "BetterNotes-preset-subtitle"
        });
      }
      /**
       * 创建左侧预设列表
       */
      createPresetList() {
        this.presetListEl = this.contentArea.createDiv("BetterNotes-preset-list-container");
        const listHeader = this.presetListEl.createDiv("BetterNotes-preset-list-header");
        listHeader.createEl("div", { text: t("preset list") });
        const addBtnContainer = listHeader.createDiv("BetterNotes-preset-add-btn-container");
        const addBtn = addBtnContainer.createDiv("BetterNotes-preset-add-btn");
        (0, import_obsidian41.setIcon)(addBtn, "plus");
        addBtn.setAttribute("aria-label", t("add new preset"));
        addBtn.addEventListener("click", () => this.addNewPreset());
        const listEl = this.presetListEl.createDiv("BetterNotes-preset-list");
        this.renderPresetList(listEl);
      }
      /**
       * 渲染预设列表
       * @param listEl - 列表容器元素
       */
      renderPresetList(listEl) {
        listEl.empty();
        this.presets.forEach((preset, index) => {
          const itemEl = listEl.createDiv({
            cls: `BetterNotes-preset-item ${index === this.currentPresetIndex ? "selected" : ""}`,
            attr: { "data-index": index.toString() }
          });
          const itemIcon = itemEl.createDiv("BetterNotes-preset-item-icon");
          (0, import_obsidian41.setIcon)(itemIcon, "message-circle");
          const itemContent = itemEl.createDiv("BetterNotes-preset-item-content");
          itemContent.createEl("div", {
            text: preset.label || t("unnamed preset"),
            cls: "BetterNotes-preset-item-title"
          });
          const previewText = preset.prompt.length > 30 ? preset.prompt.substring(0, 30) + "..." : preset.prompt;
          itemContent.createEl("div", {
            text: previewText || t("empty preset"),
            cls: "BetterNotes-preset-item-preview"
          });
          const deleteBtn = itemEl.createDiv("BetterNotes-preset-item-delete");
          (0, import_obsidian41.setIcon)(deleteBtn, "trash-2");
          deleteBtn.setAttribute("aria-label", t("delete preset"));
          itemEl.addEventListener("click", (e) => {
            if (e.target === deleteBtn || deleteBtn.contains(e.target)) {
              this.deletePreset(index);
            } else {
              this.selectPreset(index);
            }
          });
        });
      }
      /**
       * 创建右侧编辑区域
       */
      createPresetEditor() {
        this.presetEditorEl = this.contentArea.createDiv("BetterNotes-preset-editor");
        const nameContainer = this.presetEditorEl.createDiv("BetterNotes-preset-name-container");
        nameContainer.createEl("label", {
          text: t("preset name"),
          cls: "BetterNotes-preset-label",
          attr: { for: "preset-name-input" }
        });
        this.presetNameEl = nameContainer.createEl("input", {
          type: "text",
          cls: "BetterNotes-preset-name-input",
          attr: {
            id: "preset-name-input",
            placeholder: t("input preset name")
          }
        });
        const contentContainer = this.presetEditorEl.createDiv("BetterNotes-preset-content-container");
        contentContainer.createEl("label", {
          text: t("preset content"),
          cls: "BetterNotes-preset-label",
          attr: { for: "preset-content-input" }
        });
        this.presetContentEl = contentContainer.createEl("textarea", {
          cls: "BetterNotes-preset-content-input",
          attr: {
            id: "preset-content-input",
            placeholder: t("input preset content"),
            rows: "10"
          }
        });
        this.presetNameEl.addEventListener("input", () => this.updateCurrentPreset());
        this.presetContentEl.addEventListener("input", () => this.updateCurrentPreset());
      }
      /**
       * 创建底部操作按钮
       * @param parentEl - 父元素
       */
      createFooter(parentEl) {
        const footer = parentEl.createDiv("BetterNotes-modal-footer");
        const saveBtn = footer.createEl("button", {
          text: t("save"),
          cls: "BetterNotes-btn BetterNotes-btn-primary"
        });
        saveBtn.addEventListener("click", () => this.savePresets(
          true,
          true
          /*showNotice*/
        ));
        const cancelBtn = footer.createEl("button", {
          text: t("cancel"),
          cls: "BetterNotes-btn"
        });
        cancelBtn.addEventListener("click", () => {
          this.skipSaveOnClose = true;
          this.close();
        });
      }
      /**
       * 选择预设
       * @param index - 预设索引
       */
      selectPreset(index) {
        if (index < 0 || index >= this.presets.length)
          return;
        this.currentPresetIndex = index;
        const listItems = this.presetListEl.querySelectorAll(".BetterNotes-preset-item");
        listItems.forEach((item) => item.classList.remove("selected"));
        listItems[index]?.classList.add("selected");
        const preset = this.presets[index];
        this.presetNameEl.value = preset.label;
        this.presetContentEl.value = preset.prompt;
        this.enableEditor();
      }
      /**
       * 添加新预设
       */
      addNewPreset() {
        const newPreset = {
          label: t("new preset"),
          prompt: ""
        };
        this.presets.push(newPreset);
        this.renderPresetList(this.presetListEl.querySelector(".BetterNotes-preset-list"));
        this.selectPreset(this.presets.length - 1);
        this.presetNameEl.focus();
        this.presetNameEl.select();
      }
      /**
       * 删除预设
       * @param index - 预设索引
       */
      deletePreset(index) {
        if (index < 0 || index >= this.presets.length)
          return;
        this.presets.splice(index, 1);
        this.renderPresetList(this.presetListEl.querySelector(".BetterNotes-preset-list"));
        if (this.currentPresetIndex === index) {
          if (this.presets.length > 0) {
            this.selectPreset(Math.min(index, this.presets.length - 1));
          } else {
            this.currentPresetIndex = -1;
            this.disableEditor();
          }
        } else if (this.currentPresetIndex > index) {
          this.currentPresetIndex--;
        }
        this.savePresets(
          false,
          false
          /* showNotice */
        );
      }
      /**
       * 更新当前预设
       */
      updateCurrentPreset() {
        if (this.currentPresetIndex < 0)
          return;
        const preset = this.presets[this.currentPresetIndex];
        preset.label = this.presetNameEl.value;
        preset.prompt = this.presetContentEl.value;
        const listEl = this.presetListEl.querySelector(".BetterNotes-preset-list");
        const itemEl = listEl.querySelector(`.BetterNotes-preset-item[data-index="${this.currentPresetIndex}"]`);
        if (itemEl) {
          const titleEl = itemEl.querySelector(".BetterNotes-preset-item-title");
          const previewEl = itemEl.querySelector(".BetterNotes-preset-item-preview");
          titleEl.textContent = preset.label || t("unnamed preset");
          const previewText = preset.prompt.length > 30 ? preset.prompt.substring(0, 30) + "..." : preset.prompt;
          previewEl.textContent = previewText || t("empty preset");
        }
      }
      /**
       * 保存所有预设
       */
      async savePresets(shouldClose = true, showNotice = true) {
        const cleanedPresets = this.presets.filter((p5) => p5.label.trim());
        const seen = /* @__PURE__ */ new Set();
        for (const preset of cleanedPresets) {
          if (!preset.label.trim()) {
            new import_obsidian41.Notice(t("empty preset name"));
            return;
          }
          if (seen.has(preset.label)) {
            new import_obsidian41.Notice(t("duplicate preset name") + ": " + preset.label);
            return;
          }
          seen.add(preset.label);
        }
        this.plugin.dataManager.getAllPresets().forEach(
          (preset) => this.plugin.dataManager.deletePreset(preset.label)
        );
        cleanedPresets.forEach((preset) => {
          this.plugin.dataManager.upsertPreset(preset.label, preset.prompt);
        });
        const success = await this.plugin.storageManager.saveData(this.plugin.settings);
        if (success) {
          if (showNotice)
            new import_obsidian41.Notice(t("presets saved"));
          if (shouldClose) {
            this.skipSaveOnClose = true;
            this.close();
          }
        } else {
          if (showNotice)
            new import_obsidian41.Notice(t("save presets failed"));
        }
      }
      /**
       * 禁用编辑区域
       */
      disableEditor() {
        this.presetNameEl.value = "";
        this.presetContentEl.value = "";
        this.presetNameEl.disabled = true;
        this.presetContentEl.disabled = true;
        this.presetEditorEl.classList.add("disabled");
      }
      /**
       * 启用编辑区域
       */
      enableEditor() {
        this.presetNameEl.disabled = false;
        this.presetContentEl.disabled = false;
        this.presetEditorEl.classList.remove("disabled");
      }
      onClose() {
        if (!this.skipSaveOnClose) {
          this.savePresets(
            false,
            false
            /* showNotice */
          );
        }
        this.contentEl.empty();
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => BetterNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian42 = require("obsidian");

// src/models/Collection.ts
var DEFAULT_COLLECTION = {
  color: "#3498db",
  type: "set",
  parent: "",
  plan: "default"
};

// src/models/Entry.ts
var DEFAULT_ENTRY = {
  comment: "",
  tag: [],
  link: [],
  type: "md",
  attachmentFile: [],
  index: "",
  proficiency: 0,
  mtime: void 0
  // 不设置默认值，让创建时动态设置
};

// src/services/DataManager.ts
init_utils();

// src/models/Plan.ts
var DEFAULT_PLAN = {
  intervals: [0, 0, 0, 0, 0, 0],
  min: 45,
  max: 90,
  fsrs: false
};

// src/services/DataManager.ts
var DataManager = class {
  /**
   * 构造函数，初始化集合和条目存储
   */
  constructor() {
    this.collections = /* @__PURE__ */ new Map();
    this.entries = /* @__PURE__ */ new Map();
    this.plans = /* @__PURE__ */ new Map();
    this.tags = /* @__PURE__ */ new Map();
    this.presets = /* @__PURE__ */ new Map();
    const defaultIntervals = [1, 1, 2, 3, 4, 7];
    const defaultPlan = {
      ...DEFAULT_PLAN,
      name: "default",
      intervals: defaultIntervals,
      min: 10,
      max: 20,
      fsrs: false
    };
    this.plans.set("default", defaultPlan);
  }
  // ---------------------------- Tag Helpers ----------------------------
  /** 统一规范化标签名称：去首尾空格并转为小写 */
  normalizeTag(tagName) {
    return tagName.trim().toLowerCase();
  }
  /** 新增或递增标签引用 */
  addTagReference(tagName) {
    const t2 = this.normalizeTag(tagName);
    if (!t2)
      return;
    const existing = this.tags.get(t2);
    if (existing) {
      existing.count += 1;
      this.tags.set(t2, existing);
    } else {
      this.tags.set(t2, { tagName: t2, count: 1 });
    }
  }
  /** 减少标签引用，计数为 0 时自动删除 */
  removeTagReference(tagName) {
    const t2 = this.normalizeTag(tagName);
    if (!t2)
      return;
    const existing = this.tags.get(t2);
    if (!existing)
      return;
    if (existing.count <= 1) {
      this.tags.delete(t2);
    } else {
      existing.count -= 1;
      this.tags.set(t2, existing);
    }
  }
  // ----------------------------- Tag API -----------------------------
  /** 获取全部标签（按名称排序） */
  getAllTags() {
    return Array.from(this.tags.values()).sort((a2, b4) => a2.tagName.localeCompare(b4.tagName));
  }
  /** 获取指定标签 */
  getTag(tagName) {
    return this.tags.get(this.normalizeTag(tagName));
  }
  /**
   * 确保指定标签存在（如果不存在则创建，计数为0）。
   * 该方法仅用于在 UI 中提前创建标签，而不立即关联任何条目。
   * @param tagName 标签名称
   */
  ensureTag(tagName) {
    const t2 = this.normalizeTag(tagName);
    if (!t2)
      return;
    if (!this.tags.has(t2)) {
      this.tags.set(t2, { tagName: t2, count: 0 });
    }
  }
  /** 根据标签获取条目列表 */
  getEntriesByTag(tagName) {
    const t2 = this.normalizeTag(tagName);
    return Array.from(this.entries.values()).filter((e) => e.tag?.map((x4) => this.normalizeTag(x4)).includes(t2));
  }
  /**
   * 创建新的集合
   * @param name 集合名称（必需）
   * @param options 集合附加选项
   * @returns 创建的集合对象
   */
  createCollection(name2, options = {}) {
    if (this.collections.has(name2)) {
      throw new Error(`\u96C6\u5408 "${name2}" \u5DF2\u5B58\u5728`);
    }
    const collection = {
      ...DEFAULT_COLLECTION,
      name: name2,
      ...options
    };
    this.collections.set(name2, collection);
    return collection;
  }
  /**
   * 获取集合
   * @param name 集合名称
   * @returns 集合对象或undefined（如果不存在）
   */
  getCollection(name2) {
    return this.collections.get(name2);
  }
  /**
   * 获取所有集合
   * @returns 所有集合的数组
   */
  getAllCollections() {
    return Array.from(this.collections.values());
  }
  /**
   * 更新集合
   * @param name 集合名称
   * @param updates 要更新的属性
   * @returns 更新后的集合对象
   */
  updateCollection(name2, updates) {
    const collection = this.getCollection(name2);
    if (!collection) {
      throw new Error(`\u96C6\u5408 "${name2}" \u4E0D\u5B58\u5728`);
    }
    const { name: _3, ...restUpdates } = updates;
    const updatedCollection = {
      ...collection,
      ...restUpdates,
      name: name2
      // 确保名称不变
    };
    this.collections.set(name2, updatedCollection);
    return updatedCollection;
  }
  /**
   * 删除集合
   * @param name 集合名称
   * @returns 是否成功删除
   */
  deleteCollection(name2) {
    const collection = this.getCollection(name2);
    if (collection) {
      this.entries.forEach((entry, hash) => {
        if (entry.set === name2) {
          this.entries.delete(hash);
        }
      });
      return this.collections.delete(name2);
    }
    return false;
  }
  /**
   * 创建条目
   * @param value 条目内容
   * @param set 所属集合
   * @param options 其他选项
   * @returns 创建的条目对象
   */
  createEntry(value, set, options = {}) {
    if (!this.collections.has(set)) {
      throw new Error(`\u96C6\u5408 "${set}" \u4E0D\u5B58\u5728`);
    }
    const hash = generateHash();
    const now = formatDate();
    const currentTimestamp = Date.now();
    const entry = {
      ...DEFAULT_ENTRY,
      // 基础默认值
      ...options,
      // 用户提供的选项
      hash,
      // 必须保留的属性
      value,
      set,
      addTime: now,
      expireTime: now,
      sourceFile: options.sourceFile || "",
      // 确保数组字段为独立副本，避免多个条目共享引用
      tag: options.tag ? [...options.tag] : [],
      link: options.link ? [...options.link] : [],
      attachmentFile: options.attachmentFile ? [...options.attachmentFile] : [],
      mtime: currentTimestamp
      // 确保修改时间总是当前时间戳
    };
    this.entries.set(hash, entry);
    const uniqueTags = new Set(entry.tag.map((t2) => this.normalizeTag(t2)));
    uniqueTags.forEach((t2) => this.addTagReference(t2));
    return entry;
  }
  /**
   * 创建新的条目，使用指定的哈希值
   * @param value 条目文本内容
   * @param set 所属集合名称
   * @param hash 指定的哈希值（确保唯一性）
   * @param options 条目附加选项
   * @returns 创建的条目对象
   */
  createEntryWithHash(value, set, hash, options = {}) {
    if (!this.collections.has(set)) {
      throw new Error(`\u96C6\u5408 "${set}" \u4E0D\u5B58\u5728`);
    }
    if (this.entries.has(hash)) {
      throw new Error(`\u54C8\u5E0C\u503C "${hash}" \u5DF2\u5B58\u5728`);
    }
    const now = formatDate();
    const currentTimestamp = Date.now();
    const entry = {
      ...DEFAULT_ENTRY,
      // 基础默认值
      ...options,
      // 用户提供的选项
      hash,
      // 必须保留的属性
      value,
      set,
      addTime: now,
      expireTime: now,
      sourceFile: options.sourceFile || "",
      // 确保数组字段为独立副本，避免多个条目共享引用
      tag: options.tag ? [...options.tag] : [],
      link: options.link ? [...options.link] : [],
      attachmentFile: options.attachmentFile ? [...options.attachmentFile] : [],
      mtime: currentTimestamp
      // 确保修改时间总是当前时间戳
    };
    this.entries.set(hash, entry);
    const uniqueTags = new Set(entry.tag.map((t2) => this.normalizeTag(t2)));
    uniqueTags.forEach((t2) => this.addTagReference(t2));
    return entry;
  }
  /**
   * 获取条目
   * @param hash 条目哈希值
   * @returns 条目对象或undefined（如果不存在）
   */
  getEntry(hash) {
    return this.entries.get(hash);
  }
  /**
   * 获取条目（别名方法，与getEntry功能相同）
   * 提供此方法是为了保持API命名一致性
   * @param hash 条目哈希值
   * @returns 条目对象或undefined（如果不存在）
   */
  getEntryByHash(hash) {
    return this.getEntry(hash);
  }
  /**
   * 获取指定集合的所有条目
   * @param set 集合名称
   * @returns 条目对象数组
   */
  getEntriesBySet(set) {
    return Array.from(this.entries.values()).filter((entry) => entry.set === set);
  }
  /**
   * 获取所有条目
   * @returns 所有条目对象数组
   */
  getAllEntries() {
    return Array.from(this.entries.values());
  }
  /**
   * 更新条目
   * @param hash 条目哈希值
   * @param updates 要更新的属性
   * @returns 更新后的条目对象
   */
  updateEntry(hash, updates) {
    const entry = this.getEntry(hash);
    if (!entry) {
      throw new Error(`\u6761\u76EE "${hash}" \u4E0D\u5B58\u5728`);
    }
    if (updates.set && updates.set !== entry.set && !this.collections.has(updates.set)) {
      throw new Error(`\u96C6\u5408 "${updates.set}" \u4E0D\u5B58\u5728`);
    }
    const oldTags = new Set(entry.tag.map((t2) => this.normalizeTag(t2)));
    let newTagArray = entry.tag;
    if (updates.tag) {
      newTagArray = updates.tag;
    }
    const newTags = new Set(newTagArray.map((t2) => this.normalizeTag(t2)));
    const addedTags = Array.from(newTags).filter((t2) => !oldTags.has(t2));
    const removedTags = Array.from(oldTags).filter((t2) => !newTags.has(t2));
    addedTags.forEach((t2) => this.addTagReference(t2));
    removedTags.forEach((t2) => this.removeTagReference(t2));
    updates.mtime = Date.now();
    const updatedEntry = {
      ...entry,
      ...updates,
      tag: newTagArray,
      hash
      // 确保哈希值不变
    };
    this.entries.set(hash, updatedEntry);
    return updatedEntry;
  }
  /**
   * 删除条目
   * @param hash 条目哈希值
   * @returns 是否成功删除
   */
  deleteEntry(hash) {
    const entry = this.entries.get(hash);
    if (entry) {
      const uniqueTags = new Set(entry.tag.map((t2) => this.normalizeTag(t2)));
      uniqueTags.forEach((t2) => this.removeTagReference(t2));
    }
    return this.entries.delete(hash);
  }
  /**
   * 将条目添加到集合
   * @param hash 条目哈希值
   * @param set 目标集合名称
   * @returns 更新后的条目对象
   */
  addEntryToCollection(hash, set) {
    if (!this.collections.has(set)) {
      throw new Error(`\u96C6\u5408 "${set}" \u4E0D\u5B58\u5728`);
    }
    return this.updateEntry(hash, { set });
  }
  /**
   * 将数据序列化为JSON
   * @returns 序列化的数据对象
   */
  serialize() {
    return {
      collections: Array.from(this.collections.values()),
      entries: Array.from(this.entries.values()),
      plans: Array.from(this.plans.values()),
      tags: Array.from(this.tags.values()),
      presets: Array.from(this.presets.values())
    };
  }
  /**
   * 从JSON数据恢复
   * @param data 序列化的数据对象
   */
  deserialize(data) {
    this.collections.clear();
    this.entries.clear();
    this.plans.clear();
    this.tags.clear();
    this.presets.clear();
    data.collections.forEach((collection) => {
      this.collections.set(collection.name, collection);
    });
    data.entries.forEach((entry) => {
      this.entries.set(entry.hash, entry);
    });
    if (data.plans) {
      data.plans.forEach((plan) => {
        if (plan.fsrs === void 0)
          plan.fsrs = false;
        this.plans.set(plan.name, plan);
      });
    }
    if (data.tags) {
      data.tags.forEach((tag) => {
        this.tags.set(this.normalizeTag(tag.tagName), tag);
      });
    } else {
      this.entries.forEach((entry) => {
        const unique = new Set(entry.tag.map((t2) => this.normalizeTag(t2)));
        unique.forEach((t2) => this.addTagReference(t2));
      });
    }
    if (Array.isArray(data.presets)) {
      data.presets.forEach((p5) => {
        this.presets.set(p5.label, p5);
      });
    }
    if (!this.plans.has("default")) {
      const defaultIntervals = [1, 1, 2, 3, 4, 7];
      const defaultPlan = {
        ...DEFAULT_PLAN,
        name: "default",
        intervals: defaultIntervals,
        min: 10,
        max: 20,
        fsrs: false
      };
      this.plans.set("default", defaultPlan);
    }
  }
  /**
   * 根据 sourceFile 获取条目列表
   * @param sourceFile 源文件路径（完全路径）
   * @returns Entry 数组
   */
  getEntriesBySourceFile(sourceFile) {
    if (!sourceFile)
      return [];
    return Array.from(this.entries.values()).filter((entry) => entry.sourceFile === sourceFile);
  }
  /**
   * -------------------------  Plan 相关 -------------------------
   */
  /**
   * 创建新的 Plan
   * @param name Plan 名称（唯一）
   * @param options 其它可选配置项
   */
  createPlan(name2, options = {}) {
    if (this.plans.has(name2)) {
      throw new Error(`\u8BA1\u5212 "${name2}" \u5DF2\u5B58\u5728`);
    }
    const plan = {
      ...DEFAULT_PLAN,
      name: name2,
      ...options
    };
    this.plans.set(name2, plan);
    return plan;
  }
  /** 获取 Plan */
  getPlan(name2) {
    return this.plans.get(name2);
  }
  /** 获取全部 Plan */
  getAllPlans() {
    return Array.from(this.plans.values());
  }
  /** 更新 Plan（不可修改 name） */
  updatePlan(name2, updates) {
    const plan = this.getPlan(name2);
    if (!plan)
      throw new Error(`\u8BA1\u5212 "${name2}" \u4E0D\u5B58\u5728`);
    const { name: _ignored, ...rest } = updates;
    const updatedPlan = { ...plan, ...rest, name: name2 };
    this.plans.set(name2, updatedPlan);
    return updatedPlan;
  }
  /** 删除 Plan */
  deletePlan(name2) {
    if (name2 === "default")
      return false;
    return this.plans.delete(name2);
  }
  // -------------------- FSRS State Helpers --------------------
  /** 获取条目的 FSRS 状态 */
  getFSRSState(hash) {
    const entry = this.entries.get(hash);
    return entry?.reserve2;
  }
  /** 设置条目的 FSRS 状态 */
  setFSRSState(hash, state) {
    const entry = this.entries.get(hash);
    if (entry) {
      entry.reserve2 = state;
      this.entries.set(hash, entry);
    }
  }
  // ----------------------------- Preset API -----------------------------
  /** 获取全部预设 */
  getAllPresets() {
    return Array.from(this.presets.values());
  }
  /** 获取单个预设 */
  getPreset(label) {
    return this.presets.get(label);
  }
  /** 新增或更新预设 */
  upsertPreset(label, prompt) {
    this.presets.set(label, { label, prompt });
  }
  /** 删除预设 */
  deletePreset(label) {
    return this.presets.delete(label);
  }
};

// src/services/StorageManager.ts
var import_obsidian2 = require("obsidian");
var path = __toESM(require("path"));
init_i18n();
var StorageManager = class {
  /**
   * 构造函数
   * @param app Obsidian应用实例
   * @param dataManager 数据管理器实例
   * @param pluginId 插件ID
   */
  constructor(app, dataManager, pluginId) {
    this.app = app;
    this.dataManager = dataManager;
    this.pluginId = pluginId;
  }
  /**
   * 获取数据文件路径
   * @returns 完整的数据文件路径
   */
  getStorageFilePath() {
    return `${this.app.vault.configDir}/plugins/${this.pluginId}/data.json`;
  }
  /**
   * 确保目录存在
   * @param dirPath 目录路径
   */
  async ensureDirectoryExists(dirPath) {
    try {
      const adapter = this.app.vault.adapter;
      const exists = await adapter.exists(dirPath);
      if (!exists) {
        await adapter.mkdir(dirPath);
      }
    } catch (error2) {
      console.error(`\u521B\u5EFA\u76EE\u5F55\u5931\u8D25: ${dirPath}`, error2);
    }
  }
  /**
   * 保存数据到磁盘
   * @returns 是否保存成功
   */
  async saveData(settings) {
    try {
      const filePath = this.getStorageFilePath();
      const dirPath = path.dirname(filePath);
      await this.ensureDirectoryExists(dirPath);
      const businessData = this.dataManager.serialize();
      const payload = {
        ...businessData,
        settings
      };
      await this.app.vault.adapter.write(filePath, JSON.stringify(payload, null, 2));
      return true;
    } catch (error2) {
      console.error("\u4FDD\u5B58\u6570\u636E\u5931\u8D25:", error2);
      new import_obsidian2.Notice(t("save data failed"));
      return false;
    }
  }
  /**
   * 从磁盘加载数据
   * @returns 是否加载成功
   */
  async loadData() {
    try {
      const filePath = this.getStorageFilePath();
      if (!await this.app.vault.adapter.exists(filePath)) {
        return false;
      }
      const content = await this.app.vault.adapter.read(filePath);
      const parsed = JSON.parse(content);
      this.dataManager.deserialize(parsed);
      return true;
    } catch (error2) {
      console.error("\u52A0\u8F7D\u6570\u636E\u5931\u8D25:", error2);
      new import_obsidian2.Notice(t("load data failed"));
      return false;
    }
  }
};

// src/views/SidebarView.ts
var import_obsidian21 = require("obsidian");

// src/components/CollectionGrid.ts
var import_obsidian5 = require("obsidian");

// src/components/CollectionCard.ts
var import_obsidian4 = require("obsidian");

// src/components/CollectionModal.ts
var import_obsidian3 = require("obsidian");
init_i18n();
var CollectionModal = class extends import_obsidian3.Modal {
  // 绑定的 Plan 名称
  /**
   * 构造函数
   * @param plugin 插件实例
   * @param options 模态框配置选项
   */
  constructor(plugin, options) {
    super(plugin.app);
    this.collectionName = "";
    this.collectionColor = "#6FB5ED";
    // 默认颜色：天蓝色
    this.collectionType = "set";
    // 默认类型：集合
    this.collectionParent = "";
    // 默认父集合：无
    this.selectedPlan = "default";
    this.plugin = plugin;
    this.options = options;
    if (options.mode === "edit" && options.collection) {
      this.collectionName = options.collection.name;
      this.collectionColor = options.collection.color;
      this.collectionType = options.collection.type;
      this.collectionParent = options.collection.parent;
      this.selectedPlan = options.collection.plan || "";
    }
  }
  /**
   * 检查一个文件夹是否为指定集合的子文件夹（包含递归子文件夹）
   * @param folderName 要检查的文件夹名称
   * @param collectionName 当前集合名称
   * @returns 如果是子文件夹则返回true，否则返回false
   */
  isSubfolderOf(folderName, collectionName) {
    if (folderName === collectionName) {
      return true;
    }
    const folder = this.plugin.dataManager.getCollection(folderName);
    if (!folder) {
      return false;
    }
    if (!folder.parent) {
      return false;
    }
    if (folder.parent === collectionName) {
      return true;
    }
    return this.isSubfolderOf(folder.parent, collectionName);
  }
  /**
   * 渲染模态框内容
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("BetterNotes-modal");
    const headerEl = contentEl.createDiv("BetterNotes-modal-header");
    const formEl = contentEl.createDiv("BetterNotes-modal-form");
    const nameContainer = formEl.createDiv("BetterNotes-input-container");
    nameContainer.createEl("label", { text: t("name") });
    const nameInput = nameContainer.createEl("input", {
      type: "text",
      value: this.collectionName
    });
    nameInput.classList.add("BetterNotes-input");
    nameInput.focus();
    nameInput.addEventListener("input", () => {
      this.collectionName = nameInput.value;
    });
    const colorContainer = formEl.createDiv("BetterNotes-input-container");
    colorContainer.createEl("label", { text: t("color") });
    const colorPresetsEl = colorContainer.createDiv("BetterNotes-color-presets");
    const presetColors = [
      "#6FB5ED",
      // 天蓝色
      "#67C23A",
      // 绿色
      "#E6A23C",
      // 橙色
      "#F56C6C",
      // 红色
      "#9C27B0",
      // 紫色
      "#FF9FF3",
      // 粉色
      "#FFD93D"
      // 黄色
    ];
    presetColors.forEach((color) => {
      const colorBtn = colorPresetsEl.createDiv("BetterNotes-color-preset");
      colorBtn.style.backgroundColor = color;
      if (color === this.collectionColor) {
        colorBtn.classList.add("selected");
      }
      colorBtn.addEventListener("click", () => {
        document.querySelectorAll(".BetterNotes-color-preset").forEach((el) => {
          el.classList.remove("selected");
        });
        document.querySelector(".BetterNotes-custom-color-input")?.classList.remove("active");
        colorBtn.classList.add("selected");
        this.collectionColor = color;
      });
    });
    const customColorBtn = colorPresetsEl.createDiv("BetterNotes-color-preset BetterNotes-custom-color");
    customColorBtn.style.background = "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)";
    const colorInput = createEl("input");
    colorInput.type = "color";
    colorInput.value = this.collectionColor;
    colorInput.classList.add("BetterNotes-custom-color-input");
    colorInput.style.opacity = "0";
    colorInput.style.width = "0";
    colorInput.style.height = "0";
    colorInput.style.position = "absolute";
    customColorBtn.appendChild(colorInput);
    if (!presetColors.includes(this.collectionColor)) {
      customColorBtn.classList.add("active");
      colorInput.value = this.collectionColor;
    }
    customColorBtn.addEventListener("click", () => {
      colorInput.click();
    });
    colorInput.addEventListener("input", () => {
      document.querySelectorAll(".BetterNotes-color-preset").forEach((el) => {
        el.classList.remove("selected");
      });
      customColorBtn.classList.add("active");
      this.collectionColor = colorInput.value;
    });
    let planContainer;
    if (this.options.mode === "create") {
      const typeContainer = formEl.createDiv("BetterNotes-input-container");
      typeContainer.createEl("label", { text: t("type") });
      const typeToggleEl = typeContainer.createDiv("BetterNotes-toggle-container");
      const setTypeBtn = typeToggleEl.createDiv("BetterNotes-toggle-btn");
      if (this.collectionType === "set") {
        setTypeBtn.classList.add("active");
      }
      const setTypeIconEl = setTypeBtn.createSpan("BetterNotes-toggle-icon");
      (0, import_obsidian3.setIcon)(setTypeIconEl, "note");
      setTypeBtn.createSpan("BetterNotes-toggle-label").setText(t("set"));
      const folderTypeBtn = typeToggleEl.createDiv("BetterNotes-toggle-btn");
      if (this.collectionType === "folder") {
        folderTypeBtn.classList.add("active");
      }
      const folderTypeIconEl = folderTypeBtn.createSpan("BetterNotes-toggle-icon");
      (0, import_obsidian3.setIcon)(folderTypeIconEl, "folder");
      folderTypeBtn.createSpan("BetterNotes-toggle-label").setText(t("folder"));
      setTypeBtn.addEventListener("click", () => {
        setTypeBtn.classList.add("active");
        folderTypeBtn.classList.remove("active");
        this.collectionType = "set";
        planContainer.style.display = "";
      });
      folderTypeBtn.addEventListener("click", () => {
        folderTypeBtn.classList.add("active");
        setTypeBtn.classList.remove("active");
        this.collectionType = "folder";
        planContainer.style.display = "none";
      });
    }
    planContainer = formEl.createDiv("BetterNotes-input-container");
    planContainer.createEl("label", { text: t("bind plan") });
    const planTagsContainer = planContainer.createDiv("BetterNotes-folder-tags-container");
    const plans = this.plugin.dataManager.getAllPlans();
    plans.forEach((p5) => {
      const tag = planTagsContainer.createDiv("BetterNotes-folder-tag");
      tag.setText(`#${p5.name}`);
      if (this.selectedPlan === p5.name)
        tag.classList.add("selected");
      tag.addEventListener("click", () => {
        if (p5.name === "default" && plans.length === 1) {
          return;
        }
        this.selectedPlan = p5.name;
        updateTagSelection();
      });
    });
    function updateTagSelection() {
      planTagsContainer.childNodes.forEach((n3) => n3.classList.remove("selected"));
      planTagsContainer.childNodes.forEach((n3) => {
        if (n3.textContent === `#${that.selectedPlan}`) {
          n3.classList.add("selected");
        }
      });
    }
    const that = this;
    if (this.collectionType === "folder") {
      planContainer.style.display = "none";
    }
    if (this.options.mode === "edit") {
      const moveContainer = formEl.createDiv("BetterNotes-input-container");
      moveContainer.createEl("label", { text: t("move to") });
      const folderTagsContainer = moveContainer.createDiv("BetterNotes-folder-tags-container");
      const rootTag = folderTagsContainer.createDiv("BetterNotes-folder-tag");
      rootTag.classList.add("BetterNotes-root-tag");
      if (this.collectionParent === "") {
        rootTag.classList.add("selected");
      }
      const rootIconEl = rootTag.createSpan("BetterNotes-folder-tag-icon");
      (0, import_obsidian3.setIcon)(rootIconEl, "home");
      rootTag.createSpan("BetterNotes-folder-tag-name").setText(t("root"));
      rootTag.addEventListener("click", () => {
        folderTagsContainer.childNodes.forEach((el) => el.classList.remove("selected"));
        rootTag.classList.add("selected");
        this.collectionParent = "";
      });
      const folders = this.plugin.dataManager.getAllCollections().filter((c2) => c2.type === "folder" && !this.isSubfolderOf(c2.name, this.collectionName));
      folders.forEach((folder) => {
        const folderTag = folderTagsContainer.createDiv("BetterNotes-folder-tag");
        const folderColor = folder.color;
        folderTag.style.backgroundColor = this.adjustColorOpacity(folderColor, 0.2);
        folderTag.style.borderColor = folderColor;
        if (folder.name === this.collectionParent) {
          folderTag.classList.add("selected");
        }
        const folderIconEl = folderTag.createSpan("BetterNotes-folder-tag-icon");
        (0, import_obsidian3.setIcon)(folderIconEl, "folder");
        folderIconEl.style.color = folderColor;
        folderTag.createSpan("BetterNotes-folder-tag-name").setText(folder.name);
        folderTag.addEventListener("click", () => {
          folderTagsContainer.childNodes.forEach((el) => el.classList.remove("selected"));
          folderTag.classList.add("selected");
          this.collectionParent = folder.name;
        });
      });
    }
    const buttonContainer = contentEl.createDiv();
    buttonContainer.classList.add("BetterNotes-modal-buttons");
    const cancelButton = buttonContainer.createEl("button", { text: t("cancel") });
    cancelButton.classList.add("BetterNotes-btn");
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const confirmText = this.options.mode === "create" ? t("create") : t("save");
    const confirmButton = buttonContainer.createEl("button", { text: confirmText });
    confirmButton.classList.add("BetterNotes-btn", "BetterNotes-btn-primary");
    confirmButton.addEventListener("click", () => {
      if (this.collectionName.trim()) {
        this.options.onConfirm(
          this.collectionName,
          this.collectionColor,
          this.collectionType,
          this.collectionParent,
          this.selectedPlan
        );
        this.close();
      } else {
        const errorMsg = contentEl.createEl("div", {
          text: t("collection name cannot be empty"),
          cls: "BetterNotes-error"
        });
        formEl.appendChild(errorMsg);
        nameInput.classList.add("BetterNotes-input-error");
        setTimeout(() => {
          errorMsg.remove();
          nameInput.classList.remove("BetterNotes-input-error");
        }, 2e3);
      }
    });
  }
  /**
   * 调整颜色的透明度
   * @param color 原始颜色（十六进制格式）
   * @param opacity 目标透明度（0-1之间）
   * @returns 调整透明度后的颜色（rgba格式）
   */
  adjustColorOpacity(color, opacity) {
    const hex = color.replace("#", "");
    const r = parseInt(hex.substring(0, 2), 16);
    const g5 = parseInt(hex.substring(2, 4), 16);
    const b4 = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g5}, ${b4}, ${opacity})`;
  }
  /**
   * 关闭模态框
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/CollectionCard.ts
init_i18n();
var CollectionCard = class {
  /**
   * 构造函数
   * @param container 容器元素
   * @param collection 集合对象
   * @param plugin 插件实例
   * @param onFolderClick 点击文件夹的回调函数（可选）
   */
  constructor(container, collection, plugin, onFolderClick) {
    this.onFolderClick = null;
    this.container = container;
    this.collection = collection;
    this.plugin = plugin;
    this.onFolderClick = onFolderClick || null;
    if (collection.type === "folder") {
      this.container.addEventListener("click", (e) => {
        if (e.target.closest(".BetterNotes-card-tool")) {
          return;
        }
        if (this.onFolderClick) {
          this.onFolderClick(collection);
        }
      });
    }
  }
  /**
   * 递归获取文件夹中的所有集合数量
   * @param folderName 文件夹名称
   * @returns 集合数量
   */
  getTotalCollectionsInFolder(folderName) {
    const directSets = this.plugin.dataManager.getAllCollections().filter(
      (c2) => c2.parent === folderName && c2.type === "set"
    ).length;
    const subFolders = this.plugin.dataManager.getAllCollections().filter(
      (c2) => c2.parent === folderName && c2.type === "folder"
    );
    const subFolderSets = subFolders.reduce((total, folder) => {
      return total + this.getTotalCollectionsInFolder(folder.name);
    }, 0);
    return directSets + subFolderSets;
  }
  /**
   * 渲染集合卡片
   */
  render() {
    this.container.empty();
    if (this.collection.type === "set") {
      this.container.setAttr("draggable", "true");
      this.container.addEventListener("dragstart", (ev) => {
        ev.dataTransfer?.setData("text/BetterNotes-set", this.collection.name);
        ev.dataTransfer.effectAllowed = "copy";
      });
    }
    this.container.classList.add("BetterNotes-card");
    this.container.style.backgroundColor = this.collection.color;
    this.container.dataset.collectionName = this.collection.name;
    this.container.dataset.collectionType = this.collection.type;
    const titleEl = this.container.createEl("div", { cls: "BetterNotes-card-title" });
    titleEl.setText(this.collection.name);
    const iconEl = this.container.createEl("div", { cls: "BetterNotes-card-icon" });
    (0, import_obsidian4.setIcon)(iconEl, this.collection.type === "folder" ? "folder" : "note");
    if (this.collection.type === "folder") {
      iconEl.classList.add("BetterNotes-folder-icon");
      this.container.addEventListener("click", (e) => {
        if (e.target.closest(".BetterNotes-card-tool")) {
          return;
        }
        if (this.onFolderClick) {
          this.onFolderClick(this.collection);
        }
      });
    }
    const contentEl = this.container.createEl("div", { cls: "BetterNotes-card-content" });
    const statsEl = contentEl.createEl("div", { cls: "BetterNotes-card-stats" });
    if (this.collection.type === "folder") {
      const totalCollections = this.getTotalCollectionsInFolder(this.collection.name);
      statsEl.createEl("span", {
        text: `${totalCollections} ${t("set(s)")}`,
        cls: "BetterNotes-entry-count"
      });
    } else {
      const entryCount = this.plugin.dataManager.getEntriesBySet(this.collection.name).length;
      statsEl.createEl("span", {
        text: `${entryCount} ${t("entries")}`,
        cls: "BetterNotes-entry-count"
      });
    }
    const footerEl = this.container.createEl("div", { cls: "BetterNotes-card-footer" });
    const toolsEl = footerEl.createEl("div", { cls: "BetterNotes-card-tools" });
    const editBtn = toolsEl.createEl("div", { cls: "BetterNotes-card-tool" });
    (0, import_obsidian4.setIcon)(editBtn, "pencil");
    const deleteBtn = toolsEl.createEl("div", { cls: "BetterNotes-card-tool" });
    (0, import_obsidian4.setIcon)(deleteBtn, "trash");
    this.bindEventListeners();
  }
  /**
   * 打开编辑集合的模态框
   */
  openEditCollectionModal() {
    const modal = new CollectionModal(this.plugin, {
      mode: "edit",
      collection: this.collection,
      onConfirm: async (name2, color, type, parent, plan) => {
        try {
          if (name2 !== this.collection.name) {
            await this.plugin.createCollection(name2, {
              color,
              type: this.collection.type,
              // 保持原有类型
              plan,
              parent
              // 使用新的父集合
            });
            const entries = this.plugin.dataManager.getEntriesBySet(this.collection.name);
            for (const entry of entries) {
              await this.plugin.updateEntry(entry.hash, { set: name2 });
            }
            if (this.collection.type === "folder") {
              const childCollections = this.plugin.dataManager.getAllCollections().filter(
                (c2) => c2.parent === this.collection.name
              );
              for (const child of childCollections) {
                await this.plugin.updateCollection(child.name, { parent: name2 });
              }
            }
            await this.plugin.deleteCollection(this.collection.name);
          } else {
            await this.plugin.updateCollection(name2, {
              color,
              plan,
              parent
              // 更新父集合
            });
          }
          await this.plugin.refreshViews();
        } catch (error2) {
          console.error("\u66F4\u65B0\u96C6\u5408\u5931\u8D25:", error2);
        }
      }
    });
    modal.open();
  }
  /**
   * 打开删除集合的确认对话框
   */
  openDeleteCollectionConfirm() {
    const originalBgColor = this.container.style.backgroundColor;
    const originalBoxShadow = this.container.style.boxShadow;
    this.container.style.backgroundColor = "rgba(220, 53, 69, 0.8)";
    this.container.style.boxShadow = "0 0 15px rgba(220, 53, 69, 0.5)";
    this.container.style.transform = "scale(1.02)";
    this.container.style.transition = "all 0.2s ease-in-out";
    const toolsEl = this.container.querySelector(".BetterNotes-card-tools");
    if (!toolsEl)
      return;
    const originalToolsContent = toolsEl.innerHTML;
    toolsEl.empty();
    const confirmBtn = toolsEl.createEl("div", {
      cls: "BetterNotes-card-tool BetterNotes-confirm-delete",
      attr: { "aria-label": t("confirm-delete") }
    });
    (0, import_obsidian4.setIcon)(confirmBtn, "check");
    const cancelBtn = toolsEl.createEl("div", {
      cls: "BetterNotes-card-tool BetterNotes-cancel-delete",
      attr: { "aria-label": t("cancel") }
    });
    (0, import_obsidian4.setIcon)(cancelBtn, "x");
    const restoreCard = () => {
      this.container.style.backgroundColor = originalBgColor;
      this.container.style.boxShadow = originalBoxShadow;
      this.container.style.transform = "";
      this.container.style.transition = "";
      toolsEl.innerHTML = originalToolsContent;
      this.bindEventListeners();
    };
    confirmBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      confirmBtn.addClass("is-loading");
      (0, import_obsidian4.setIcon)(confirmBtn, "loader");
      if (this.collection.type === "folder") {
        await this.recursiveDeleteFolder(this.collection.name);
      } else {
        await this.plugin.deleteCollection(this.collection.name);
        await this.plugin.refreshViews();
      }
    });
    cancelBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      restoreCard();
    });
    const cancelClickHandler = (e) => {
      if (e.target.closest(".BetterNotes-confirm-delete") || e.target.closest(".BetterNotes-cancel-delete")) {
        return;
      }
      restoreCard();
      this.container.removeEventListener("click", cancelClickHandler);
    };
    this.container.addEventListener("click", cancelClickHandler);
  }
  /**
   * 重新绑定卡片的事件监听器
   * 在取消删除确认后需要重新绑定原有的事件
   */
  bindEventListeners() {
    const toolsEl = this.container.querySelector(".BetterNotes-card-tools");
    if (!toolsEl)
      return;
    const editBtn = toolsEl.querySelector(".BetterNotes-card-tool:first-child");
    if (editBtn) {
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.openEditCollectionModal();
      });
    }
    const deleteBtn = toolsEl.querySelector(".BetterNotes-card-tool:last-child");
    if (deleteBtn) {
      deleteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.openDeleteCollectionConfirm();
      });
    }
    if (this.collection.type !== "folder") {
      this.container.addEventListener("click", (e) => {
        if (e.target.closest(".BetterNotes-card-tool")) {
          return;
        }
        this.openEntryListView();
      });
    }
  }
  /**
   * 递归删除文件夹及其所有子集合
   * @param folderName 文件夹名称
   */
  async recursiveDeleteFolder(folderName) {
    const childCollections = this.plugin.dataManager.getAllCollections().filter(
      (c2) => c2.parent === folderName
    );
    for (const child of childCollections) {
      if (child.type === "folder") {
        await this.recursiveDeleteFolder(child.name);
      } else {
        await this.plugin.deleteCollection(child.name);
      }
    }
    await this.plugin.deleteCollection(folderName);
    await this.plugin.refreshViews();
  }
  /**
   * 打开条目列表视图
   */
  openEntryListView() {
    if (this.plugin.sidebarView) {
      this.plugin.sidebarView.showEntryList(this.collection);
    }
  }
};

// src/components/CollectionGrid.ts
var CollectionGrid = class {
  /**
   * 构造函数
   * @param container 容器元素
   * @param plugin 插件实例
   * @param onFolderClick 点击文件夹的回调函数（可选）
   */
  constructor(container, plugin, onFolderClick) {
    this.container = container;
    this.plugin = plugin;
    this.onFolderClick = onFolderClick;
    this.gridElement = this.container.createEl("div");
    this.gridElement.classList.add("BetterNotes-grid");
  }
  /**
   * 渲染集合网格
   * @param parentFolder 父文件夹名称（可选，默认显示根级集合）
   */
  render(parentFolder) {
    this.gridElement.empty();
    const collections = this.plugin.dataManager.getAllCollections().filter((collection) => {
      return parentFolder ? collection.parent === parentFolder : !collection.parent;
    });
    collections.sort((a2, b4) => a2.name.localeCompare(b4.name));
    collections.forEach((collection) => {
      this.renderCollectionCard(collection);
    });
    this.renderAddCollectionCard(parentFolder);
  }
  /**
   * 渲染单个集合卡片
   * @param collection 集合对象
   */
  renderCollectionCard(collection) {
    const cardEl = this.gridElement.createEl("div");
    cardEl.classList.add("BetterNotes-card");
    cardEl.style.backgroundColor = collection.color;
    const card = new CollectionCard(
      cardEl,
      collection,
      this.plugin,
      this.onFolderClick
      // 传递点击文件夹的回调函数
    );
    card.render();
  }
  /**
   * 渲染添加新集合的卡片
   * @param parentFolder 父文件夹名称（可选）
   */
  renderAddCollectionCard(parentFolder) {
    const addCardEl = this.gridElement.createEl("div");
    addCardEl.classList.add("BetterNotes-card", "BetterNotes-add-card");
    addCardEl.style.backgroundColor = "#87CEEB";
    const iconContainer = addCardEl.createEl("div", { cls: "BetterNotes-add-icon-container" });
    (0, import_obsidian5.setIcon)(iconContainer, "plus");
    addCardEl.addEventListener("click", () => {
      this.openCreateCollectionModal(parentFolder);
    });
  }
  /**
   * 打开创建新集合的模态框
   * @param parentFolder 父文件夹名称（可选）
   */
  openCreateCollectionModal(parentFolder) {
    const modal = new CollectionModal(this.plugin, {
      mode: "create",
      onConfirm: async (name2, color, type, _parent, plan) => {
        try {
          await this.plugin.createCollection(name2, {
            color,
            type,
            plan: plan || "default",
            parent: parentFolder || ""
            // 设置父文件夹
          });
          this.render(parentFolder);
        } catch (error2) {
          console.error("\u521B\u5EFA\u96C6\u5408\u5931\u8D25:", error2);
        }
      }
    });
    modal.open();
  }
};

// src/components/TopNavBar.ts
var import_obsidian6 = require("obsidian");
init_i18n();
var TopNavBar = class {
  /**
   * 实际构造函数实现
   */
  constructor(container, plugin, titleOrCallback, onBackClick) {
    this.container = container;
    this.plugin = plugin;
    if (typeof titleOrCallback === "function") {
      this.onNavItemClick = titleOrCallback;
      this.onBackClick = null;
      this.title = null;
      this.navItems = [
        { id: "home", icon: "home", label: t("home"), active: true },
        { id: "comments", icon: "message-square", label: t("comments"), active: false },
        { id: "review", icon: "star", label: t("review"), active: false },
        { id: "plan", icon: "calendar-clock", label: t("plan"), active: false }
      ];
    } else {
      this.title = titleOrCallback;
      this.onBackClick = onBackClick || null;
      this.onNavItemClick = null;
      this.navItems = [];
    }
    this.navContainer = this.container.createEl("div", { cls: "BetterNotes-nav-container" });
  }
  /**
   * 渲染导航栏
   */
  render() {
    this.navContainer.empty();
    if (this.title && this.onBackClick) {
      this.renderTitleBar();
    } else {
      this.renderNavigation();
    }
  }
  /**
   * 渲染标题栏
   */
  renderTitleBar() {
    const titleBarEl = this.navContainer.createEl("div", { cls: "BetterNotes-titlebar" });
    const backBtn = titleBarEl.createEl("div", { cls: "BetterNotes-back-button" });
    (0, import_obsidian6.setIcon)(backBtn, "arrow-left");
    backBtn.addEventListener("click", () => {
      if (this.onBackClick) {
        this.onBackClick();
      }
    });
    titleBarEl.createEl("div", {
      cls: "BetterNotes-title",
      text: this.title || t("collection details")
    });
  }
  /**
   * 渲染导航栏
   */
  renderNavigation() {
    const iconsContainer = this.navContainer.createEl("div", { cls: "BetterNotes-nav-icons" });
    this.navItems.forEach((item) => {
      this.renderNavItem(iconsContainer, item);
    });
  }
  /**
   * 渲染单个导航项
   * @param container 容器元素
   * @param item 导航项数据
   */
  renderNavItem(container, item) {
    const navItemEl = container.createEl("div", { cls: "BetterNotes-nav-item" });
    if (item.active) {
      navItemEl.addClass("active");
    }
    const iconContainer = navItemEl.createEl("div", { cls: "BetterNotes-nav-icon" });
    (0, import_obsidian6.setIcon)(iconContainer, item.icon);
    navItemEl.addEventListener("click", () => {
      this.navItems.forEach((navItem) => {
        navItem.active = navItem.id === item.id;
      });
      if (this.onNavItemClick) {
        this.onNavItemClick(item.id);
      }
      this.render();
    });
  }
  /**
   * 设置激活的导航项
   * @param id 导航项ID
   */
  setActiveNavItem(id) {
    this.navItems.forEach((item) => {
      item.active = item.id === id;
    });
    this.render();
  }
};

// src/components/FolderView.ts
var import_obsidian7 = require("obsidian");
var FolderView = class {
  /**
   * 构造函数
   * @param container 容器元素
   * @param plugin 插件实例
   * @param folder 当前文件夹
   * @param onNavigateBack 返回上一级的回调函数
   * @param onFolderClick 点击子文件夹的回调函数（可选）
   */
  constructor(container, plugin, folder, onNavigateBack, onFolderClick) {
    this.container = container;
    this.plugin = plugin;
    this.currentFolder = folder;
    this.onNavigateBack = onNavigateBack;
    this.onFolderClick = onFolderClick || ((folder2) => this.navigateToSubfolder(folder2));
    this.gridElement = this.container.createEl("div");
    this.gridElement.classList.add("BetterNotes-grid");
  }
  /**
   * 渲染文件夹视图
   */
  render() {
    this.gridElement.empty();
    this.renderBackCard();
    const collections = this.plugin.dataManager.getAllCollections().filter(
      (collection) => collection.parent === this.currentFolder.name
    );
    collections.sort((a2, b4) => a2.name.localeCompare(b4.name));
    collections.forEach((collection) => {
      this.renderCollectionCard(collection);
    });
    this.renderAddCollectionCard();
  }
  /**
   * 渲染返回卡片
   */
  renderBackCard() {
    const backCardEl = this.gridElement.createEl("div");
    backCardEl.classList.add("BetterNotes-card", "BetterNotes-back-card");
    backCardEl.style.backgroundColor = "#f0f0f0";
    const iconContainer = backCardEl.createEl("div", { cls: "BetterNotes-back-icon-container" });
    (0, import_obsidian7.setIcon)(iconContainer, "arrow-left");
    backCardEl.addEventListener("click", () => {
      this.onNavigateBack();
    });
  }
  /**
   * 渲染单个集合卡片
   * @param collection 集合对象
   */
  renderCollectionCard(collection) {
    const cardEl = this.gridElement.createEl("div");
    cardEl.classList.add("BetterNotes-card");
    cardEl.style.backgroundColor = collection.color;
    const card = new CollectionCard(
      cardEl,
      collection,
      this.plugin,
      this.onFolderClick
    );
    card.render();
  }
  /**
   * 导航到子文件夹
   * @param folder 子文件夹集合对象
   */
  navigateToSubfolder(folder) {
    this.onFolderClick(folder);
  }
  /**
   * 渲染添加新集合的卡片
   */
  renderAddCollectionCard() {
    const addCardEl = this.gridElement.createEl("div");
    addCardEl.classList.add("BetterNotes-card", "BetterNotes-add-card");
    addCardEl.style.backgroundColor = "#87CEEB";
    const iconContainer = addCardEl.createEl("div", { cls: "BetterNotes-add-icon-container" });
    (0, import_obsidian7.setIcon)(iconContainer, "plus");
    addCardEl.addEventListener("click", () => {
      this.openCreateCollectionModal();
    });
  }
  /**
   * 打开创建新集合的模态框
   */
  openCreateCollectionModal() {
    const modal = new CollectionModal(this.plugin, {
      mode: "create",
      onConfirm: async (name2, color, type) => {
        try {
          await this.plugin.createCollection(name2, {
            color,
            type,
            parent: this.currentFolder.name
            // 设置父文件夹
          });
          this.render();
        } catch (error2) {
          console.error("\u521B\u5EFA\u96C6\u5408\u5931\u8D25:", error2);
        }
      }
    });
    modal.open();
  }
};

// src/components/EntryCard.ts
var import_obsidian12 = require("obsidian");

// src/components/AnnotationModal.ts
var import_obsidian10 = require("obsidian");
init_AttachmentService();

// src/components/ImageEditorModal.ts
var import_obsidian9 = require("obsidian");
init_i18n();
var ImageEditorModal = class extends import_obsidian9.Modal {
  constructor(plugin, options) {
    super(plugin.app);
    // 状态
    this.scale = 1;
    this.translateX = 0;
    this.translateY = 0;
    this.plugin = plugin;
    this.options = options;
  }
  /**
   * Modal 打开时渲染内容
   */
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    modalEl.style.width = "90vw";
    modalEl.style.height = "90vh";
    modalEl.style.maxWidth = "90vw";
    modalEl.style.maxHeight = "90vh";
    contentEl.style.width = "100%";
    contentEl.style.height = "100%";
    contentEl.style.display = "flex";
    contentEl.style.flexDirection = "column";
    contentEl.style.overflow = "hidden";
    const imgWrapper = contentEl.createDiv();
    imgWrapper.style.flex = "1";
    imgWrapper.style.position = "relative";
    imgWrapper.style.overflow = "hidden";
    const imgEl = imgWrapper.createEl("img");
    imgEl.style.userSelect = "none";
    imgEl.style.pointerEvents = "all";
    imgEl.style.position = "absolute";
    imgEl.style.top = "50%";
    imgEl.style.left = "50%";
    imgEl.style.transform = "translate(-50%, -50%) scale(1)";
    imgEl.style.transformOrigin = "center center";
    imgEl.style.maxWidth = "none";
    imgEl.style.maxHeight = "none";
    imgEl.setAttr("draggable", "false");
    imgEl.addEventListener("dragstart", (e) => e.preventDefault());
    const imageUrl = this.options.imageUrl ?? this.plugin.app.vault.adapter.getResourcePath(this.options.imagePath);
    imgEl.src = imageUrl;
    imgWrapper.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      this.scale = Math.min(10, Math.max(0.1, this.scale + delta));
      this.applyTransform(imgEl);
    });
    imgWrapper.style.cursor = "grab";
    imgWrapper.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      if (e.button !== 0)
        return;
      imgWrapper.style.cursor = "grabbing";
      imgWrapper.setPointerCapture(e.pointerId);
      const onMove = (ev) => {
        this.translateX += ev.movementX;
        this.translateY += ev.movementY;
        this.applyTransform(imgEl);
      };
      const onUp = (ev) => {
        if (ev.pointerId !== e.pointerId)
          return;
        imgWrapper.releasePointerCapture(e.pointerId);
        imgWrapper.style.cursor = "grab";
        imgWrapper.removeEventListener("pointermove", onMove);
        imgWrapper.removeEventListener("pointerup", onUp);
      };
      imgWrapper.addEventListener("pointermove", onMove);
      imgWrapper.addEventListener("pointerup", onUp);
    });
    const btnContainer = contentEl.createDiv();
    btnContainer.style.display = "flex";
    btnContainer.style.justifyContent = "flex-end";
    btnContainer.style.gap = "12px";
    btnContainer.style.marginTop = "8px";
    const closeBtn = btnContainer.createEl("button", { text: t("close") });
    closeBtn.classList.add("BetterNotes-btn");
    closeBtn.addEventListener("click", () => this.close());
    if (this.options.onSave) {
      const saveBtn = btnContainer.createEl("button", { text: t("save") });
      saveBtn.classList.add("BetterNotes-btn", "BetterNotes-btn-primary");
      saveBtn.addEventListener("click", async () => {
        try {
          const dataUrl = await this.convertImgToDataUrl(imgEl);
          await Promise.resolve(this.options.onSave(dataUrl));
          this.close();
        } catch (err2) {
          console.error("[BetterNotes] convert image to DataURL failed", err2);
          new import_obsidian9.Notice(t("save image failed"));
        }
      });
    }
  }
  /**
   * 应用缩放和平移变换
   */
  applyTransform(imgEl) {
    imgEl.style.transform = `translate(-50%, -50%) translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
  }
  /**
   * 将 <img> 元素转换为 DataURL（无编辑功能，因此直接复制原图）
   */
  async convertImgToDataUrl(img) {
    if (!img.complete) {
      await new Promise((res) => {
        img.addEventListener("load", res, { once: true });
      });
    }
    const canvas = document.createElement("canvas");
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext("2d");
    if (!ctx)
      throw new Error(t("cannot get canvas context"));
    ctx.drawImage(img, 0, 0);
    return canvas.toDataURL();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/AnnotationModal.ts
init_i18n();
var AnnotationModal = class extends import_obsidian10.Modal {
  /**
   * 构造函数
   * @param plugin 插件实例
   * @param options 模态框配置选项
   */
  constructor(plugin, options) {
    super(plugin.app);
    this.selectedCollection = "";
    this.comments = "";
    this.tags = [];
    this.attachmentFiles = [];
    // 附件文件路径
    // 待删除的附件文件路径（在点击删除按钮时仅入队，待保存时再真正删除）
    this.attachmentsToDelete = [];
    this.isEditMode = false;
    // 是否为编辑模式
    this.editingEntry = null;
    // 正在编辑的条目
    // 集合列表
    this.collections = [];
    // 所有可用标签
    this.availableTags = [];
    // 图片预览容器
    this.imagesPreviewContainer = null;
    this.plugin = plugin;
    this.options = options;
    this.selectedText = options.selectedText;
    this.attachmentService = new AttachmentService(plugin.app);
    if (options.entry) {
      this.isEditMode = true;
      this.editingEntry = options.entry;
      this.selectedText = options.entry.value;
      this.selectedCollection = options.entry.set;
      this.comments = options.entry.comment || "";
      this.tags = options.entry.tag ? [...options.entry.tag] : [];
      this.attachmentFiles = options.entry.attachmentFile ? [...options.entry.attachmentFile] : [];
    }
    this.loadAvailableTags();
  }
  /**
   * 加载所有可用标签
   * 从现有条目中提取所有已使用的标签
   */
  loadAvailableTags() {
    const tags = this.plugin.dataManager.getAllTags();
    this.availableTags = tags.map((t2) => t2.tagName);
  }
  /**
   * 渲染模态框内容
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("BetterNotes-modal");
    const headerEl = contentEl.createDiv("BetterNotes-modal-header");
    const formEl = contentEl.createDiv("BetterNotes-modal-form");
    const valueContainer = formEl.createDiv("BetterNotes-input-container");
    valueContainer.createEl("label", { text: t("Front") });
    const valueInput = valueContainer.createEl("textarea");
    valueInput.classList.add("BetterNotes-input");
    valueInput.style.minHeight = "60px";
    valueInput.style.resize = "vertical";
    valueInput.value = this.selectedText;
    valueInput.addEventListener("input", () => {
      this.selectedText = valueInput.value;
    });
    this.collections = this.plugin.dataManager.getAllCollections().filter((c2) => c2.type === "set").sort((a2, b4) => a2.name.localeCompare(b4.name));
    const collectionContainer = formEl.createDiv("BetterNotes-input-container");
    collectionContainer.createEl("label", { text: t("Collection") });
    const collectionTagsContainer = collectionContainer.createDiv("BetterNotes-folder-tags-container");
    this.collections.forEach((collection) => {
      const collectionTag = collectionTagsContainer.createDiv("BetterNotes-folder-tag");
      const collectionColor = collection.color;
      collectionTag.style.backgroundColor = this.adjustColorOpacity(collectionColor, 0.2);
      collectionTag.style.borderColor = collectionColor;
      const collectionIconEl = collectionTag.createSpan("BetterNotes-folder-tag-icon");
      (0, import_obsidian10.setIcon)(collectionIconEl, "note");
      collectionIconEl.style.color = collectionColor;
      collectionTag.createSpan("BetterNotes-folder-tag-name").setText(collection.name);
      if (this.isEditMode && this.selectedCollection === collection.name) {
        collectionTag.classList.add("selected");
      }
      collectionTag.addEventListener("click", () => {
        document.querySelectorAll(".BetterNotes-folder-tag").forEach((el) => {
          el.classList.remove("selected");
        });
        collectionTag.classList.add("selected");
        this.selectedCollection = collection.name;
      });
    });
    const commentsContainer = formEl.createDiv("BetterNotes-input-container");
    commentsContainer.createEl("label", { text: t("Back") });
    const commentsInput = commentsContainer.createEl("textarea", {
      placeholder: t("add your comments...")
    });
    commentsInput.classList.add("BetterNotes-input");
    commentsInput.style.minHeight = "80px";
    commentsInput.style.resize = "vertical";
    if (this.isEditMode && this.comments) {
      commentsInput.value = this.comments;
    }
    commentsInput.addEventListener("input", () => {
      this.comments = commentsInput.value;
    });
    commentsInput.addEventListener("paste", async (e) => {
      if (e.clipboardData && e.clipboardData.files.length > 0) {
        const imagePaths = await this.attachmentService.handlePastedImages(e);
        if (imagePaths.length > 0) {
          this.attachmentFiles = [...this.attachmentFiles, ...imagePaths];
          this.renderImagePreviews(formEl);
          new import_obsidian10.Notice(t("added") + " " + imagePaths.length + " " + t("images"));
        }
      }
    });
    this.imagesPreviewContainer = formEl.createDiv("BetterNotes-images-preview-container");
    this.imagesPreviewContainer.style.display = "none";
    if (this.isEditMode && this.attachmentFiles.length > 0) {
      this.renderImagePreviews(formEl);
    }
    const tagsContainer = formEl.createDiv("BetterNotes-input-container");
    tagsContainer.createEl("label", { text: t("Tags") });
    const tagsGridContainer = tagsContainer.createDiv("BetterNotes-tags-grid-container");
    this.renderAvailableTags(tagsGridContainer);
    const customTagContainer = tagsContainer.createDiv("BetterNotes-custom-tag-container");
    const customTagInput = customTagContainer.createEl("input", {
      type: "text",
      placeholder: t("add custom tags...")
    });
    customTagInput.classList.add("BetterNotes-input");
    const addTagBtn = customTagContainer.createEl("button", { text: t("add") });
    addTagBtn.classList.add("BetterNotes-btn");
    addTagBtn.addEventListener("click", () => {
      const tag = customTagInput.value.trim();
      if (tag) {
        if (!this.availableTags.includes(tag)) {
          this.plugin.dataManager.ensureTag(tag);
          this.availableTags.push(tag);
          this.availableTags.sort();
          tagsGridContainer.empty();
          this.renderAvailableTags(tagsGridContainer);
        }
        if (!this.tags.includes(tag)) {
          this.tags.push(tag);
          const tagElements = tagsGridContainer.querySelectorAll(".BetterNotes-tag");
          tagElements.forEach((el) => {
            if (el.textContent === tag) {
              el.classList.add("selected");
            }
          });
        }
        customTagInput.value = "";
      }
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.classList.add("BetterNotes-modal-buttons");
    const cancelButton = buttonContainer.createEl("button", { text: t("cancel") });
    cancelButton.classList.add("BetterNotes-btn");
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: this.isEditMode ? t("save changes") : t("save annotation")
    });
    confirmButton.classList.add("BetterNotes-btn", "BetterNotes-btn-primary");
    confirmButton.addEventListener("click", () => {
      if (this.selectedCollection) {
        const entry = {
          value: this.selectedText.trim() || "",
          set: this.selectedCollection,
          comment: this.comments,
          tag: this.tags,
          sourceFile: this.options.sourcePath,
          attachmentFile: this.attachmentFiles
          // 附件文件路径
        };
        if (!this.isEditMode) {
          entry.type = "md";
        }
        if (this.isEditMode && this.editingEntry) {
          entry.hash = this.editingEntry.hash;
          entry.type = this.editingEntry.type;
        }
        this.options.onConfirm(entry).then(async () => {
          await this.deleteMarkedAttachments();
          this.close();
        }).catch((error2) => {
          console.error("\u4FDD\u5B58\u6807\u6CE8\u5931\u8D25:", error2);
          const errorMsg = formEl.createEl("div", {
            text: t("save failed") + ": " + error2.message,
            cls: "BetterNotes-error"
          });
          setTimeout(() => {
            errorMsg.remove();
          }, 2e3);
        });
      } else {
        const errorMsg = formEl.createEl("div", {
          text: t("please select a collection"),
          cls: "BetterNotes-error"
        });
        setTimeout(() => {
          errorMsg.remove();
        }, 2e3);
      }
    });
  }
  /**
   * 渲染图片预览
   * @param container 容器元素
   */
  renderImagePreviews(container) {
    if (!this.imagesPreviewContainer)
      return;
    this.imagesPreviewContainer.empty();
    if (this.attachmentFiles.length === 0) {
      this.imagesPreviewContainer.style.display = "none";
      return;
    }
    this.imagesPreviewContainer.style.display = "flex";
    const gridEl = this.imagesPreviewContainer.createDiv("BetterNotes-images-preview-grid");
    this.attachmentFiles.forEach((path2, index) => {
      const previewItem = gridEl.createDiv("BetterNotes-image-preview-item");
      const imageContainer = previewItem.createDiv("BetterNotes-image-container");
      const imgEl = imageContainer.createEl("img", {
        cls: "BetterNotes-preview-image",
        attr: {
          src: this.plugin.app.vault.adapter.getResourcePath(path2),
          alt: t("attachment image") + " " + (index + 1)
        }
      });
      imgEl.addEventListener("click", () => {
        const viewerModal = new ImageEditorModal(this.plugin, { imagePath: path2 });
        viewerModal.open();
      });
      const deleteBtn = previewItem.createDiv("BetterNotes-image-delete-btn");
      (0, import_obsidian10.setIcon)(deleteBtn, "trash");
      deleteBtn.addEventListener("click", () => {
        const normPath = path2.startsWith("/") ? path2.slice(1) : path2;
        if (!this.attachmentsToDelete.includes(normPath)) {
          this.attachmentsToDelete.push(normPath);
        }
        this.attachmentFiles = this.attachmentFiles.filter((p5) => p5 !== path2 && p5 !== normPath);
        this.renderImagePreviews(container);
      });
      const pathEl = previewItem.createDiv("BetterNotes-image-path");
      pathEl.setText(path2);
    });
  }
  /**
   * 渲染所有可用标签
   * @param container 标签容器元素
   */
  renderAvailableTags(container) {
    const tagsGrid = container.createDiv("BetterNotes-tags-grid");
    this.availableTags.forEach((tag) => {
      const tagEl = tagsGrid.createDiv("BetterNotes-tag");
      tagEl.setText(tag);
      if (this.tags.includes(tag)) {
        tagEl.classList.add("selected");
      }
      tagEl.addEventListener("click", () => {
        if (tagEl.classList.contains("selected")) {
          tagEl.classList.remove("selected");
          this.tags = this.tags.filter((t2) => t2 !== tag);
        } else {
          tagEl.classList.add("selected");
          if (!this.tags.includes(tag)) {
            this.tags.push(tag);
          }
        }
      });
    });
  }
  /**
   * 调整颜色的透明度
   * @param color 原始颜色（十六进制格式）
   * @param opacity 目标透明度（0-1之间）
   * @returns 调整透明度后的颜色（rgba格式）
   */
  adjustColorOpacity(color, opacity) {
    const hex = color.replace("#", "");
    const r = parseInt(hex.substring(0, 2), 16);
    const g5 = parseInt(hex.substring(2, 4), 16);
    const b4 = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g5}, ${b4}, ${opacity})`;
  }
  /**
   * 关闭模态框
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 真正执行已标记的附件删除操作
   */
  async deleteMarkedAttachments() {
    if (this.attachmentsToDelete.length === 0)
      return;
    for (const p5 of this.attachmentsToDelete) {
      try {
        const file = this.plugin.app.vault.getAbstractFileByPath(p5);
        if (file instanceof import_obsidian10.TFile) {
          await this.plugin.app.vault.delete(file);
        }
      } catch (e) {
        console.error("\u5220\u9664\u9644\u4EF6\u6587\u4EF6\u5931\u8D25:", e);
      }
    }
    this.attachmentsToDelete = [];
  }
};

// src/components/EntryCard.ts
init_AttachmentService();

// src/components/LinkedEntriesModal.ts
var import_obsidian11 = require("obsidian");
init_utils();
init_i18n();
var LinkedEntriesModal = class extends import_obsidian11.Modal {
  /**
   * 构造函数
   * @param plugin BetterNotes插件实例
   * @param entry 当前条目
   */
  constructor(plugin, entry) {
    super(plugin.app);
    this.plugin = plugin;
    this.entry = entry;
  }
  /**
   * 模态框打开时调用
   * 渲染模态框内容
   */
  onOpen() {
    const { contentEl } = this;
    const entryInfoEl = contentEl.createDiv({ cls: "BetterNotes-linked-entry-info" });
    const currentCollection = this.plugin.dataManager.getCollection(this.entry.set);
    const currentColor = currentCollection ? currentCollection.color : "#7F7F7F";
    const currentEntryEl = entryInfoEl.createDiv({ cls: "BetterNotes-current-entry" });
    currentEntryEl.createEl("div", { text: t("current entry") });
    const currentEntryCard = currentEntryEl.createDiv({ cls: "BetterNotes-modal-entry-card" });
    currentEntryCard.style.borderLeft = `4px solid ${currentColor}`;
    currentEntryCard.style.backgroundColor = hexToRgba(currentColor, 0.1);
    currentEntryCard.createEl("div", {
      cls: "BetterNotes-modal-entry-value",
      text: this.entry.value
    });
    if (this.entry.comment) {
      currentEntryCard.createEl("div", {
        cls: "BetterNotes-modal-entry-comment",
        text: this.entry.comment
      });
    }
    const linkedEntries = this.plugin.internalLinkService.getLinkedEntries(this.entry.hash);
    const linkedEntriesEl = contentEl.createDiv({ cls: "BetterNotes-linked-entries" });
    linkedEntriesEl.createEl("div", {
      text: `${t("linked entries")} (${linkedEntries.length})`,
      cls: "BetterNotes-linked-entries-title"
    });
    if (linkedEntries.length === 0) {
      linkedEntriesEl.createEl("div", {
        cls: "BetterNotes-no-linked-entries",
        text: t("no linked entries")
      });
    } else {
      const linkedEntriesList = linkedEntriesEl.createDiv({ cls: "BetterNotes-linked-entries-list" });
      linkedEntries.forEach((linkedEntry) => {
        const linkedEntryCard = linkedEntriesList.createDiv({ cls: "BetterNotes-linked-entry-card" });
        const linkedCollection = this.plugin.dataManager.getCollection(linkedEntry.set);
        const linkedColor = linkedCollection ? linkedCollection.color : "#7F7F7F";
        linkedEntryCard.style.borderLeft = `4px solid ${linkedColor}`;
        linkedEntryCard.style.backgroundColor = hexToRgba(linkedColor, 0.1);
        linkedEntryCard.createEl("div", {
          cls: "BetterNotes-linked-entry-value",
          text: linkedEntry.value
        });
        if (linkedEntry.comment) {
          linkedEntryCard.createEl("div", {
            cls: "BetterNotes-linked-entry-comment",
            text: linkedEntry.comment
          });
        }
        const actionArea = linkedEntryCard.createDiv({ cls: "BetterNotes-linked-entry-actions" });
        const navBtn = actionArea.createDiv({ cls: "BetterNotes-linked-entry-action" });
        (0, import_obsidian11.setIcon)(navBtn, "arrow-right");
        navBtn.setAttribute("aria-label", t("navigate to entry"));
        navBtn.addEventListener("click", () => {
          this.navigateToEntry(linkedEntry);
        });
        const unlinkBtn = actionArea.createDiv({ cls: "BetterNotes-linked-entry-action" });
        (0, import_obsidian11.setIcon)(unlinkBtn, "unlink");
        unlinkBtn.setAttribute("aria-label", t("remove link"));
        unlinkBtn.addEventListener("click", () => {
          this.removeLink(linkedEntry);
        });
      });
    }
    const footerEl = contentEl.createDiv({ cls: "BetterNotes-modal-footer" });
    new import_obsidian11.ButtonComponent(footerEl).setButtonText(t("close")).onClick(() => {
      this.close();
    });
  }
  /**
   * 模态框关闭时调用
   * 清理模态框内容
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 导航到指定条目
   * @param entry 要导航到的条目
   */
  async navigateToEntry(entry) {
    this.close();
    await this.plugin.entryNavigation.navigateToEntry(entry);
  }
  /**
   * 移除与指定条目的链接关系
   * @param linkedEntry 要移除链接的条目
   */
  async removeLink(linkedEntry) {
    try {
      const result = await this.plugin.internalLinkService.removeBidirectionalLink(
        this.entry.hash,
        linkedEntry.hash
      );
      if (result) {
        this.close();
        const modal = new LinkedEntriesModal(this.plugin, this.entry);
        modal.open();
      }
    } catch (error2) {
      console.error("\u79FB\u9664\u94FE\u63A5\u5931\u8D25:", error2);
      new import_obsidian11.Notice(t("remove link failed"));
    }
  }
};

// src/components/EntryCard.ts
init_utils();
init_i18n();
var EntryCard = class {
  /**
   * 构造函数
   * @param container 容器元素
   * @param entry 条目对象
   * @param plugin 插件实例
   * @param collection 所属集合
   */
  constructor(container, entry, plugin, collection) {
    this.container = container;
    this.entry = entry;
    this.plugin = plugin;
    this.collection = collection;
  }
  /**
   * 渲染卡片内容
   */
  render() {
    this.container.empty();
    this.container.setAttr("draggable", "true");
    this.container.addEventListener("dragstart", (ev) => {
      const dt2 = ev.dataTransfer;
      dt2.setData("text/BetterNotes-entry", this.entry.hash);
      dt2.effectAllowed = "copy";
    });
    this.container.style.backgroundColor = hexToRgba(this.collection.color, 0.7);
    this.container.setAttribute("data-entry-hash", this.entry.hash);
    const contentArea = this.container.createEl("div", { cls: "BetterNotes-entry-content-area" });
    const contentEl = contentArea.createEl("div", { cls: "BetterNotes-entry-content" });
    contentEl.setText(this.entry.value);
    if (this.entry.comment) {
      const commentEl = contentArea.createEl("div", { cls: "BetterNotes-entry-comment" });
      commentEl.setText(this.entry.comment);
    }
    if (this.entry.attachmentFile && this.entry.attachmentFile.length > 0) {
      const imageAttachments = this.entry.attachmentFile.filter((p5) => this.isImageFile(p5));
      if (imageAttachments.length > 0) {
        const attachmentsEl = contentArea.createEl("div", { cls: "BetterNotes-entry-attachments" });
        const isPdfRectEntry = this.entry.type === "pdf" && this.entry.index?.includes("rect=");
        const isVideoTimestampEntry = this.entry.type === "video" && this.entry.index?.includes("timestamp&&&");
        imageAttachments.forEach((path2, index) => {
          const isFullWidthImage = (isPdfRectEntry || isVideoTimestampEntry) && index === 0;
          const thumbEl = attachmentsEl.createEl("img", {
            cls: isFullWidthImage ? "BetterNotes-attachment-fullwidth" : "BetterNotes-attachment-thumb",
            attr: {
              src: this.plugin.app.vault.adapter.getResourcePath(path2),
              alt: t("attachment image")
            }
          });
          thumbEl.addEventListener("click", (e) => {
            e.stopPropagation();
            this.openImageEditor(path2);
          });
        });
      }
    }
    if (this.entry.tag && this.entry.tag.length > 0) {
      const tagsEl = contentArea.createEl("div", { cls: "BetterNotes-entry-tags" });
      this.entry.tag.forEach((t2) => {
        const tagEl = tagsEl.createSpan("BetterNotes-entry-tag");
        tagEl.setText("#" + t2);
        tagEl.setAttr("draggable", "true");
        tagEl.addEventListener("dragstart", (ev) => {
          ev.dataTransfer?.setData("text/BetterNotes-tag", t2);
          ev.dataTransfer.effectAllowed = "copy";
        });
        tagEl.addEventListener("click", async (e) => {
          e.stopPropagation();
          await this.plugin.activateSidebarView();
          this.plugin.sidebarView?.goHome();
          this.plugin.sidebarView?.getSearchBar()?.setSearch("#" + t2);
        });
      });
    }
    const bottomArea = this.container.createEl("div", { cls: "BetterNotes-entry-bottom-area" });
    const actionsEl = bottomArea.createEl("div", { cls: "BetterNotes-entry-actions" });
    const editBtn = actionsEl.createEl("div", { cls: "BetterNotes-entry-action" });
    (0, import_obsidian12.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openEditEntryModal();
    });
    const annotationBtn = actionsEl.createEl("div", { cls: "BetterNotes-entry-action" });
    (0, import_obsidian12.setIcon)(annotationBtn, "message-square");
    annotationBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openInlineCommentEditor(contentArea, annotationBtn);
    });
    const linkActionBtn = actionsEl.createEl("div", { cls: "BetterNotes-entry-action" });
    (0, import_obsidian12.setIcon)(linkActionBtn, "download");
    linkActionBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.plugin.linkService.showLinkMenu(this.entry, linkActionBtn);
    });
    const internalLinkBtn = actionsEl.createEl("div", { cls: "BetterNotes-entry-action" });
    (0, import_obsidian12.setIcon)(internalLinkBtn, "link-2");
    if (this.entry.link && this.entry.link.length > 0) {
      const linkCountBadge = internalLinkBtn.createSpan({ cls: "BetterNotes-link-count-badge" });
      linkCountBadge.setText(this.entry.link.length.toString());
    }
    internalLinkBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openLinkedEntriesModal();
    });
    const deleteBtn = actionsEl.createEl("div", { cls: "BetterNotes-entry-action" });
    (0, import_obsidian12.setIcon)(deleteBtn, "trash");
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openDeleteEntryConfirm();
    });
    const infoEl = bottomArea.createEl("div", { cls: "BetterNotes-entry-info" });
    const typeEl = infoEl.createEl("div", { cls: "BetterNotes-entry-type" });
    const typeBadge = typeEl.createEl("span", { cls: "BetterNotes-type-badge" });
    switch (this.entry.type) {
      case "md":
        typeBadge.setText("M");
        break;
      case "video":
        typeBadge.setText("V");
        break;
      case "pdf":
        typeBadge.setText("P");
        break;
      case "image":
        typeBadge.setText("I");
        break;
      default:
        typeBadge.setText(String(this.entry.type).charAt(0).toUpperCase());
    }
    typeBadge.classList.add(`BetterNotes-type-${this.entry.type}`);
    this.container.addEventListener("click", (e) => {
      if (!e.target.closest(".BetterNotes-entry-action")) {
        this.naviToEntry();
      }
    });
    this.container.addEventListener("contextmenu", async (e) => {
      e.preventDefault();
      if (this.plugin.internalLinkService) {
        await this.plugin.internalLinkService.handleEntryRightClick(this.entry);
      }
    });
    const sourceHash = this.plugin.internalLinkService?.getLinkingSourceHash();
    if (sourceHash && sourceHash === this.entry.hash) {
      this.container.classList.add("BetterNotes-linking-source");
    }
  }
  /**
   * 打开链接模态框
   * 显示与当前条目相关的链接
   */
  openLinkedEntriesModal() {
    const modal = new LinkedEntriesModal(this.plugin, this.entry);
    modal.open();
  }
  /**
   * 打开编辑条目模态框
   * 使用AnnotationModal进行编辑
   */
  openEditEntryModal() {
    const modal = new AnnotationModal(this.plugin, {
      selectedText: this.entry.value,
      sourcePath: this.entry.sourceFile || "",
      entry: this.entry,
      // 传入现有条目
      onConfirm: async (updatedEntry) => {
        try {
          await this.plugin.updateEntry(this.entry.hash, updatedEntry);
          await this.plugin.refreshViews();
          return Promise.resolve();
        } catch (error2) {
          console.error("\u66F4\u65B0\u6761\u76EE\u5931\u8D25:", error2);
          return Promise.reject(error2);
        }
      }
    });
    modal.open();
  }
  /**
   * 打开删除条目确认对话框
   */
  openDeleteEntryConfirm() {
    this.deleteEntry();
  }
  /**
   * 删除当前条目
   */
  async deleteEntry() {
    try {
      const result = await this.plugin.deleteEntry(this.entry.hash);
      if (result) {
        this.container.style.opacity = "0";
        this.container.style.height = "0";
        setTimeout(() => {
          this.container.remove();
        }, 300);
      }
    } catch (error2) {
      console.error("\u5220\u9664\u6761\u76EE\u5931\u8D25:", error2);
    }
  }
  /**
   * 
   * 跳转到条目在文档中的位置并高亮显示
   */
  async naviToEntry() {
    const entryNavigation = this.plugin.entryNavigation;
    if (entryNavigation) {
      await entryNavigation.navigateToEntry(this.entry);
    } else {
      console.error("\u5BFC\u822A\u670D\u52A1\u672A\u521D\u59CB\u5316");
    }
  }
  /**
   * 截断字符串
   * @param str 原字符串
   * @param maxLength 最大长度
   * @returns 截断后的字符串
   */
  truncateString(str, maxLength) {
    return str.length > maxLength ? str.substring(0, maxLength) + "..." : str;
  }
  /**
   * 判断路径是否为常见图片文件
   * @param path 文件路径
   */
  isImageFile(path2) {
    return /\.(png|jpe?g|gif|bmp|webp|svg)$/i.test(path2);
  }
  /**
   * 打开图片编辑器，并在保存后替换原附件文件，同时更新 Entry 数据并刷新视图
   * @param imagePath 图片在 Vault 中的路径
   */
  openImageEditor(imagePath) {
    const viewerModal = new ImageEditorModal(this.plugin, { imagePath });
    viewerModal.open();
  }
  /**
   * 打开/显示批注的内联编辑器
   * @param contentArea 条目主体内容区域 DOM 元素
   * @param triggerBtn 触发按钮，用于在编辑状态时禁用
   */
  openInlineCommentEditor(contentArea, triggerBtn) {
    if (contentArea.querySelector(".BetterNotes-inline-comment-editor")) {
      return;
    }
    const existingComment = contentArea.querySelector(".BetterNotes-entry-comment");
    if (existingComment)
      existingComment.style.display = "none";
    triggerBtn.addClass("disabled");
    const textarea = existingComment ? existingComment.parentElement.insertBefore(document.createElement("textarea"), existingComment) : contentArea.appendChild(document.createElement("textarea"));
    textarea.classList.add("BetterNotes-inline-comment-editor");
    textarea.value = this.entry.comment || "";
    setTimeout(() => {
      textarea.focus();
      const len = textarea.value.length;
      textarea.setSelectionRange(len, len);
    }, 0);
    const autoResize = () => {
      textarea.style.height = "auto";
      textarea.style.height = textarea.scrollHeight + "px";
    };
    autoResize();
    textarea.addEventListener("input", autoResize);
    const stop2 = (ev) => ev.stopPropagation();
    textarea.addEventListener("click", stop2);
    textarea.addEventListener("mousedown", stop2);
    textarea.addEventListener("mouseup", stop2);
    textarea.addEventListener("keydown", stop2);
    textarea.addEventListener("keydown", async (ev) => {
      if (ev.key === "Enter" && !ev.shiftKey) {
        ev.preventDefault();
        await saveAndRender();
      }
    });
    textarea.addEventListener("blur", async () => {
      await saveAndRender();
    });
    const saveAndRender = async () => {
      const newComment = textarea.value.trim();
      if (newComment === (this.entry.comment || "")) {
        this.render();
        return;
      }
      try {
        const updated = await this.plugin.updateEntry(this.entry.hash, { comment: newComment });
        this.entry = updated;
        this.render();
      } catch (err2) {
        console.error(err2);
      }
    };
    if (existingComment)
      existingComment.remove();
    const attachmentService = new AttachmentService(this.plugin.app);
    textarea.addEventListener("paste", async (e) => {
      if (!e.clipboardData)
        return;
      const hasImage = Array.from(e.clipboardData.files).some((f3) => f3.type.startsWith("image/"));
      if (!hasImage)
        return;
      e.preventDefault();
      const imagePaths = await attachmentService.handlePastedImages(e);
      if (imagePaths.length > 0) {
        const merged = [...this.entry.attachmentFile || [], ...imagePaths];
        const updated = await this.plugin.updateEntry(this.entry.hash, { attachmentFile: merged });
        this.entry = updated;
        this.render();
      }
    });
  }
};

// src/components/TitleBar.ts
var import_obsidian13 = require("obsidian");
var TitleBar = class {
  /**
   * 构造函数
   * @param parent 父级容器
   * @param title 标题文本
   * @param onBack 点击返回回调
   */
  constructor(parent, title, onBack) {
    this.container = parent.createEl("div", { cls: "BetterNotes-titlebar" });
    this.title = title;
    this.onBack = onBack;
    this.render();
  }
  /** 渲染标题栏 */
  render() {
    this.container.empty();
    const backBtn = this.container.createEl("div", { cls: "BetterNotes-back-button" });
    (0, import_obsidian13.setIcon)(backBtn, "arrow-left");
    backBtn.addEventListener("click", () => {
      this.onBack();
    });
    this.container.createEl("div", { cls: "BetterNotes-title", text: this.title });
  }
  /** 更新标题 */
  setTitle(title) {
    this.title = title;
    this.render();
  }
};

// src/components/EntryListView.ts
var EntryListView = class {
  /**
   * 构造函数
   * @param container 容器元素
   * @param collection 集合对象
   * @param plugin 插件实例
   * @param onBackClick 返回按钮点击回调
   */
  constructor(container, collection, plugin, onBackClick) {
    this.entries = [];
    this.container = container;
    this.collection = collection;
    this.plugin = plugin;
    this.onBackClick = onBackClick;
    this.entries = this.plugin.dataManager.getEntriesBySet(collection.name);
    this.navBar = new TitleBar(this.container, collection.name, this.onBackClick);
    this.contentContainer = this.container.createEl("div", { cls: "BetterNotes-entry-list-container" });
  }
  /**
   * 渲染条目列表
   */
  render() {
    this.contentContainer.empty();
    if (this.entries.length === 0) {
      this.renderEmptyState();
      return;
    }
    const listContainer = this.contentContainer.createEl("div", { cls: "BetterNotes-entries-container" });
    const sortedEntries = [...this.entries].sort((a2, b4) => {
      return new Date(a2.expireTime).getTime() - new Date(b4.expireTime).getTime();
    });
    sortedEntries.forEach((entry) => {
      this.renderEntryCard(listContainer, entry);
    });
  }
  /**
   * 渲染单个条目卡片
   * @param container 父容器元素
   * @param entry 条目对象
   */
  renderEntryCard(container, entry) {
    const cardEl = container.createEl("div", {
      cls: "BetterNotes-entry-item"
    });
    const entryCard = new EntryCard(cardEl, entry, this.plugin, this.collection);
    entryCard.render();
    if (entry.sourceFile) {
      cardEl.classList.add("BetterNotes-entry-navigable");
    }
  }
  /**
   * 渲染空状态
   */
  renderEmptyState() {
    const emptyStateEl = this.contentContainer.createEl("div", {
      cls: "BetterNotes-empty-state"
    });
  }
  /**
   * 刷新视图
   */
  refresh() {
    this.entries = this.plugin.dataManager.getEntriesBySet(this.collection.name);
    this.render();
  }
};

// src/components/SearchBar.ts
init_i18n();
var SearchBar = class {
  constructor(parent, plugin, sidebarView) {
    // debounce handler
    this.debounceTimer = null;
    this.parent = parent;
    this.plugin = plugin;
    this.sidebarView = sidebarView;
    this.render();
  }
  /**
   * 创建并渲染搜索栏 UI
   */
  render() {
    const bar = this.parent.createDiv("BetterNotes-search-bar");
    this.inputEl = bar.createEl("input", {
      cls: "BetterNotes-search-input",
      attr: {
        type: "text"
      }
    });
    this.updatePlaceholder();
    this.resultContainer = this.parent.createDiv("BetterNotes-search-result-list");
    this.inputEl.addEventListener("input", () => this.scheduleSearch());
  }
  /**
   * 在 150ms 内防抖执行搜索
   */
  scheduleSearch() {
    if (this.debounceTimer)
      window.clearTimeout(this.debounceTimer);
    this.debounceTimer = window.setTimeout(() => {
      this.debounceTimer = null;
      this.performSearch();
    }, 150);
  }
  /**
   * 执行搜索并渲染结果
   */
  performSearch() {
    const keywordRaw = this.inputEl.value.trim();
    if (keywordRaw.length < 2) {
      this.resultContainer.empty();
      return;
    }
    const words = keywordRaw.split(/\s+/).filter(Boolean);
    const tagTokens = words.filter((w6) => w6.startsWith("#")).map((t2) => t2.slice(1).toLowerCase());
    const textKeyword = words.filter((w6) => !w6.startsWith("#")).join(" ").toLowerCase();
    const candidates = this.getEntriesByContext();
    const matched = [];
    for (const entry of candidates) {
      const entryTagsLower = (entry.tag || []).map((t2) => t2.replace(/^#/, "").toLowerCase());
      const hasAllTags = tagTokens.every((t2) => entryTagsLower.includes(t2));
      if (!hasAllTags)
        continue;
      if (textKeyword.length === 0) {
        matched.push(entry);
      } else {
        const haystack = ((entry.value || "") + " " + (entry.comment || "") + " " + entryTagsLower.join(" ")).toLowerCase();
        if (haystack.includes(textKeyword)) {
          matched.push(entry);
        }
      }
    }
    this.renderResults(matched, textKeyword.length ? textKeyword : keywordRaw);
  }
  /**
   * 根据 SidebarView 的上下文返回候选条目数组
   * 规则：
   *  - comments 视图：当前活动文件中的条目
   *  - home 根目录：所有集合条目
   *  - home>folderX：folderX 及其子文件夹下所有集合的条目
   */
  getEntriesByContext() {
    const viewType = this.sidebarView.getCurrentView?.() ?? "home";
    if (viewType === "comments") {
      const activeFile = this.plugin.app.workspace.getActiveFile();
      if (!activeFile)
        return [];
      return this.plugin.dataManager.getEntriesBySourceFile(activeFile.path);
    }
    const collection = this.sidebarView.getCurrentCollection?.();
    if (collection) {
      return this.plugin.dataManager.getEntriesBySet(collection.name);
    }
    const folder = this.sidebarView.getCurrentFolder?.();
    if (!folder) {
      return this.plugin.dataManager.getAllEntries();
    }
    const allowedSets = this.collectSetsUnderFolder(folder.name);
    const allowedSetSet = new Set(allowedSets);
    return this.plugin.dataManager.getAllEntries().filter((e) => allowedSetSet.has(e.set));
  }
  /**
   * 递归收集指定文件夹下所有 set 集合名称
   */
  collectSetsUnderFolder(folderName) {
    const collections = this.plugin.dataManager.getAllCollections();
    const result = [];
    const dfs = (name2) => {
      for (const c2 of collections) {
        if (c2.parent === name2) {
          if (c2.type === "set")
            result.push(c2.name);
          else if (c2.type === "folder")
            dfs(c2.name);
        }
      }
    };
    dfs(folderName);
    return result;
  }
  /**
   * 渲染搜索结果列表
   * @param entries 命中条目
   * @param keyword 原始关键字（保持大小写，用于高亮）
   */
  renderResults(entries, keyword) {
    this.resultContainer.empty();
    if (entries.length === 0) {
      this.resultContainer.createDiv({ text: t("no matching results"), cls: "BetterNotes-search-empty" });
      return;
    }
    const regex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
    entries.forEach((entry) => {
      const item = this.resultContainer.createDiv("BetterNotes-search-result-item");
      const snippet = this.buildContextSnippet(entry, keyword, this.plugin.settings.snippetContext);
      const snippetEl = item.createDiv("BetterNotes-search-snippet");
      snippetEl.innerHTML = this.highlight(snippet, regex);
      const metaEl = item.createDiv("BetterNotes-search-meta");
      metaEl.setText(`${entry.set} \xB7 ${entry.sourceFile}`);
      const collection = this.plugin.dataManager.getCollection(entry.set);
      if (collection) {
        item.style.backgroundColor = this.hexToRgba(collection.color, 0.6);
      }
      item.addEventListener("click", async () => {
        try {
          await this.plugin.entryNavigation.navigateToEntry(entry);
          await this.plugin.activateSidebarView?.();
          this.sidebarView.openCommentsViewAndHighlightEntry(entry);
          this.sidebarView.getSearchBar()?.updatePlaceholder();
        } catch (e) {
          console.error(t("search result jump failed"), e);
        }
      });
    });
  }
  /**
   * 高亮 keyword
   */
  highlight(text, regex) {
    return text.replace(regex, (match) => `<mark>${match}</mark>`);
  }
  /**
   * 构建包含匹配关键字的上下文片段（前后各 contextLen 字）
   */
  buildContextSnippet(entry, keyword, contextLen) {
    const keywordLower = keyword.toLowerCase();
    const fields = [
      { text: entry.value, label: "" },
      { text: entry.comment || "", label: "" }
    ];
    for (const field of fields) {
      const idx = field.text.toLowerCase().indexOf(keywordLower);
      if (idx !== -1) {
        const start2 = Math.max(0, idx - contextLen);
        const end = Math.min(field.text.length, idx + keyword.length + contextLen);
        let snippet = field.text.substring(start2, end);
        if (start2 > 0)
          snippet = "\u2026" + snippet;
        if (end < field.text.length)
          snippet = snippet + "\u2026";
        return snippet;
      }
    }
    if (entry.tag && entry.tag.length > 0) {
      const joined = entry.tag.join(" ");
      const idx = joined.toLowerCase().indexOf(keywordLower);
      if (idx !== -1) {
        const start2 = Math.max(0, idx - contextLen);
        const end = Math.min(joined.length, idx + keyword.length + contextLen);
        let snippet = joined.substring(start2, end);
        if (start2 > 0)
          snippet = "\u2026" + snippet;
        if (end < joined.length)
          snippet += "\u2026";
        return snippet;
      }
    }
    return entry.value.substring(0, contextLen * 2) + "\u2026";
  }
  /** RGBA helper */
  hexToRgba(hex, alpha) {
    hex = hex.replace("#", "");
    const r = parseInt(hex.substring(0, 2), 16);
    const g5 = parseInt(hex.substring(2, 4), 16);
    const b4 = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r},${g5},${b4},${alpha})`;
  }
  /**
   * 根据 SidebarView 上下文更新输入框 placeholder
   */
  updatePlaceholder() {
    if (!this.inputEl)
      return;
    const view = this.sidebarView.getCurrentView?.() ?? "home";
    let placeholder;
    if (view === "comments") {
      placeholder = t("current search range: this file");
    } else {
      const collection = this.sidebarView.getCurrentCollection?.();
      if (collection) {
        placeholder = t("current search range: this collection");
      } else {
        const folder = this.sidebarView.getCurrentFolder?.();
        if (!folder) {
          placeholder = t("current search range: all collections");
        } else {
          placeholder = t("current search range: all collections in this folder");
        }
      }
    }
    this.inputEl.placeholder = placeholder;
  }
  /**
   * 外部调用：设置搜索框内容并立即执行搜索
   */
  setSearch(text) {
    if (!this.inputEl)
      return;
    this.inputEl.value = text;
    this.scheduleSearch();
  }
};

// src/components/PlanCard.ts
var import_obsidian15 = require("obsidian");

// src/components/PlanModal.ts
var import_obsidian14 = require("obsidian");
init_i18n();
var PlanModal = class extends import_obsidian14.Modal {
  constructor(plugin, options) {
    super(plugin.app);
    this.name = "";
    this.intervals = [0, 0, 0, 0, 0, 0];
    this.min = 45;
    this.max = 90;
    this.fsrs = false;
    this.plugin = plugin;
    this.options = options;
    if (options.mode === "edit" && options.plan) {
      this.name = options.plan.name;
      this.intervals = [...options.plan.intervals];
      this.min = options.plan.min;
      this.max = options.plan.max;
      this.fsrs = options.plan.fsrs;
    }
  }
  /**
   * 渲染模态框内容
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("BetterNotes-modal");
    const headerEl = contentEl.createDiv("BetterNotes-modal-header");
    const formEl = contentEl.createDiv("BetterNotes-modal-form");
    const nameCtn = formEl.createDiv("BetterNotes-input-container");
    nameCtn.createEl("label", { text: t("name") });
    const nameInput = nameCtn.createEl("input", {
      type: "text",
      value: this.name
    });
    if (this.options.mode === "edit") {
      nameInput.disabled = true;
    }
    nameInput.classList.add("BetterNotes-input");
    nameInput.addEventListener("input", () => {
      this.name = nameInput.value.trim();
    });
    const intervalsCtn = formEl.createDiv("BetterNotes-input-container");
    intervalsCtn.createEl("label", { text: t("In how many days will review again after remembered last time") });
    const listCtn = intervalsCtn.createDiv("BetterNotes-intervals-list");
    const renderIntervalInputs = () => {
      listCtn.empty();
      this.intervals.forEach((val, idx) => {
        if (val === 0)
          return;
        const item = listCtn.createDiv("BetterNotes-interval-item");
        item.createSpan({ text: t("last remembered") + " " });
        const input = item.createEl("input", {
          type: "number",
          value: String(val)
        });
        input.classList.add("BetterNotes-input", "BetterNotes-interval-input");
        input.addEventListener("input", () => {
          this.intervals[idx] = Number(input.value);
        });
        item.createSpan({ text: `days away\uFF0C NO.${idx + 1} review` });
        if (this.intervals.length > 1) {
          const delBtn = item.createDiv("BetterNotes-interval-del");
          (0, import_obsidian14.setIcon)(delBtn, "x");
          delBtn.addEventListener("click", () => {
            this.intervals[idx] = 0;
            renderIntervalInputs();
          });
        }
      });
    };
    renderIntervalInputs();
    const bigAddBtn = intervalsCtn.createDiv("BetterNotes-big-add");
    (0, import_obsidian14.setIcon)(bigAddBtn, "plus");
    bigAddBtn.addEventListener("click", () => {
      if (this.intervals.filter((v4) => v4 > 0).length >= 6) {
        new import_obsidian14.Notice(t("maximum 6 intervals"));
        return;
      }
      const idx = this.intervals.findIndex((v4) => v4 === 0);
      if (idx !== -1) {
        this.intervals[idx] = 1;
      }
      renderIntervalInputs();
    });
    const fsrsCtn = formEl.createDiv("BetterNotes-input-container");
    const fsrsLabel = fsrsCtn.createEl("label", { text: t("FSRS for advanced intervals") });
    const fsrsCheckbox = fsrsCtn.createEl("input", { type: "checkbox" });
    fsrsCheckbox.checked = this.fsrs;
    fsrsCheckbox.addEventListener("change", () => {
      this.fsrs = fsrsCheckbox.checked;
    });
    const rangeCtn = formEl.createDiv("BetterNotes-input-container");
    rangeCtn.createEl("label", { text: t("Random intervals (proficiency > 5)") });
    const rangeInputs = rangeCtn.createDiv("BetterNotes-range-inputs");
    const minInput = rangeInputs.createEl("input", {
      type: "number",
      value: String(this.min),
      placeholder: t("min value")
    });
    minInput.classList.add("BetterNotes-input");
    minInput.addEventListener("input", () => {
      this.min = Number(minInput.value);
    });
    rangeInputs.createSpan({ text: " ~ " });
    const maxInput = rangeInputs.createEl("input", {
      type: "number",
      value: String(this.max),
      placeholder: t("max value")
    });
    maxInput.classList.add("BetterNotes-input");
    maxInput.addEventListener("input", () => {
      this.max = Number(maxInput.value);
    });
    const footer = contentEl.createDiv("BetterNotes-modal-footer");
    const confirmBtn = footer.createEl("button", { text: t("confirm") });
    confirmBtn.classList.add("mod-cta");
    confirmBtn.addEventListener("click", () => {
      if (!this.name) {
        new import_obsidian14.Notice(t("name cannot be empty"));
        return;
      }
      const finalIntervals = [...this.intervals];
      this.options.onConfirm(this.name, finalIntervals, this.min, this.max, this.fsrs);
      this.close();
    });
    const cancelBtn = footer.createEl("button", { text: t("cancel") });
    cancelBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/PlanCard.ts
init_i18n();
var PlanCard = class {
  constructor(container, plan, plugin) {
    this.container = container;
    this.plan = plan;
    this.plugin = plugin;
  }
  /** 渲染卡片 */
  render() {
    this.container.empty();
    this.container.classList.add("BetterNotes-card");
    this.container.style.backgroundColor = "#2b1540";
    const title = this.container.createEl("div", { cls: "BetterNotes-card-title", text: this.plan.name });
    const iconEl = this.container.createEl("div", { cls: "BetterNotes-card-icon" });
    (0, import_obsidian15.setIcon)(iconEl, "calendar");
    const footer = this.container.createEl("div", { cls: "BetterNotes-card-footer" });
    const tools = footer.createEl("div", { cls: "BetterNotes-card-tools" });
    const editBtn = tools.createEl("div", { cls: "BetterNotes-card-tool" });
    (0, import_obsidian15.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openEditModal();
    });
    if (this.plan.name !== "default") {
      const delBtn = tools.createEl("div", { cls: "BetterNotes-card-tool" });
      (0, import_obsidian15.setIcon)(delBtn, "trash");
      delBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.openDeleteConfirm();
      });
    }
  }
  /** 打开编辑 Plan 模态框 */
  openEditModal() {
    const modal = new PlanModal(this.plugin, {
      mode: "edit",
      plan: this.plan,
      onConfirm: async (name2, intervals, min, max, fsrs) => {
        await this.plugin.dataManager.updatePlan(name2, { intervals, min, max, fsrs });
        await this.plugin.refreshViews();
      }
    });
    modal.open();
  }
  /** 删除确认 */
  openDeleteConfirm() {
    const confirmed = confirm(t("confirm delete plan") + ' "' + this.plan.name + '"');
    if (!confirmed)
      return;
    this.plugin.dataManager.deletePlan(this.plan.name);
    this.plugin.refreshViews();
  }
};

// src/components/PlanGrid.ts
var import_obsidian16 = require("obsidian");
var PlanGrid = class {
  constructor(container, plugin) {
    this.container = container;
    this.plugin = plugin;
    this.gridElement = this.container.createEl("div");
    this.gridElement.classList.add("BetterNotes-grid");
  }
  /** 渲染全部 Plan */
  render() {
    this.gridElement.empty();
    const plans = this.plugin.dataManager.getAllPlans().sort((a2, b4) => a2.name.localeCompare(b4.name));
    plans.forEach((p5) => this.renderCard(p5));
    this.renderAddCard();
  }
  renderCard(plan) {
    const cardEl = this.gridElement.createEl("div");
    const card = new PlanCard(cardEl, plan, this.plugin);
    card.render();
  }
  renderAddCard() {
    const addCardEl = this.gridElement.createEl("div");
    addCardEl.classList.add("BetterNotes-card", "BetterNotes-add-card");
    addCardEl.style.backgroundColor = "#FFCDD2";
    const iconCtn = addCardEl.createEl("div", { cls: "BetterNotes-add-icon-container" });
    (0, import_obsidian16.setIcon)(iconCtn, "plus");
    addCardEl.addEventListener("click", () => this.openCreateModal());
  }
  openCreateModal() {
    const modal = new PlanModal(this.plugin, {
      mode: "create",
      onConfirm: async (name2, intervals, min, max, fsrs) => {
        await this.plugin.dataManager.createPlan(name2, { intervals, min, max, fsrs });
        this.render();
      }
    });
    modal.open();
  }
};

// src/components/ReviewSelectGrid.ts
var import_obsidian17 = require("obsidian");
init_i18n();
var ReviewSelectGrid = class {
  /**
   * @param container 容器元素
   * @param plugin 插件实例
   * @param onConfirm 确认回调，参数为选中的集合名称数组
   */
  constructor(container, plugin, onConfirm) {
    this.selected = /* @__PURE__ */ new Set();
    this.container = container;
    this.plugin = plugin;
    this.onConfirm = onConfirm;
    this.gridElement = this.container.createEl("div");
    this.gridElement.classList.add("BetterNotes-grid");
  }
  /** 渲染选择网格 */
  render() {
    this.gridElement.empty();
    const sets = this.plugin.dataManager.getAllCollections().filter((c2) => c2.type === "set");
    sets.forEach((set) => this.renderCard(set));
    this.renderConfirmButton(sets);
  }
  /** 渲染单个集合卡片 */
  renderCard(collection) {
    const cardEl = this.gridElement.createEl("div");
    cardEl.classList.add("BetterNotes-card", "BetterNotes-selectable-card");
    cardEl.style.backgroundColor = collection.color;
    cardEl.style.cursor = "pointer";
    if (this.selected.has(collection.name)) {
      cardEl.classList.add("selected");
    }
    const titleEl = cardEl.createEl("div", { cls: "BetterNotes-card-title", text: collection.name });
    const iconEl = cardEl.createEl("div", { cls: "BetterNotes-card-icon" });
    (0, import_obsidian17.setIcon)(iconEl, "note");
    const checkEl = cardEl.createEl("div", { cls: "BetterNotes-card-check" });
    (0, import_obsidian17.setIcon)(checkEl, "check");
    checkEl.style.display = this.selected.has(collection.name) ? "" : "none";
    cardEl.addEventListener("click", () => {
      if (this.selected.has(collection.name)) {
        this.selected.delete(collection.name);
      } else {
        this.selected.add(collection.name);
      }
      this.render();
    });
  }
  /**
   * 渲染底部操作栏
   * @param allSets 当前展示的所有集合
   */
  renderConfirmButton(allSets) {
    const oldFooter = this.container.querySelector(".review-select-footer");
    if (oldFooter)
      oldFooter.remove();
    const footer = this.container.createDiv({ cls: "BetterNotes-modal-footer review-select-footer" });
    footer.style.flexDirection = "column";
    footer.style.alignItems = "center";
    footer.style.gap = "15px";
    const totalEntries = Array.from(this.selected).reduce((acc, setName) => {
      return acc + this.plugin.dataManager.getEntriesBySet(setName).length;
    }, 0);
    const summaryEl = footer.createEl("div", {
      text: `${t("total")} ${totalEntries} ${t("cards")}`
    });
    summaryEl.style.color = "var(--text-normal)";
    summaryEl.style.fontWeight = "600";
    summaryEl.style.fontSize = "15px";
    summaryEl.style.textAlign = "center";
    const buttonContainer = footer.createDiv({ cls: "review-buttons-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "center";
    buttonContainer.style.gap = "15px";
    const selectAllBtnText = this.selected.size === allSets.length ? t("cancel select all") : t("select all");
    const selectAllBtn = buttonContainer.createEl("button", {
      cls: "flashforge-review-button",
      text: selectAllBtnText
    });
    selectAllBtn.addEventListener("click", () => {
      if (this.selected.size === allSets.length) {
        this.selected.clear();
      } else {
        allSets.forEach((s5) => this.selected.add(s5.name));
      }
      this.render();
    });
    const confirmBtn = buttonContainer.createEl("button", {
      cls: "flashforge-review-button primary",
      text: t("start review")
    });
    confirmBtn.addEventListener("click", () => {
      if (this.selected.size === 0) {
        confirmBtn.classList.add("shake");
        setTimeout(() => confirmBtn.classList.remove("shake"), 500);
        return;
      }
      this.onConfirm(Array.from(this.selected));
    });
  }
};

// src/components/ReviewSessionView.ts
var import_obsidian18 = require("obsidian");
init_FSRSTypes();
init_i18n();
var ReviewSessionView = class {
  /**
   * @param container 容器
   * @param plugin 插件实例
   * @param sets 复习的集合名称数组
   */
  constructor(container, plugin, sets) {
    this.queue = [];
    this.currentEntry = null;
    this.totalCount = 0;
    this.isShowingAnnotation = false;
    this.cardParent = null;
    this.container = container;
    this.plugin = plugin;
    this.sets = sets;
    this.fsrsService = plugin.fsrsService;
  }
  /** 渲染复习 UI */
  render() {
    this.container.empty();
    this.queue = this.buildReviewQueue();
    this.totalCount = this.queue.length;
    this.renderProgressBar();
    this.renderCardArea();
    this.renderActionButtons();
    this.nextCard();
  }
  /** 渲染顶部进度条 */
  renderProgressBar() {
    const barWrapper = this.container.createDiv("flashforge-progress-wrapper");
    this.progressFilled = barWrapper.createDiv("flashforge-progress-filled");
  }
  /** 渲染卡片区域 */
  renderCardArea() {
    const cardContainer = this.container.createDiv("flashforge-review-card-container");
    this.renderCard(cardContainer, t("review content will be shown here"));
    this.cardParent = cardContainer;
  }
  renderCard(parent, content, isAnnotation = false) {
    parent.empty();
    const cardFront = parent.createDiv("flashforge-review-card-front");
    if (isAnnotation) {
      cardFront.addClass("annotation-mode");
    }
    const contentEl = cardFront.createDiv("flashforge-review-card-content");
    if (content) {
      contentEl.setText(content);
    }
    if (isAnnotation) {
      this.renderAttachments(contentEl, "back");
    } else {
      this.renderAttachments(contentEl, "front");
    }
  }
  /**
   * 渲染指定侧（正面/背面）的附件图片。
   * @param container - 图片将被添加到的父级DOM元素。
   * @param side - 'front' 或 'back'，用于筛选文件名。
   */
  renderAttachments(container, side) {
    if (!this.currentEntry || !this.currentEntry.attachmentFile?.length) {
      return;
    }
    const attachments = this.currentEntry.attachmentFile;
    const filtered = attachments.filter((p5) => p5.toLowerCase().includes(`-${side}.`));
    if (filtered.length === 0)
      return;
    const attachmentsContainer = container.createDiv("flashforge-review-attachments");
    filtered.forEach((path2) => {
      const imgEl = attachmentsContainer.createEl("img");
      imgEl.src = this.plugin.app.vault.adapter.getResourcePath(path2);
      imgEl.style.width = "100%";
      imgEl.style.borderRadius = "8px";
      imgEl.style.marginTop = "12px";
      imgEl.style.cursor = "pointer";
      imgEl.addEventListener("click", () => {
        new ImageEditorModal(this.plugin, { imagePath: path2 }).open();
      });
    });
  }
  /** 渲染按钮与功能条 */
  renderActionButtons() {
    const btnContainer = this.container.createDiv("flashforge-review-btn-container");
    this.createReviewButton(btnContainer, "again", "repeat");
    this.createReviewButton(btnContainer, "hard", "alert-triangle");
    this.createReviewButton(btnContainer, "easy", "check");
    const barCtn = this.container.createDiv("flashforge-extra-bar-container");
    const contextBtn = this.createExtraBar(barCtn, t("context"));
    contextBtn.addEventListener("click", () => this.handleContextClick());
    const editBtn = this.createExtraBar(barCtn, t("edit"));
    editBtn.addEventListener("click", () => this.openEditModal());
    const viewBtn = this.createExtraBar(barCtn, t("view"));
    viewBtn.addEventListener("click", () => this.toggleAnnotation());
  }
  /** 打开编辑模态框 */
  openEditModal() {
    if (!this.currentEntry)
      return;
    const entry = this.currentEntry;
    const modal = new AnnotationModal(this.plugin, {
      selectedText: entry.value,
      sourcePath: entry.sourceFile,
      entry,
      onConfirm: async (updates) => {
        await this.plugin.updateEntry(entry.hash, updates);
        Object.assign(entry, updates);
        if (this.cardParent) {
          if (this.isShowingAnnotation) {
            this.renderCard(this.cardParent, entry.comment, true);
          } else {
            this.renderCard(this.cardParent, entry.value);
          }
        }
      }
    });
    modal.open();
  }
  createReviewButton(parent, label, icon) {
    const btn = parent.createDiv("flashforge-review-btn");
    (0, import_obsidian18.setIcon)(btn, icon);
    btn.createSpan({ text: ` ${label}` });
    btn.addEventListener("click", () => this.handleResponse(label));
    return btn;
  }
  createExtraBar(parent, text) {
    const bar = parent.createDiv("flashforge-extra-bar");
    bar.setText(text);
    return bar;
  }
  // 处理"语境"按钮点击
  handleContextClick() {
    if (this.currentEntry && this.currentEntry.hash) {
      this.plugin.entryNavigation.navigateToEntry(this.currentEntry);
    }
  }
  // 切换显示批注
  toggleAnnotation() {
    if (!this.currentEntry)
      return;
    this.isShowingAnnotation = !this.isShowingAnnotation;
    if (this.cardParent && this.cardParent.firstElementChild) {
      const currentCard = this.cardParent.firstElementChild;
      currentCard.classList.add("card-scroll-collapse");
      setTimeout(() => {
        const cardParent = this.cardParent;
        if (this.isShowingAnnotation) {
          const annotation = this.currentEntry.comment;
          this.renderCard(cardParent, annotation, true);
        } else {
          this.renderCard(cardParent, this.currentEntry.value, false);
        }
        if (this.cardParent?.firstElementChild) {
          const newCard = this.cardParent.firstElementChild;
          newCard.classList.add("card-scroll-expand");
          setTimeout(() => {
            newCard.classList.remove("card-scroll-expand");
          }, 600);
        }
      }, 400);
    }
  }
  /** 跳到下一张卡片(仅 UI 占位) */
  nextCard() {
    if (this.queue.length === 0) {
      this.cardParent?.empty();
      this.cardParent?.createSpan({ text: t("\u{1F389} review completed") });
      this.updateProgress(1);
      return;
    }
    this.isShowingAnnotation = false;
    this.currentEntry = this.queue.shift();
    const progressRatio = (this.totalCount - this.queue.length - 1) / this.totalCount;
    this.updateProgress(Math.max(0, progressRatio));
    if (this.cardParent && this.currentEntry) {
      if (this.cardParent.firstElementChild) {
        const currentCard = this.cardParent.firstElementChild;
        currentCard.classList.add("card-scroll-collapse");
        setTimeout(() => {
          this.renderCard(this.cardParent, this.currentEntry.value);
          if (this.cardParent?.firstElementChild) {
            const newCard = this.cardParent.firstElementChild;
            newCard.classList.add("card-scroll-expand");
            setTimeout(() => {
              newCard.classList.remove("card-scroll-expand");
            }, 600);
          }
        }, 400);
      } else {
        this.renderCard(this.cardParent, this.currentEntry.value);
        if (this.cardParent?.firstElementChild) {
          const newCard = this.cardParent.firstElementChild;
          newCard.classList.add("card-scroll-expand");
          setTimeout(() => {
            newCard.classList.remove("card-scroll-expand");
          }, 600);
        }
      }
    }
  }
  handleResponse(action) {
    if (!this.currentEntry)
      return;
    const entry = this.currentEntry;
    const collection = this.plugin.dataManager.getCollection(entry.set);
    const plan = collection ? this.plugin.dataManager.getPlan(collection.plan) : void 0;
    const pro = entry.proficiency ?? 0;
    const intervalVal = plan?.intervals[pro] ?? 0;
    if (intervalVal !== 0 || !plan?.fsrs) {
      if (action === "again") {
        entry.proficiency = Math.max(0, entry.proficiency - 1);
      } else if (action === "hard") {
        entry.proficiency = 0;
      } else if (action === "easy") {
        this.calculateNextExpire(entry, entry.proficiency);
        entry.proficiency++;
      }
    } else {
      let card = this.plugin.dataManager.getFSRSState(entry.hash);
      if (!card) {
        card = this.fsrsService.initializeCard();
      }
      const ratingMap = {
        again: FSRS_RATING.AGAIN,
        hard: FSRS_RATING.HARD,
        easy: FSRS_RATING.EASY
      };
      const newCard = this.fsrsService.review(card, ratingMap[action]);
      this.plugin.dataManager.setFSRSState(entry.hash, newCard);
      entry.expireTime = new Date(newCard.nextReview).toISOString().slice(0, 10);
      entry.proficiency++;
    }
    this.plugin.updateEntry(entry.hash, { expireTime: entry.expireTime });
    if (action !== "easy") {
      this.queue.push(entry);
    }
    this.nextCard();
  }
  /** 根据 proficiency 计算下次复习时间 */
  calculateNextExpire(entry, pro) {
    const collection = this.plugin.dataManager.getCollection(entry.set);
    if (!collection)
      return;
    const planName = collection.plan;
    const plan = this.plugin.dataManager.getPlan(planName);
    if (!plan)
      return;
    const idx = pro >= plan.intervals.length ? plan.intervals.length - 1 : pro;
    let days = plan.intervals[idx];
    if (days === 0) {
      days = Math.floor(Math.random() * (plan.max - plan.min + 1)) + plan.min;
    }
    const target = new Date();
    target.setDate(target.getDate() + days);
    entry.expireTime = target.toISOString().slice(0, 10);
  }
  /** 构建复习队列 */
  buildReviewQueue() {
    const list = [];
    const todayStr = new Date().toISOString().slice(0, 10);
    this.sets.forEach((name2) => {
      const collection = this.plugin.dataManager.getCollection(name2);
      if (!collection)
        return;
      const planName = collection.plan || "default";
      const plan = this.plugin.dataManager.getPlan(planName);
      if (!plan)
        return;
      const entries = this.plugin.dataManager.getEntriesBySet(name2);
      entries.forEach((entry) => {
        const pro = entry.proficiency ?? 0;
        const intervalVal = plan.intervals[pro] ?? 0;
        if (intervalVal !== 0) {
          if (!entry.expireTime || entry.expireTime <= todayStr) {
            list.push(entry);
          }
        } else {
          if (!plan.fsrs) {
            if (!entry.expireTime || entry.expireTime <= todayStr) {
              list.push(entry);
            }
          } else {
            let card = this.plugin.dataManager.getFSRSState(entry.hash);
            if (!card) {
              card = this.fsrsService.initializeCard();
              this.plugin.dataManager.setFSRSState(entry.hash, card);
            }
            if (this.fsrsService.isDue(card)) {
              list.push(entry);
            }
          }
        }
      });
    });
    return list;
  }
  /** 更新进度条 0~1 */
  updateProgress(ratio) {
    if (this.progressFilled) {
      this.progressFilled.style.width = `${Math.floor(ratio * 100)}%`;
    }
  }
};

// src/views/SidebarView.ts
init_i18n();

// src/services/video/view.ts
var import_obsidian20 = require("obsidian");

// src/services/video/caption/SubtitleSelectionManager.ts
var SubtitleSelectionManager = class {
  constructor(root) {
    /** Selection state */
    this.selecting = false;
    this.selectedSpans = [];
    this.anchorSpan = null;
    /** 当前高亮颜色 */
    this.highlightColor = null;
    this.root = root;
    this.bindEvents();
  }
  /**
   * Attach pointer listeners to the root container.
   * Word <span> elements are identified by the presence of the `index`
   * attribute. Listeners are delegated to avoid rebinding on every cue update.
   */
  bindEvents() {
    this.root.addEventListener("pointerdown", (ev) => {
      const target = ev.target;
      if (!target?.hasAttribute("index") || target.closest(".subtitle-auto-highlight"))
        return;
      ev.preventDefault();
      ev.stopPropagation();
      const docColor = document.documentElement.dataset.snCurrentColor || "";
      if (!docColor)
        return;
      this.resetSelection();
      this.selecting = true;
      this.highlightColor = docColor;
      this.anchorSpan = target;
      this.updateRangeSelection(target);
      this.root.setPointerCapture(ev.pointerId);
      const moveHandler = (mv) => {
        mv.preventDefault();
        mv.stopPropagation();
        if (!this.selecting)
          return;
        const el = document.elementFromPoint(mv.clientX, mv.clientY);
        if (el && el.hasAttribute("index") && !el.closest(".subtitle-auto-highlight")) {
          this.updateRangeSelection(el);
        }
      };
      const upHandler = (up) => {
        up.preventDefault();
        up.stopPropagation();
        if (!this.selecting)
          return;
        this.selecting = false;
        this.root.releasePointerCapture(up.pointerId);
        this.root.removeEventListener("pointermove", moveHandler);
        this.root.removeEventListener("pointerup", upHandler);
        this.root.removeEventListener("pointercancel", upHandler);
        if (this.selectedSpans.length > 0) {
          this.mergeSelection();
        }
      };
      this.root.addEventListener("pointermove", moveHandler);
      this.root.addEventListener("pointerup", upHandler);
      this.root.addEventListener("pointercancel", upHandler);
    });
  }
  /** Highlight or add span to current selection */
  toggleSpan(span, adding) {
    if (adding && !this.selectedSpans.includes(span)) {
      this.selectedSpans.push(span);
      span.classList.add("subtitle-selecting");
      if (this.highlightColor) {
        span.style.color = this.highlightColor;
      }
    }
  }
  /** Reset any in-progress selection state */
  resetSelection() {
    this.selectedSpans.forEach((s5) => {
      s5.classList.remove("subtitle-selecting");
      if (this.highlightColor) {
        s5.style.removeProperty("color");
      }
    });
    this.selectedSpans = [];
    this.anchorSpan = null;
    this.highlightColor = null;
  }
  /**
   * Merge the selected word spans into a single span element. The words are
   * concatenated with spaces to preserve original spacing. The new span gets
   * class `subtitle-auto-highlight` and inline style for color.
   */
  mergeSelection() {
    if (this.selectedSpans.length === 0)
      return;
    this.selectedSpans.sort((a2, b4) => {
      if (a2 === b4)
        return 0;
      return a2.compareDocumentPosition(b4) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
    const mergedText = this.selectedSpans.map((s5) => s5.textContent ?? "").join(" ");
    const firstSpan = this.selectedSpans[0];
    const startIdx = Number(this.selectedSpans[0].getAttribute("index"));
    const endIdx = Number(this.selectedSpans[this.selectedSpans.length - 1].getAttribute("index"));
    const merged = document.createElement("span");
    merged.textContent = mergedText;
    merged.classList.add("subtitle-auto-highlight");
    if (this.highlightColor) {
      merged.style.color = this.highlightColor;
    }
    const lineEl = firstSpan.closest("[line]");
    const lineNumber = lineEl ? lineEl.getAttribute("line") : "0";
    if (lineEl) {
      merged.setAttribute("line", lineNumber);
    }
    const lastSpan = this.selectedSpans[this.selectedSpans.length - 1];
    let node = firstSpan;
    const nodesToRemove = [];
    while (node) {
      nodesToRemove.push(node);
      if (node === lastSpan)
        break;
      node = node.nextSibling;
    }
    firstSpan.parentElement?.insertBefore(merged, firstSpan);
    nodesToRemove.forEach((n3) => n3.remove());
    const videoUrl = this.root.dataset.videoUrl || "";
    const payload = {
      element: merged,
      text: mergedText,
      line: Number(lineNumber),
      start: startIdx,
      end: endIdx,
      url: videoUrl,
      time: parseFloat(this.root.dataset.startTime || "0")
    };
    document.dispatchEvent(new CustomEvent("BetterNotes-subtitle-entry", { detail: payload }));
    this.selectedSpans = [];
    this.anchorSpan = null;
  }
  /**
   * Highlight all word spans between the anchor and current span (inclusive).
   * This allows the user to drag backwards to shrink the selection.
   */
  updateRangeSelection(current) {
    if (!this.anchorSpan)
      return;
    const allWords = Array.from(this.root.querySelectorAll("span[index]"));
    const startIdx = allWords.indexOf(this.anchorSpan);
    const endIdx = allWords.indexOf(current);
    if (startIdx === -1 || endIdx === -1)
      return;
    const [lo, hi] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
    const newSelection = allWords.slice(lo, hi + 1);
    this.selectedSpans.forEach((s5) => {
      if (!newSelection.includes(s5)) {
        s5.classList.remove("subtitle-selecting");
        if (this.highlightColor)
          s5.style.removeProperty("color");
      }
    });
    newSelection.forEach((s5) => {
      if (!this.selectedSpans.includes(s5))
        s5.classList.add("subtitle-selecting");
      if (this.highlightColor)
        s5.style.color = this.highlightColor;
    });
    this.selectedSpans = newSelection;
  }
};
function injectSubtitleSelectionStyles() {
  if (document.getElementById("subtitle-selection-style"))
    return;
  const style = document.createElement("style");
  style.id = "subtitle-selection-style";
  style.textContent = `
    /* Temporary selecting state */
    .subtitle-selecting {
      /* \u52A8\u6001\u7740\u8272\u7531\u884C\u5185 style \u51B3\u5B9A\uFF0C\u5982\u65E0\u96C6\u5408\u5219\u7EE7\u627F\u6587\u5B57\u8272 */
      transform: translateY(-1px);
      cursor: pointer;
    }
    /* \u5B57\u5E55\u5355\u8BCD\u53EF\u70B9\u51FB\u6307\u9488\u6837\u5F0F */
    .video-caption span[index] {
      cursor: pointer;
      /* \u7981\u6B62\u6587\u672C\u9009\u62E9 */
      user-select: none;
      -webkit-user-select: none;
    }
    /* \u5DF2\u9AD8\u4EAE\u6761\u76EE\u60AC\u505C\u63D0\u793A */
    .subtitle-auto-highlight {
      /* \u5408\u5E76\u9AD8\u4EAE\u5143\u7D20\u6837\u5F0F\uFF0C\u989C\u8272\u7531\u884C\u5185style\u51B3\u5B9A */
      cursor: pointer;
      /* \u60AC\u505C\u6DFB\u52A0\u4E0B\u5212\u7EBF\uFF0C\u63D0\u793A\u53EF\u70B9\u51FB */
      transition: text-decoration-color 0.2s;
      /* \u7981\u6B62\u6587\u672C\u9009\u62E9 */
      user-select: none;
      -webkit-user-select: none;
    }
    .subtitle-auto-highlight:hover {
      text-decoration: underline;
      text-decoration-color: rgba(255, 255, 255, 0.6);
    }
    /* \u4E3A\u6574\u4E2A\u5B57\u5E55\u5BB9\u5668\u6DFB\u52A0\u9009\u62E9\u9650\u5236 */
    .video-caption {
      user-select: none;
      -webkit-user-select: none;
    }
  `;
  document.head.appendChild(style);
}
function setupSubtitleNavigationKeys() {
  if (window.__subtitleKeysSetup)
    return;
  window.__subtitleKeysSetup = true;
  document.addEventListener("click", (e) => {
    const target = e.target;
    if (target.classList.contains("subtitle-auto-highlight")) {
      const entryHash = target.getAttribute("data-entry-hash");
      if (entryHash) {
        e.preventDefault();
        e.stopPropagation();
        document.dispatchEvent(new CustomEvent("BetterNotes-navigate-to-entry", {
          detail: { hash: entryHash }
        }));
      }
    }
  });
}

// src/services/video/caption/SubtitleRenderer.ts
function renderSubtitleCue(cue, container) {
  injectSubtitleSelectionStyles();
  container.empty();
  if (cue) {
    container.dataset.startTime = String(cue.start);
  } else {
    delete container.dataset.startTime;
  }
  if (!cue)
    return;
  const lineNumber = cue.lineNumber;
  const singleLineText = cue.text.replace(/\s*\n+\s*/g, " ").trim();
  const lineEl = document.createElement("span");
  lineEl.setAttr("line", String(lineNumber ?? 1));
  const words = singleLineText.split(/\s+/);
  words.forEach((word, i3) => {
    const wordSpan = document.createElement("span");
    wordSpan.setAttr("index", String(i3 + 1));
    wordSpan.setAttr("data-original-index", String(i3 + 1));
    wordSpan.textContent = word;
    lineEl.appendChild(wordSpan);
    if (i3 !== words.length - 1) {
      lineEl.appendChild(document.createTextNode(" "));
    }
  });
  container.appendChild(lineEl);
  ensureSelectionManager(container);
  if (typeof lineNumber === "number") {
    document.dispatchEvent(new CustomEvent("BetterNotes-subtitle-line-rendered", {
      detail: { line: lineNumber, container }
    }));
  }
}
var MANAGER_SYMBOL = Symbol("subtitle-selection-manager");
function ensureSelectionManager(container) {
  if (container[MANAGER_SYMBOL])
    return;
  container.addEventListener("selectstart", (e) => {
    e.preventDefault();
    return false;
  });
  container[MANAGER_SYMBOL] = new SubtitleSelectionManager(container);
}

// src/services/video/caption/CaptionSync.ts
var CaptionSync = class {
  constructor(cues, container) {
    this.lastIndex = -1;
    this.cues = [...cues].sort((a2, b4) => a2.start - b4.start);
    this.container = container;
  }
  /**
   * 在播放时间更新时调用。
   * 若当前时间落在不同 Cue 内，则重新渲染字幕。
   */
  update(time) {
    const idx = this.findCueIndex(time);
    if (idx === this.lastIndex)
      return;
    if (idx === -1) {
      renderSubtitleCue(null, this.container);
    } else {
      renderSubtitleCue(this.cues[idx], this.container);
    }
    this.lastIndex = idx;
  }
  /**
   * 手动清空字幕并重置内部状态。
   */
  reset() {
    this.lastIndex = -1;
    renderSubtitleCue(null, this.container);
  }
  /**
   * 使用二分查找定位包含给定时间点的 Cue。
   * @returns Cue 的索引；未命中则返回 -1
   */
  findCueIndex(time) {
    let lo = 0;
    let hi = this.cues.length - 1;
    while (lo <= hi) {
      const mid = lo + hi >> 1;
      const cue = this.cues[mid];
      if (time < cue.start) {
        hi = mid - 1;
      } else if (time > cue.end) {
        lo = mid + 1;
      } else {
        return mid;
      }
    }
    return -1;
  }
};

// src/services/video/caption/CaptionLoader.ts
var import_fs = require("fs");

// src/services/video/utils.ts
var import_obsidian19 = require("obsidian");
var import_url = require("url");
var nodePath2 = __toESM(require("path"));
function parseSrt(srt) {
  const lines = srt.split(/\r?\n/);
  const cues = [];
  let i3 = 0;
  while (i3 < lines.length) {
    const idxLine = lines[i3].trim();
    if (!idxLine) {
      i3++;
      continue;
    }
    const maybeNumber = parseInt(idxLine, 10);
    if (isNaN(maybeNumber)) {
      if (idxLine.includes("-->")) {
      } else {
        i3++;
        continue;
      }
    }
    let timingLine;
    if (idxLine.includes("-->")) {
      timingLine = idxLine;
    } else {
      i3++;
      timingLine = (lines[i3] || "").trim();
    }
    const timeMatch = timingLine.match(/(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s+-->\s+(\d{2}:\d{2}:\d{2}[,\.]\d{3})/);
    if (!timeMatch) {
      i3++;
      continue;
    }
    const start2 = timeToSeconds(timeMatch[1]);
    const end = timeToSeconds(timeMatch[2]);
    i3++;
    const textLines = [];
    while (i3 < lines.length && lines[i3].trim() !== "") {
      textLines.push(lines[i3]);
      i3++;
    }
    cues.push({ start: start2, end, text: textLines.join("\n"), lineNumber: isNaN(maybeNumber) ? void 0 : maybeNumber });
    i3++;
  }
  return cues;
}
function timeToSeconds(t2) {
  const [h3, m5, s5] = t2.replace(",", ".").split(":").map(parseFloat);
  return h3 * 3600 + m5 * 60 + s5;
}
function normalizeVideoSource(plugin, source) {
  if (/^[a-z]+:\/\//i.test(source)) {
    if (source.startsWith("file://")) {
      try {
        const p5 = nodePath2.normalize(new URL(source).pathname);
        return { fileUrl: source, filePath: p5 };
      } catch {
        return { fileUrl: null, filePath: "" };
      }
    }
    return { fileUrl: source, filePath: "" };
  }
  const adapter = plugin.app.vault.adapter;
  if (!(adapter instanceof import_obsidian19.FileSystemAdapter)) {
    return { fileUrl: null, filePath: "" };
  }
  const absPath = nodePath2.isAbsolute(source) ? source : nodePath2.join(adapter.getBasePath(), source);
  return { fileUrl: (0, import_url.pathToFileURL)(absPath).href, filePath: absPath };
}

// src/services/video/caption/CaptionLoader.ts
async function loadSrtForVideo(videoPath) {
  const srtPath = videoPath.replace(/\.[^.]+$/, ".srt");
  try {
    const data = await import_fs.promises.readFile(srtPath, { encoding: "utf8" });
    if (!data.trim())
      return null;
    return parseSrt(data);
  } catch (err2) {
    console.debug("[CaptionLoader] Unable to load SRT:", err2);
    return null;
  }
}

// src/services/video/view.ts
var VIDEO_VIEW_TYPE = "mini-video-view";
var VideoView = class extends import_obsidian20.ItemView {
  constructor(leaf) {
    super(leaf);
    /**
     * HTML5 <video> element用于播放位于当前 Obsidian Vault 内的媒体文件。
     * 之所以只在 Vault 文件使用 <video>，是因为 Vault 文件可以通过
     * `vault.getResourcePath` 获得一个 app:// 协议的安全资源路径，
     * 直接赋给 <video>.src 即可。
     */
    this.videoEl = null;
    /**
     * Electron <webview> 元素用于播放 Vault 之外的本地文件。
     * 直接在普通 <video> 上设置 file:// 会被 Electron 限制，
     * 但 <webview> 拥有独立的进程与权限，可以安全加载本地资源。
     */
    this.webviewEl = null;
    /** 包裹播放器的 Flex 容器 */
    this.wrapperEl = null;
    this.playerHolder = null;
    /** 字幕容器 */
    this.captionEl = null;
    /** 字幕同步器 */
    this.captionSync = null;
    /** MessageChannel port 用于 RPC；握手成功后赋值 */
    this.activePort = null;
    this.portReady = false;
    /** 若在 ready 前收到 seekTo 请求，暂存至此 */
    this.pendingSeek = null;
    /** RPC 调用表，用于匹配响应 */
    this.pendingRpcCalls = /* @__PURE__ */ new Map();
    /** 最近一次从 webview 收到的播放时间 */
    this.lastKnownTime = 0;
    /** 最近一次播放的文件信息，用于持久化 workspace 状态 */
    this._currentFileUrl = null;
    this._currentFilePath = null;
  }
  getViewType() {
    return VIDEO_VIEW_TYPE;
  }
  getDisplayText() {
    const filePath = this.getState()?.filePath;
    return filePath?.split("/").pop()?.split("\\").pop() || "Video";
  }
  getIcon() {
    return "play";
  }
  /** 清空播放器容器，释放已有元素 */
  clearContainer() {
    if (this.wrapperEl) {
      this.wrapperEl.remove();
      this.wrapperEl = null;
      this.playerHolder = null;
      this.captionEl = null;
      this.captionSync = null;
    }
    if (this.videoEl) {
      this.videoEl.pause();
      this.videoEl.remove();
      this.videoEl = null;
    }
    if (this.webviewEl) {
      this.webviewEl.src = "";
      this.webviewEl.remove();
      this.webviewEl = null;
    }
  }
  /**
   * 在容器中渲染合适的播放器（<video> 或 <webview>）。
   */
  renderPlayer(fileUrl, filePath) {
    this.clearContainer();
    this._currentFileUrl = fileUrl;
    this._currentFilePath = filePath;
    this.ensureWrapper();
    this.webviewEl = document.createElement("webview");
    this.webviewEl.src = fileUrl;
    this.webviewEl.setAttribute("webpreferences", "allowRunningInsecureContent=yes, autoplayPolicy=no-user-gesture-required");
    this.webviewEl.style.width = "100%";
    this.webviewEl.style.height = "100%";
    this.playerHolder.appendChild(this.webviewEl);
    (async () => {
      const cues = await loadSrtForVideo(filePath);
      if (cues && this.captionEl) {
        this.captionEl.dataset.videoUrl = fileUrl;
        this.captionSync = new CaptionSync(cues, this.captionEl);
      }
    })();
    this.webviewEl.addEventListener("dom-ready", () => {
      const wv = this.webviewEl;
      if (wv?.insertCSS) {
        wv.insertCSS(`
                        html, body {
                            background: transparent !important;
                            margin: 0;
                        }
                        video {
                            width: 100% !important;
                            height: 100% !important;
                            object-fit: contain !important;
                            background: transparent !important;
                        }
                    `);
      }
      if (wv?.executeJavaScript) {
        const bootstrap = `(()=>{
   /** \u7B49\u5F85\u9875\u9762\u51FA\u73B0 <video>\uFF0CMutationObserver \u515C\u5E95 */
   function waitVideo(){
     const v=document.querySelector('video');
     if(v) return Promise.resolve(v);
     return new Promise(r=>{
       const mo=new MutationObserver(()=>{
         const vv=document.querySelector('video');
         if(vv){mo.disconnect();r(vv);} });
       mo.observe(document,{childList:true,subtree:true});
     });
   }
 
   window.addEventListener('message',async(e)=>{
     if(e.data==='init-port'){
       const port=e.ports[0];
       if(!port) return;
       const vid=await waitVideo();
 
       // -- RPC \u65B9\u6CD5\u5904\u7406\u5668 --
       const rpcHandlers={
         seek(time){
           vid.currentTime=time;
           if(vid.paused||vid.ended) vid.play().catch(()=>{});
         },
         async screenshot(type='image/png',quality=0.9){
           const canvas=document.createElement('canvas');
           canvas.width=vid.videoWidth;
           canvas.height=vid.videoHeight;
           const ctx=canvas.getContext('2d');
           if(!ctx) throw new Error('Could not get 2d context');
           ctx.drawImage(vid,0,0,canvas.width,canvas.height);
           const blob=await new Promise(r=>canvas.toBlob(r,type,quality));
           if(!blob) throw new Error('Failed to create blob from canvas');
           const arrayBuffer=await blob.arrayBuffer();
           return {
             value: { arrayBuffer, type: blob.type, time: vid.currentTime },
             transfer: [arrayBuffer]
           };
         }
       };
 
       port.onmessage=async(ev)=>{
         const d=ev.data;
         if(d?.type==='invoke' && d.id && rpcHandlers[d.method]){
           try {
             const result=await rpcHandlers[d.method](...d.args);
             if (result?.transfer) {
               port.postMessage({type:'response',id:d.id,result:result.value}, result.transfer);
             } else {
               port.postMessage({type:'response',id:d.id,result});
             }
           } catch(err){
             port.postMessage({type:'response',id:d.id,error:err.message});
           }
         }
       };
 
       // -- \u4E8B\u4EF6\u63A8\u9001 --
       vid.addEventListener('timeupdate',()=>{
         port.postMessage({type:'timeupdate',current:vid.currentTime});
       });
 
       // -- \u63E1\u624B --
       port.postMessage({type:'ready'});
     }
   });
 })();`;
        wv.executeJavaScript(bootstrap, true);
      }
    });
    let ready = false;
    let activePort = null;
    let attempts = 0;
    const MAX_ATTEMPTS = 3;
    const tryInitChannel = () => {
      if (ready || attempts >= MAX_ATTEMPTS)
        return;
      attempts++;
      const channel = new MessageChannel();
      channel.port1.onmessage = (ev) => {
        const data = ev.data;
        switch (data?.type) {
          case "ready":
            ready = true;
            this.portReady = true;
            this.activePort = channel.port1;
            if (this.pendingSeek != null) {
              this.seekTo(this.pendingSeek);
              this.pendingSeek = null;
            }
            break;
          case "timeupdate":
            this.lastKnownTime = data.current;
            this.captionSync?.update(data.current);
            break;
          case "response":
            this.handleRpcResponse(data);
            break;
        }
      };
      try {
        const cw = this.webviewEl?.contentWindow;
        if (cw) {
          cw.postMessage("init-port", "*", [channel.port2]);
        } else {
          console.warn("[BetterNotes] contentWindow not available, will retry channel init.");
        }
      } catch (err2) {
        console.error("[MiniVideo] postMessage failed:", err2);
      }
    };
    this.webviewEl.addEventListener("did-stop-loading", () => {
      tryInitChannel();
      setTimeout(() => {
        if (!ready)
          tryInitChannel();
      }, 1e3);
    });
  }
  /**
   * 创建或复用 wrapperEl：上下两栏，播放器占 50%，spacer 占 50%。
   */
  ensureWrapper() {
    if (this.wrapperEl)
      return;
    this.wrapperEl = document.createElement("div");
    this.wrapperEl.style.display = "flex";
    this.wrapperEl.style.flexDirection = "column";
    this.wrapperEl.style.width = "100%";
    this.wrapperEl.style.height = "100%";
    this.wrapperEl.style.overflow = "hidden";
    this.playerHolder = document.createElement("div");
    this.playerHolder.style.width = "100%";
    this.playerHolder.style.aspectRatio = "16/9";
    this.playerHolder.style.overflow = "hidden";
    this.playerHolder.style.display = "flex";
    this.playerHolder.style.alignItems = "stretch";
    this.playerHolder.style.justifyContent = "stretch";
    const spacer = document.createElement("div");
    spacer.style.flex = "1 1 auto";
    this.wrapperEl.appendChild(this.playerHolder);
    const captionWrapper = document.createElement("div");
    captionWrapper.className = "video-caption-wrapper";
    captionWrapper.style.display = "flex";
    captionWrapper.style.alignItems = "center";
    captionWrapper.style.justifyContent = "center";
    captionWrapper.style.position = "relative";
    this.captionEl = document.createElement("div");
    this.captionEl.className = "video-caption";
    this.captionEl.style.flex = "1 1 auto";
    const camBtn = document.createElement("div");
    camBtn.className = "video-caption-camera";
    camBtn.style.flex = "0 0 auto";
    camBtn.style.marginLeft = "12px";
    camBtn.style.marginRight = "20px";
    camBtn.style.width = "24px";
    camBtn.style.height = "24px";
    camBtn.style.cursor = "pointer";
    camBtn.style.opacity = "0.8";
    camBtn.onmouseenter = () => camBtn.style.opacity = "1";
    camBtn.onmouseleave = () => camBtn.style.opacity = "0.8";
    camBtn.textContent = "\u{1F4F7}";
    camBtn.style.fontSize = "40px";
    captionWrapper.appendChild(this.captionEl);
    captionWrapper.appendChild(camBtn);
    camBtn.onclick = async () => {
      if (!document.documentElement.dataset.snCurrentColor)
        return;
      try {
        const { arrayBuffer, type, time } = await this.takeScreenshot();
        const { AttachmentService: AttachmentService2 } = await Promise.resolve().then(() => (init_AttachmentService(), AttachmentService_exports));
        const svc = new AttachmentService2(this.app);
        const videoName = this._currentFilePath ? this._currentFilePath.split(/[\\/]/).pop().split(".").shift() : "video";
        const ext = type === "image/jpeg" ? ".jpg" : ".png";
        const tStr = time.toFixed(2).replace(/\./, "_");
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        const fileName = `${videoName}_${tStr}_${ts}-front${ext}`;
        const savedPath = await svc.saveBinaryAttachment(fileName, arrayBuffer);
        document.dispatchEvent(new CustomEvent("BetterNotes-video-screenshot-entry", {
          detail: {
            time,
            videoUrl: this._currentFileUrl,
            attachmentPath: savedPath
          }
        }));
      } catch (e) {
        console.error("Failed to take or save screenshot:", e);
      }
    };
    this.wrapperEl.appendChild(captionWrapper);
    this.wrapperEl.appendChild(spacer);
    this.containerEl.appendChild(this.wrapperEl);
  }
  async onOpen() {
    this.containerEl.empty();
    this.containerEl.addClass("mini-video-player-container");
    this.containerEl.style.setProperty("aspect-ratio", "16/9");
    this.containerEl.style.overflow = "hidden";
    const state = this.getState();
    if (state?.fileUrl && state?.filePath) {
      this.renderPlayer(state.fileUrl, state.filePath);
    }
  }
  async setState(state, options) {
    if (state?.fileUrl && state?.filePath) {
      this.renderPlayer(state.fileUrl, state.filePath);
    }
    return super.setState(state, options);
  }
  /**
   * 返回需要持久化到 workspace.json 的视图状态。
   * 必须包含 fileUrl / filePath，才能在 Obsidian 重启后自动恢复播放。
   */
  getState() {
    const base = super.getState() ?? {};
    return {
      ...base,
      fileUrl: this._currentFileUrl,
      filePath: this._currentFilePath
    };
  }
  async onClose() {
    this.clearContainer();
  }
  /**
   * 对外公开：跳转到指定播放时间（秒）。
   * @param time 目标时间（秒，可带小数）
   */
  seekTo(time) {
    if (Number.isNaN(time) || time < 0)
      return;
    if (this.portReady && this.activePort) {
      this.invokeRpc("seek", time).catch((err2) => console.error("Seek failed:", err2));
    } else {
      this.pendingSeek = time;
    }
  }
  /**
   * 截取当前视频帧。
   * @param type The image format (e.g., 'image/png', 'image/jpeg').
   * @param quality The image quality (0 to 1) for formats that support it.
   * @returns A promise that resolves with the screenshot data.
   */
  async takeScreenshot(type = "image/png", quality = 0.9) {
    return this.invokeRpc("screenshot", type, quality);
  }
  /**
   * 内部 RPC 调用函数。
   * @param method WebView 端注册的方法名
   * @param args 传递给方法的参数
   */
  invokeRpc(method, ...args2) {
    if (!this.portReady || !this.activePort) {
      return Promise.reject(new Error("MessagePort not ready for RPC."));
    }
    const id = crypto.randomUUID();
    const promise = new Promise((resolve2, reject) => {
      this.pendingRpcCalls.set(id, { resolve: resolve2, reject });
    });
    this.activePort.postMessage({ type: "invoke", id, method, args: args2 });
    return promise;
  }
  /**
   * 处理来自 WebView 的 RPC 响应。
   */
  handleRpcResponse(response) {
    const rpc = this.pendingRpcCalls.get(response.id);
    if (!rpc)
      return;
    if (response.error) {
      rpc.reject(new Error(response.error));
    } else {
      rpc.resolve(response.result);
    }
    this.pendingRpcCalls.delete(response.id);
  }
};

// src/views/SidebarView.ts
var _SidebarView = class extends import_obsidian21.ItemView {
  /**
   * 构造函数
   * @param leaf 工作区叶子节点
   * @param plugin 插件实例
   */
  constructor(leaf, plugin) {
    super(leaf);
    this.currentView = "home";
    this.navigationStack = [];
    // 导航栈，用于记录浏览历史（存储完整的Collection对象）
    this.currentFolder = null;
    // 当前文件夹
    this.entryListView = null;
    this.currentCollection = null;
    // 当前查看的集合
    this.commentsContainer = null;
    // 评论视图容器
    this.commentsFileListener = null;
    this.plugin = plugin;
  }
  /**
   * 获取视图类型
   * @returns 视图类型标识符
   */
  getViewType() {
    return _SidebarView.VIEW_TYPE;
  }
  /**
   * 获取显示的标题
   * @returns 视图标题
   */
  getDisplayText() {
    return "BetterNotes";
  }
  /**
   * 获取视图图标
   * @returns 图标名称
   */
  getIcon() {
    return "sparkles";
  }
  /**
   * 当视图被打开或获得焦点时调用
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.classList.add("BetterNotes-container");
    this.topNavBar = new TopNavBar(container, this.plugin, (id) => this.handleNavigation(id));
    this.topNavBar.render();
    const setSelectionParent = container.createDiv();
    const { SetSelectionBar: SetSelectionBar2 } = await Promise.resolve().then(() => (init_SetSelectionBar(), SetSelectionBar_exports));
    this.setSelectionBar = new SetSelectionBar2(setSelectionParent, this.plugin, this.plugin.setSelectionService);
    const searchParent = container.createDiv();
    this.searchBar = new SearchBar(searchParent, this.plugin, this);
    this.contentContainer = container.createEl("div", { cls: "BetterNotes-content-container" });
    this.showHomeView();
  }
  /**
   * 处理导航事件
   * @param id 导航项ID
   */
  handleNavigation(id) {
    if (this.currentView === "comments") {
      this.clearCommentsListener();
    }
    if (id !== this.currentView) {
      this.navigationStack = [];
      this.currentFolder = null;
    }
    this.currentView = id;
    this.contentContainer.empty();
    this.currentFolder = null;
    this.currentCollection = null;
    this.entryListView = null;
    switch (id) {
      case "home":
        this.showHomeView();
        break;
      case "comments":
        this.showCommentsView();
        break;
      case "review":
        this.showReviewView();
        break;
      case "plan":
        this.showPlanView();
        break;
      default:
        this.showHomeView();
    }
    this.searchBar?.updatePlaceholder();
  }
  /**
   * 显示首页视图（集合网格）
   */
  showHomeView() {
    if (this.currentFolder) {
      this.showFolderView(this.currentFolder);
      return;
    }
    this.contentContainer.empty();
    this.collectionGrid = new CollectionGrid(
      this.contentContainer,
      this.plugin,
      (folder) => this.navigateToFolder(folder)
    );
    this.collectionGrid.render();
    this.renderBreadcrumb();
    this.searchBar?.updatePlaceholder();
  }
  /**
   * 渲染面包屑导航
   */
  renderBreadcrumb() {
    const breadcrumbContainer = this.contentContainer.createEl("div", { cls: "BetterNotes-breadcrumb" });
    breadcrumbContainer.style.order = "-1";
    const homeLink = breadcrumbContainer.createEl("span", {
      text: "home",
      cls: "BetterNotes-breadcrumb-link"
    });
    homeLink.addEventListener("click", () => {
      this.currentFolder = null;
      this.navigationStack = [];
      this.showHomeView();
    });
    if (this.navigationStack.length > 0) {
      this.navigationStack.forEach((folder, index) => {
        breadcrumbContainer.createEl("span", {
          text: " > ",
          cls: "BetterNotes-breadcrumb-separator"
        });
        const folderLink = breadcrumbContainer.createEl("span", {
          text: folder.name,
          cls: "BetterNotes-breadcrumb-link"
        });
        folderLink.addEventListener("click", () => {
          this.navigationStack = this.navigationStack.slice(0, index);
          this.currentFolder = folder;
          this.showFolderView(folder);
        });
      });
    }
    if (this.currentFolder) {
      breadcrumbContainer.createEl("span", {
        text: " > ",
        cls: "BetterNotes-breadcrumb-separator"
      });
      breadcrumbContainer.createEl("span", {
        text: this.currentFolder.name,
        cls: "BetterNotes-breadcrumb-current"
      });
    } else if (this.navigationStack.length === 0) {
      breadcrumbContainer.empty();
      breadcrumbContainer.createEl("span", {
        text: "home",
        cls: "BetterNotes-breadcrumb-current"
      });
    }
  }
  /**
   * 导航到指定文件夹
   * @param folder 文件夹集合对象
   */
  navigateToFolder(folder) {
    if (this.currentFolder) {
      this.navigationStack.push(this.currentFolder);
    }
    this.currentFolder = folder;
    this.showFolderView(folder);
  }
  /**
   * 显示文件夹视图
   * @param folder 文件夹集合对象
   */
  showFolderView(folder) {
    this.contentContainer.empty();
    const folderView = new FolderView(
      this.contentContainer,
      this.plugin,
      folder,
      () => this.navigateBack(),
      // 返回上一级的回调函数
      (subfolder) => this.navigateToFolder(subfolder)
      // 点击子文件夹的回调函数
    );
    folderView.render();
    this.renderBreadcrumb();
    this.searchBar?.updatePlaceholder();
  }
  /**
   * 返回上一级
   */
  navigateBack() {
    if (this.navigationStack.length === 0) {
      this.currentFolder = null;
      this.showHomeView();
      return;
    }
    const parentFolder = this.navigationStack.pop();
    this.currentFolder = parentFolder || null;
    if (this.currentFolder) {
      this.showFolderView(this.currentFolder);
    } else {
      this.showHomeView();
    }
  }
  /**
   * 显示评论视图
   */
  showCommentsView() {
    this.contentContainer.empty();
    this.commentsContainer = this.contentContainer.createEl("div", { cls: "BetterNotes-entry-list-container" });
    this.renderCommentsForActiveFile();
    if (this.commentsFileListener)
      this.app.workspace.off("active-leaf-change", this.commentsFileListener);
    this.commentsFileListener = (leaf) => {
      if (leaf && leaf.view instanceof _SidebarView)
        return;
      if (this.currentView === "comments") {
        this.renderCommentsForActiveFile();
      }
    };
    this.app.workspace.on("active-leaf-change", this.commentsFileListener);
    this.searchBar?.updatePlaceholder();
  }
  /**
   * 渲染当前活动文件的条目列表
   */
  async renderCommentsForActiveFile() {
    if (!this.commentsContainer)
      return;
    let leafToRender = this.app.workspace.activeLeaf;
    if (leafToRender && this.plugin.isIgnoredView(leafToRender.view.getViewType())) {
      leafToRender = this.plugin.lastActiveViewLeaf;
    }
    if (!leafToRender) {
      this.commentsContainer.empty();
      this.commentsContainer.createEl("div", { cls: "BetterNotes-placeholder-text", text: t("no file opened") });
      return;
    }
    const view = leafToRender.view;
    let entries = [];
    if (view instanceof VideoView) {
      const state = view.getState();
      const videoUrl = state?.fileUrl;
      if (videoUrl) {
        entries = this.plugin.dataManager.getAllEntries().filter(
          (e) => e.type === "video" && typeof e.index === "string" && e.index.endsWith(videoUrl)
        );
      }
    } else if (view instanceof import_obsidian21.FileView && view.file) {
      const file = view.file;
      const filePath = file.path;
      entries = this.plugin.dataManager.getEntriesBySourceFile(filePath);
      if (file.extension === "md") {
        try {
          const fileContent = await this.app.vault.read(file);
          entries = [...entries].sort((a2, b4) => {
            const posA = fileContent.indexOf(`data-hash="${a2.hash}"`);
            const posB = fileContent.indexOf(`data-hash="${b4.hash}"`);
            return posA - posB;
          });
        } catch (e) {
          console.error("\u8BFB\u53D6\u6587\u4EF6\u5185\u5BB9\u5931\u8D25:", e);
        }
      }
    }
    this.commentsContainer.empty();
    if (entries.length === 0) {
      this.commentsContainer.createEl("div", { cls: "BetterNotes-placeholder-text", text: t("no annotation in this file") });
      return;
    }
    const listContainer = this.commentsContainer.createEl("div", { cls: "BetterNotes-entries-container" });
    entries.forEach((entry) => {
      const collection = this.plugin.dataManager.getCollection(entry.set);
      if (!collection)
        return;
      const cardEl = listContainer.createEl("div", { cls: "BetterNotes-entry-item" });
      const entryCard = new EntryCard(cardEl, entry, this.plugin, collection);
      entryCard.render();
    });
  }
  // 在 navigateBack 等函数中以及刷新时，若离开 comments 视图，需要移除监听。
  // 在 handleNavigation 开头添加逻辑，但此处插入简易清理
  clearCommentsListener() {
    if (this.commentsFileListener) {
      this.app.workspace.off("active-leaf-change", this.commentsFileListener);
      this.commentsFileListener = null;
    }
  }
  /**
   * 显示复习视图
   */
  showReviewView() {
    this.contentContainer.empty();
    const reviewGrid = new ReviewSelectGrid(this.contentContainer, this.plugin, (selected) => {
      const session = new ReviewSessionView(this.contentContainer, this.plugin, selected);
      session.render();
    });
    reviewGrid.render();
  }
  /**
   * 显示计划视图
   */
  showPlanView() {
    this.contentContainer.empty();
    const planGrid = new PlanGrid(this.contentContainer, this.plugin);
    planGrid.render();
  }
  /**
   * 显示条目列表视图
   * @param collection 集合对象
   */
  showEntryList(collection) {
    this.currentCollection = collection;
    this.contentContainer.empty();
    this.entryListView = new EntryListView(
      this.contentContainer,
      collection,
      this.plugin,
      () => this.handleBackFromEntryList()
    );
    this.entryListView.render();
    this.searchBar?.updatePlaceholder();
  }
  /**
   * 处理从条目列表返回
   */
  handleBackFromEntryList() {
    this.entryListView = null;
    this.currentCollection = null;
    if (this.currentFolder) {
      this.showFolderView(this.currentFolder);
    } else {
      this.showHomeView();
    }
  }
  /**
   * 刷新视图
   */
  async refresh() {
    if (this.entryListView && this.currentCollection) {
      this.entryListView.refresh();
    } else if (this.currentFolder) {
      this.showFolderView(this.currentFolder);
    } else if (this.currentView === "comments") {
      this.renderCommentsForActiveFile();
    } else if (this.currentView === "plan") {
      this.showPlanView();
    } else if (this.currentView === "review") {
      this.showReviewView();
    } else {
      this.showHomeView();
    }
    if (!this.setSelectionBar) {
      const selParent = this.containerEl.querySelector(".BetterNotes-set-selection-bar") ?? this.contentContainer.parentElement?.createDiv();
      const { SetSelectionBar: SetSelectionBar2 } = await Promise.resolve().then(() => (init_SetSelectionBar(), SetSelectionBar_exports));
      this.setSelectionBar = new SetSelectionBar2(selParent, this.plugin, this.plugin.setSelectionService);
    }
    this.setSelectionBar?.refresh();
  }
  /**
   * 打开comments视图并高亮显示特定条目
   * 此方法用于从文档中的span标签点击时，跳转到侧边栏的comments视图并显示对应条目
   * 如果当前已处于 comments 视图且活跃文件与条目来源文件一致，
  * 则复用现有 DOM，避免不必要的清空与重新渲染。
   * @param entry 需要高亮显示的条目
   */
  async openCommentsViewAndHighlightEntry(entry) {
    let isSameContext = false;
    if (entry.type === "video") {
      const videoView = this.app.workspace.getActiveViewOfType(VideoView);
      if (videoView) {
        const videoUrl = videoView.getState()?.fileUrl;
        if (videoUrl && typeof entry.index === "string" && entry.index.endsWith(videoUrl)) {
          isSameContext = true;
        }
      }
    } else {
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
      if (markdownView && markdownView.file && markdownView.file.path === entry.sourceFile) {
        isSameContext = true;
      }
    }
    if (this.currentView === "comments" && isSameContext && this.commentsContainer) {
      await this.insertEntryIntoComments(entry);
      this.highlightEntryInComments(entry);
      this.topNavBar.setActiveNavItem("comments");
      return;
    }
    this.currentView = "comments";
    this.currentCollection = null;
    this.currentFolder = null;
    this.entryListView = null;
    this.contentContainer.empty();
    this.commentsContainer = this.contentContainer.createEl("div", { cls: "BetterNotes-entry-list-container" });
    await this.renderCommentsForActiveFile();
    this.highlightEntryInComments(entry);
    this.topNavBar.setActiveNavItem("comments");
    this.commentsFileListener = (leaf) => {
      if (leaf && leaf.view instanceof _SidebarView)
        return;
      if (this.currentView === "comments") {
        this.renderCommentsForActiveFile();
      }
    };
    this.searchBar?.updatePlaceholder();
    this.app.workspace.on("active-leaf-change", this.commentsFileListener);
  }
  /**
   * 在当前 comments 列表中插入指定条目的 DOM。
   * 若列表已存在该条目则不作处理。
   * 按文件中 data-hash 出现顺序确定插入位置，保证与 renderCommentsForActiveFile 一致。
   * @param entry 目标条目
   */
  async insertEntryIntoComments(entry) {
    if (!this.commentsContainer)
      return;
    let listContainer = this.commentsContainer.querySelector(".BetterNotes-entries-container");
    if (!listContainer) {
      this.commentsContainer.empty();
      listContainer = this.commentsContainer.createEl("div", { cls: "BetterNotes-entries-container" });
    }
    if (listContainer.querySelector(`[data-entry-hash="${entry.hash}"]`))
      return;
    const collection = this.plugin.dataManager.getCollection(entry.set);
    if (!collection)
      return;
    const cardWrapper = document.createElement("div");
    cardWrapper.classList.add("BetterNotes-entry-item");
    const entryCard = new EntryCard(cardWrapper, entry, this.plugin, collection);
    entryCard.render();
    let inserted = false;
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        const fileContent = await this.app.vault.read(activeFile);
        const targetPos = fileContent.indexOf(`data-hash="${entry.hash}"`);
        if (targetPos !== -1) {
          const children = Array.from(listContainer.children);
          for (const child of children) {
            const hash = child.getAttribute("data-entry-hash");
            if (!hash)
              continue;
            const pos = fileContent.indexOf(`data-hash="${hash}"`);
            if (pos > targetPos) {
              listContainer.insertBefore(cardWrapper, child);
              inserted = true;
              break;
            }
          }
        }
      }
    } catch (e) {
      console.error("insertEntryIntoComments: failed to compute position", e);
    }
    if (!inserted)
      listContainer.appendChild(cardWrapper);
  }
  /**
   * 在comments视图中高亮显示特定条目
   * @param entry 需要高亮显示的条目
   */
  highlightEntryInComments(entry) {
    if (!this.commentsContainer)
      return;
    setTimeout(() => {
      const entryElement = this.commentsContainer?.querySelector(`[data-entry-hash="${entry.hash}"]`);
      if (entryElement) {
        entryElement.scrollIntoView({ behavior: "smooth", block: "center" });
        entryElement.classList.add("BetterNotes-highlighted-entry");
        setTimeout(() => {
          entryElement.classList.remove("BetterNotes-highlighted-entry");
        }, 3e3);
      }
    }, 200);
  }
  /**
   * 当视图被关闭时调用
   */
  async onClose() {
  }
  /**
   * 获取当前查看的集合（若有）供外部组件使用
   */
  getCurrentCollection() {
    return this.currentCollection;
  }
  /** 当前所在文件夹（若有） */
  getCurrentFolder() {
    return this.currentFolder;
  }
  /** 当前视图类型 home / comments / review / plan 等 */
  getCurrentView() {
    return this.currentView;
  }
  /** 导航到首页 */
  goHome() {
    this.handleNavigation("home");
  }
  /** 获取搜索栏实例 */
  getSearchBar() {
    return this.searchBar;
  }
};
var SidebarView = _SidebarView;
/**
 * 视图的唯一标识符
 */
SidebarView.VIEW_TYPE = "BetterNotes-sidebar-view";

// src/main.ts
init_utils();

// src/services/HashSpanHandler.ts
var import_obsidian22 = require("obsidian");
init_i18n();
var HashSpanHandler = class {
  /**
   * 构造函数
   * @param app Obsidian应用实例
   * @param plugin BetterNotes插件实例
   */
  constructor(app, plugin) {
    this.isModifierKeyPressed = false;
    this.currentHoverSpan = null;
    // 追踪已处理的元素，避免重复处理
    this.processedElements = /* @__PURE__ */ new Set();
    /**
     * 悬停计时器 ID，超过阈值后显示 tooltip
     */
    this.hoverTimer = null;
    /**
     * 当前展示的 tooltip 元素
     */
    this.tooltipEl = null;
    this.app = app;
    this.plugin = plugin;
    this.boundHandleMouseOver = this.handleMouseOver.bind(this);
    this.boundHandleMouseOut = this.handleMouseOut.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.initializeEventListeners();
  }
  /**
   * 初始化事件监听器
   * 包括全局键盘事件和文档变更监听器
   */
  initializeEventListeners() {
    document.addEventListener("keydown", this.boundHandleKeyDown);
    document.addEventListener("keyup", this.boundHandleKeyUp);
    this.setupMutationObserver();
    this.processExistingHashSpans();
  }
  /**
   * 处理已存在的hash span元素
   * 为文档中所有带data-hash属性的span添加类和事件监听器
   */
  processExistingHashSpans() {
    const hashSpans = document.querySelectorAll("span[data-hash]");
    hashSpans.forEach((span) => {
      this.setupHashSpan(span);
    });
  }
  /**
   * 设置DOM变更观察器
   * 监听文档的变化以处理新添加的hash span
   */
  setupMutationObserver() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              if (node instanceof HTMLElement && node.tagName === "SPAN" && node.hasAttribute("data-hash")) {
                this.setupHashSpan(node);
              }
              const hashSpans = node.querySelectorAll("span[data-hash]");
              hashSpans.forEach((span) => {
                this.setupHashSpan(span);
              });
            }
          });
        }
      });
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }
  /**
   * 设置单个hash span元素
   * 添加类名和事件监听器
   * @param span HTML span元素
   */
  setupHashSpan(span) {
    if (!span.hasAttribute("data-hash"))
      return;
    if (this.processedElements.has(span))
      return;
    this.processedElements.add(span);
    span.classList.add("BetterNotes-hash-span");
    span.addEventListener("mouseover", this.boundHandleMouseOver);
    span.addEventListener("mouseout", this.boundHandleMouseOut);
    span.addEventListener("click", this.boundHandleClick);
  }
  /**
   * 处理键盘按下事件
   * @param event 键盘事件对象
   */
  handleKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      this.isModifierKeyPressed = true;
      if (this.currentHoverSpan) {
        this.currentHoverSpan.classList.add("mod-hover");
      }
    }
  }
  /**
   * 处理键盘释放事件
   * @param event 键盘事件对象
   */
  handleKeyUp(event) {
    if (event.key === "Meta" || event.key === "Control") {
      this.isModifierKeyPressed = false;
      document.querySelectorAll(".BetterNotes-hash-span.mod-hover").forEach((span) => {
        span.classList.remove("mod-hover");
      });
    }
  }
  /**
   * 处理鼠标悬停事件
   * @param event 鼠标事件对象
   */
  handleMouseOver(event) {
    const span = event.currentTarget;
    this.currentHoverSpan = span;
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    const hash = span.getAttribute("data-hash");
    if (hash) {
      const entry = this.plugin.dataManager.getEntry(hash);
      if (entry && entry.comment) {
        this.hoverTimer = window.setTimeout(() => {
          this.showCommentTooltip(span, entry);
        }, 1e3);
      }
    }
    if (this.isModifierKeyPressed) {
      span.classList.add("mod-hover");
    }
  }
  /**
   * 处理鼠标离开事件
   * @param event 鼠标事件对象
   */
  handleMouseOut(event) {
    const span = event.currentTarget;
    if (this.currentHoverSpan === span) {
      this.currentHoverSpan = null;
    }
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    this.hideCommentTooltip();
    span.classList.remove("mod-hover");
  }
  /**
   * 处理点击事件
   * @param event 鼠标事件对象
   */
  handleClick(event) {
    if (!this.isModifierKeyPressed)
      return;
    const span = event.currentTarget;
    const hash = span.getAttribute("data-hash");
    if (!hash)
      return;
    const entry = this.plugin.dataManager.getEntry(hash);
    if (entry) {
      this.openSidebarAndNavigateToEntry(entry);
    }
    event.preventDefault();
    event.stopPropagation();
  }
  /**
   * 打开侧边栏并导航到对应条目
   * 激活侧边栏，打开comments视图，并高亮显示特定条目
   * @param entry 要导航到的条目对象
   */
  async openSidebarAndNavigateToEntry(entry) {
    try {
      await this.plugin.activateSidebarView();
      if (!this.plugin.sidebarView) {
        new import_obsidian22.Notice(t("cannot open sidebar view"));
        return;
      }
      this.plugin.sidebarView.openCommentsViewAndHighlightEntry(entry);
    } catch (error2) {
      console.error("\u6253\u5F00\u4FA7\u8FB9\u680F\u5E76\u5BFC\u822A\u5230\u6761\u76EE\u65F6\u51FA\u9519:", error2);
      new import_obsidian22.Notice(t("cannot navigate") + ": " + t("unsupported entry type or missing necessary information"));
    }
  }
  /**
   * 清理资源，移除事件监听器
   * 在插件卸载时调用
   */
  cleanup() {
    document.removeEventListener("keydown", this.boundHandleKeyDown);
    document.removeEventListener("keyup", this.boundHandleKeyUp);
    this.processedElements.forEach((span) => {
      span.removeEventListener("mouseover", this.boundHandleMouseOver);
      span.removeEventListener("mouseout", this.boundHandleMouseOut);
      span.removeEventListener("click", this.boundHandleClick);
    });
    this.processedElements.clear();
    this.hideCommentTooltip();
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
  }
  /**
   * 创建并显示评论 tooltip
   * @param span 触发的 span 元素
   * @param entry 对应的条目对象
   */
  showCommentTooltip(span, entry) {
    this.hideCommentTooltip();
    const tooltip = document.createElement("div");
    tooltip.className = "BetterNotes-comment-tooltip";
    const contentEl = document.createElement("div");
    contentEl.className = "BetterNotes-comment-content";
    contentEl.textContent = entry.comment;
    tooltip.appendChild(contentEl);
    const dateEl = document.createElement("div");
    dateEl.className = "BetterNotes-comment-date";
    dateEl.textContent = entry.addTime;
    tooltip.appendChild(dateEl);
    document.body.appendChild(tooltip);
    const rect = span.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    const top = rect.bottom + window.scrollY + 6;
    let left = rect.left + window.scrollX + (rect.width - tooltipRect.width) / 2;
    left = Math.max(left, 8);
    const maxLeft = document.documentElement.clientWidth - tooltipRect.width - 8;
    left = Math.min(left, maxLeft);
    tooltip.style.top = `${top}px`;
    tooltip.style.left = `${left}px`;
    this.tooltipEl = tooltip;
  }
  /**
   * 隐藏并销毁评论 tooltip
   */
  hideCommentTooltip() {
    if (this.tooltipEl) {
      this.tooltipEl.remove();
      this.tooltipEl = null;
    }
  }
};

// src/services/EntryNavigation.ts
var import_obsidian23 = require("obsidian");
init_i18n();
var EntryNavigation = class {
  /**
   * 构造函数
   * @param app Obsidian应用实例
   * @param plugin BetterNotes插件实例
   */
  constructor(app, plugin) {
    this.highlightClass = "BetterNotes-flash-highlight";
    this.highlightDuration = 2e3;
    // 高亮持续时间（毫秒）
    /** 用于 PDF 矩形条目的临时填充高亮持续时间（毫秒） */
    this.pdfRectFlashDuration = 1e3;
    this.app = app;
    this.plugin = plugin;
    this.addHighlightStyle();
  }
  /**
   * 添加高亮样式到文档
   * 创建一个用于闪烁高亮效果的CSS类
   */
  addHighlightStyle() {
    const styleEl = document.createElement("style");
    styleEl.id = "BetterNotes-highlight-style";
    const css = `
            @keyframes BetterNotes-flash {
                0% { background-color: rgba(255, 255, 0, 0.7); }
                100% { background-color: rgba(255, 255, 0, 0); }
            }
            
            .${this.highlightClass} {
                background-color: rgba(255, 255, 0, 0);
                animation: BetterNotes-flash ${this.highlightDuration}ms ease-out;
            }
        `;
    styleEl.textContent = css;
    document.head.appendChild(styleEl);
  }
  /**
   * 跳转到指定条目并高亮显示
   * @param entry 要跳转到的条目
   * @returns Promise - 成功时返回true，失败时返回false
   */
  async navigateToEntry(entry) {
    try {
      if (entry.type === "pdf") {
        if (entry.index) {
          const hashLink = `${entry.index}&hash='${entry.hash}'`;
          await this.app.workspace.openLinkText(hashLink, "", false);
          return true;
        }
        return false;
      } else if (entry.type === "md") {
        if (!entry.sourceFile) {
          new import_obsidian23.Notice(t("cannot locate") + ": " + t("entry is not associated with a source file"));
          return false;
        }
        const file = this.app.vault.getAbstractFileByPath(entry.sourceFile);
        if (!file) {
          new import_obsidian23.Notice(t("source file not found") + ": " + entry.sourceFile);
          return false;
        }
        const hashLink = `${entry.sourceFile}#hash='${entry.hash}'`;
        await this.app.workspace.openLinkText(hashLink, "", false);
        return true;
      } else {
        if (entry.type === "video" && entry.index) {
          try {
            const parts2 = entry.index.split("&");
            if (parts2.length >= 5) {
              const timeSeconds = parts2[0];
              const videoUrl = parts2[4];
              const processedLink = `#video='${videoUrl}'&timestamp=${timeSeconds}`;
              await this.app.workspace.openLinkText(processedLink, "", false);
              return true;
            } else {
              console.error("\u89C6\u9891\u6761\u76EE index \u683C\u5F0F\u4E0D\u6B63\u786E:", entry.index);
              new import_obsidian23.Notice(t("cannot navigate") + ": " + t("video entry format is incorrect"));
            }
          } catch (error2) {
            console.error("\u5904\u7406\u89C6\u9891\u6761\u76EE\u5BFC\u822A\u65F6\u51FA\u9519:", error2);
            new import_obsidian23.Notice(t("cannot navigate") + ": " + t("video entry format is incorrect"));
          }
        } else {
          new import_obsidian23.Notice(t("cannot navigate") + ": " + t("unsupported entry type or missing necessary information"));
        }
        return false;
      }
    } catch (error2) {
      console.error("\u5BFC\u822A\u5230\u6761\u76EE\u5931\u8D25:", error2);
      new import_obsidian23.Notice(t("cannot navigate") + ": " + t("unsupported entry type or missing necessary information"));
      return false;
    }
  }
  /**
   * 高亮 PDF 矩形截取条目对应的所有 selection 矩形 DOM，支持跨行 selection。
   * @param hash 条目 hash，唯一标识 selection
   *
   * 工程实践：
   * - 支持同一 hash 关联的多个 .rect-capture-highlight 元素（跨行 selection）
   * - 高亮持续一段时间后自动恢复原背景色
   * - 代码高复用、低耦合，便于后续维护
   */
  highlightPdfRect(hash) {
    const maxAttempts = 50;
    const interval = 50;
    let attempts = 0;
    let timer;
    const highlightRects = (rects, highlightColor, duration) => {
      const originalStyles = [];
      rects.forEach((rect) => {
        originalStyles.push(rect.style.background);
        rect.style.background = highlightColor;
      });
      if (duration > 0) {
        setTimeout(() => {
          rects.forEach((rect, i3) => {
            rect.style.background = originalStyles[i3] || "";
          });
        }, duration);
      }
    };
    timer = window.setInterval(() => {
      const rects = document.querySelectorAll(`.rect-capture-highlight[data-hash="${hash}"]`);
      if (rects.length > 0) {
        clearInterval(timer);
        highlightRects(rects, "rgba(255, 255, 0, 0.7)", this.pdfRectFlashDuration);
      }
      attempts++;
      if (attempts >= maxAttempts) {
        clearInterval(timer);
      }
    }, interval);
  }
};

// src/utils/pdfUtils.ts
function applyInverseTransform(m5, p5) {
  const [a2, b4, c2, d3, e, f3] = m5;
  const det = a2 * d3 - b4 * c2 || 1e-6;
  const ia = d3 / det;
  const ib = -b4 / det;
  const ic = -c2 / det;
  const id = a2 / det;
  const ie2 = (c2 * f3 - d3 * e) / det;
  const if_ = (b4 * e - a2 * f3) / det;
  const [x4, y4] = p5;
  return [ia * x4 + ic * y4 + ie2, ib * x4 + id * y4 + if_];
}
function areRectanglesMergeableHorizontally(a2, b4) {
  const midY1 = (a2[1] + a2[3]) / 2;
  const midY2 = (b4[1] + b4[3]) / 2;
  const h1 = Math.abs(a2[3] - a2[1]);
  const h22 = Math.abs(b4[3] - b4[1]);
  const threshold = 0.5 * Math.max(h1, h22);
  return Math.abs(midY1 - midY2) < threshold;
}
function mergeSequentialRects(rects) {
  if (rects.length <= 1)
    return rects;
  const merged = [];
  let cur = rects[0];
  for (let i3 = 1; i3 < rects.length; i3++) {
    const r = rects[i3];
    if (areRectanglesMergeableHorizontally(cur, r)) {
      cur = [
        Math.min(cur[0], r[0]),
        Math.min(cur[1], r[1]),
        Math.max(cur[2], r[2]),
        Math.max(cur[3], r[3])
      ];
    } else {
      merged.push(cur);
      cur = r;
    }
  }
  merged.push(cur);
  return merged;
}
function rectsToQuadPoints(rects) {
  return rects.flatMap(([l4, b4, r, t2]) => [l4, t2, r, t2, l4, b4, r, b4]);
}
function mergeRects(rects) {
  const l4 = Math.min(...rects.map((r2) => r2[0]));
  const b4 = Math.min(...rects.map((r2) => r2[1]));
  const r = Math.max(...rects.map((r2) => r2[2]));
  const t2 = Math.max(...rects.map((r2) => r2[3]));
  return [l4, b4, r, t2];
}

// src/services/pdf/PdfSelectionService.ts
var PdfSelectionService = class {
  /**
   * 从浏览器 Selection 解析出页码及精确字符范围。
   * @param selection `window.getSelection()` 的结果
   * @returns `{ page, selection? }` 若无法确定则返回 `null`
   */
  getPageAndTextRange(selection) {
    const pageEl = this.getPageElementFromSelection(selection);
    if (!pageEl || pageEl.dataset.pageNumber === void 0)
      return null;
    const pageNumber = Number(pageEl.dataset.pageNumber);
    if (Number.isNaN(pageNumber))
      return null;
    const range2 = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
    if (range2) {
      const selRange = this.getTextSelectionRange(pageEl, range2);
      if (selRange)
        return { page: pageNumber, selection: selRange };
    }
    return { page: pageNumber };
  }
  /**
   * 计算选区在 PDF 坐标中的矩形集合（每行为一个矩形）。
   * @param pageEl `div.page` 元素
   * @param selRange 字符范围
   * @param pageView pdf.js PageView（需包含 viewport / div 等）
   */
  computeRectsForSelection(pageEl, selRange, pageView) {
    const rects = [];
    const { beginIndex, beginOffset, endIndex, endOffset } = selRange;
    if (!pageView?.viewport)
      return rects;
    const viewport = pageView.viewport;
    const pageRect = pageEl.getBoundingClientRect();
    const style = window.getComputedStyle(pageView.div);
    const borderLeft = parseFloat(style.borderLeftWidth);
    const paddingLeft = parseFloat(style.paddingLeft);
    const borderTop = parseFloat(style.borderTopWidth);
    const paddingTop = parseFloat(style.paddingTop);
    const toPdf = (clientX, clientY) => {
      const localX = clientX - (pageRect.left + borderLeft + paddingLeft);
      const localY = clientY - (pageRect.top + borderTop + paddingTop);
      return applyInverseTransform(viewport.transform, [localX, localY]);
    };
    for (let idx = beginIndex; idx <= endIndex; idx++) {
      const node = pageEl.querySelector(`span.textLayerNode[data-idx='${idx}']`);
      if (!node)
        continue;
      let domRect;
      if (idx === beginIndex || idx === endIndex) {
        const range2 = node.ownerDocument.createRange();
        if (idx === beginIndex) {
          const pos = this.getNodeAndOffsetOfTextPos(node, Math.min(beginOffset, node.textContent?.length ?? 0));
          range2.setStart(pos?.node ?? node, pos?.offset ?? 0);
        } else {
          range2.setStartBefore(node);
        }
        if (idx === endIndex) {
          const pos = this.getNodeAndOffsetOfTextPos(node, Math.min(endOffset, node.textContent?.length ?? 0));
          range2.setEnd(pos?.node ?? node, pos?.offset ?? (node.textContent?.length ?? 0));
        } else {
          range2.setEndAfter(node);
        }
        domRect = range2.getBoundingClientRect();
      } else {
        domRect = node.getBoundingClientRect();
      }
      const [x1, yTop] = toPdf(domRect.left, domRect.top);
      const [x22, yBottom] = toPdf(domRect.right, domRect.bottom);
      const bottom = Math.min(yTop, yBottom);
      const top = Math.max(yTop, yBottom);
      const normalized = window.pdfjsLib?.Util?.normalizeRect ? window.pdfjsLib.Util.normalizeRect([x1, bottom, x22, top]) : [x1, bottom, x22, top];
      rects.push(normalized);
    }
    return mergeSequentialRects(rects);
  }
  /**
   * 获取选区所在的 `div.page` 元素。
   */
  getPageElementFromSelection(selection) {
    if (!selection || selection.rangeCount === 0)
      return null;
    const range2 = selection.getRangeAt(0);
    let node = range2.commonAncestorContainer;
    while (node && node !== document) {
      if (node instanceof HTMLElement && node.classList.contains("page"))
        return node;
      node = node.parentNode;
    }
    return null;
  }
  // ----------------------- 私有工具 -----------------------
  getTextSelectionRange(pageEl, range2) {
    const startTLN = this.getTextLayerNode(pageEl, range2.startContainer);
    const endTLN = this.getTextLayerNode(pageEl, range2.endContainer);
    if (!startTLN || !endTLN)
      return null;
    const beginIndex = parseInt(startTLN.dataset.idx ?? "", 10);
    const endIndex = parseInt(endTLN.dataset.idx ?? "", 10);
    if (Number.isNaN(beginIndex) || Number.isNaN(endIndex))
      return null;
    const beginOffset = this.getOffsetInTextLayerNode(startTLN, range2.startContainer, range2.startOffset);
    const endOffset = this.getOffsetInTextLayerNode(endTLN, range2.endContainer, range2.endOffset);
    if (beginOffset == null || endOffset == null)
      return null;
    return { beginIndex, beginOffset, endIndex, endOffset };
  }
  getTextLayerNode(pageEl, node) {
    if (!pageEl.contains(node))
      return null;
    if (node instanceof HTMLElement && node.classList.contains("textLayerNode"))
      return node;
    let cur = node;
    while (cur = cur.parentNode) {
      if (cur === pageEl)
        return null;
      if (cur instanceof HTMLElement && cur.classList.contains("textLayerNode"))
        return cur;
    }
    return null;
  }
  getOffsetInTextLayerNode(textLayerNode, container, offsetInNode) {
    if (!textLayerNode.contains(container))
      return null;
    const iter = textLayerNode.ownerDocument.createNodeIterator(textLayerNode, NodeFilter.SHOW_TEXT);
    let textNode;
    let offset = offsetInNode;
    while (textNode = iter.nextNode()) {
      if (textNode === container)
        break;
      offset += textNode.textContent?.length ?? 0;
    }
    return offset;
  }
  /**
   * 遍历 textLayerNode 获取给定字符偏移对应的具体 DOM Node 及其偏移。
   */
  getNodeAndOffsetOfTextPos(textLayerNode, offset) {
    const iter = textLayerNode.ownerDocument.createNodeIterator(textLayerNode, NodeFilter.SHOW_TEXT);
    let textNode;
    while ((textNode = iter.nextNode()) && offset > textNode.length) {
      offset -= textNode.length;
    }
    return textNode ? { node: textNode, offset } : null;
  }
};

// node_modules/pdf-lib/node_modules/tslib/tslib.es6.js
var extendStatics = function(d3, b4) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
    d4.__proto__ = b5;
  } || function(d4, b5) {
    for (var p5 in b5)
      if (b5.hasOwnProperty(p5))
        d4[p5] = b5[p5];
  };
  return extendStatics(d3, b4);
};
function __extends(d3, b4) {
  extendStatics(d3, b4);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s5, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s5 = arguments[i3];
      for (var p5 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p5))
          t2[p5] = s5[p5];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s5, e) {
  var t2 = {};
  for (var p5 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p5) && e.indexOf(p5) < 0)
      t2[p5] = s5[p5];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p5 = Object.getOwnPropertySymbols(s5); i3 < p5.length; i3++) {
      if (e.indexOf(p5[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p5[i3]))
        t2[p5[i3]] = s5[p5[i3]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _3 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y4, t2, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n3) {
    return function(v4) {
      return step([n3, v4]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (_3)
      try {
        if (f3 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
          return t2;
        if (y4 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _3.label++;
            return { value: op[1], done: false };
          case 5:
            _3.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _3.ops.pop();
            _3.trys.pop();
            continue;
          default:
            if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _3 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _3.label = op[1];
              break;
            }
            if (op[0] === 6 && _3.label < t2[1]) {
              _3.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _3.label < t2[2]) {
              _3.label = t2[2];
              _3.ops.push(op);
              break;
            }
            if (t2[2])
              _3.ops.pop();
            _3.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _3);
      } catch (e) {
        op = [6, e];
        y4 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s5 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s5 += arguments[i3].length;
  for (var r = Array(s5), k5 = 0, i3 = 0; i3 < il; i3++)
    for (var a2 = arguments[i3], j4 = 0, jl = a2.length; j4 < jl; j4++, k5++)
      r[k5] = a2[j4];
  return r;
}

// node_modules/pdf-lib/es/utils/base64.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = new Uint8Array(256);
for (i3 = 0; i3 < chars.length; i3++) {
  lookup[chars.charCodeAt(i3)] = i3;
}
var i3;
var encodeToBase64 = function(bytes) {
  var base64 = "";
  var len = bytes.length;
  for (var i3 = 0; i3 < len; i3 += 3) {
    base64 += chars[bytes[i3] >> 2];
    base64 += chars[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
    base64 += chars[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
    base64 += chars[bytes[i3 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
var decodeFromBase64 = function(base64) {
  var bufferLength = base64.length * 0.75;
  var len = base64.length;
  var i3;
  var p5 = 0;
  var encoded1;
  var encoded2;
  var encoded3;
  var encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  var bytes = new Uint8Array(bufferLength);
  for (i3 = 0; i3 < len; i3 += 4) {
    encoded1 = lookup[base64.charCodeAt(i3)];
    encoded2 = lookup[base64.charCodeAt(i3 + 1)];
    encoded3 = lookup[base64.charCodeAt(i3 + 2)];
    encoded4 = lookup[base64.charCodeAt(i3 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
};
var DATA_URI_PREFIX_REGEX = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i;
var decodeFromBase64DataUri = function(dataUri) {
  var trimmedUri = dataUri.trim();
  var prefix = trimmedUri.substring(0, 100);
  var res = prefix.match(DATA_URI_PREFIX_REGEX);
  if (!res)
    return decodeFromBase64(trimmedUri);
  var fullMatch = res[0];
  var data = trimmedUri.substring(fullMatch.length);
  return decodeFromBase64(data);
};

// node_modules/pdf-lib/es/utils/strings.js
var toCharCode = function(character) {
  return character.charCodeAt(0);
};
var toCodePoint = function(character) {
  return character.codePointAt(0);
};
var toHexStringOfMinLength = function(num, minLength) {
  return padStart(num.toString(16), minLength, "0").toUpperCase();
};
var toHexString = function(num) {
  return toHexStringOfMinLength(num, 2);
};
var charFromCode = function(code) {
  return String.fromCharCode(code);
};
var charFromHexCode = function(hex) {
  return charFromCode(parseInt(hex, 16));
};
var padStart = function(value, length, padChar) {
  var padding = "";
  for (var idx = 0, len = length - value.length; idx < len; idx++) {
    padding += padChar;
  }
  return padding + value;
};
var copyStringIntoBuffer = function(str, buffer, offset) {
  var length = str.length;
  for (var idx = 0; idx < length; idx++) {
    buffer[offset++] = str.charCodeAt(idx);
  }
  return length;
};
var escapeRegExp = function(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var cleanText = function(text) {
  return text.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "");
};
var escapedNewlineChars = ["\\n", "\\f", "\\r", "\\u000B"];
var isNewlineChar = function(text) {
  return /^[\n\f\r\u000B]$/.test(text);
};
var lineSplit = function(text) {
  return text.split(/[\n\f\r\u000B]/);
};
var mergeLines = function(text) {
  return text.replace(/[\n\f\r\u000B]/g, " ");
};
var charAtIndex = function(text, index) {
  var cuFirst = text.charCodeAt(index);
  var cuSecond;
  var nextIndex = index + 1;
  var length = 1;
  if (
    // Check if it's the start of a surrogate pair.
    cuFirst >= 55296 && cuFirst <= 56319 && // high surrogate
    text.length > nextIndex
  ) {
    cuSecond = text.charCodeAt(nextIndex);
    if (cuSecond >= 56320 && cuSecond <= 57343)
      length = 2;
  }
  return [text.slice(index, index + length), length];
};
var charSplit = function(text) {
  var chars3 = [];
  for (var idx = 0, len = text.length; idx < len; ) {
    var _a = charAtIndex(text, idx), c2 = _a[0], cLen = _a[1];
    chars3.push(c2);
    idx += cLen;
  }
  return chars3;
};
var buildWordBreakRegex = function(wordBreaks) {
  var newlineCharUnion = escapedNewlineChars.join("|");
  var escapedRules = ["$"];
  for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {
    var wordBreak = wordBreaks[idx];
    if (isNewlineChar(wordBreak)) {
      throw new TypeError("`wordBreak` must not include " + newlineCharUnion);
    }
    escapedRules.push(wordBreak === "" ? "." : escapeRegExp(wordBreak));
  }
  var breakRules = escapedRules.join("|");
  return new RegExp("(" + newlineCharUnion + ")|((.*?)(" + breakRules + "))", "gm");
};
var breakTextIntoLines = function(text, wordBreaks, maxWidth, computeWidthOfText) {
  var regex = buildWordBreakRegex(wordBreaks);
  var words = cleanText(text).match(regex);
  var currLine = "";
  var currWidth = 0;
  var lines = [];
  var pushCurrLine = function() {
    if (currLine !== "")
      lines.push(currLine);
    currLine = "";
    currWidth = 0;
  };
  for (var idx = 0, len = words.length; idx < len; idx++) {
    var word = words[idx];
    if (isNewlineChar(word)) {
      pushCurrLine();
    } else {
      var width = computeWidthOfText(word);
      if (currWidth + width > maxWidth)
        pushCurrLine();
      currLine += word;
      currWidth += width;
    }
  }
  pushCurrLine();
  return lines;
};
var dateRegex = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;
var parseDate = function(dateStr) {
  var match = dateStr.match(dateRegex);
  if (!match)
    return void 0;
  var year = match[1], _a = match[2], month = _a === void 0 ? "01" : _a, _b = match[3], day = _b === void 0 ? "01" : _b, _c = match[4], hours = _c === void 0 ? "00" : _c, _d = match[5], mins = _d === void 0 ? "00" : _d, _e2 = match[6], secs = _e2 === void 0 ? "00" : _e2, _f = match[7], offsetSign = _f === void 0 ? "Z" : _f, _g = match[8], offsetHours = _g === void 0 ? "00" : _g, _h = match[9], offsetMins = _h === void 0 ? "00" : _h;
  var tzOffset = offsetSign === "Z" ? "Z" : "" + offsetSign + offsetHours + ":" + offsetMins;
  var date = new Date(year + "-" + month + "-" + day + "T" + hours + ":" + mins + ":" + secs + tzOffset);
  return date;
};
var findLastMatch = function(value, regex) {
  var _a;
  var position = 0;
  var lastMatch;
  while (position < value.length) {
    var match = value.substring(position).match(regex);
    if (!match)
      return { match: lastMatch, pos: position };
    lastMatch = match;
    position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;
  }
  return { match: lastMatch, pos: position };
};

// node_modules/pdf-lib/es/utils/arrays.js
var last = function(array) {
  return array[array.length - 1];
};
var typedArrayFor = function(value) {
  if (value instanceof Uint8Array)
    return value;
  var length = value.length;
  var typedArray = new Uint8Array(length);
  for (var idx = 0; idx < length; idx++) {
    typedArray[idx] = value.charCodeAt(idx);
  }
  return typedArray;
};
var mergeIntoTypedArray = function() {
  var arrays = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    arrays[_i] = arguments[_i];
  }
  var arrayCount = arrays.length;
  var typedArrays = [];
  for (var idx = 0; idx < arrayCount; idx++) {
    var element = arrays[idx];
    typedArrays[idx] = element instanceof Uint8Array ? element : typedArrayFor(element);
  }
  var totalSize = 0;
  for (var idx = 0; idx < arrayCount; idx++) {
    totalSize += arrays[idx].length;
  }
  var merged = new Uint8Array(totalSize);
  var offset = 0;
  for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {
    var arr = typedArrays[arrIdx];
    for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {
      merged[offset++] = arr[byteIdx];
    }
  }
  return merged;
};
var mergeUint8Arrays = function(arrays) {
  var totalSize = 0;
  for (var idx = 0, len = arrays.length; idx < len; idx++) {
    totalSize += arrays[idx].length;
  }
  var mergedBuffer = new Uint8Array(totalSize);
  var offset = 0;
  for (var idx = 0, len = arrays.length; idx < len; idx++) {
    var array = arrays[idx];
    mergedBuffer.set(array, offset);
    offset += array.length;
  }
  return mergedBuffer;
};
var arrayAsString = function(array) {
  var str = "";
  for (var idx = 0, len = array.length; idx < len; idx++) {
    str += charFromCode(array[idx]);
  }
  return str;
};
var byAscendingId = function(a2, b4) {
  return a2.id - b4.id;
};
var sortedUniq = function(array, indexer) {
  var uniq = [];
  for (var idx = 0, len = array.length; idx < len; idx++) {
    var curr = array[idx];
    var prev = array[idx - 1];
    if (idx === 0 || indexer(curr) !== indexer(prev)) {
      uniq.push(curr);
    }
  }
  return uniq;
};
var reverseArray = function(array) {
  var arrayLen = array.length;
  for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {
    var leftIdx = idx;
    var rightIdx = arrayLen - idx - 1;
    var temp = array[idx];
    array[leftIdx] = array[rightIdx];
    array[rightIdx] = temp;
  }
  return array;
};
var sum = function(array) {
  var total = 0;
  for (var idx = 0, len = array.length; idx < len; idx++) {
    total += array[idx];
  }
  return total;
};
var range = function(start2, end) {
  var arr = new Array(end - start2);
  for (var idx = 0, len = arr.length; idx < len; idx++) {
    arr[idx] = start2 + idx;
  }
  return arr;
};
var pluckIndices = function(arr, indices) {
  var plucked = new Array(indices.length);
  for (var idx = 0, len = indices.length; idx < len; idx++) {
    plucked[idx] = arr[indices[idx]];
  }
  return plucked;
};
var canBeConvertedToUint8Array = function(input) {
  return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === "string";
};
var toUint8Array = function(input) {
  if (typeof input === "string") {
    return decodeFromBase64DataUri(input);
  } else if (input instanceof ArrayBuffer) {
    return new Uint8Array(input);
  } else if (input instanceof Uint8Array) {
    return input;
  } else {
    throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`");
  }
};

// node_modules/pdf-lib/es/utils/async.js
var waitForTick = function() {
  return new Promise(function(resolve2) {
    setTimeout(function() {
      return resolve2();
    }, 0);
  });
};

// node_modules/pdf-lib/es/utils/unicode.js
var utf16Encode = function(input, byteOrderMark) {
  if (byteOrderMark === void 0) {
    byteOrderMark = true;
  }
  var encoded = [];
  if (byteOrderMark)
    encoded.push(65279);
  for (var idx = 0, len = input.length; idx < len; ) {
    var codePoint = input.codePointAt(idx);
    if (codePoint < 65536) {
      encoded.push(codePoint);
      idx += 1;
    } else if (codePoint < 1114112) {
      encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));
      idx += 2;
    } else
      throw new Error("Invalid code point: 0x" + toHexString(codePoint));
  }
  return new Uint16Array(encoded);
};
var isWithinBMP = function(codePoint) {
  return codePoint >= 0 && codePoint <= 65535;
};
var hasSurrogates = function(codePoint) {
  return codePoint >= 65536 && codePoint <= 1114111;
};
var highSurrogate = function(codePoint) {
  return Math.floor((codePoint - 65536) / 1024) + 55296;
};
var lowSurrogate = function(codePoint) {
  return (codePoint - 65536) % 1024 + 56320;
};
var ByteOrder;
(function(ByteOrder2) {
  ByteOrder2["BigEndian"] = "BigEndian";
  ByteOrder2["LittleEndian"] = "LittleEndian";
})(ByteOrder || (ByteOrder = {}));
var REPLACEMENT = "\uFFFD".codePointAt(0);
var utf16Decode = function(input, byteOrderMark) {
  if (byteOrderMark === void 0) {
    byteOrderMark = true;
  }
  if (input.length <= 1)
    return String.fromCodePoint(REPLACEMENT);
  var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;
  var idx = byteOrderMark ? 2 : 0;
  var codePoints = [];
  while (input.length - idx >= 2) {
    var first = decodeValues(input[idx++], input[idx++], byteOrder);
    if (isHighSurrogate(first)) {
      if (input.length - idx < 2) {
        codePoints.push(REPLACEMENT);
      } else {
        var second = decodeValues(input[idx++], input[idx++], byteOrder);
        if (isLowSurrogate(second)) {
          codePoints.push(first, second);
        } else {
          codePoints.push(REPLACEMENT);
        }
      }
    } else if (isLowSurrogate(first)) {
      idx += 2;
      codePoints.push(REPLACEMENT);
    } else {
      codePoints.push(first);
    }
  }
  if (idx < input.length)
    codePoints.push(REPLACEMENT);
  return String.fromCodePoint.apply(String, codePoints);
};
var isHighSurrogate = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
};
var isLowSurrogate = function(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
};
var decodeValues = function(first, second, byteOrder) {
  if (byteOrder === ByteOrder.LittleEndian)
    return second << 8 | first;
  if (byteOrder === ByteOrder.BigEndian)
    return first << 8 | second;
  throw new Error("Invalid byteOrder: " + byteOrder);
};
var readBOM = function(bytes) {
  return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;
};
var hasUtf16BigEndianBOM = function(bytes) {
  return bytes[0] === 254 && bytes[1] === 255;
};
var hasUtf16LittleEndianBOM = function(bytes) {
  return bytes[0] === 255 && bytes[1] === 254;
};
var hasUtf16BOM = function(bytes) {
  return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);
};

// node_modules/pdf-lib/es/utils/numbers.js
var numberToString = function(num) {
  var numStr = String(num);
  if (Math.abs(num) < 1) {
    var e = parseInt(num.toString().split("e-")[1]);
    if (e) {
      var negative = num < 0;
      if (negative)
        num *= -1;
      num *= Math.pow(10, e - 1);
      numStr = "0." + new Array(e).join("0") + num.toString().substring(2);
      if (negative)
        numStr = "-" + numStr;
    }
  } else {
    var e = parseInt(num.toString().split("+")[1]);
    if (e > 20) {
      e -= 20;
      num /= Math.pow(10, e);
      numStr = num.toString() + new Array(e + 1).join("0");
    }
  }
  return numStr;
};
var sizeInBytes = function(n3) {
  return Math.ceil(n3.toString(2).length / 8);
};
var bytesFor = function(n3) {
  var bytes = new Uint8Array(sizeInBytes(n3));
  for (var i3 = 1; i3 <= bytes.length; i3++) {
    bytes[i3 - 1] = n3 >> (bytes.length - i3) * 8;
  }
  return bytes;
};

// node_modules/pdf-lib/es/utils/errors.js
var error = function(msg) {
  throw new Error(msg);
};

// node_modules/@pdf-lib/standard-fonts/es/utils.js
var import_pako = __toESM(require_pako());
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup2 = new Uint8Array(256);
for (i3 = 0; i3 < chars2.length; i3++) {
  lookup2[chars2.charCodeAt(i3)] = i3;
}
var i3;
var decodeFromBase642 = function(base64) {
  var bufferLength = base64.length * 0.75;
  var len = base64.length;
  var i3;
  var p5 = 0;
  var encoded1;
  var encoded2;
  var encoded3;
  var encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  var bytes = new Uint8Array(bufferLength);
  for (i3 = 0; i3 < len; i3 += 4) {
    encoded1 = lookup2[base64.charCodeAt(i3)];
    encoded2 = lookup2[base64.charCodeAt(i3 + 1)];
    encoded3 = lookup2[base64.charCodeAt(i3 + 2)];
    encoded4 = lookup2[base64.charCodeAt(i3 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
};
var arrayToString = function(array) {
  var str = "";
  for (var i3 = 0; i3 < array.length; i3++) {
    str += String.fromCharCode(array[i3]);
  }
  return str;
};
var decompressJson = function(compressedJson) {
  return arrayToString(import_pako.default.inflate(decodeFromBase642(compressedJson)));
};
var padStart2 = function(value, length, padChar) {
  var padding = "";
  for (var idx = 0, len = length - value.length; idx < len; idx++) {
    padding += padChar;
  }
  return padding + value;
};

// node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json
var Courier_Bold_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json
var Courier_BoldOblique_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json
var Courier_Oblique_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json
var Courier_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json
var Helvetica_Bold_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json
var Helvetica_BoldOblique_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json
var Helvetica_Oblique_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json
var Helvetica_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json
var Times_Bold_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json
var Times_BoldItalic_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json
var Times_Italic_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json
var Times_Roman_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json
var Symbol_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json
var ZapfDingbats_compressed_default = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";

// node_modules/@pdf-lib/standard-fonts/es/Font.js
var compressedJsonForFontName = {
  "Courier": Courier_compressed_default,
  "Courier-Bold": Courier_Bold_compressed_default,
  "Courier-Oblique": Courier_Oblique_compressed_default,
  "Courier-BoldOblique": Courier_BoldOblique_compressed_default,
  "Helvetica": Helvetica_compressed_default,
  "Helvetica-Bold": Helvetica_Bold_compressed_default,
  "Helvetica-Oblique": Helvetica_Oblique_compressed_default,
  "Helvetica-BoldOblique": Helvetica_BoldOblique_compressed_default,
  "Times-Roman": Times_Roman_compressed_default,
  "Times-Bold": Times_Bold_compressed_default,
  "Times-Italic": Times_Italic_compressed_default,
  "Times-BoldItalic": Times_BoldItalic_compressed_default,
  "Symbol": Symbol_compressed_default,
  "ZapfDingbats": ZapfDingbats_compressed_default
};
var FontNames;
(function(FontNames2) {
  FontNames2["Courier"] = "Courier";
  FontNames2["CourierBold"] = "Courier-Bold";
  FontNames2["CourierOblique"] = "Courier-Oblique";
  FontNames2["CourierBoldOblique"] = "Courier-BoldOblique";
  FontNames2["Helvetica"] = "Helvetica";
  FontNames2["HelveticaBold"] = "Helvetica-Bold";
  FontNames2["HelveticaOblique"] = "Helvetica-Oblique";
  FontNames2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
  FontNames2["TimesRoman"] = "Times-Roman";
  FontNames2["TimesRomanBold"] = "Times-Bold";
  FontNames2["TimesRomanItalic"] = "Times-Italic";
  FontNames2["TimesRomanBoldItalic"] = "Times-BoldItalic";
  FontNames2["Symbol"] = "Symbol";
  FontNames2["ZapfDingbats"] = "ZapfDingbats";
})(FontNames || (FontNames = {}));
var fontCache = {};
var Font = (
  /** @class */
  function() {
    function Font2() {
      var _this = this;
      this.getWidthOfGlyph = function(glyphName) {
        return _this.CharWidths[glyphName];
      };
      this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {
        return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];
      };
    }
    Font2.load = function(fontName) {
      var cachedFont = fontCache[fontName];
      if (cachedFont)
        return cachedFont;
      var json = decompressJson(compressedJsonForFontName[fontName]);
      var font = Object.assign(new Font2(), JSON.parse(json));
      font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {
        acc[metric.N] = metric.WX;
        return acc;
      }, {});
      font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {
        var name1 = _a[0], name2 = _a[1], width = _a[2];
        if (!acc[name1])
          acc[name1] = {};
        acc[name1][name2] = width;
        return acc;
      }, {});
      fontCache[fontName] = font;
      return font;
    };
    return Font2;
  }()
);

// node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json
var all_encodings_compressed_default = "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";

// node_modules/@pdf-lib/standard-fonts/es/Encoding.js
var decompressedEncodings = decompressJson(all_encodings_compressed_default);
var allUnicodeMappings = JSON.parse(decompressedEncodings);
var Encoding = (
  /** @class */
  function() {
    function Encoding2(name2, unicodeMappings) {
      var _this = this;
      this.canEncodeUnicodeCodePoint = function(codePoint) {
        return codePoint in _this.unicodeMappings;
      };
      this.encodeUnicodeCodePoint = function(codePoint) {
        var mapped = _this.unicodeMappings[codePoint];
        if (!mapped) {
          var str = String.fromCharCode(codePoint);
          var hexCode = "0x" + padStart2(codePoint.toString(16), 4, "0");
          var msg = _this.name + ' cannot encode "' + str + '" (' + hexCode + ")";
          throw new Error(msg);
        }
        return { code: mapped[0], name: mapped[1] };
      };
      this.name = name2;
      this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a2, b4) {
        return a2 - b4;
      });
      this.unicodeMappings = unicodeMappings;
    }
    return Encoding2;
  }()
);
var Encodings = {
  Symbol: new Encoding("Symbol", allUnicodeMappings.symbol),
  ZapfDingbats: new Encoding("ZapfDingbats", allUnicodeMappings.zapfdingbats),
  WinAnsi: new Encoding("WinAnsi", allUnicodeMappings.win1252)
};

// node_modules/pdf-lib/es/utils/objects.js
var values = function(obj) {
  return Object.keys(obj).map(function(k5) {
    return obj[k5];
  });
};
var StandardFontValues = values(FontNames);
var isStandardFont = function(input) {
  return StandardFontValues.includes(input);
};
var rectanglesAreEqual = function(a2, b4) {
  return a2.x === b4.x && a2.y === b4.y && a2.width === b4.width && a2.height === b4.height;
};

// node_modules/pdf-lib/es/utils/validators.js
var backtick = function(val) {
  return "`" + val + "`";
};
var singleQuote = function(val) {
  return "'" + val + "'";
};
var formatValue = function(value) {
  var type = typeof value;
  if (type === "string")
    return singleQuote(value);
  else if (type === "undefined")
    return backtick(value);
  else
    return value;
};
var createValueErrorMsg = function(value, valueName, values2) {
  var allowedValues = new Array(values2.length);
  for (var idx = 0, len = values2.length; idx < len; idx++) {
    var v4 = values2[idx];
    allowedValues[idx] = formatValue(v4);
  }
  var joinedValues = allowedValues.join(" or ");
  return backtick(valueName) + " must be one of " + joinedValues + ", but was actually " + formatValue(value);
};
var assertIsOneOf = function(value, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  for (var idx = 0, len = allowedValues.length; idx < len; idx++) {
    if (value === allowedValues[idx])
      return;
  }
  throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));
};
var assertIsOneOfOrUndefined = function(value, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  assertIsOneOf(value, valueName, allowedValues.concat(void 0));
};
var assertIsSubset = function(values2, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  for (var idx = 0, len = values2.length; idx < len; idx++) {
    assertIsOneOf(values2[idx], valueName, allowedValues);
  }
};
var getType = function(val) {
  if (val === null)
    return "null";
  if (val === void 0)
    return "undefined";
  if (typeof val === "string")
    return "string";
  if (isNaN(val))
    return "NaN";
  if (typeof val === "number")
    return "number";
  if (typeof val === "boolean")
    return "boolean";
  if (typeof val === "symbol")
    return "symbol";
  if (typeof val === "bigint")
    return "bigint";
  if (val.constructor && val.constructor.name)
    return val.constructor.name;
  if (val.name)
    return val.name;
  if (val.constructor)
    return String(val.constructor);
  return String(val);
};
var isType = function(value, type) {
  if (type === "null")
    return value === null;
  if (type === "undefined")
    return value === void 0;
  if (type === "string")
    return typeof value === "string";
  if (type === "number")
    return typeof value === "number" && !isNaN(value);
  if (type === "boolean")
    return typeof value === "boolean";
  if (type === "symbol")
    return typeof value === "symbol";
  if (type === "bigint")
    return typeof value === "bigint";
  if (type === Date)
    return value instanceof Date;
  if (type === Array)
    return value instanceof Array;
  if (type === Uint8Array)
    return value instanceof Uint8Array;
  if (type === ArrayBuffer)
    return value instanceof ArrayBuffer;
  if (type === Function)
    return value instanceof Function;
  return value instanceof type[0];
};
var createTypeErrorMsg = function(value, valueName, types) {
  var allowedTypes = new Array(types.length);
  for (var idx = 0, len = types.length; idx < len; idx++) {
    var type = types[idx];
    if (type === "null")
      allowedTypes[idx] = backtick("null");
    if (type === "undefined")
      allowedTypes[idx] = backtick("undefined");
    if (type === "string")
      allowedTypes[idx] = backtick("string");
    else if (type === "number")
      allowedTypes[idx] = backtick("number");
    else if (type === "boolean")
      allowedTypes[idx] = backtick("boolean");
    else if (type === "symbol")
      allowedTypes[idx] = backtick("symbol");
    else if (type === "bigint")
      allowedTypes[idx] = backtick("bigint");
    else if (type === Array)
      allowedTypes[idx] = backtick("Array");
    else if (type === Uint8Array)
      allowedTypes[idx] = backtick("Uint8Array");
    else if (type === ArrayBuffer)
      allowedTypes[idx] = backtick("ArrayBuffer");
    else
      allowedTypes[idx] = backtick(type[1]);
  }
  var joinedTypes = allowedTypes.join(" or ");
  return backtick(valueName) + " must be of type " + joinedTypes + ", but was actually of type " + backtick(getType(value));
};
var assertIs = function(value, valueName, types) {
  for (var idx = 0, len = types.length; idx < len; idx++) {
    if (isType(value, types[idx]))
      return;
  }
  throw new TypeError(createTypeErrorMsg(value, valueName, types));
};
var assertOrUndefined = function(value, valueName, types) {
  assertIs(value, valueName, types.concat("undefined"));
};
var assertEachIs = function(values2, valueName, types) {
  for (var idx = 0, len = values2.length; idx < len; idx++) {
    assertIs(values2[idx], valueName, types);
  }
};
var assertRange = function(value, valueName, min, max) {
  assertIs(value, valueName, ["number"]);
  assertIs(min, "min", ["number"]);
  assertIs(max, "max", ["number"]);
  max = Math.max(min, max);
  if (value < min || value > max) {
    throw new Error(backtick(valueName) + " must be at least " + min + " and at most " + max + ", but was actually " + value);
  }
};
var assertRangeOrUndefined = function(value, valueName, min, max) {
  assertIs(value, valueName, ["number", "undefined"]);
  if (typeof value === "number")
    assertRange(value, valueName, min, max);
};
var assertMultiple = function(value, valueName, multiplier) {
  assertIs(value, valueName, ["number"]);
  if (value % multiplier !== 0) {
    throw new Error(backtick(valueName) + " must be a multiple of " + multiplier + ", but was actually " + value);
  }
};
var assertInteger = function(value, valueName) {
  if (!Number.isInteger(value)) {
    throw new Error(backtick(valueName) + " must be an integer, but was actually " + value);
  }
};
var assertPositive = function(value, valueName) {
  if (![1, 0].includes(Math.sign(value))) {
    throw new Error(backtick(valueName) + " must be a positive number or 0, but was actually " + value);
  }
};

// node_modules/pdf-lib/es/utils/pdfDocEncoding.js
var pdfDocEncodingToUnicode = new Uint16Array(256);
for (idx = 0; idx < 256; idx++) {
  pdfDocEncodingToUnicode[idx] = idx;
}
var idx;
pdfDocEncodingToUnicode[22] = toCharCode("");
pdfDocEncodingToUnicode[24] = toCharCode("\u02D8");
pdfDocEncodingToUnicode[25] = toCharCode("\u02C7");
pdfDocEncodingToUnicode[26] = toCharCode("\u02C6");
pdfDocEncodingToUnicode[27] = toCharCode("\u02D9");
pdfDocEncodingToUnicode[28] = toCharCode("\u02DD");
pdfDocEncodingToUnicode[29] = toCharCode("\u02DB");
pdfDocEncodingToUnicode[30] = toCharCode("\u02DA");
pdfDocEncodingToUnicode[31] = toCharCode("\u02DC");
pdfDocEncodingToUnicode[127] = toCharCode("\uFFFD");
pdfDocEncodingToUnicode[128] = toCharCode("\u2022");
pdfDocEncodingToUnicode[129] = toCharCode("\u2020");
pdfDocEncodingToUnicode[130] = toCharCode("\u2021");
pdfDocEncodingToUnicode[131] = toCharCode("\u2026");
pdfDocEncodingToUnicode[132] = toCharCode("\u2014");
pdfDocEncodingToUnicode[133] = toCharCode("\u2013");
pdfDocEncodingToUnicode[134] = toCharCode("\u0192");
pdfDocEncodingToUnicode[135] = toCharCode("\u2044");
pdfDocEncodingToUnicode[136] = toCharCode("\u2039");
pdfDocEncodingToUnicode[137] = toCharCode("\u203A");
pdfDocEncodingToUnicode[138] = toCharCode("\u2212");
pdfDocEncodingToUnicode[139] = toCharCode("\u2030");
pdfDocEncodingToUnicode[140] = toCharCode("\u201E");
pdfDocEncodingToUnicode[141] = toCharCode("\u201C");
pdfDocEncodingToUnicode[142] = toCharCode("\u201D");
pdfDocEncodingToUnicode[143] = toCharCode("\u2018");
pdfDocEncodingToUnicode[144] = toCharCode("\u2019");
pdfDocEncodingToUnicode[145] = toCharCode("\u201A");
pdfDocEncodingToUnicode[146] = toCharCode("\u2122");
pdfDocEncodingToUnicode[147] = toCharCode("\uFB01");
pdfDocEncodingToUnicode[148] = toCharCode("\uFB02");
pdfDocEncodingToUnicode[149] = toCharCode("\u0141");
pdfDocEncodingToUnicode[150] = toCharCode("\u0152");
pdfDocEncodingToUnicode[151] = toCharCode("\u0160");
pdfDocEncodingToUnicode[152] = toCharCode("\u0178");
pdfDocEncodingToUnicode[153] = toCharCode("\u017D");
pdfDocEncodingToUnicode[154] = toCharCode("\u0131");
pdfDocEncodingToUnicode[155] = toCharCode("\u0142");
pdfDocEncodingToUnicode[156] = toCharCode("\u0153");
pdfDocEncodingToUnicode[157] = toCharCode("\u0161");
pdfDocEncodingToUnicode[158] = toCharCode("\u017E");
pdfDocEncodingToUnicode[159] = toCharCode("\uFFFD");
pdfDocEncodingToUnicode[160] = toCharCode("\u20AC");
pdfDocEncodingToUnicode[173] = toCharCode("\uFFFD");
var pdfDocEncodingDecode = function(bytes) {
  var codePoints = new Array(bytes.length);
  for (var idx = 0, len = bytes.length; idx < len; idx++) {
    codePoints[idx] = pdfDocEncodingToUnicode[bytes[idx]];
  }
  return String.fromCodePoint.apply(String, codePoints);
};

// node_modules/pdf-lib/es/utils/Cache.js
var Cache = (
  /** @class */
  function() {
    function Cache2(populate) {
      this.populate = populate;
      this.value = void 0;
    }
    Cache2.prototype.getValue = function() {
      return this.value;
    };
    Cache2.prototype.access = function() {
      if (!this.value)
        this.value = this.populate();
      return this.value;
    };
    Cache2.prototype.invalidate = function() {
      this.value = void 0;
    };
    Cache2.populatedBy = function(populate) {
      return new Cache2(populate);
    };
    return Cache2;
  }()
);
var Cache_default = Cache;

// node_modules/pdf-lib/es/core/errors.js
var MethodNotImplementedError = (
  /** @class */
  function(_super) {
    __extends(MethodNotImplementedError2, _super);
    function MethodNotImplementedError2(className, methodName) {
      var _this = this;
      var msg = "Method " + className + "." + methodName + "() not implemented";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MethodNotImplementedError2;
  }(Error)
);
var PrivateConstructorError = (
  /** @class */
  function(_super) {
    __extends(PrivateConstructorError2, _super);
    function PrivateConstructorError2(className) {
      var _this = this;
      var msg = "Cannot construct " + className + " - it has a private constructor";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return PrivateConstructorError2;
  }(Error)
);
var UnexpectedObjectTypeError = (
  /** @class */
  function(_super) {
    __extends(UnexpectedObjectTypeError2, _super);
    function UnexpectedObjectTypeError2(expected, actual) {
      var _this = this;
      var name2 = function(t2) {
        var _a, _b;
        return (_a = t2 === null || t2 === void 0 ? void 0 : t2.name) !== null && _a !== void 0 ? _a : (_b = t2 === null || t2 === void 0 ? void 0 : t2.constructor) === null || _b === void 0 ? void 0 : _b.name;
      };
      var expectedTypes = Array.isArray(expected) ? expected.map(name2) : [name2(expected)];
      var msg = "Expected instance of " + expectedTypes.join(" or ") + ", " + ("but got instance of " + (actual ? name2(actual) : actual));
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return UnexpectedObjectTypeError2;
  }(Error)
);
var UnsupportedEncodingError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedEncodingError2, _super);
    function UnsupportedEncodingError2(encoding) {
      var _this = this;
      var msg = encoding + " stream encoding not supported";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return UnsupportedEncodingError2;
  }(Error)
);
var ReparseError = (
  /** @class */
  function(_super) {
    __extends(ReparseError2, _super);
    function ReparseError2(className, methodName) {
      var _this = this;
      var msg = "Cannot call " + className + "." + methodName + "() more than once";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return ReparseError2;
  }(Error)
);
var MissingCatalogError = (
  /** @class */
  function(_super) {
    __extends(MissingCatalogError2, _super);
    function MissingCatalogError2(ref) {
      var _this = this;
      var msg = "Missing catalog (ref=" + ref + ")";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MissingCatalogError2;
  }(Error)
);
var MissingPageContentsEmbeddingError = (
  /** @class */
  function(_super) {
    __extends(MissingPageContentsEmbeddingError2, _super);
    function MissingPageContentsEmbeddingError2() {
      var _this = this;
      var msg = "Can't embed page with missing Contents";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MissingPageContentsEmbeddingError2;
  }(Error)
);
var UnrecognizedStreamTypeError = (
  /** @class */
  function(_super) {
    __extends(UnrecognizedStreamTypeError2, _super);
    function UnrecognizedStreamTypeError2(stream2) {
      var _a, _b, _c;
      var _this = this;
      var streamType = (_c = (_b = (_a = stream2 === null || stream2 === void 0 ? void 0 : stream2.contructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : stream2 === null || stream2 === void 0 ? void 0 : stream2.name) !== null && _c !== void 0 ? _c : stream2;
      var msg = "Unrecognized stream type: " + streamType;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return UnrecognizedStreamTypeError2;
  }(Error)
);
var PageEmbeddingMismatchedContextError = (
  /** @class */
  function(_super) {
    __extends(PageEmbeddingMismatchedContextError2, _super);
    function PageEmbeddingMismatchedContextError2() {
      var _this = this;
      var msg = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return PageEmbeddingMismatchedContextError2;
  }(Error)
);
var PDFArrayIsNotRectangleError = (
  /** @class */
  function(_super) {
    __extends(PDFArrayIsNotRectangleError2, _super);
    function PDFArrayIsNotRectangleError2(size) {
      var _this = this;
      var msg = "Attempted to convert PDFArray with " + size + " elements to rectangle, but must have exactly 4 elements.";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return PDFArrayIsNotRectangleError2;
  }(Error)
);
var InvalidPDFDateStringError = (
  /** @class */
  function(_super) {
    __extends(InvalidPDFDateStringError2, _super);
    function InvalidPDFDateStringError2(value) {
      var _this = this;
      var msg = 'Attempted to convert "' + value + '" to a date, but it does not match the PDF date string format.';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return InvalidPDFDateStringError2;
  }(Error)
);
var InvalidTargetIndexError = (
  /** @class */
  function(_super) {
    __extends(InvalidTargetIndexError2, _super);
    function InvalidTargetIndexError2(targetIndex, Count) {
      var _this = this;
      var msg = "Invalid targetIndex specified: targetIndex=" + targetIndex + " must be less than Count=" + Count;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return InvalidTargetIndexError2;
  }(Error)
);
var CorruptPageTreeError = (
  /** @class */
  function(_super) {
    __extends(CorruptPageTreeError2, _super);
    function CorruptPageTreeError2(targetIndex, operation) {
      var _this = this;
      var msg = "Failed to " + operation + " at targetIndex=" + targetIndex + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return CorruptPageTreeError2;
  }(Error)
);
var IndexOutOfBoundsError = (
  /** @class */
  function(_super) {
    __extends(IndexOutOfBoundsError2, _super);
    function IndexOutOfBoundsError2(index, min, max) {
      var _this = this;
      var msg = "index should be at least " + min + " and at most " + max + ", but was actually " + index;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return IndexOutOfBoundsError2;
  }(Error)
);
var InvalidAcroFieldValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidAcroFieldValueError2, _super);
    function InvalidAcroFieldValueError2() {
      var _this = this;
      var msg = "Attempted to set invalid field value";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return InvalidAcroFieldValueError2;
  }(Error)
);
var MultiSelectValueError = (
  /** @class */
  function(_super) {
    __extends(MultiSelectValueError2, _super);
    function MultiSelectValueError2() {
      var _this = this;
      var msg = "Attempted to select multiple values for single-select field";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MultiSelectValueError2;
  }(Error)
);
var MissingDAEntryError = (
  /** @class */
  function(_super) {
    __extends(MissingDAEntryError2, _super);
    function MissingDAEntryError2(fieldName) {
      var _this = this;
      var msg = "No /DA (default appearance) entry found for field: " + fieldName;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MissingDAEntryError2;
  }(Error)
);
var MissingTfOperatorError = (
  /** @class */
  function(_super) {
    __extends(MissingTfOperatorError2, _super);
    function MissingTfOperatorError2(fieldName) {
      var _this = this;
      var msg = "No Tf operator found for DA of field: " + fieldName;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MissingTfOperatorError2;
  }(Error)
);
var NumberParsingError = (
  /** @class */
  function(_super) {
    __extends(NumberParsingError2, _super);
    function NumberParsingError2(pos, value) {
      var _this = this;
      var msg = "Failed to parse number " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + '): "' + value + '"');
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return NumberParsingError2;
  }(Error)
);
var PDFParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFParsingError2, _super);
    function PDFParsingError2(pos, details) {
      var _this = this;
      var msg = "Failed to parse PDF document " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + "): " + details);
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return PDFParsingError2;
  }(Error)
);
var NextByteAssertionError = (
  /** @class */
  function(_super) {
    __extends(NextByteAssertionError2, _super);
    function NextByteAssertionError2(pos, expectedByte, actualByte) {
      var _this = this;
      var msg = "Expected next byte to be " + expectedByte + " but it was actually " + actualByte;
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return NextByteAssertionError2;
  }(PDFParsingError)
);
var PDFObjectParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFObjectParsingError2, _super);
    function PDFObjectParsingError2(pos, byte) {
      var _this = this;
      var msg = "Failed to parse PDF object starting with the following byte: " + byte;
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return PDFObjectParsingError2;
  }(PDFParsingError)
);
var PDFInvalidObjectParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFInvalidObjectParsingError2, _super);
    function PDFInvalidObjectParsingError2(pos) {
      var _this = this;
      var msg = "Failed to parse invalid PDF object";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return PDFInvalidObjectParsingError2;
  }(PDFParsingError)
);
var PDFStreamParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFStreamParsingError2, _super);
    function PDFStreamParsingError2(pos) {
      var _this = this;
      var msg = "Failed to parse PDF stream";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return PDFStreamParsingError2;
  }(PDFParsingError)
);
var UnbalancedParenthesisError = (
  /** @class */
  function(_super) {
    __extends(UnbalancedParenthesisError2, _super);
    function UnbalancedParenthesisError2(pos) {
      var _this = this;
      var msg = "Failed to parse PDF literal string due to unbalanced parenthesis";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return UnbalancedParenthesisError2;
  }(PDFParsingError)
);
var StalledParserError = (
  /** @class */
  function(_super) {
    __extends(StalledParserError2, _super);
    function StalledParserError2(pos) {
      var _this = this;
      var msg = "Parser stalled";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return StalledParserError2;
  }(PDFParsingError)
);
var MissingPDFHeaderError = (
  /** @class */
  function(_super) {
    __extends(MissingPDFHeaderError2, _super);
    function MissingPDFHeaderError2(pos) {
      var _this = this;
      var msg = "No PDF header found";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return MissingPDFHeaderError2;
  }(PDFParsingError)
);
var MissingKeywordError = (
  /** @class */
  function(_super) {
    __extends(MissingKeywordError2, _super);
    function MissingKeywordError2(pos, keyword) {
      var _this = this;
      var msg = "Did not find expected keyword '" + arrayAsString(keyword) + "'";
      _this = _super.call(this, pos, msg) || this;
      return _this;
    }
    return MissingKeywordError2;
  }(PDFParsingError)
);

// node_modules/pdf-lib/es/core/syntax/CharCodes.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Null"] = 0] = "Null";
  CharCodes2[CharCodes2["Backspace"] = 8] = "Backspace";
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["Newline"] = 10] = "Newline";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationPoint"] = 33] = "ExclamationPoint";
  CharCodes2[CharCodes2["Hash"] = 35] = "Hash";
  CharCodes2[CharCodes2["Percent"] = 37] = "Percent";
  CharCodes2[CharCodes2["LeftParen"] = 40] = "LeftParen";
  CharCodes2[CharCodes2["RightParen"] = 41] = "RightParen";
  CharCodes2[CharCodes2["Plus"] = 43] = "Plus";
  CharCodes2[CharCodes2["Minus"] = 45] = "Minus";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Period"] = 46] = "Period";
  CharCodes2[CharCodes2["ForwardSlash"] = 47] = "ForwardSlash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["One"] = 49] = "One";
  CharCodes2[CharCodes2["Two"] = 50] = "Two";
  CharCodes2[CharCodes2["Three"] = 51] = "Three";
  CharCodes2[CharCodes2["Four"] = 52] = "Four";
  CharCodes2[CharCodes2["Five"] = 53] = "Five";
  CharCodes2[CharCodes2["Six"] = 54] = "Six";
  CharCodes2[CharCodes2["Seven"] = 55] = "Seven";
  CharCodes2[CharCodes2["Eight"] = 56] = "Eight";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["LessThan"] = 60] = "LessThan";
  CharCodes2[CharCodes2["GreaterThan"] = 62] = "GreaterThan";
  CharCodes2[CharCodes2["A"] = 65] = "A";
  CharCodes2[CharCodes2["D"] = 68] = "D";
  CharCodes2[CharCodes2["E"] = 69] = "E";
  CharCodes2[CharCodes2["F"] = 70] = "F";
  CharCodes2[CharCodes2["O"] = 79] = "O";
  CharCodes2[CharCodes2["P"] = 80] = "P";
  CharCodes2[CharCodes2["R"] = 82] = "R";
  CharCodes2[CharCodes2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
  CharCodes2[CharCodes2["BackSlash"] = 92] = "BackSlash";
  CharCodes2[CharCodes2["RightSquareBracket"] = 93] = "RightSquareBracket";
  CharCodes2[CharCodes2["a"] = 97] = "a";
  CharCodes2[CharCodes2["b"] = 98] = "b";
  CharCodes2[CharCodes2["d"] = 100] = "d";
  CharCodes2[CharCodes2["e"] = 101] = "e";
  CharCodes2[CharCodes2["f"] = 102] = "f";
  CharCodes2[CharCodes2["i"] = 105] = "i";
  CharCodes2[CharCodes2["j"] = 106] = "j";
  CharCodes2[CharCodes2["l"] = 108] = "l";
  CharCodes2[CharCodes2["m"] = 109] = "m";
  CharCodes2[CharCodes2["n"] = 110] = "n";
  CharCodes2[CharCodes2["o"] = 111] = "o";
  CharCodes2[CharCodes2["r"] = 114] = "r";
  CharCodes2[CharCodes2["s"] = 115] = "s";
  CharCodes2[CharCodes2["t"] = 116] = "t";
  CharCodes2[CharCodes2["u"] = 117] = "u";
  CharCodes2[CharCodes2["x"] = 120] = "x";
  CharCodes2[CharCodes2["LeftCurly"] = 123] = "LeftCurly";
  CharCodes2[CharCodes2["RightCurly"] = 125] = "RightCurly";
  CharCodes2[CharCodes2["Tilde"] = 126] = "Tilde";
})(CharCodes || (CharCodes = {}));
var CharCodes_default = CharCodes;

// node_modules/pdf-lib/es/core/PDFContext.js
var import_pako3 = __toESM(require_pako());

// node_modules/pdf-lib/es/core/document/PDFHeader.js
var PDFHeader = (
  /** @class */
  function() {
    function PDFHeader2(major, minor) {
      this.major = String(major);
      this.minor = String(minor);
    }
    PDFHeader2.prototype.toString = function() {
      var bc = charFromCode(129);
      return "%PDF-" + this.major + "." + this.minor + "\n%" + bc + bc + bc + bc;
    };
    PDFHeader2.prototype.sizeInBytes = function() {
      return 12 + this.major.length + this.minor.length;
    };
    PDFHeader2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.Percent;
      buffer[offset++] = CharCodes_default.P;
      buffer[offset++] = CharCodes_default.D;
      buffer[offset++] = CharCodes_default.F;
      buffer[offset++] = CharCodes_default.Dash;
      offset += copyStringIntoBuffer(this.major, buffer, offset);
      buffer[offset++] = CharCodes_default.Period;
      offset += copyStringIntoBuffer(this.minor, buffer, offset);
      buffer[offset++] = CharCodes_default.Newline;
      buffer[offset++] = CharCodes_default.Percent;
      buffer[offset++] = 129;
      buffer[offset++] = 129;
      buffer[offset++] = 129;
      buffer[offset++] = 129;
      return offset - initialOffset;
    };
    PDFHeader2.forVersion = function(major, minor) {
      return new PDFHeader2(major, minor);
    };
    return PDFHeader2;
  }()
);
var PDFHeader_default = PDFHeader;

// node_modules/pdf-lib/es/core/objects/PDFObject.js
var PDFObject = (
  /** @class */
  function() {
    function PDFObject2() {
    }
    PDFObject2.prototype.clone = function(_context) {
      throw new MethodNotImplementedError(this.constructor.name, "clone");
    };
    PDFObject2.prototype.toString = function() {
      throw new MethodNotImplementedError(this.constructor.name, "toString");
    };
    PDFObject2.prototype.sizeInBytes = function() {
      throw new MethodNotImplementedError(this.constructor.name, "sizeInBytes");
    };
    PDFObject2.prototype.copyBytesInto = function(_buffer, _offset) {
      throw new MethodNotImplementedError(this.constructor.name, "copyBytesInto");
    };
    return PDFObject2;
  }()
);
var PDFObject_default = PDFObject;

// node_modules/pdf-lib/es/core/objects/PDFNumber.js
var PDFNumber = (
  /** @class */
  function(_super) {
    __extends(PDFNumber2, _super);
    function PDFNumber2(value) {
      var _this = _super.call(this) || this;
      _this.numberValue = value;
      _this.stringValue = numberToString(value);
      return _this;
    }
    PDFNumber2.prototype.asNumber = function() {
      return this.numberValue;
    };
    PDFNumber2.prototype.value = function() {
      return this.numberValue;
    };
    PDFNumber2.prototype.clone = function() {
      return PDFNumber2.of(this.numberValue);
    };
    PDFNumber2.prototype.toString = function() {
      return this.stringValue;
    };
    PDFNumber2.prototype.sizeInBytes = function() {
      return this.stringValue.length;
    };
    PDFNumber2.prototype.copyBytesInto = function(buffer, offset) {
      offset += copyStringIntoBuffer(this.stringValue, buffer, offset);
      return this.stringValue.length;
    };
    PDFNumber2.of = function(value) {
      return new PDFNumber2(value);
    };
    return PDFNumber2;
  }(PDFObject_default)
);
var PDFNumber_default = PDFNumber;

// node_modules/pdf-lib/es/core/objects/PDFArray.js
var PDFArray = (
  /** @class */
  function(_super) {
    __extends(PDFArray2, _super);
    function PDFArray2(context) {
      var _this = _super.call(this) || this;
      _this.array = [];
      _this.context = context;
      return _this;
    }
    PDFArray2.prototype.size = function() {
      return this.array.length;
    };
    PDFArray2.prototype.push = function(object) {
      this.array.push(object);
    };
    PDFArray2.prototype.insert = function(index, object) {
      this.array.splice(index, 0, object);
    };
    PDFArray2.prototype.indexOf = function(object) {
      var index = this.array.indexOf(object);
      return index === -1 ? void 0 : index;
    };
    PDFArray2.prototype.remove = function(index) {
      this.array.splice(index, 1);
    };
    PDFArray2.prototype.set = function(idx, object) {
      this.array[idx] = object;
    };
    PDFArray2.prototype.get = function(index) {
      return this.array[index];
    };
    PDFArray2.prototype.lookupMaybe = function(index) {
      var _a;
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      return (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(index)], types));
    };
    PDFArray2.prototype.lookup = function(index) {
      var _a;
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      return (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(index)], types));
    };
    PDFArray2.prototype.asRectangle = function() {
      if (this.size() !== 4)
        throw new PDFArrayIsNotRectangleError(this.size());
      var lowerLeftX = this.lookup(0, PDFNumber_default).asNumber();
      var lowerLeftY = this.lookup(1, PDFNumber_default).asNumber();
      var upperRightX = this.lookup(2, PDFNumber_default).asNumber();
      var upperRightY = this.lookup(3, PDFNumber_default).asNumber();
      var x4 = lowerLeftX;
      var y4 = lowerLeftY;
      var width = upperRightX - lowerLeftX;
      var height = upperRightY - lowerLeftY;
      return { x: x4, y: y4, width, height };
    };
    PDFArray2.prototype.asArray = function() {
      return this.array.slice();
    };
    PDFArray2.prototype.clone = function(context) {
      var clone = PDFArray2.withContext(context || this.context);
      for (var idx = 0, len = this.size(); idx < len; idx++) {
        clone.push(this.array[idx]);
      }
      return clone;
    };
    PDFArray2.prototype.toString = function() {
      var arrayString = "[ ";
      for (var idx = 0, len = this.size(); idx < len; idx++) {
        arrayString += this.get(idx).toString();
        arrayString += " ";
      }
      arrayString += "]";
      return arrayString;
    };
    PDFArray2.prototype.sizeInBytes = function() {
      var size = 3;
      for (var idx = 0, len = this.size(); idx < len; idx++) {
        size += this.get(idx).sizeInBytes() + 1;
      }
      return size;
    };
    PDFArray2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.LeftSquareBracket;
      buffer[offset++] = CharCodes_default.Space;
      for (var idx = 0, len = this.size(); idx < len; idx++) {
        offset += this.get(idx).copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Space;
      }
      buffer[offset++] = CharCodes_default.RightSquareBracket;
      return offset - initialOffset;
    };
    PDFArray2.prototype.scalePDFNumbers = function(x4, y4) {
      for (var idx = 0, len = this.size(); idx < len; idx++) {
        var el = this.lookup(idx);
        if (el instanceof PDFNumber_default) {
          var factor = idx % 2 === 0 ? x4 : y4;
          this.set(idx, PDFNumber_default.of(el.asNumber() * factor));
        }
      }
    };
    PDFArray2.withContext = function(context) {
      return new PDFArray2(context);
    };
    return PDFArray2;
  }(PDFObject_default)
);
var PDFArray_default = PDFArray;

// node_modules/pdf-lib/es/core/objects/PDFBool.js
var ENFORCER = {};
var PDFBool = (
  /** @class */
  function(_super) {
    __extends(PDFBool2, _super);
    function PDFBool2(enforcer, value) {
      var _this = this;
      if (enforcer !== ENFORCER)
        throw new PrivateConstructorError("PDFBool");
      _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFBool2.prototype.asBoolean = function() {
      return this.value;
    };
    PDFBool2.prototype.clone = function() {
      return this;
    };
    PDFBool2.prototype.toString = function() {
      return String(this.value);
    };
    PDFBool2.prototype.sizeInBytes = function() {
      return this.value ? 4 : 5;
    };
    PDFBool2.prototype.copyBytesInto = function(buffer, offset) {
      if (this.value) {
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.u;
        buffer[offset++] = CharCodes_default.e;
        return 4;
      } else {
        buffer[offset++] = CharCodes_default.f;
        buffer[offset++] = CharCodes_default.a;
        buffer[offset++] = CharCodes_default.l;
        buffer[offset++] = CharCodes_default.s;
        buffer[offset++] = CharCodes_default.e;
        return 5;
      }
    };
    PDFBool2.True = new PDFBool2(ENFORCER, true);
    PDFBool2.False = new PDFBool2(ENFORCER, false);
    return PDFBool2;
  }(PDFObject_default)
);
var PDFBool_default = PDFBool;

// node_modules/pdf-lib/es/core/syntax/Delimiters.js
var IsDelimiter = new Uint8Array(256);
IsDelimiter[CharCodes_default.LeftParen] = 1;
IsDelimiter[CharCodes_default.RightParen] = 1;
IsDelimiter[CharCodes_default.LessThan] = 1;
IsDelimiter[CharCodes_default.GreaterThan] = 1;
IsDelimiter[CharCodes_default.LeftSquareBracket] = 1;
IsDelimiter[CharCodes_default.RightSquareBracket] = 1;
IsDelimiter[CharCodes_default.LeftCurly] = 1;
IsDelimiter[CharCodes_default.RightCurly] = 1;
IsDelimiter[CharCodes_default.ForwardSlash] = 1;
IsDelimiter[CharCodes_default.Percent] = 1;

// node_modules/pdf-lib/es/core/syntax/Whitespace.js
var IsWhitespace = new Uint8Array(256);
IsWhitespace[CharCodes_default.Null] = 1;
IsWhitespace[CharCodes_default.Tab] = 1;
IsWhitespace[CharCodes_default.Newline] = 1;
IsWhitespace[CharCodes_default.FormFeed] = 1;
IsWhitespace[CharCodes_default.CarriageReturn] = 1;
IsWhitespace[CharCodes_default.Space] = 1;

// node_modules/pdf-lib/es/core/syntax/Irregular.js
var IsIrregular = new Uint8Array(256);
for (idx = 0, len = 256; idx < len; idx++) {
  IsIrregular[idx] = IsWhitespace[idx] || IsDelimiter[idx] ? 1 : 0;
}
var idx;
var len;
IsIrregular[CharCodes_default.Hash] = 1;

// node_modules/pdf-lib/es/core/objects/PDFName.js
var decodeName = function(name2) {
  return name2.replace(/#([\dABCDEF]{2})/g, function(_3, hex) {
    return charFromHexCode(hex);
  });
};
var isRegularChar = function(charCode) {
  return charCode >= CharCodes_default.ExclamationPoint && charCode <= CharCodes_default.Tilde && !IsIrregular[charCode];
};
var ENFORCER2 = {};
var pool = /* @__PURE__ */ new Map();
var PDFName = (
  /** @class */
  function(_super) {
    __extends(PDFName2, _super);
    function PDFName2(enforcer, name2) {
      var _this = this;
      if (enforcer !== ENFORCER2)
        throw new PrivateConstructorError("PDFName");
      _this = _super.call(this) || this;
      var encodedName = "/";
      for (var idx = 0, len = name2.length; idx < len; idx++) {
        var character = name2[idx];
        var code = toCharCode(character);
        encodedName += isRegularChar(code) ? character : "#" + toHexString(code);
      }
      _this.encodedName = encodedName;
      return _this;
    }
    PDFName2.prototype.asBytes = function() {
      var bytes = [];
      var hex = "";
      var escaped = false;
      var pushByte = function(byte2) {
        if (byte2 !== void 0)
          bytes.push(byte2);
        escaped = false;
      };
      for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {
        var char = this.encodedName[idx];
        var byte = toCharCode(char);
        var nextChar = this.encodedName[idx + 1];
        if (!escaped) {
          if (byte === CharCodes_default.Hash)
            escaped = true;
          else
            pushByte(byte);
        } else {
          if (byte >= CharCodes_default.Zero && byte <= CharCodes_default.Nine || byte >= CharCodes_default.a && byte <= CharCodes_default.f || byte >= CharCodes_default.A && byte <= CharCodes_default.F) {
            hex += char;
            if (hex.length === 2 || !(nextChar >= "0" && nextChar <= "9" || nextChar >= "a" && nextChar <= "f" || nextChar >= "A" && nextChar <= "F")) {
              pushByte(parseInt(hex, 16));
              hex = "";
            }
          } else {
            pushByte(byte);
          }
        }
      }
      return new Uint8Array(bytes);
    };
    PDFName2.prototype.decodeText = function() {
      var bytes = this.asBytes();
      return String.fromCharCode.apply(String, Array.from(bytes));
    };
    PDFName2.prototype.asString = function() {
      return this.encodedName;
    };
    PDFName2.prototype.value = function() {
      return this.encodedName;
    };
    PDFName2.prototype.clone = function() {
      return this;
    };
    PDFName2.prototype.toString = function() {
      return this.encodedName;
    };
    PDFName2.prototype.sizeInBytes = function() {
      return this.encodedName.length;
    };
    PDFName2.prototype.copyBytesInto = function(buffer, offset) {
      offset += copyStringIntoBuffer(this.encodedName, buffer, offset);
      return this.encodedName.length;
    };
    PDFName2.of = function(name2) {
      var decodedValue = decodeName(name2);
      var instance2 = pool.get(decodedValue);
      if (!instance2) {
        instance2 = new PDFName2(ENFORCER2, decodedValue);
        pool.set(decodedValue, instance2);
      }
      return instance2;
    };
    PDFName2.Length = PDFName2.of("Length");
    PDFName2.FlateDecode = PDFName2.of("FlateDecode");
    PDFName2.Resources = PDFName2.of("Resources");
    PDFName2.Font = PDFName2.of("Font");
    PDFName2.XObject = PDFName2.of("XObject");
    PDFName2.ExtGState = PDFName2.of("ExtGState");
    PDFName2.Contents = PDFName2.of("Contents");
    PDFName2.Type = PDFName2.of("Type");
    PDFName2.Parent = PDFName2.of("Parent");
    PDFName2.MediaBox = PDFName2.of("MediaBox");
    PDFName2.Page = PDFName2.of("Page");
    PDFName2.Annots = PDFName2.of("Annots");
    PDFName2.TrimBox = PDFName2.of("TrimBox");
    PDFName2.ArtBox = PDFName2.of("ArtBox");
    PDFName2.BleedBox = PDFName2.of("BleedBox");
    PDFName2.CropBox = PDFName2.of("CropBox");
    PDFName2.Rotate = PDFName2.of("Rotate");
    PDFName2.Title = PDFName2.of("Title");
    PDFName2.Author = PDFName2.of("Author");
    PDFName2.Subject = PDFName2.of("Subject");
    PDFName2.Creator = PDFName2.of("Creator");
    PDFName2.Keywords = PDFName2.of("Keywords");
    PDFName2.Producer = PDFName2.of("Producer");
    PDFName2.CreationDate = PDFName2.of("CreationDate");
    PDFName2.ModDate = PDFName2.of("ModDate");
    return PDFName2;
  }(PDFObject_default)
);
var PDFName_default = PDFName;

// node_modules/pdf-lib/es/core/objects/PDFNull.js
var PDFNull = (
  /** @class */
  function(_super) {
    __extends(PDFNull2, _super);
    function PDFNull2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFNull2.prototype.asNull = function() {
      return null;
    };
    PDFNull2.prototype.clone = function() {
      return this;
    };
    PDFNull2.prototype.toString = function() {
      return "null";
    };
    PDFNull2.prototype.sizeInBytes = function() {
      return 4;
    };
    PDFNull2.prototype.copyBytesInto = function(buffer, offset) {
      buffer[offset++] = CharCodes_default.n;
      buffer[offset++] = CharCodes_default.u;
      buffer[offset++] = CharCodes_default.l;
      buffer[offset++] = CharCodes_default.l;
      return 4;
    };
    return PDFNull2;
  }(PDFObject_default)
);
var PDFNull_default = new PDFNull();

// node_modules/pdf-lib/es/core/objects/PDFDict.js
var PDFDict = (
  /** @class */
  function(_super) {
    __extends(PDFDict2, _super);
    function PDFDict2(map, context) {
      var _this = _super.call(this) || this;
      _this.dict = map;
      _this.context = context;
      return _this;
    }
    PDFDict2.prototype.keys = function() {
      return Array.from(this.dict.keys());
    };
    PDFDict2.prototype.values = function() {
      return Array.from(this.dict.values());
    };
    PDFDict2.prototype.entries = function() {
      return Array.from(this.dict.entries());
    };
    PDFDict2.prototype.set = function(key, value) {
      this.dict.set(key, value);
    };
    PDFDict2.prototype.get = function(key, preservePDFNull) {
      if (preservePDFNull === void 0) {
        preservePDFNull = false;
      }
      var value = this.dict.get(key);
      if (value === PDFNull_default && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.has = function(key) {
      var value = this.dict.get(key);
      return value !== void 0 && value !== PDFNull_default;
    };
    PDFDict2.prototype.lookupMaybe = function(key) {
      var _a;
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types.includes(PDFNull_default);
      var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));
      if (value === PDFNull_default && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.lookup = function(key) {
      var _a;
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types.includes(PDFNull_default);
      var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));
      if (value === PDFNull_default && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.delete = function(key) {
      return this.dict.delete(key);
    };
    PDFDict2.prototype.asMap = function() {
      return new Map(this.dict);
    };
    PDFDict2.prototype.uniqueKey = function(tag) {
      if (tag === void 0) {
        tag = "";
      }
      var existingKeys = this.keys();
      var key = PDFName_default.of(this.context.addRandomSuffix(tag, 10));
      while (existingKeys.includes(key)) {
        key = PDFName_default.of(this.context.addRandomSuffix(tag, 10));
      }
      return key;
    };
    PDFDict2.prototype.clone = function(context) {
      var clone = PDFDict2.withContext(context || this.context);
      var entries = this.entries();
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], key = _a[0], value = _a[1];
        clone.set(key, value);
      }
      return clone;
    };
    PDFDict2.prototype.toString = function() {
      var dictString = "<<\n";
      var entries = this.entries();
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], key = _a[0], value = _a[1];
        dictString += key.toString() + " " + value.toString() + "\n";
      }
      dictString += ">>";
      return dictString;
    };
    PDFDict2.prototype.sizeInBytes = function() {
      var size = 5;
      var entries = this.entries();
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], key = _a[0], value = _a[1];
        size += key.sizeInBytes() + value.sizeInBytes() + 2;
      }
      return size;
    };
    PDFDict2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.LessThan;
      buffer[offset++] = CharCodes_default.LessThan;
      buffer[offset++] = CharCodes_default.Newline;
      var entries = this.entries();
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], key = _a[0], value = _a[1];
        offset += key.copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Space;
        offset += value.copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
      }
      buffer[offset++] = CharCodes_default.GreaterThan;
      buffer[offset++] = CharCodes_default.GreaterThan;
      return offset - initialOffset;
    };
    PDFDict2.withContext = function(context) {
      return new PDFDict2(/* @__PURE__ */ new Map(), context);
    };
    PDFDict2.fromMapWithContext = function(map, context) {
      return new PDFDict2(map, context);
    };
    return PDFDict2;
  }(PDFObject_default)
);
var PDFDict_default = PDFDict;

// node_modules/pdf-lib/es/core/objects/PDFStream.js
var PDFStream = (
  /** @class */
  function(_super) {
    __extends(PDFStream2, _super);
    function PDFStream2(dict) {
      var _this = _super.call(this) || this;
      _this.dict = dict;
      return _this;
    }
    PDFStream2.prototype.clone = function(_context) {
      throw new MethodNotImplementedError(this.constructor.name, "clone");
    };
    PDFStream2.prototype.getContentsString = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContentsString");
    };
    PDFStream2.prototype.getContents = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContents");
    };
    PDFStream2.prototype.getContentsSize = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContentsSize");
    };
    PDFStream2.prototype.updateDict = function() {
      var contentsSize = this.getContentsSize();
      this.dict.set(PDFName_default.Length, PDFNumber_default.of(contentsSize));
    };
    PDFStream2.prototype.sizeInBytes = function() {
      this.updateDict();
      return this.dict.sizeInBytes() + this.getContentsSize() + 18;
    };
    PDFStream2.prototype.toString = function() {
      this.updateDict();
      var streamString = this.dict.toString();
      streamString += "\nstream\n";
      streamString += this.getContentsString();
      streamString += "\nendstream";
      return streamString;
    };
    PDFStream2.prototype.copyBytesInto = function(buffer, offset) {
      this.updateDict();
      var initialOffset = offset;
      offset += this.dict.copyBytesInto(buffer, offset);
      buffer[offset++] = CharCodes_default.Newline;
      buffer[offset++] = CharCodes_default.s;
      buffer[offset++] = CharCodes_default.t;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.a;
      buffer[offset++] = CharCodes_default.m;
      buffer[offset++] = CharCodes_default.Newline;
      var contents = this.getContents();
      for (var idx = 0, len = contents.length; idx < len; idx++) {
        buffer[offset++] = contents[idx];
      }
      buffer[offset++] = CharCodes_default.Newline;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.n;
      buffer[offset++] = CharCodes_default.d;
      buffer[offset++] = CharCodes_default.s;
      buffer[offset++] = CharCodes_default.t;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.a;
      buffer[offset++] = CharCodes_default.m;
      return offset - initialOffset;
    };
    return PDFStream2;
  }(PDFObject_default)
);
var PDFStream_default = PDFStream;

// node_modules/pdf-lib/es/core/objects/PDFRawStream.js
var PDFRawStream = (
  /** @class */
  function(_super) {
    __extends(PDFRawStream2, _super);
    function PDFRawStream2(dict, contents) {
      var _this = _super.call(this, dict) || this;
      _this.contents = contents;
      return _this;
    }
    PDFRawStream2.prototype.asUint8Array = function() {
      return this.contents.slice();
    };
    PDFRawStream2.prototype.clone = function(context) {
      return PDFRawStream2.of(this.dict.clone(context), this.contents.slice());
    };
    PDFRawStream2.prototype.getContentsString = function() {
      return arrayAsString(this.contents);
    };
    PDFRawStream2.prototype.getContents = function() {
      return this.contents;
    };
    PDFRawStream2.prototype.getContentsSize = function() {
      return this.contents.length;
    };
    PDFRawStream2.of = function(dict, contents) {
      return new PDFRawStream2(dict, contents);
    };
    return PDFRawStream2;
  }(PDFStream_default)
);
var PDFRawStream_default = PDFRawStream;

// node_modules/pdf-lib/es/core/objects/PDFRef.js
var ENFORCER3 = {};
var pool2 = /* @__PURE__ */ new Map();
var PDFRef = (
  /** @class */
  function(_super) {
    __extends(PDFRef2, _super);
    function PDFRef2(enforcer, objectNumber, generationNumber) {
      var _this = this;
      if (enforcer !== ENFORCER3)
        throw new PrivateConstructorError("PDFRef");
      _this = _super.call(this) || this;
      _this.objectNumber = objectNumber;
      _this.generationNumber = generationNumber;
      _this.tag = objectNumber + " " + generationNumber + " R";
      return _this;
    }
    PDFRef2.prototype.clone = function() {
      return this;
    };
    PDFRef2.prototype.toString = function() {
      return this.tag;
    };
    PDFRef2.prototype.sizeInBytes = function() {
      return this.tag.length;
    };
    PDFRef2.prototype.copyBytesInto = function(buffer, offset) {
      offset += copyStringIntoBuffer(this.tag, buffer, offset);
      return this.tag.length;
    };
    PDFRef2.of = function(objectNumber, generationNumber) {
      if (generationNumber === void 0) {
        generationNumber = 0;
      }
      var tag = objectNumber + " " + generationNumber + " R";
      var instance2 = pool2.get(tag);
      if (!instance2) {
        instance2 = new PDFRef2(ENFORCER3, objectNumber, generationNumber);
        pool2.set(tag, instance2);
      }
      return instance2;
    };
    return PDFRef2;
  }(PDFObject_default)
);
var PDFRef_default = PDFRef;

// node_modules/pdf-lib/es/core/operators/PDFOperator.js
var PDFOperator = (
  /** @class */
  function() {
    function PDFOperator2(name2, args2) {
      this.name = name2;
      this.args = args2 || [];
    }
    PDFOperator2.prototype.clone = function(context) {
      var args2 = new Array(this.args.length);
      for (var idx = 0, len = args2.length; idx < len; idx++) {
        var arg = this.args[idx];
        args2[idx] = arg instanceof PDFObject_default ? arg.clone(context) : arg;
      }
      return PDFOperator2.of(this.name, args2);
    };
    PDFOperator2.prototype.toString = function() {
      var value = "";
      for (var idx = 0, len = this.args.length; idx < len; idx++) {
        value += String(this.args[idx]) + " ";
      }
      value += this.name;
      return value;
    };
    PDFOperator2.prototype.sizeInBytes = function() {
      var size = 0;
      for (var idx = 0, len = this.args.length; idx < len; idx++) {
        var arg = this.args[idx];
        size += (arg instanceof PDFObject_default ? arg.sizeInBytes() : arg.length) + 1;
      }
      size += this.name.length;
      return size;
    };
    PDFOperator2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      for (var idx = 0, len = this.args.length; idx < len; idx++) {
        var arg = this.args[idx];
        if (arg instanceof PDFObject_default) {
          offset += arg.copyBytesInto(buffer, offset);
        } else {
          offset += copyStringIntoBuffer(arg, buffer, offset);
        }
        buffer[offset++] = CharCodes_default.Space;
      }
      offset += copyStringIntoBuffer(this.name, buffer, offset);
      return offset - initialOffset;
    };
    PDFOperator2.of = function(name2, args2) {
      return new PDFOperator2(name2, args2);
    };
    return PDFOperator2;
  }()
);
var PDFOperator_default = PDFOperator;

// node_modules/pdf-lib/es/core/operators/PDFOperatorNames.js
var PDFOperatorNames;
(function(PDFOperatorNames2) {
  PDFOperatorNames2["NonStrokingColor"] = "sc";
  PDFOperatorNames2["NonStrokingColorN"] = "scn";
  PDFOperatorNames2["NonStrokingColorRgb"] = "rg";
  PDFOperatorNames2["NonStrokingColorGray"] = "g";
  PDFOperatorNames2["NonStrokingColorCmyk"] = "k";
  PDFOperatorNames2["NonStrokingColorspace"] = "cs";
  PDFOperatorNames2["StrokingColor"] = "SC";
  PDFOperatorNames2["StrokingColorN"] = "SCN";
  PDFOperatorNames2["StrokingColorRgb"] = "RG";
  PDFOperatorNames2["StrokingColorGray"] = "G";
  PDFOperatorNames2["StrokingColorCmyk"] = "K";
  PDFOperatorNames2["StrokingColorspace"] = "CS";
  PDFOperatorNames2["BeginMarkedContentSequence"] = "BDC";
  PDFOperatorNames2["BeginMarkedContent"] = "BMC";
  PDFOperatorNames2["EndMarkedContent"] = "EMC";
  PDFOperatorNames2["MarkedContentPointWithProps"] = "DP";
  PDFOperatorNames2["MarkedContentPoint"] = "MP";
  PDFOperatorNames2["DrawObject"] = "Do";
  PDFOperatorNames2["ConcatTransformationMatrix"] = "cm";
  PDFOperatorNames2["PopGraphicsState"] = "Q";
  PDFOperatorNames2["PushGraphicsState"] = "q";
  PDFOperatorNames2["SetFlatness"] = "i";
  PDFOperatorNames2["SetGraphicsStateParams"] = "gs";
  PDFOperatorNames2["SetLineCapStyle"] = "J";
  PDFOperatorNames2["SetLineDashPattern"] = "d";
  PDFOperatorNames2["SetLineJoinStyle"] = "j";
  PDFOperatorNames2["SetLineMiterLimit"] = "M";
  PDFOperatorNames2["SetLineWidth"] = "w";
  PDFOperatorNames2["SetTextMatrix"] = "Tm";
  PDFOperatorNames2["SetRenderingIntent"] = "ri";
  PDFOperatorNames2["AppendRectangle"] = "re";
  PDFOperatorNames2["BeginInlineImage"] = "BI";
  PDFOperatorNames2["BeginInlineImageData"] = "ID";
  PDFOperatorNames2["EndInlineImage"] = "EI";
  PDFOperatorNames2["ClipEvenOdd"] = "W*";
  PDFOperatorNames2["ClipNonZero"] = "W";
  PDFOperatorNames2["CloseAndStroke"] = "s";
  PDFOperatorNames2["CloseFillEvenOddAndStroke"] = "b*";
  PDFOperatorNames2["CloseFillNonZeroAndStroke"] = "b";
  PDFOperatorNames2["ClosePath"] = "h";
  PDFOperatorNames2["AppendBezierCurve"] = "c";
  PDFOperatorNames2["CurveToReplicateFinalPoint"] = "y";
  PDFOperatorNames2["CurveToReplicateInitialPoint"] = "v";
  PDFOperatorNames2["EndPath"] = "n";
  PDFOperatorNames2["FillEvenOddAndStroke"] = "B*";
  PDFOperatorNames2["FillEvenOdd"] = "f*";
  PDFOperatorNames2["FillNonZeroAndStroke"] = "B";
  PDFOperatorNames2["FillNonZero"] = "f";
  PDFOperatorNames2["LegacyFillNonZero"] = "F";
  PDFOperatorNames2["LineTo"] = "l";
  PDFOperatorNames2["MoveTo"] = "m";
  PDFOperatorNames2["ShadingFill"] = "sh";
  PDFOperatorNames2["StrokePath"] = "S";
  PDFOperatorNames2["BeginText"] = "BT";
  PDFOperatorNames2["EndText"] = "ET";
  PDFOperatorNames2["MoveText"] = "Td";
  PDFOperatorNames2["MoveTextSetLeading"] = "TD";
  PDFOperatorNames2["NextLine"] = "T*";
  PDFOperatorNames2["SetCharacterSpacing"] = "Tc";
  PDFOperatorNames2["SetFontAndSize"] = "Tf";
  PDFOperatorNames2["SetTextHorizontalScaling"] = "Tz";
  PDFOperatorNames2["SetTextLineHeight"] = "TL";
  PDFOperatorNames2["SetTextRenderingMode"] = "Tr";
  PDFOperatorNames2["SetTextRise"] = "Ts";
  PDFOperatorNames2["SetWordSpacing"] = "Tw";
  PDFOperatorNames2["ShowText"] = "Tj";
  PDFOperatorNames2["ShowTextAdjusted"] = "TJ";
  PDFOperatorNames2["ShowTextLine"] = "'";
  PDFOperatorNames2["ShowTextLineAndSpace"] = '"';
  PDFOperatorNames2["Type3D0"] = "d0";
  PDFOperatorNames2["Type3D1"] = "d1";
  PDFOperatorNames2["BeginCompatibilitySection"] = "BX";
  PDFOperatorNames2["EndCompatibilitySection"] = "EX";
})(PDFOperatorNames || (PDFOperatorNames = {}));
var PDFOperatorNames_default = PDFOperatorNames;

// node_modules/pdf-lib/es/core/structures/PDFFlateStream.js
var import_pako2 = __toESM(require_pako());
var PDFFlateStream = (
  /** @class */
  function(_super) {
    __extends(PDFFlateStream2, _super);
    function PDFFlateStream2(dict, encode) {
      var _this = _super.call(this, dict) || this;
      _this.computeContents = function() {
        var unencodedContents = _this.getUnencodedContents();
        return _this.encode ? import_pako2.default.deflate(unencodedContents) : unencodedContents;
      };
      _this.encode = encode;
      if (encode)
        dict.set(PDFName_default.of("Filter"), PDFName_default.of("FlateDecode"));
      _this.contentsCache = Cache_default.populatedBy(_this.computeContents);
      return _this;
    }
    PDFFlateStream2.prototype.getContents = function() {
      return this.contentsCache.access();
    };
    PDFFlateStream2.prototype.getContentsSize = function() {
      return this.contentsCache.access().length;
    };
    PDFFlateStream2.prototype.getUnencodedContents = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getUnencodedContents");
    };
    return PDFFlateStream2;
  }(PDFStream_default)
);
var PDFFlateStream_default = PDFFlateStream;

// node_modules/pdf-lib/es/core/structures/PDFContentStream.js
var PDFContentStream = (
  /** @class */
  function(_super) {
    __extends(PDFContentStream2, _super);
    function PDFContentStream2(dict, operators, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, dict, encode) || this;
      _this.operators = operators;
      return _this;
    }
    PDFContentStream2.prototype.push = function() {
      var _a;
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operators[_i] = arguments[_i];
      }
      (_a = this.operators).push.apply(_a, operators);
    };
    PDFContentStream2.prototype.clone = function(context) {
      var operators = new Array(this.operators.length);
      for (var idx = 0, len = this.operators.length; idx < len; idx++) {
        operators[idx] = this.operators[idx].clone(context);
      }
      var _a = this, dict = _a.dict, encode = _a.encode;
      return PDFContentStream2.of(dict.clone(context), operators, encode);
    };
    PDFContentStream2.prototype.getContentsString = function() {
      var value = "";
      for (var idx = 0, len = this.operators.length; idx < len; idx++) {
        value += this.operators[idx] + "\n";
      }
      return value;
    };
    PDFContentStream2.prototype.getUnencodedContents = function() {
      var buffer = new Uint8Array(this.getUnencodedContentsSize());
      var offset = 0;
      for (var idx = 0, len = this.operators.length; idx < len; idx++) {
        offset += this.operators[idx].copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
      }
      return buffer;
    };
    PDFContentStream2.prototype.getUnencodedContentsSize = function() {
      var size = 0;
      for (var idx = 0, len = this.operators.length; idx < len; idx++) {
        size += this.operators[idx].sizeInBytes() + 1;
      }
      return size;
    };
    PDFContentStream2.of = function(dict, operators, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFContentStream2(dict, operators, encode);
    };
    return PDFContentStream2;
  }(PDFFlateStream_default)
);
var PDFContentStream_default = PDFContentStream;

// node_modules/pdf-lib/es/utils/rng.js
var SimpleRNG = (
  /** @class */
  function() {
    function SimpleRNG2(seed) {
      this.seed = seed;
    }
    SimpleRNG2.prototype.nextInt = function() {
      var x4 = Math.sin(this.seed++) * 1e4;
      return x4 - Math.floor(x4);
    };
    SimpleRNG2.withSeed = function(seed) {
      return new SimpleRNG2(seed);
    };
    return SimpleRNG2;
  }()
);

// node_modules/pdf-lib/es/core/PDFContext.js
var byAscendingObjectNumber = function(_a, _b) {
  var a2 = _a[0];
  var b4 = _b[0];
  return a2.objectNumber - b4.objectNumber;
};
var PDFContext = (
  /** @class */
  function() {
    function PDFContext2() {
      this.largestObjectNumber = 0;
      this.header = PDFHeader_default.forVersion(1, 7);
      this.trailerInfo = {};
      this.indirectObjects = /* @__PURE__ */ new Map();
      this.rng = SimpleRNG.withSeed(1);
    }
    PDFContext2.prototype.assign = function(ref, object) {
      this.indirectObjects.set(ref, object);
      if (ref.objectNumber > this.largestObjectNumber) {
        this.largestObjectNumber = ref.objectNumber;
      }
    };
    PDFContext2.prototype.nextRef = function() {
      this.largestObjectNumber += 1;
      return PDFRef_default.of(this.largestObjectNumber);
    };
    PDFContext2.prototype.register = function(object) {
      var ref = this.nextRef();
      this.assign(ref, object);
      return ref;
    };
    PDFContext2.prototype.delete = function(ref) {
      return this.indirectObjects.delete(ref);
    };
    PDFContext2.prototype.lookupMaybe = function(ref) {
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types.includes(PDFNull_default);
      var result = ref instanceof PDFRef_default ? this.indirectObjects.get(ref) : ref;
      if (!result || result === PDFNull_default && !preservePDFNull)
        return void 0;
      for (var idx = 0, len = types.length; idx < len; idx++) {
        var type = types[idx];
        if (type === PDFNull_default) {
          if (result === PDFNull_default)
            return result;
        } else {
          if (result instanceof type)
            return result;
        }
      }
      throw new UnexpectedObjectTypeError(types, result);
    };
    PDFContext2.prototype.lookup = function(ref) {
      var types = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
      }
      var result = ref instanceof PDFRef_default ? this.indirectObjects.get(ref) : ref;
      if (types.length === 0)
        return result;
      for (var idx = 0, len = types.length; idx < len; idx++) {
        var type = types[idx];
        if (type === PDFNull_default) {
          if (result === PDFNull_default)
            return result;
        } else {
          if (result instanceof type)
            return result;
        }
      }
      throw new UnexpectedObjectTypeError(types, result);
    };
    PDFContext2.prototype.getObjectRef = function(pdfObject) {
      var entries = Array.from(this.indirectObjects.entries());
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], ref = _a[0], object = _a[1];
        if (object === pdfObject) {
          return ref;
        }
      }
      return void 0;
    };
    PDFContext2.prototype.enumerateIndirectObjects = function() {
      return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);
    };
    PDFContext2.prototype.obj = function(literal) {
      if (literal instanceof PDFObject_default) {
        return literal;
      } else if (literal === null || literal === void 0) {
        return PDFNull_default;
      } else if (typeof literal === "string") {
        return PDFName_default.of(literal);
      } else if (typeof literal === "number") {
        return PDFNumber_default.of(literal);
      } else if (typeof literal === "boolean") {
        return literal ? PDFBool_default.True : PDFBool_default.False;
      } else if (Array.isArray(literal)) {
        var array = PDFArray_default.withContext(this);
        for (var idx = 0, len = literal.length; idx < len; idx++) {
          array.push(this.obj(literal[idx]));
        }
        return array;
      } else {
        var dict = PDFDict_default.withContext(this);
        var keys = Object.keys(literal);
        for (var idx = 0, len = keys.length; idx < len; idx++) {
          var key = keys[idx];
          var value = literal[key];
          if (value !== void 0)
            dict.set(PDFName_default.of(key), this.obj(value));
        }
        return dict;
      }
    };
    PDFContext2.prototype.stream = function(contents, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return PDFRawStream_default.of(this.obj(dict), typedArrayFor(contents));
    };
    PDFContext2.prototype.flateStream = function(contents, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return this.stream(import_pako3.default.deflate(typedArrayFor(contents)), __assign(__assign({}, dict), { Filter: "FlateDecode" }));
    };
    PDFContext2.prototype.contentStream = function(operators, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return PDFContentStream_default.of(this.obj(dict), operators);
    };
    PDFContext2.prototype.formXObject = function(operators, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return this.contentStream(operators, __assign(__assign({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, dict), { Type: "XObject", Subtype: "Form" }));
    };
    PDFContext2.prototype.getPushGraphicsStateContentStream = function() {
      if (this.pushGraphicsStateContentStreamRef) {
        return this.pushGraphicsStateContentStreamRef;
      }
      var dict = this.obj({});
      var op = PDFOperator_default.of(PDFOperatorNames_default.PushGraphicsState);
      var stream2 = PDFContentStream_default.of(dict, [op]);
      this.pushGraphicsStateContentStreamRef = this.register(stream2);
      return this.pushGraphicsStateContentStreamRef;
    };
    PDFContext2.prototype.getPopGraphicsStateContentStream = function() {
      if (this.popGraphicsStateContentStreamRef) {
        return this.popGraphicsStateContentStreamRef;
      }
      var dict = this.obj({});
      var op = PDFOperator_default.of(PDFOperatorNames_default.PopGraphicsState);
      var stream2 = PDFContentStream_default.of(dict, [op]);
      this.popGraphicsStateContentStreamRef = this.register(stream2);
      return this.popGraphicsStateContentStreamRef;
    };
    PDFContext2.prototype.addRandomSuffix = function(prefix, suffixLength) {
      if (suffixLength === void 0) {
        suffixLength = 4;
      }
      return prefix + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));
    };
    PDFContext2.create = function() {
      return new PDFContext2();
    };
    return PDFContext2;
  }()
);
var PDFContext_default = PDFContext;

// node_modules/pdf-lib/es/core/structures/PDFPageLeaf.js
var PDFPageLeaf = (
  /** @class */
  function(_super) {
    __extends(PDFPageLeaf2, _super);
    function PDFPageLeaf2(map, context, autoNormalizeCTM) {
      if (autoNormalizeCTM === void 0) {
        autoNormalizeCTM = true;
      }
      var _this = _super.call(this, map, context) || this;
      _this.normalized = false;
      _this.autoNormalizeCTM = autoNormalizeCTM;
      return _this;
    }
    PDFPageLeaf2.prototype.clone = function(context) {
      var clone = PDFPageLeaf2.fromMapWithContext(/* @__PURE__ */ new Map(), context || this.context, this.autoNormalizeCTM);
      var entries = this.entries();
      for (var idx = 0, len = entries.length; idx < len; idx++) {
        var _a = entries[idx], key = _a[0], value = _a[1];
        clone.set(key, value);
      }
      return clone;
    };
    PDFPageLeaf2.prototype.Parent = function() {
      return this.lookupMaybe(PDFName_default.Parent, PDFDict_default);
    };
    PDFPageLeaf2.prototype.Contents = function() {
      return this.lookup(PDFName_default.of("Contents"));
    };
    PDFPageLeaf2.prototype.Annots = function() {
      return this.lookupMaybe(PDFName_default.Annots, PDFArray_default);
    };
    PDFPageLeaf2.prototype.BleedBox = function() {
      return this.lookupMaybe(PDFName_default.BleedBox, PDFArray_default);
    };
    PDFPageLeaf2.prototype.TrimBox = function() {
      return this.lookupMaybe(PDFName_default.TrimBox, PDFArray_default);
    };
    PDFPageLeaf2.prototype.ArtBox = function() {
      return this.lookupMaybe(PDFName_default.ArtBox, PDFArray_default);
    };
    PDFPageLeaf2.prototype.Resources = function() {
      var dictOrRef = this.getInheritableAttribute(PDFName_default.Resources);
      return this.context.lookupMaybe(dictOrRef, PDFDict_default);
    };
    PDFPageLeaf2.prototype.MediaBox = function() {
      var arrayOrRef = this.getInheritableAttribute(PDFName_default.MediaBox);
      return this.context.lookup(arrayOrRef, PDFArray_default);
    };
    PDFPageLeaf2.prototype.CropBox = function() {
      var arrayOrRef = this.getInheritableAttribute(PDFName_default.CropBox);
      return this.context.lookupMaybe(arrayOrRef, PDFArray_default);
    };
    PDFPageLeaf2.prototype.Rotate = function() {
      var numberOrRef = this.getInheritableAttribute(PDFName_default.Rotate);
      return this.context.lookupMaybe(numberOrRef, PDFNumber_default);
    };
    PDFPageLeaf2.prototype.getInheritableAttribute = function(name2) {
      var attribute;
      this.ascend(function(node) {
        if (!attribute)
          attribute = node.get(name2);
      });
      return attribute;
    };
    PDFPageLeaf2.prototype.setParent = function(parentRef) {
      this.set(PDFName_default.Parent, parentRef);
    };
    PDFPageLeaf2.prototype.addContentStream = function(contentStreamRef) {
      var Contents = this.normalizedEntries().Contents || this.context.obj([]);
      this.set(PDFName_default.Contents, Contents);
      Contents.push(contentStreamRef);
    };
    PDFPageLeaf2.prototype.wrapContentStreams = function(startStream, endStream) {
      var Contents = this.Contents();
      if (Contents instanceof PDFArray_default) {
        Contents.insert(0, startStream);
        Contents.push(endStream);
        return true;
      }
      return false;
    };
    PDFPageLeaf2.prototype.addAnnot = function(annotRef) {
      var Annots = this.normalizedEntries().Annots;
      Annots.push(annotRef);
    };
    PDFPageLeaf2.prototype.removeAnnot = function(annotRef) {
      var Annots = this.normalizedEntries().Annots;
      var index = Annots.indexOf(annotRef);
      if (index !== void 0) {
        Annots.remove(index);
      }
    };
    PDFPageLeaf2.prototype.setFontDictionary = function(name2, fontDictRef) {
      var Font2 = this.normalizedEntries().Font;
      Font2.set(name2, fontDictRef);
    };
    PDFPageLeaf2.prototype.newFontDictionaryKey = function(tag) {
      var Font2 = this.normalizedEntries().Font;
      return Font2.uniqueKey(tag);
    };
    PDFPageLeaf2.prototype.newFontDictionary = function(tag, fontDictRef) {
      var key = this.newFontDictionaryKey(tag);
      this.setFontDictionary(key, fontDictRef);
      return key;
    };
    PDFPageLeaf2.prototype.setXObject = function(name2, xObjectRef) {
      var XObject = this.normalizedEntries().XObject;
      XObject.set(name2, xObjectRef);
    };
    PDFPageLeaf2.prototype.newXObjectKey = function(tag) {
      var XObject = this.normalizedEntries().XObject;
      return XObject.uniqueKey(tag);
    };
    PDFPageLeaf2.prototype.newXObject = function(tag, xObjectRef) {
      var key = this.newXObjectKey(tag);
      this.setXObject(key, xObjectRef);
      return key;
    };
    PDFPageLeaf2.prototype.setExtGState = function(name2, extGStateRef) {
      var ExtGState = this.normalizedEntries().ExtGState;
      ExtGState.set(name2, extGStateRef);
    };
    PDFPageLeaf2.prototype.newExtGStateKey = function(tag) {
      var ExtGState = this.normalizedEntries().ExtGState;
      return ExtGState.uniqueKey(tag);
    };
    PDFPageLeaf2.prototype.newExtGState = function(tag, extGStateRef) {
      var key = this.newExtGStateKey(tag);
      this.setExtGState(key, extGStateRef);
      return key;
    };
    PDFPageLeaf2.prototype.ascend = function(visitor) {
      visitor(this);
      var Parent = this.Parent();
      if (Parent)
        Parent.ascend(visitor);
    };
    PDFPageLeaf2.prototype.normalize = function() {
      if (this.normalized)
        return;
      var context = this.context;
      var contentsRef = this.get(PDFName_default.Contents);
      var contents = this.context.lookup(contentsRef);
      if (contents instanceof PDFStream_default) {
        this.set(PDFName_default.Contents, context.obj([contentsRef]));
      }
      if (this.autoNormalizeCTM) {
        this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
      }
      var dictOrRef = this.getInheritableAttribute(PDFName_default.Resources);
      var Resources = context.lookupMaybe(dictOrRef, PDFDict_default) || context.obj({});
      this.set(PDFName_default.Resources, Resources);
      var Font2 = Resources.lookupMaybe(PDFName_default.Font, PDFDict_default) || context.obj({});
      Resources.set(PDFName_default.Font, Font2);
      var XObject = Resources.lookupMaybe(PDFName_default.XObject, PDFDict_default) || context.obj({});
      Resources.set(PDFName_default.XObject, XObject);
      var ExtGState = Resources.lookupMaybe(PDFName_default.ExtGState, PDFDict_default) || context.obj({});
      Resources.set(PDFName_default.ExtGState, ExtGState);
      var Annots = this.Annots() || context.obj([]);
      this.set(PDFName_default.Annots, Annots);
      this.normalized = true;
    };
    PDFPageLeaf2.prototype.normalizedEntries = function() {
      this.normalize();
      var Annots = this.Annots();
      var Resources = this.Resources();
      var Contents = this.Contents();
      return {
        Annots,
        Resources,
        Contents,
        Font: Resources.lookup(PDFName_default.Font, PDFDict_default),
        XObject: Resources.lookup(PDFName_default.XObject, PDFDict_default),
        ExtGState: Resources.lookup(PDFName_default.ExtGState, PDFDict_default)
      };
    };
    PDFPageLeaf2.InheritableEntries = [
      "Resources",
      "MediaBox",
      "CropBox",
      "Rotate"
    ];
    PDFPageLeaf2.withContextAndParent = function(context, parent) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName_default.Type, PDFName_default.Page);
      dict.set(PDFName_default.Parent, parent);
      dict.set(PDFName_default.Resources, context.obj({}));
      dict.set(PDFName_default.MediaBox, context.obj([0, 0, 612, 792]));
      return new PDFPageLeaf2(dict, context, false);
    };
    PDFPageLeaf2.fromMapWithContext = function(map, context, autoNormalizeCTM) {
      if (autoNormalizeCTM === void 0) {
        autoNormalizeCTM = true;
      }
      return new PDFPageLeaf2(map, context, autoNormalizeCTM);
    };
    return PDFPageLeaf2;
  }(PDFDict_default)
);
var PDFPageLeaf_default = PDFPageLeaf;

// node_modules/pdf-lib/es/core/PDFObjectCopier.js
var PDFObjectCopier = (
  /** @class */
  function() {
    function PDFObjectCopier2(src, dest) {
      var _this = this;
      this.traversedObjects = /* @__PURE__ */ new Map();
      this.copy = function(object) {
        return object instanceof PDFPageLeaf_default ? _this.copyPDFPage(object) : object instanceof PDFDict_default ? _this.copyPDFDict(object) : object instanceof PDFArray_default ? _this.copyPDFArray(object) : object instanceof PDFStream_default ? _this.copyPDFStream(object) : object instanceof PDFRef_default ? _this.copyPDFIndirectObject(object) : object.clone();
      };
      this.copyPDFPage = function(originalPage) {
        var clonedPage = originalPage.clone();
        var InheritableEntries = PDFPageLeaf_default.InheritableEntries;
        for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {
          var key = PDFName_default.of(InheritableEntries[idx]);
          var value = clonedPage.getInheritableAttribute(key);
          if (!clonedPage.get(key) && value)
            clonedPage.set(key, value);
        }
        clonedPage.delete(PDFName_default.of("Parent"));
        return _this.copyPDFDict(clonedPage);
      };
      this.copyPDFDict = function(originalDict) {
        if (_this.traversedObjects.has(originalDict)) {
          return _this.traversedObjects.get(originalDict);
        }
        var clonedDict = originalDict.clone(_this.dest);
        _this.traversedObjects.set(originalDict, clonedDict);
        var entries = originalDict.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          clonedDict.set(key, _this.copy(value));
        }
        return clonedDict;
      };
      this.copyPDFArray = function(originalArray) {
        if (_this.traversedObjects.has(originalArray)) {
          return _this.traversedObjects.get(originalArray);
        }
        var clonedArray = originalArray.clone(_this.dest);
        _this.traversedObjects.set(originalArray, clonedArray);
        for (var idx = 0, len = originalArray.size(); idx < len; idx++) {
          var value = originalArray.get(idx);
          clonedArray.set(idx, _this.copy(value));
        }
        return clonedArray;
      };
      this.copyPDFStream = function(originalStream) {
        if (_this.traversedObjects.has(originalStream)) {
          return _this.traversedObjects.get(originalStream);
        }
        var clonedStream = originalStream.clone(_this.dest);
        _this.traversedObjects.set(originalStream, clonedStream);
        var entries = originalStream.dict.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          clonedStream.dict.set(key, _this.copy(value));
        }
        return clonedStream;
      };
      this.copyPDFIndirectObject = function(ref) {
        var alreadyMapped = _this.traversedObjects.has(ref);
        if (!alreadyMapped) {
          var newRef = _this.dest.nextRef();
          _this.traversedObjects.set(ref, newRef);
          var dereferencedValue = _this.src.lookup(ref);
          if (dereferencedValue) {
            var cloned = _this.copy(dereferencedValue);
            _this.dest.assign(newRef, cloned);
          }
        }
        return _this.traversedObjects.get(ref);
      };
      this.src = src;
      this.dest = dest;
    }
    PDFObjectCopier2.for = function(src, dest) {
      return new PDFObjectCopier2(src, dest);
    };
    return PDFObjectCopier2;
  }()
);
var PDFObjectCopier_default = PDFObjectCopier;

// node_modules/pdf-lib/es/core/document/PDFCrossRefSection.js
var PDFCrossRefSection = (
  /** @class */
  function() {
    function PDFCrossRefSection2(firstEntry) {
      this.subsections = firstEntry ? [[firstEntry]] : [];
      this.chunkIdx = 0;
      this.chunkLength = firstEntry ? 1 : 0;
    }
    PDFCrossRefSection2.prototype.addEntry = function(ref, offset) {
      this.append({ ref, offset, deleted: false });
    };
    PDFCrossRefSection2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
      this.append({ ref, offset: nextFreeObjectNumber, deleted: true });
    };
    PDFCrossRefSection2.prototype.toString = function() {
      var section = "xref\n";
      for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {
        var range2 = this.subsections[rangeIdx];
        section += range2[0].ref.objectNumber + " " + range2.length + "\n";
        for (var entryIdx = 0, entryLen = range2.length; entryIdx < entryLen; entryIdx++) {
          var entry = range2[entryIdx];
          section += padStart(String(entry.offset), 10, "0");
          section += " ";
          section += padStart(String(entry.ref.generationNumber), 5, "0");
          section += " ";
          section += entry.deleted ? "f" : "n";
          section += " \n";
        }
      }
      return section;
    };
    PDFCrossRefSection2.prototype.sizeInBytes = function() {
      var size = 5;
      for (var idx = 0, len = this.subsections.length; idx < len; idx++) {
        var subsection = this.subsections[idx];
        var subsectionLength = subsection.length;
        var firstEntry = subsection[0];
        size += 2;
        size += String(firstEntry.ref.objectNumber).length;
        size += String(subsectionLength).length;
        size += 20 * subsectionLength;
      }
      return size;
    };
    PDFCrossRefSection2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.x;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.f;
      buffer[offset++] = CharCodes_default.Newline;
      offset += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset);
      return offset - initialOffset;
    };
    PDFCrossRefSection2.prototype.copySubsectionsIntoBuffer = function(subsections, buffer, offset) {
      var initialOffset = offset;
      var length = subsections.length;
      for (var idx = 0; idx < length; idx++) {
        var subsection = this.subsections[idx];
        var firstObjectNumber = String(subsection[0].ref.objectNumber);
        offset += copyStringIntoBuffer(firstObjectNumber, buffer, offset);
        buffer[offset++] = CharCodes_default.Space;
        var rangeLength = String(subsection.length);
        offset += copyStringIntoBuffer(rangeLength, buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
        offset += this.copyEntriesIntoBuffer(subsection, buffer, offset);
      }
      return offset - initialOffset;
    };
    PDFCrossRefSection2.prototype.copyEntriesIntoBuffer = function(entries, buffer, offset) {
      var length = entries.length;
      for (var idx = 0; idx < length; idx++) {
        var entry = entries[idx];
        var entryOffset = padStart(String(entry.offset), 10, "0");
        offset += copyStringIntoBuffer(entryOffset, buffer, offset);
        buffer[offset++] = CharCodes_default.Space;
        var entryGen = padStart(String(entry.ref.generationNumber), 5, "0");
        offset += copyStringIntoBuffer(entryGen, buffer, offset);
        buffer[offset++] = CharCodes_default.Space;
        buffer[offset++] = entry.deleted ? CharCodes_default.f : CharCodes_default.n;
        buffer[offset++] = CharCodes_default.Space;
        buffer[offset++] = CharCodes_default.Newline;
      }
      return 20 * length;
    };
    PDFCrossRefSection2.prototype.append = function(currEntry) {
      if (this.chunkLength === 0) {
        this.subsections.push([currEntry]);
        this.chunkIdx = 0;
        this.chunkLength = 1;
        return;
      }
      var chunk = this.subsections[this.chunkIdx];
      var prevEntry = chunk[this.chunkLength - 1];
      if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
        this.subsections.push([currEntry]);
        this.chunkIdx += 1;
        this.chunkLength = 1;
      } else {
        chunk.push(currEntry);
        this.chunkLength += 1;
      }
    };
    PDFCrossRefSection2.create = function() {
      return new PDFCrossRefSection2({
        ref: PDFRef_default.of(0, 65535),
        offset: 0,
        deleted: true
      });
    };
    PDFCrossRefSection2.createEmpty = function() {
      return new PDFCrossRefSection2();
    };
    return PDFCrossRefSection2;
  }()
);
var PDFCrossRefSection_default = PDFCrossRefSection;

// node_modules/pdf-lib/es/core/document/PDFTrailer.js
var PDFTrailer = (
  /** @class */
  function() {
    function PDFTrailer2(lastXRefOffset) {
      this.lastXRefOffset = String(lastXRefOffset);
    }
    PDFTrailer2.prototype.toString = function() {
      return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
    };
    PDFTrailer2.prototype.sizeInBytes = function() {
      return 16 + this.lastXRefOffset.length;
    };
    PDFTrailer2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.s;
      buffer[offset++] = CharCodes_default.t;
      buffer[offset++] = CharCodes_default.a;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.t;
      buffer[offset++] = CharCodes_default.x;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.f;
      buffer[offset++] = CharCodes_default.Newline;
      offset += copyStringIntoBuffer(this.lastXRefOffset, buffer, offset);
      buffer[offset++] = CharCodes_default.Newline;
      buffer[offset++] = CharCodes_default.Percent;
      buffer[offset++] = CharCodes_default.Percent;
      buffer[offset++] = CharCodes_default.E;
      buffer[offset++] = CharCodes_default.O;
      buffer[offset++] = CharCodes_default.F;
      return offset - initialOffset;
    };
    PDFTrailer2.forLastCrossRefSectionOffset = function(offset) {
      return new PDFTrailer2(offset);
    };
    return PDFTrailer2;
  }()
);
var PDFTrailer_default = PDFTrailer;

// node_modules/pdf-lib/es/core/document/PDFTrailerDict.js
var PDFTrailerDict = (
  /** @class */
  function() {
    function PDFTrailerDict2(dict) {
      this.dict = dict;
    }
    PDFTrailerDict2.prototype.toString = function() {
      return "trailer\n" + this.dict.toString();
    };
    PDFTrailerDict2.prototype.sizeInBytes = function() {
      return 8 + this.dict.sizeInBytes();
    };
    PDFTrailerDict2.prototype.copyBytesInto = function(buffer, offset) {
      var initialOffset = offset;
      buffer[offset++] = CharCodes_default.t;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.a;
      buffer[offset++] = CharCodes_default.i;
      buffer[offset++] = CharCodes_default.l;
      buffer[offset++] = CharCodes_default.e;
      buffer[offset++] = CharCodes_default.r;
      buffer[offset++] = CharCodes_default.Newline;
      offset += this.dict.copyBytesInto(buffer, offset);
      return offset - initialOffset;
    };
    PDFTrailerDict2.of = function(dict) {
      return new PDFTrailerDict2(dict);
    };
    return PDFTrailerDict2;
  }()
);
var PDFTrailerDict_default = PDFTrailerDict;

// node_modules/pdf-lib/es/core/structures/PDFObjectStream.js
var PDFObjectStream = (
  /** @class */
  function(_super) {
    __extends(PDFObjectStream2, _super);
    function PDFObjectStream2(context, objects, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, context.obj({}), encode) || this;
      _this.objects = objects;
      _this.offsets = _this.computeObjectOffsets();
      _this.offsetsString = _this.computeOffsetsString();
      _this.dict.set(PDFName_default.of("Type"), PDFName_default.of("ObjStm"));
      _this.dict.set(PDFName_default.of("N"), PDFNumber_default.of(_this.objects.length));
      _this.dict.set(PDFName_default.of("First"), PDFNumber_default.of(_this.offsetsString.length));
      return _this;
    }
    PDFObjectStream2.prototype.getObjectsCount = function() {
      return this.objects.length;
    };
    PDFObjectStream2.prototype.clone = function(context) {
      return PDFObjectStream2.withContextAndObjects(context || this.dict.context, this.objects.slice(), this.encode);
    };
    PDFObjectStream2.prototype.getContentsString = function() {
      var value = this.offsetsString;
      for (var idx = 0, len = this.objects.length; idx < len; idx++) {
        var _a = this.objects[idx], object = _a[1];
        value += object + "\n";
      }
      return value;
    };
    PDFObjectStream2.prototype.getUnencodedContents = function() {
      var buffer = new Uint8Array(this.getUnencodedContentsSize());
      var offset = copyStringIntoBuffer(this.offsetsString, buffer, 0);
      for (var idx = 0, len = this.objects.length; idx < len; idx++) {
        var _a = this.objects[idx], object = _a[1];
        offset += object.copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
      }
      return buffer;
    };
    PDFObjectStream2.prototype.getUnencodedContentsSize = function() {
      return this.offsetsString.length + last(this.offsets)[1] + last(this.objects)[1].sizeInBytes() + 1;
    };
    PDFObjectStream2.prototype.computeOffsetsString = function() {
      var offsetsString = "";
      for (var idx = 0, len = this.offsets.length; idx < len; idx++) {
        var _a = this.offsets[idx], objectNumber = _a[0], offset = _a[1];
        offsetsString += objectNumber + " " + offset + " ";
      }
      return offsetsString;
    };
    PDFObjectStream2.prototype.computeObjectOffsets = function() {
      var offset = 0;
      var offsets = new Array(this.objects.length);
      for (var idx = 0, len = this.objects.length; idx < len; idx++) {
        var _a = this.objects[idx], ref = _a[0], object = _a[1];
        offsets[idx] = [ref.objectNumber, offset];
        offset += object.sizeInBytes() + 1;
      }
      return offsets;
    };
    PDFObjectStream2.withContextAndObjects = function(context, objects, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFObjectStream2(context, objects, encode);
    };
    return PDFObjectStream2;
  }(PDFFlateStream_default)
);
var PDFObjectStream_default = PDFObjectStream;

// node_modules/pdf-lib/es/core/writers/PDFWriter.js
var PDFWriter = (
  /** @class */
  function() {
    function PDFWriter2(context, objectsPerTick) {
      var _this = this;
      this.parsedObjects = 0;
      this.shouldWaitForTick = function(n3) {
        _this.parsedObjects += n3;
        return _this.parsedObjects % _this.objectsPerTick === 0;
      };
      this.context = context;
      this.objectsPerTick = objectsPerTick;
    }
    PDFWriter2.prototype.serializeToBuffer = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n3;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              return [4, this.computeBufferSize()];
            case 1:
              _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;
              offset = 0;
              buffer = new Uint8Array(size);
              offset += header.copyBytesInto(buffer, offset);
              buffer[offset++] = CharCodes_default.Newline;
              buffer[offset++] = CharCodes_default.Newline;
              idx = 0, len = indirectObjects.length;
              _c.label = 2;
            case 2:
              if (!(idx < len))
                return [3, 5];
              _b = indirectObjects[idx], ref = _b[0], object = _b[1];
              objectNumber = String(ref.objectNumber);
              offset += copyStringIntoBuffer(objectNumber, buffer, offset);
              buffer[offset++] = CharCodes_default.Space;
              generationNumber = String(ref.generationNumber);
              offset += copyStringIntoBuffer(generationNumber, buffer, offset);
              buffer[offset++] = CharCodes_default.Space;
              buffer[offset++] = CharCodes_default.o;
              buffer[offset++] = CharCodes_default.b;
              buffer[offset++] = CharCodes_default.j;
              buffer[offset++] = CharCodes_default.Newline;
              offset += object.copyBytesInto(buffer, offset);
              buffer[offset++] = CharCodes_default.Newline;
              buffer[offset++] = CharCodes_default.e;
              buffer[offset++] = CharCodes_default.n;
              buffer[offset++] = CharCodes_default.d;
              buffer[offset++] = CharCodes_default.o;
              buffer[offset++] = CharCodes_default.b;
              buffer[offset++] = CharCodes_default.j;
              buffer[offset++] = CharCodes_default.Newline;
              buffer[offset++] = CharCodes_default.Newline;
              n3 = object instanceof PDFObjectStream_default ? object.getObjectsCount() : 1;
              if (!this.shouldWaitForTick(n3))
                return [3, 4];
              return [4, waitForTick()];
            case 3:
              _c.sent();
              _c.label = 4;
            case 4:
              idx++;
              return [3, 2];
            case 5:
              if (xref) {
                offset += xref.copyBytesInto(buffer, offset);
                buffer[offset++] = CharCodes_default.Newline;
              }
              if (trailerDict) {
                offset += trailerDict.copyBytesInto(buffer, offset);
                buffer[offset++] = CharCodes_default.Newline;
                buffer[offset++] = CharCodes_default.Newline;
              }
              offset += trailer.copyBytesInto(buffer, offset);
              return [2, buffer];
          }
        });
      });
    };
    PDFWriter2.prototype.computeIndirectObjectSize = function(_a) {
      var ref = _a[0], object = _a[1];
      var refSize = ref.sizeInBytes() + 3;
      var objectSize = object.sizeInBytes() + 9;
      return refSize + objectSize;
    };
    PDFWriter2.prototype.createTrailerDict = function() {
      return this.context.obj({
        Size: this.context.largestObjectNumber + 1,
        Root: this.context.trailerInfo.Root,
        Encrypt: this.context.trailerInfo.Encrypt,
        Info: this.context.trailerInfo.Info,
        ID: this.context.trailerInfo.ID
      });
    };
    PDFWriter2.prototype.computeBufferSize = function() {
      return __awaiter(this, void 0, void 0, function() {
        var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              header = PDFHeader_default.forVersion(1, 7);
              size = header.sizeInBytes() + 2;
              xref = PDFCrossRefSection_default.create();
              indirectObjects = this.context.enumerateIndirectObjects();
              idx = 0, len = indirectObjects.length;
              _a.label = 1;
            case 1:
              if (!(idx < len))
                return [3, 4];
              indirectObject = indirectObjects[idx];
              ref = indirectObject[0];
              xref.addEntry(ref, size);
              size += this.computeIndirectObjectSize(indirectObject);
              if (!this.shouldWaitForTick(1))
                return [3, 3];
              return [4, waitForTick()];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              xrefOffset = size;
              size += xref.sizeInBytes() + 1;
              trailerDict = PDFTrailerDict_default.of(this.createTrailerDict());
              size += trailerDict.sizeInBytes() + 2;
              trailer = PDFTrailer_default.forLastCrossRefSectionOffset(xrefOffset);
              size += trailer.sizeInBytes();
              return [2, { size, header, indirectObjects, xref, trailerDict, trailer }];
          }
        });
      });
    };
    PDFWriter2.forContext = function(context, objectsPerTick) {
      return new PDFWriter2(context, objectsPerTick);
    };
    return PDFWriter2;
  }()
);
var PDFWriter_default = PDFWriter;

// node_modules/pdf-lib/es/core/objects/PDFInvalidObject.js
var PDFInvalidObject = (
  /** @class */
  function(_super) {
    __extends(PDFInvalidObject2, _super);
    function PDFInvalidObject2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    PDFInvalidObject2.prototype.clone = function() {
      return PDFInvalidObject2.of(this.data.slice());
    };
    PDFInvalidObject2.prototype.toString = function() {
      return "PDFInvalidObject(" + this.data.length + " bytes)";
    };
    PDFInvalidObject2.prototype.sizeInBytes = function() {
      return this.data.length;
    };
    PDFInvalidObject2.prototype.copyBytesInto = function(buffer, offset) {
      var length = this.data.length;
      for (var idx = 0; idx < length; idx++) {
        buffer[offset++] = this.data[idx];
      }
      return length;
    };
    PDFInvalidObject2.of = function(data) {
      return new PDFInvalidObject2(data);
    };
    return PDFInvalidObject2;
  }(PDFObject_default)
);
var PDFInvalidObject_default = PDFInvalidObject;

// node_modules/pdf-lib/es/core/structures/PDFCrossRefStream.js
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Deleted"] = 0] = "Deleted";
  EntryType2[EntryType2["Uncompressed"] = 1] = "Uncompressed";
  EntryType2[EntryType2["Compressed"] = 2] = "Compressed";
})(EntryType || (EntryType = {}));
var PDFCrossRefStream = (
  /** @class */
  function(_super) {
    __extends(PDFCrossRefStream2, _super);
    function PDFCrossRefStream2(dict, entries, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, dict, encode) || this;
      _this.computeIndex = function() {
        var subsections = [];
        var subsectionLength = 0;
        for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
          var currEntry = _this.entries[idx];
          var prevEntry = _this.entries[idx - 1];
          if (idx === 0) {
            subsections.push(currEntry.ref.objectNumber);
          } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
            subsections.push(subsectionLength);
            subsections.push(currEntry.ref.objectNumber);
            subsectionLength = 0;
          }
          subsectionLength += 1;
        }
        subsections.push(subsectionLength);
        return subsections;
      };
      _this.computeEntryTuples = function() {
        var entryTuples = new Array(_this.entries.length);
        for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
          var entry = _this.entries[idx];
          if (entry.type === EntryType.Deleted) {
            var type = entry.type, nextFreeObjectNumber = entry.nextFreeObjectNumber, ref = entry.ref;
            entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];
          }
          if (entry.type === EntryType.Uncompressed) {
            var type = entry.type, offset = entry.offset, ref = entry.ref;
            entryTuples[idx] = [type, offset, ref.generationNumber];
          }
          if (entry.type === EntryType.Compressed) {
            var type = entry.type, objectStreamRef = entry.objectStreamRef, index = entry.index;
            entryTuples[idx] = [type, objectStreamRef.objectNumber, index];
          }
        }
        return entryTuples;
      };
      _this.computeMaxEntryByteWidths = function() {
        var entryTuples = _this.entryTuplesCache.access();
        var widths = [0, 0, 0];
        for (var idx = 0, len = entryTuples.length; idx < len; idx++) {
          var _a = entryTuples[idx], first = _a[0], second = _a[1], third = _a[2];
          var firstSize = sizeInBytes(first);
          var secondSize = sizeInBytes(second);
          var thirdSize = sizeInBytes(third);
          if (firstSize > widths[0])
            widths[0] = firstSize;
          if (secondSize > widths[1])
            widths[1] = secondSize;
          if (thirdSize > widths[2])
            widths[2] = thirdSize;
        }
        return widths;
      };
      _this.entries = entries || [];
      _this.entryTuplesCache = Cache_default.populatedBy(_this.computeEntryTuples);
      _this.maxByteWidthsCache = Cache_default.populatedBy(_this.computeMaxEntryByteWidths);
      _this.indexCache = Cache_default.populatedBy(_this.computeIndex);
      dict.set(PDFName_default.of("Type"), PDFName_default.of("XRef"));
      return _this;
    }
    PDFCrossRefStream2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
      var type = EntryType.Deleted;
      this.entries.push({ type, ref, nextFreeObjectNumber });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.addUncompressedEntry = function(ref, offset) {
      var type = EntryType.Uncompressed;
      this.entries.push({ type, ref, offset });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.addCompressedEntry = function(ref, objectStreamRef, index) {
      var type = EntryType.Compressed;
      this.entries.push({ type, ref, objectStreamRef, index });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.clone = function(context) {
      var _a = this, dict = _a.dict, entries = _a.entries, encode = _a.encode;
      return PDFCrossRefStream2.of(dict.clone(context), entries.slice(), encode);
    };
    PDFCrossRefStream2.prototype.getContentsString = function() {
      var entryTuples = this.entryTuplesCache.access();
      var byteWidths = this.maxByteWidthsCache.access();
      var value = "";
      for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
        var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
        var firstBytes = reverseArray(bytesFor(first));
        var secondBytes = reverseArray(bytesFor(second));
        var thirdBytes = reverseArray(bytesFor(third));
        for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
          value += (firstBytes[idx] || 0).toString(2);
        }
        for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
          value += (secondBytes[idx] || 0).toString(2);
        }
        for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
          value += (thirdBytes[idx] || 0).toString(2);
        }
      }
      return value;
    };
    PDFCrossRefStream2.prototype.getUnencodedContents = function() {
      var entryTuples = this.entryTuplesCache.access();
      var byteWidths = this.maxByteWidthsCache.access();
      var buffer = new Uint8Array(this.getUnencodedContentsSize());
      var offset = 0;
      for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
        var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
        var firstBytes = reverseArray(bytesFor(first));
        var secondBytes = reverseArray(bytesFor(second));
        var thirdBytes = reverseArray(bytesFor(third));
        for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
          buffer[offset++] = firstBytes[idx] || 0;
        }
        for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
          buffer[offset++] = secondBytes[idx] || 0;
        }
        for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
          buffer[offset++] = thirdBytes[idx] || 0;
        }
      }
      return buffer;
    };
    PDFCrossRefStream2.prototype.getUnencodedContentsSize = function() {
      var byteWidths = this.maxByteWidthsCache.access();
      var entryWidth = sum(byteWidths);
      return entryWidth * this.entries.length;
    };
    PDFCrossRefStream2.prototype.updateDict = function() {
      _super.prototype.updateDict.call(this);
      var byteWidths = this.maxByteWidthsCache.access();
      var index = this.indexCache.access();
      var context = this.dict.context;
      this.dict.set(PDFName_default.of("W"), context.obj(byteWidths));
      this.dict.set(PDFName_default.of("Index"), context.obj(index));
    };
    PDFCrossRefStream2.create = function(dict, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var stream2 = new PDFCrossRefStream2(dict, [], encode);
      stream2.addDeletedEntry(PDFRef_default.of(0, 65535), 0);
      return stream2;
    };
    PDFCrossRefStream2.of = function(dict, entries, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFCrossRefStream2(dict, entries, encode);
    };
    return PDFCrossRefStream2;
  }(PDFFlateStream_default)
);
var PDFCrossRefStream_default = PDFCrossRefStream;

// node_modules/pdf-lib/es/core/writers/PDFStreamWriter.js
var PDFStreamWriter = (
  /** @class */
  function(_super) {
    __extends(PDFStreamWriter2, _super);
    function PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream) {
      var _this = _super.call(this, context, objectsPerTick) || this;
      _this.encodeStreams = encodeStreams;
      _this.objectsPerStream = objectsPerStream;
      return _this;
    }
    PDFStreamWriter2.prototype.computeBufferSize = function() {
      return __awaiter(this, void 0, void 0, function() {
        var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              objectNumber = this.context.largestObjectNumber + 1;
              header = PDFHeader_default.forVersion(1, 7);
              size = header.sizeInBytes() + 2;
              xrefStream = PDFCrossRefStream_default.create(this.createTrailerDict(), this.encodeStreams);
              uncompressedObjects = [];
              compressedObjects = [];
              objectStreamRefs = [];
              indirectObjects = this.context.enumerateIndirectObjects();
              idx = 0, len = indirectObjects.length;
              _a.label = 1;
            case 1:
              if (!(idx < len))
                return [3, 6];
              indirectObject = indirectObjects[idx];
              ref = indirectObject[0], object = indirectObject[1];
              shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object instanceof PDFStream_default || object instanceof PDFInvalidObject_default || ref.generationNumber !== 0;
              if (!shouldNotCompress)
                return [3, 4];
              uncompressedObjects.push(indirectObject);
              xrefStream.addUncompressedEntry(ref, size);
              size += this.computeIndirectObjectSize(indirectObject);
              if (!this.shouldWaitForTick(1))
                return [3, 3];
              return [4, waitForTick()];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              return [3, 5];
            case 4:
              chunk = last(compressedObjects);
              objectStreamRef = last(objectStreamRefs);
              if (!chunk || chunk.length % this.objectsPerStream === 0) {
                chunk = [];
                compressedObjects.push(chunk);
                objectStreamRef = PDFRef_default.of(objectNumber++);
                objectStreamRefs.push(objectStreamRef);
              }
              xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);
              chunk.push(indirectObject);
              _a.label = 5;
            case 5:
              idx++;
              return [3, 1];
            case 6:
              idx = 0, len = compressedObjects.length;
              _a.label = 7;
            case 7:
              if (!(idx < len))
                return [3, 10];
              chunk = compressedObjects[idx];
              ref = objectStreamRefs[idx];
              objectStream = PDFObjectStream_default.withContextAndObjects(this.context, chunk, this.encodeStreams);
              xrefStream.addUncompressedEntry(ref, size);
              size += this.computeIndirectObjectSize([ref, objectStream]);
              uncompressedObjects.push([ref, objectStream]);
              if (!this.shouldWaitForTick(chunk.length))
                return [3, 9];
              return [4, waitForTick()];
            case 8:
              _a.sent();
              _a.label = 9;
            case 9:
              idx++;
              return [3, 7];
            case 10:
              xrefStreamRef = PDFRef_default.of(objectNumber++);
              xrefStream.dict.set(PDFName_default.of("Size"), PDFNumber_default.of(objectNumber));
              xrefStream.addUncompressedEntry(xrefStreamRef, size);
              xrefOffset = size;
              size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);
              uncompressedObjects.push([xrefStreamRef, xrefStream]);
              trailer = PDFTrailer_default.forLastCrossRefSectionOffset(xrefOffset);
              size += trailer.sizeInBytes();
              return [2, { size, header, indirectObjects: uncompressedObjects, trailer }];
          }
        });
      });
    };
    PDFStreamWriter2.forContext = function(context, objectsPerTick, encodeStreams, objectsPerStream) {
      if (encodeStreams === void 0) {
        encodeStreams = true;
      }
      if (objectsPerStream === void 0) {
        objectsPerStream = 50;
      }
      return new PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream);
    };
    return PDFStreamWriter2;
  }(PDFWriter_default)
);
var PDFStreamWriter_default = PDFStreamWriter;

// node_modules/pdf-lib/es/core/objects/PDFHexString.js
var PDFHexString = (
  /** @class */
  function(_super) {
    __extends(PDFHexString2, _super);
    function PDFHexString2(value) {
      var _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFHexString2.prototype.asBytes = function() {
      var hex = this.value + (this.value.length % 2 === 1 ? "0" : "");
      var hexLength = hex.length;
      var bytes = new Uint8Array(hex.length / 2);
      var hexOffset = 0;
      var bytesOffset = 0;
      while (hexOffset < hexLength) {
        var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);
        bytes[bytesOffset] = byte;
        hexOffset += 2;
        bytesOffset += 1;
      }
      return bytes;
    };
    PDFHexString2.prototype.decodeText = function() {
      var bytes = this.asBytes();
      if (hasUtf16BOM(bytes))
        return utf16Decode(bytes);
      return pdfDocEncodingDecode(bytes);
    };
    PDFHexString2.prototype.decodeDate = function() {
      var text = this.decodeText();
      var date = parseDate(text);
      if (!date)
        throw new InvalidPDFDateStringError(text);
      return date;
    };
    PDFHexString2.prototype.asString = function() {
      return this.value;
    };
    PDFHexString2.prototype.clone = function() {
      return PDFHexString2.of(this.value);
    };
    PDFHexString2.prototype.toString = function() {
      return "<" + this.value + ">";
    };
    PDFHexString2.prototype.sizeInBytes = function() {
      return this.value.length + 2;
    };
    PDFHexString2.prototype.copyBytesInto = function(buffer, offset) {
      buffer[offset++] = CharCodes_default.LessThan;
      offset += copyStringIntoBuffer(this.value, buffer, offset);
      buffer[offset++] = CharCodes_default.GreaterThan;
      return this.value.length + 2;
    };
    PDFHexString2.of = function(value) {
      return new PDFHexString2(value);
    };
    PDFHexString2.fromText = function(value) {
      var encoded = utf16Encode(value);
      var hex = "";
      for (var idx = 0, len = encoded.length; idx < len; idx++) {
        hex += toHexStringOfMinLength(encoded[idx], 4);
      }
      return new PDFHexString2(hex);
    };
    return PDFHexString2;
  }(PDFObject_default)
);
var PDFHexString_default = PDFHexString;

// node_modules/pdf-lib/es/core/embedders/StandardFontEmbedder.js
var StandardFontEmbedder = (
  /** @class */
  function() {
    function StandardFontEmbedder2(fontName, customName) {
      this.encoding = fontName === FontNames.ZapfDingbats ? Encodings.ZapfDingbats : fontName === FontNames.Symbol ? Encodings.Symbol : Encodings.WinAnsi;
      this.font = Font.load(fontName);
      this.fontName = this.font.FontName;
      this.customName = customName;
    }
    StandardFontEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.encodeTextAsGlyphs(text);
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        hexCodes[idx] = toHexString(glyphs[idx].code);
      }
      return PDFHexString_default.of(hexCodes.join(""));
    };
    StandardFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
      var glyphs = this.encodeTextAsGlyphs(text);
      var totalWidth = 0;
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        var left = glyphs[idx].name;
        var right = (glyphs[idx + 1] || {}).name;
        var kernAmount = this.font.getXAxisKerningForPair(left, right) || 0;
        totalWidth += this.widthOfGlyph(left) + kernAmount;
      }
      var scale2 = size / 1e3;
      return totalWidth * scale2;
    };
    StandardFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.descender, descender = _a === void 0 ? true : _a;
      var _b = this.font, Ascender = _b.Ascender, Descender = _b.Descender, FontBBox = _b.FontBBox;
      var yTop = Ascender || FontBBox[3];
      var yBottom = Descender || FontBBox[1];
      var height = yTop - yBottom;
      if (!descender)
        height += Descender || 0;
      return height / 1e3 * size;
    };
    StandardFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
      var _a = this.font, Ascender = _a.Ascender, Descender = _a.Descender, FontBBox = _a.FontBBox;
      var yTop = Ascender || FontBBox[3];
      var yBottom = Descender || FontBBox[1];
      return 1e3 * height / (yTop - yBottom);
    };
    StandardFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
      var fontDict = context.obj({
        Type: "Font",
        Subtype: "Type1",
        BaseFont: this.customName || this.fontName,
        Encoding: this.encoding === Encodings.WinAnsi ? "WinAnsiEncoding" : void 0
      });
      if (ref) {
        context.assign(ref, fontDict);
        return ref;
      } else {
        return context.register(fontDict);
      }
    };
    StandardFontEmbedder2.prototype.widthOfGlyph = function(glyphName) {
      return this.font.getWidthOfGlyph(glyphName) || 250;
    };
    StandardFontEmbedder2.prototype.encodeTextAsGlyphs = function(text) {
      var codePoints = Array.from(text);
      var glyphs = new Array(codePoints.length);
      for (var idx = 0, len = codePoints.length; idx < len; idx++) {
        var codePoint = toCodePoint(codePoints[idx]);
        glyphs[idx] = this.encoding.encodeUnicodeCodePoint(codePoint);
      }
      return glyphs;
    };
    StandardFontEmbedder2.for = function(fontName, customName) {
      return new StandardFontEmbedder2(fontName, customName);
    };
    return StandardFontEmbedder2;
  }()
);
var StandardFontEmbedder_default = StandardFontEmbedder;

// node_modules/pdf-lib/es/core/embedders/CMap.js
var createCmap = function(glyphs, glyphId) {
  var bfChars = new Array(glyphs.length);
  for (var idx = 0, len = glyphs.length; idx < len; idx++) {
    var glyph = glyphs[idx];
    var id = cmapHexFormat(cmapHexString(glyphId(glyph)));
    var unicode = cmapHexFormat.apply(void 0, glyph.codePoints.map(cmapCodePointFormat));
    bfChars[idx] = [id, unicode];
  }
  return fillCmapTemplate(bfChars);
};
var fillCmapTemplate = function(bfChars) {
  return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + bfChars.length + " beginbfchar\n" + bfChars.map(function(_a) {
    var glyphId = _a[0], codePoint = _a[1];
    return glyphId + " " + codePoint;
  }).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
};
var cmapHexFormat = function() {
  var values2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values2[_i] = arguments[_i];
  }
  return "<" + values2.join("") + ">";
};
var cmapHexString = function(value) {
  return toHexStringOfMinLength(value, 4);
};
var cmapCodePointFormat = function(codePoint) {
  if (isWithinBMP(codePoint))
    return cmapHexString(codePoint);
  if (hasSurrogates(codePoint)) {
    var hs = highSurrogate(codePoint);
    var ls = lowSurrogate(codePoint);
    return "" + cmapHexString(hs) + cmapHexString(ls);
  }
  var hex = toHexString(codePoint);
  var msg = "0x" + hex + " is not a valid UTF-8 or UTF-16 codepoint.";
  throw new Error(msg);
};

// node_modules/pdf-lib/es/core/embedders/FontFlags.js
var makeFontFlags = function(options) {
  var flags2 = 0;
  var flipBit = function(bit) {
    flags2 |= 1 << bit - 1;
  };
  if (options.fixedPitch)
    flipBit(1);
  if (options.serif)
    flipBit(2);
  if (options.symbolic)
    flipBit(3);
  if (options.script)
    flipBit(4);
  if (options.nonsymbolic)
    flipBit(6);
  if (options.italic)
    flipBit(7);
  if (options.allCap)
    flipBit(17);
  if (options.smallCap)
    flipBit(18);
  if (options.forceBold)
    flipBit(19);
  return flags2;
};
var deriveFontFlags = function(font) {
  var familyClass = font["OS/2"] ? font["OS/2"].sFamilyClass : 0;
  var flags2 = makeFontFlags({
    fixedPitch: font.post.isFixedPitch,
    serif: 1 <= familyClass && familyClass <= 7,
    symbolic: true,
    script: familyClass === 10,
    italic: font.head.macStyle.italic
  });
  return flags2;
};

// node_modules/pdf-lib/es/core/objects/PDFString.js
var PDFString = (
  /** @class */
  function(_super) {
    __extends(PDFString2, _super);
    function PDFString2(value) {
      var _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFString2.prototype.asBytes = function() {
      var bytes = [];
      var octal = "";
      var escaped = false;
      var pushByte = function(byte2) {
        if (byte2 !== void 0)
          bytes.push(byte2);
        escaped = false;
      };
      for (var idx = 0, len = this.value.length; idx < len; idx++) {
        var char = this.value[idx];
        var byte = toCharCode(char);
        var nextChar = this.value[idx + 1];
        if (!escaped) {
          if (byte === CharCodes_default.BackSlash)
            escaped = true;
          else
            pushByte(byte);
        } else {
          if (byte === CharCodes_default.Newline)
            pushByte();
          else if (byte === CharCodes_default.CarriageReturn)
            pushByte();
          else if (byte === CharCodes_default.n)
            pushByte(CharCodes_default.Newline);
          else if (byte === CharCodes_default.r)
            pushByte(CharCodes_default.CarriageReturn);
          else if (byte === CharCodes_default.t)
            pushByte(CharCodes_default.Tab);
          else if (byte === CharCodes_default.b)
            pushByte(CharCodes_default.Backspace);
          else if (byte === CharCodes_default.f)
            pushByte(CharCodes_default.FormFeed);
          else if (byte === CharCodes_default.LeftParen)
            pushByte(CharCodes_default.LeftParen);
          else if (byte === CharCodes_default.RightParen)
            pushByte(CharCodes_default.RightParen);
          else if (byte === CharCodes_default.Backspace)
            pushByte(CharCodes_default.BackSlash);
          else if (byte >= CharCodes_default.Zero && byte <= CharCodes_default.Seven) {
            octal += char;
            if (octal.length === 3 || !(nextChar >= "0" && nextChar <= "7")) {
              pushByte(parseInt(octal, 8));
              octal = "";
            }
          } else {
            pushByte(byte);
          }
        }
      }
      return new Uint8Array(bytes);
    };
    PDFString2.prototype.decodeText = function() {
      var bytes = this.asBytes();
      if (hasUtf16BOM(bytes))
        return utf16Decode(bytes);
      return pdfDocEncodingDecode(bytes);
    };
    PDFString2.prototype.decodeDate = function() {
      var text = this.decodeText();
      var date = parseDate(text);
      if (!date)
        throw new InvalidPDFDateStringError(text);
      return date;
    };
    PDFString2.prototype.asString = function() {
      return this.value;
    };
    PDFString2.prototype.clone = function() {
      return PDFString2.of(this.value);
    };
    PDFString2.prototype.toString = function() {
      return "(" + this.value + ")";
    };
    PDFString2.prototype.sizeInBytes = function() {
      return this.value.length + 2;
    };
    PDFString2.prototype.copyBytesInto = function(buffer, offset) {
      buffer[offset++] = CharCodes_default.LeftParen;
      offset += copyStringIntoBuffer(this.value, buffer, offset);
      buffer[offset++] = CharCodes_default.RightParen;
      return this.value.length + 2;
    };
    PDFString2.of = function(value) {
      return new PDFString2(value);
    };
    PDFString2.fromDate = function(date) {
      var year = padStart(String(date.getUTCFullYear()), 4, "0");
      var month = padStart(String(date.getUTCMonth() + 1), 2, "0");
      var day = padStart(String(date.getUTCDate()), 2, "0");
      var hours = padStart(String(date.getUTCHours()), 2, "0");
      var mins = padStart(String(date.getUTCMinutes()), 2, "0");
      var secs = padStart(String(date.getUTCSeconds()), 2, "0");
      return new PDFString2("D:" + year + month + day + hours + mins + secs + "Z");
    };
    return PDFString2;
  }(PDFObject_default)
);
var PDFString_default = PDFString;

// node_modules/pdf-lib/es/core/embedders/CustomFontEmbedder.js
var CustomFontEmbedder = (
  /** @class */
  function() {
    function CustomFontEmbedder2(font, fontData, customName, fontFeatures) {
      var _this = this;
      this.allGlyphsInFontSortedById = function() {
        var glyphs = new Array(_this.font.characterSet.length);
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          var codePoint = _this.font.characterSet[idx];
          glyphs[idx] = _this.font.glyphForCodePoint(codePoint);
        }
        return sortedUniq(glyphs.sort(byAscendingId), function(g5) {
          return g5.id;
        });
      };
      this.font = font;
      this.scale = 1e3 / this.font.unitsPerEm;
      this.fontData = fontData;
      this.fontName = this.font.postscriptName || "Font";
      this.customName = customName;
      this.fontFeatures = fontFeatures;
      this.baseFontName = "";
      this.glyphCache = Cache_default.populatedBy(this.allGlyphsInFontSortedById);
    }
    CustomFontEmbedder2.for = function(fontkit, fontData, customName, fontFeatures) {
      return __awaiter(this, void 0, void 0, function() {
        var font;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, fontkit.create(fontData)];
            case 1:
              font = _a.sent();
              return [2, new CustomFontEmbedder2(font, fontData, customName, fontFeatures)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        hexCodes[idx] = toHexStringOfMinLength(glyphs[idx].id, 4);
      }
      return PDFHexString_default.of(hexCodes.join(""));
    };
    CustomFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var totalWidth = 0;
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        totalWidth += glyphs[idx].advanceWidth * this.scale;
      }
      var scale2 = size / 1e3;
      return totalWidth * scale2;
    };
    CustomFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.descender, descender = _a === void 0 ? true : _a;
      var _b = this.font, ascent = _b.ascent, descent = _b.descent, bbox = _b.bbox;
      var yTop = (ascent || bbox.maxY) * this.scale;
      var yBottom = (descent || bbox.minY) * this.scale;
      var height = yTop - yBottom;
      if (!descender)
        height -= Math.abs(descent) || 0;
      return height / 1e3 * size;
    };
    CustomFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
      var _a = this.font, ascent = _a.ascent, descent = _a.descent, bbox = _a.bbox;
      var yTop = (ascent || bbox.maxY) * this.scale;
      var yBottom = (descent || bbox.minY) * this.scale;
      return 1e3 * height / (yTop - yBottom);
    };
    CustomFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
      this.baseFontName = this.customName || context.addRandomSuffix(this.fontName);
      return this.embedFontDict(context, ref);
    };
    CustomFontEmbedder2.prototype.embedFontDict = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var cidFontDictRef, unicodeCMapRef, fontDict;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.embedCIDFontDict(context)];
            case 1:
              cidFontDictRef = _a.sent();
              unicodeCMapRef = this.embedUnicodeCmap(context);
              fontDict = context.obj({
                Type: "Font",
                Subtype: "Type0",
                BaseFont: this.baseFontName,
                Encoding: "Identity-H",
                DescendantFonts: [cidFontDictRef],
                ToUnicode: unicodeCMapRef
              });
              if (ref) {
                context.assign(ref, fontDict);
                return [2, ref];
              } else {
                return [2, context.register(fontDict)];
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.isCFF = function() {
      return this.font.cff;
    };
    CustomFontEmbedder2.prototype.embedCIDFontDict = function(context) {
      return __awaiter(this, void 0, void 0, function() {
        var fontDescriptorRef, cidFontDict;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.embedFontDescriptor(context)];
            case 1:
              fontDescriptorRef = _a.sent();
              cidFontDict = context.obj({
                Type: "Font",
                Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                CIDToGIDMap: "Identity",
                BaseFont: this.baseFontName,
                CIDSystemInfo: {
                  Registry: PDFString_default.of("Adobe"),
                  Ordering: PDFString_default.of("Identity"),
                  Supplement: 0
                },
                FontDescriptor: fontDescriptorRef,
                W: this.computeWidths()
              });
              return [2, context.register(cidFontDict)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.embedFontDescriptor = function(context) {
      return __awaiter(this, void 0, void 0, function() {
        var fontStreamRef, scale2, _a, italicAngle, ascent, descent, capHeight, xHeight, _b, minX, minY, maxX, maxY, fontDescriptor;
        var _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.embedFontStream(context)];
            case 1:
              fontStreamRef = _d.sent();
              scale2 = this.scale;
              _a = this.font, italicAngle = _a.italicAngle, ascent = _a.ascent, descent = _a.descent, capHeight = _a.capHeight, xHeight = _a.xHeight;
              _b = this.font.bbox, minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
              fontDescriptor = context.obj((_c = {
                Type: "FontDescriptor",
                FontName: this.baseFontName,
                Flags: deriveFontFlags(this.font),
                FontBBox: [minX * scale2, minY * scale2, maxX * scale2, maxY * scale2],
                ItalicAngle: italicAngle,
                Ascent: ascent * scale2,
                Descent: descent * scale2,
                CapHeight: (capHeight || ascent) * scale2,
                XHeight: (xHeight || 0) * scale2,
                // Not sure how to compute/find this, nor is anybody else really:
                // https://stackoverflow.com/questions/35485179/stemv-value-of-the-truetype-font
                StemV: 0
              }, _c[this.isCFF() ? "FontFile3" : "FontFile2"] = fontStreamRef, _c));
              return [2, context.register(fontDescriptor)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.serializeFont = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, this.fontData];
        });
      });
    };
    CustomFontEmbedder2.prototype.embedFontStream = function(context) {
      return __awaiter(this, void 0, void 0, function() {
        var fontStream, _a, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _b = (_a = context).flateStream;
              return [4, this.serializeFont()];
            case 1:
              fontStream = _b.apply(_a, [_c.sent(), {
                Subtype: this.isCFF() ? "CIDFontType0C" : void 0
              }]);
              return [2, context.register(fontStream)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.embedUnicodeCmap = function(context) {
      var cmap = createCmap(this.glyphCache.access(), this.glyphId.bind(this));
      var cmapStream = context.flateStream(cmap);
      return context.register(cmapStream);
    };
    CustomFontEmbedder2.prototype.glyphId = function(glyph) {
      return glyph ? glyph.id : -1;
    };
    CustomFontEmbedder2.prototype.computeWidths = function() {
      var glyphs = this.glyphCache.access();
      var widths = [];
      var currSection = [];
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        var currGlyph = glyphs[idx];
        var prevGlyph = glyphs[idx - 1];
        var currGlyphId = this.glyphId(currGlyph);
        var prevGlyphId = this.glyphId(prevGlyph);
        if (idx === 0) {
          widths.push(currGlyphId);
        } else if (currGlyphId - prevGlyphId !== 1) {
          widths.push(currSection);
          widths.push(currGlyphId);
          currSection = [];
        }
        currSection.push(currGlyph.advanceWidth * this.scale);
      }
      widths.push(currSection);
      return widths;
    };
    return CustomFontEmbedder2;
  }()
);
var CustomFontEmbedder_default = CustomFontEmbedder;

// node_modules/pdf-lib/es/core/embedders/CustomFontSubsetEmbedder.js
var CustomFontSubsetEmbedder = (
  /** @class */
  function(_super) {
    __extends(CustomFontSubsetEmbedder2, _super);
    function CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures) {
      var _this = _super.call(this, font, fontData, customFontName, fontFeatures) || this;
      _this.subset = _this.font.createSubset();
      _this.glyphs = [];
      _this.glyphCache = Cache_default.populatedBy(function() {
        return _this.glyphs;
      });
      _this.glyphIdMap = /* @__PURE__ */ new Map();
      return _this;
    }
    CustomFontSubsetEmbedder2.for = function(fontkit, fontData, customFontName, fontFeatures) {
      return __awaiter(this, void 0, void 0, function() {
        var font;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, fontkit.create(fontData)];
            case 1:
              font = _a.sent();
              return [2, new CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures)];
          }
        });
      });
    };
    CustomFontSubsetEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        var glyph = glyphs[idx];
        var subsetGlyphId = this.subset.includeGlyph(glyph);
        this.glyphs[subsetGlyphId - 1] = glyph;
        this.glyphIdMap.set(glyph.id, subsetGlyphId);
        hexCodes[idx] = toHexStringOfMinLength(subsetGlyphId, 4);
      }
      this.glyphCache.invalidate();
      return PDFHexString_default.of(hexCodes.join(""));
    };
    CustomFontSubsetEmbedder2.prototype.isCFF = function() {
      return this.subset.cff;
    };
    CustomFontSubsetEmbedder2.prototype.glyphId = function(glyph) {
      return glyph ? this.glyphIdMap.get(glyph.id) : -1;
    };
    CustomFontSubsetEmbedder2.prototype.serializeFont = function() {
      var _this = this;
      return new Promise(function(resolve2, reject) {
        var parts2 = [];
        _this.subset.encodeStream().on("data", function(bytes) {
          return parts2.push(bytes);
        }).on("end", function() {
          return resolve2(mergeUint8Arrays(parts2));
        }).on("error", function(err2) {
          return reject(err2);
        });
      });
    };
    return CustomFontSubsetEmbedder2;
  }(CustomFontEmbedder_default)
);
var CustomFontSubsetEmbedder_default = CustomFontSubsetEmbedder;

// node_modules/pdf-lib/es/core/embedders/FileEmbedder.js
var AFRelationship;
(function(AFRelationship2) {
  AFRelationship2["Source"] = "Source";
  AFRelationship2["Data"] = "Data";
  AFRelationship2["Alternative"] = "Alternative";
  AFRelationship2["Supplement"] = "Supplement";
  AFRelationship2["EncryptedPayload"] = "EncryptedPayload";
  AFRelationship2["FormData"] = "EncryptedPayload";
  AFRelationship2["Schema"] = "Schema";
  AFRelationship2["Unspecified"] = "Unspecified";
})(AFRelationship || (AFRelationship = {}));
var FileEmbedder = (
  /** @class */
  function() {
    function FileEmbedder2(fileData, fileName, options) {
      if (options === void 0) {
        options = {};
      }
      this.fileData = fileData;
      this.fileName = fileName;
      this.options = options;
    }
    FileEmbedder2.for = function(bytes, fileName, options) {
      if (options === void 0) {
        options = {};
      }
      return new FileEmbedder2(bytes, fileName, options);
    };
    FileEmbedder2.prototype.embedIntoContext = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, mimeType, description, creationDate, modificationDate, afRelationship, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;
        return __generator(this, function(_b) {
          _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate, afRelationship = _a.afRelationship;
          embeddedFileStream = context.flateStream(this.fileData, {
            Type: "EmbeddedFile",
            Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : void 0,
            Params: {
              Size: this.fileData.length,
              CreationDate: creationDate ? PDFString_default.fromDate(creationDate) : void 0,
              ModDate: modificationDate ? PDFString_default.fromDate(modificationDate) : void 0
            }
          });
          embeddedFileStreamRef = context.register(embeddedFileStream);
          fileSpecDict = context.obj({
            Type: "Filespec",
            F: PDFString_default.of(this.fileName),
            UF: PDFHexString_default.fromText(this.fileName),
            EF: { F: embeddedFileStreamRef },
            Desc: description ? PDFHexString_default.fromText(description) : void 0,
            AFRelationship: afRelationship !== null && afRelationship !== void 0 ? afRelationship : void 0
          });
          if (ref) {
            context.assign(ref, fileSpecDict);
            return [2, ref];
          } else {
            return [2, context.register(fileSpecDict)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    return FileEmbedder2;
  }()
);
var FileEmbedder_default = FileEmbedder;

// node_modules/pdf-lib/es/core/embedders/JpegEmbedder.js
var MARKERS = [
  65472,
  65473,
  65474,
  65475,
  65477,
  65478,
  65479,
  65480,
  65481,
  65482,
  65483,
  65484,
  65485,
  65486,
  65487
];
var ColorSpace;
(function(ColorSpace2) {
  ColorSpace2["DeviceGray"] = "DeviceGray";
  ColorSpace2["DeviceRGB"] = "DeviceRGB";
  ColorSpace2["DeviceCMYK"] = "DeviceCMYK";
})(ColorSpace || (ColorSpace = {}));
var ChannelToColorSpace = {
  1: ColorSpace.DeviceGray,
  3: ColorSpace.DeviceRGB,
  4: ColorSpace.DeviceCMYK
};
var JpegEmbedder = (
  /** @class */
  function() {
    function JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace) {
      this.imageData = imageData;
      this.bitsPerComponent = bitsPerComponent;
      this.width = width;
      this.height = height;
      this.colorSpace = colorSpace;
    }
    JpegEmbedder2.for = function(imageData) {
      return __awaiter(this, void 0, void 0, function() {
        var dataView, soi, pos, marker, bitsPerComponent, height, width, channelByte, channelName, colorSpace;
        return __generator(this, function(_a) {
          dataView = new DataView(imageData.buffer);
          soi = dataView.getUint16(0);
          if (soi !== 65496)
            throw new Error("SOI not found in JPEG");
          pos = 2;
          while (pos < dataView.byteLength) {
            marker = dataView.getUint16(pos);
            pos += 2;
            if (MARKERS.includes(marker))
              break;
            pos += dataView.getUint16(pos);
          }
          if (!MARKERS.includes(marker))
            throw new Error("Invalid JPEG");
          pos += 2;
          bitsPerComponent = dataView.getUint8(pos++);
          height = dataView.getUint16(pos);
          pos += 2;
          width = dataView.getUint16(pos);
          pos += 2;
          channelByte = dataView.getUint8(pos++);
          channelName = ChannelToColorSpace[channelByte];
          if (!channelName)
            throw new Error("Unknown JPEG channel.");
          colorSpace = channelName;
          return [2, new JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace)];
        });
      });
    };
    JpegEmbedder2.prototype.embedIntoContext = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var xObject;
        return __generator(this, function(_a) {
          xObject = context.stream(this.imageData, {
            Type: "XObject",
            Subtype: "Image",
            BitsPerComponent: this.bitsPerComponent,
            Width: this.width,
            Height: this.height,
            ColorSpace: this.colorSpace,
            Filter: "DCTDecode",
            // CMYK JPEG streams in PDF are typically stored complemented,
            // with 1 as 'off' and 0 as 'on' (PDF 32000-1:2008, 8.6.4.4).
            //
            // Standalone CMYK JPEG (usually exported by Photoshop) are
            // stored inverse, with 0 as 'off' and 1 as 'on', like RGB.
            //
            // Applying a swap here as a hedge that most bytes passing
            // through this method will benefit from it.
            Decode: this.colorSpace === ColorSpace.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
          });
          if (ref) {
            context.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context.register(xObject)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    return JpegEmbedder2;
  }()
);
var JpegEmbedder_default = JpegEmbedder;

// node_modules/@pdf-lib/upng/UPNG.js
var import_pako4 = __toESM(require_pako());
var UPNG = {};
UPNG.toRGBA8 = function(out2) {
  var w6 = out2.width, h3 = out2.height;
  if (out2.tabs.acTL == null)
    return [UPNG.toRGBA8.decodeImage(out2.data, w6, h3, out2).buffer];
  var frms = [];
  if (out2.frames[0].data == null)
    out2.frames[0].data = out2.data;
  var len = w6 * h3 * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
  for (var i3 = 0; i3 < out2.frames.length; i3++) {
    var frm = out2.frames[i3];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out2);
    if (i3 != 0)
      for (var j4 = 0; j4 < len; j4++)
        prev[j4] = img[j4];
    if (frm.blend == 0)
      UPNG._copyTile(fdata, fw, fh, img, w6, h3, fx, fy, 0);
    else if (frm.blend == 1)
      UPNG._copyTile(fdata, fw, fh, img, w6, h3, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 0) {
    } else if (frm.dispose == 1)
      UPNG._copyTile(empty, fw, fh, img, w6, h3, fx, fy, 0);
    else if (frm.dispose == 2)
      for (var j4 = 0; j4 < len; j4++)
        img[j4] = prev[j4];
  }
  return frms;
};
UPNG.toRGBA8.decodeImage = function(data, w6, h3, out2) {
  var area = w6 * h3, bpp = UPNG.decode._getBPP(out2);
  var bpl = Math.ceil(w6 * bpp / 8);
  var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out2.ctype, depth = out2.depth;
  var rs = UPNG._bin.readUshort;
  var time = Date.now();
  if (ctype == 6) {
    var qarea = area << 2;
    if (depth == 8)
      for (var i3 = 0; i3 < qarea; i3 += 4) {
        bf[i3] = data[i3];
        bf[i3 + 1] = data[i3 + 1];
        bf[i3 + 2] = data[i3 + 2];
        bf[i3 + 3] = data[i3 + 3];
      }
    if (depth == 16)
      for (var i3 = 0; i3 < qarea; i3++) {
        bf[i3] = data[i3 << 1];
      }
  } else if (ctype == 2) {
    var ts = out2.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8)
        for (var i3 = 0; i3 < area; i3++) {
          var ti = i3 * 3;
          bf32[i3] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
        }
      if (depth == 16)
        for (var i3 = 0; i3 < area; i3++) {
          var ti = i3 * 6;
          bf32[i3] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
        }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8)
        for (var i3 = 0; i3 < area; i3++) {
          var qi = i3 << 2, ti = i3 * 3;
          bf32[i3] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
            bf[qi + 3] = 0;
        }
      if (depth == 16)
        for (var i3 = 0; i3 < area; i3++) {
          var qi = i3 << 2, ti = i3 * 6;
          bf32[i3] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
            bf[qi + 3] = 0;
        }
    }
  } else if (ctype == 3) {
    var p5 = out2.tabs["PLTE"], ap = out2.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1)
      for (var y4 = 0; y4 < h3; y4++) {
        var s0 = y4 * bpl, t0 = y4 * w6;
        for (var i3 = 0; i3 < w6; i3++) {
          var qi = t0 + i3 << 2, j4 = data[s0 + (i3 >> 3)] >> 7 - ((i3 & 7) << 0) & 1, cj = 3 * j4;
          bf[qi] = p5[cj];
          bf[qi + 1] = p5[cj + 1];
          bf[qi + 2] = p5[cj + 2];
          bf[qi + 3] = j4 < tl ? ap[j4] : 255;
        }
      }
    if (depth == 2)
      for (var y4 = 0; y4 < h3; y4++) {
        var s0 = y4 * bpl, t0 = y4 * w6;
        for (var i3 = 0; i3 < w6; i3++) {
          var qi = t0 + i3 << 2, j4 = data[s0 + (i3 >> 2)] >> 6 - ((i3 & 3) << 1) & 3, cj = 3 * j4;
          bf[qi] = p5[cj];
          bf[qi + 1] = p5[cj + 1];
          bf[qi + 2] = p5[cj + 2];
          bf[qi + 3] = j4 < tl ? ap[j4] : 255;
        }
      }
    if (depth == 4)
      for (var y4 = 0; y4 < h3; y4++) {
        var s0 = y4 * bpl, t0 = y4 * w6;
        for (var i3 = 0; i3 < w6; i3++) {
          var qi = t0 + i3 << 2, j4 = data[s0 + (i3 >> 1)] >> 4 - ((i3 & 1) << 2) & 15, cj = 3 * j4;
          bf[qi] = p5[cj];
          bf[qi + 1] = p5[cj + 1];
          bf[qi + 2] = p5[cj + 2];
          bf[qi + 3] = j4 < tl ? ap[j4] : 255;
        }
      }
    if (depth == 8)
      for (var i3 = 0; i3 < area; i3++) {
        var qi = i3 << 2, j4 = data[i3], cj = 3 * j4;
        bf[qi] = p5[cj];
        bf[qi + 1] = p5[cj + 1];
        bf[qi + 2] = p5[cj + 2];
        bf[qi + 3] = j4 < tl ? ap[j4] : 255;
      }
  } else if (ctype == 4) {
    if (depth == 8)
      for (var i3 = 0; i3 < area; i3++) {
        var qi = i3 << 2, di = i3 << 1, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 1];
      }
    if (depth == 16)
      for (var i3 = 0; i3 < area; i3++) {
        var qi = i3 << 2, di = i3 << 2, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 2];
      }
  } else if (ctype == 0) {
    var tr = out2.tabs["tRNS"] ? out2.tabs["tRNS"] : -1;
    for (var y4 = 0; y4 < h3; y4++) {
      var off = y4 * bpl, to = y4 * w6;
      if (depth == 1)
        for (var x4 = 0; x4 < w6; x4++) {
          var gr = 255 * (data[off + (x4 >>> 3)] >>> 7 - (x4 & 7) & 1), al = gr == tr * 255 ? 0 : 255;
          bf32[to + x4] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 2)
        for (var x4 = 0; x4 < w6; x4++) {
          var gr = 85 * (data[off + (x4 >>> 2)] >>> 6 - ((x4 & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
          bf32[to + x4] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 4)
        for (var x4 = 0; x4 < w6; x4++) {
          var gr = 17 * (data[off + (x4 >>> 1)] >>> 4 - ((x4 & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
          bf32[to + x4] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 8)
        for (var x4 = 0; x4 < w6; x4++) {
          var gr = data[off + x4], al = gr == tr ? 0 : 255;
          bf32[to + x4] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 16)
        for (var x4 = 0; x4 < w6; x4++) {
          var gr = data[off + (x4 << 1)], al = rs(data, off + (x4 << i3)) == tr ? 0 : 255;
          bf32[to + x4] = al << 24 | gr << 16 | gr << 8 | gr;
        }
    }
  }
  return bf;
};
UPNG.decode = function(buff) {
  var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out2 = { tabs: {}, frames: [] };
  var dd = new Uint8Array(data.length), doff = 0;
  var fd, foff = 0;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i3 = 0; i3 < 8; i3++)
    if (data[i3] != mgck[i3])
      throw "The input is not a PNG file!";
  while (offset < data.length) {
    var len = bin.readUint(data, offset);
    offset += 4;
    var type = bin.readASCII(data, offset, 4);
    offset += 4;
    if (type == "IHDR") {
      UPNG.decode._IHDR(data, offset, out2);
    } else if (type == "IDAT") {
      for (var i3 = 0; i3 < len; i3++)
        dd[doff + i3] = data[offset + i3];
      doff += len;
    } else if (type == "acTL") {
      out2.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };
      fd = new Uint8Array(data.length);
    } else if (type == "fcTL") {
      if (foff != 0) {
        var fr = out2.frames[out2.frames.length - 1];
        fr.data = UPNG.decode._decompress(out2, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = { x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8) };
      var del = rUs(data, offset + 22);
      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
      var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data[offset + 24], blend: data[offset + 25] };
      out2.frames.push(frm);
    } else if (type == "fdAT") {
      for (var i3 = 0; i3 < len - 4; i3++)
        fd[foff + i3] = data[offset + i3 + 4];
      foff += len - 4;
    } else if (type == "pHYs") {
      out2.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
    } else if (type == "cHRM") {
      out2.tabs[type] = [];
      for (var i3 = 0; i3 < 8; i3++)
        out2.tabs[type].push(bin.readUint(data, offset + i3 * 4));
    } else if (type == "tEXt") {
      if (out2.tabs[type] == null)
        out2.tabs[type] = {};
      var nz = bin.nextZero(data, offset);
      var keyw = bin.readASCII(data, offset, nz - offset);
      var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);
      out2.tabs[type][keyw] = text;
    } else if (type == "iTXt") {
      if (out2.tabs[type] == null)
        out2.tabs[type] = {};
      var nz = 0, off = offset;
      nz = bin.nextZero(data, off);
      var keyw = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      var cflag = data[off], cmeth = data[off + 1];
      off += 2;
      nz = bin.nextZero(data, off);
      var ltag = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      nz = bin.nextZero(data, off);
      var tkeyw = bin.readUTF8(data, off, nz - off);
      off = nz + 1;
      var text = bin.readUTF8(data, off, len - (off - offset));
      out2.tabs[type][keyw] = text;
    } else if (type == "PLTE") {
      out2.tabs[type] = bin.readBytes(data, offset, len);
    } else if (type == "hIST") {
      var pl = out2.tabs["PLTE"].length / 3;
      out2.tabs[type] = [];
      for (var i3 = 0; i3 < pl; i3++)
        out2.tabs[type].push(rUs(data, offset + i3 * 2));
    } else if (type == "tRNS") {
      if (out2.ctype == 3)
        out2.tabs[type] = bin.readBytes(data, offset, len);
      else if (out2.ctype == 0)
        out2.tabs[type] = rUs(data, offset);
      else if (out2.ctype == 2)
        out2.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
    } else if (type == "gAMA")
      out2.tabs[type] = bin.readUint(data, offset) / 1e5;
    else if (type == "sRGB")
      out2.tabs[type] = data[offset];
    else if (type == "bKGD") {
      if (out2.ctype == 0 || out2.ctype == 4)
        out2.tabs[type] = [rUs(data, offset)];
      else if (out2.ctype == 2 || out2.ctype == 6)
        out2.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      else if (out2.ctype == 3)
        out2.tabs[type] = data[offset];
    } else if (type == "IEND") {
      break;
    }
    offset += len;
    var crc = bin.readUint(data, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out2.frames[out2.frames.length - 1];
    fr.data = UPNG.decode._decompress(out2, fd.slice(0, foff), fr.rect.width, fr.rect.height);
    foff = 0;
  }
  out2.data = UPNG.decode._decompress(out2, dd, out2.width, out2.height);
  delete out2.compress;
  delete out2.interlace;
  delete out2.filter;
  return out2;
};
UPNG.decode._decompress = function(out2, dd, w6, h3) {
  var time = Date.now();
  var bpp = UPNG.decode._getBPP(out2), bpl = Math.ceil(w6 * bpp / 8), buff = new Uint8Array((bpl + 1 + out2.interlace) * h3);
  dd = UPNG.decode._inflate(dd, buff);
  var time = Date.now();
  if (out2.interlace == 0)
    dd = UPNG.decode._filterZero(dd, out2, 0, w6, h3);
  else if (out2.interlace == 1)
    dd = UPNG.decode._readInterlace(dd, out2);
  return dd;
};
UPNG.decode._inflate = function(data, buff) {
  var out2 = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
  return out2;
};
UPNG.inflateRaw = function() {
  var H5 = {};
  H5.H = {};
  H5.H.N = function(N4, W5) {
    var R6 = Uint8Array, i3 = 0, m5 = 0, J3 = 0, h3 = 0, Q4 = 0, X4 = 0, u4 = 0, w6 = 0, d3 = 0, v4, C6;
    if (N4[0] == 3 && N4[1] == 0)
      return W5 ? W5 : new R6(0);
    var V3 = H5.H, n3 = V3.b, A4 = V3.e, l4 = V3.R, M4 = V3.n, I4 = V3.A, e = V3.Z, b4 = V3.m, Z4 = W5 == null;
    if (Z4)
      W5 = new R6(N4.length >>> 2 << 3);
    while (i3 == 0) {
      i3 = n3(N4, d3, 1);
      m5 = n3(N4, d3 + 1, 2);
      d3 += 3;
      if (m5 == 0) {
        if ((d3 & 7) != 0)
          d3 += 8 - (d3 & 7);
        var D6 = (d3 >>> 3) + 4, q4 = N4[D6 - 4] | N4[D6 - 3] << 8;
        if (Z4)
          W5 = H5.H.W(W5, w6 + q4);
        W5.set(new R6(N4.buffer, N4.byteOffset + D6, q4), w6);
        d3 = D6 + q4 << 3;
        w6 += q4;
        continue;
      }
      if (Z4)
        W5 = H5.H.W(W5, w6 + (1 << 17));
      if (m5 == 1) {
        v4 = b4.J;
        C6 = b4.h;
        X4 = (1 << 9) - 1;
        u4 = (1 << 5) - 1;
      }
      if (m5 == 2) {
        J3 = A4(N4, d3, 5) + 257;
        h3 = A4(N4, d3 + 5, 5) + 1;
        Q4 = A4(N4, d3 + 10, 4) + 4;
        d3 += 14;
        var E2 = d3, j4 = 1;
        for (var c2 = 0; c2 < 38; c2 += 2) {
          b4.Q[c2] = 0;
          b4.Q[c2 + 1] = 0;
        }
        for (var c2 = 0; c2 < Q4; c2++) {
          var K4 = A4(N4, d3 + c2 * 3, 3);
          b4.Q[(b4.X[c2] << 1) + 1] = K4;
          if (K4 > j4)
            j4 = K4;
        }
        d3 += 3 * Q4;
        M4(b4.Q, j4);
        I4(b4.Q, j4, b4.u);
        v4 = b4.w;
        C6 = b4.d;
        d3 = l4(b4.u, (1 << j4) - 1, J3 + h3, N4, d3, b4.v);
        var r = V3.V(b4.v, 0, J3, b4.C);
        X4 = (1 << r) - 1;
        var S4 = V3.V(b4.v, J3, h3, b4.D);
        u4 = (1 << S4) - 1;
        M4(b4.C, r);
        I4(b4.C, r, v4);
        M4(b4.D, S4);
        I4(b4.D, S4, C6);
      }
      while (true) {
        var T4 = v4[e(N4, d3) & X4];
        d3 += T4 & 15;
        var p5 = T4 >>> 4;
        if (p5 >>> 8 == 0) {
          W5[w6++] = p5;
        } else if (p5 == 256) {
          break;
        } else {
          var z4 = w6 + p5 - 254;
          if (p5 > 264) {
            var _3 = b4.q[p5 - 257];
            z4 = w6 + (_3 >>> 3) + A4(N4, d3, _3 & 7);
            d3 += _3 & 7;
          }
          var $5 = C6[e(N4, d3) & u4];
          d3 += $5 & 15;
          var s5 = $5 >>> 4, Y4 = b4.c[s5], a2 = (Y4 >>> 4) + n3(N4, d3, Y4 & 15);
          d3 += Y4 & 15;
          while (w6 < z4) {
            W5[w6] = W5[w6++ - a2];
            W5[w6] = W5[w6++ - a2];
            W5[w6] = W5[w6++ - a2];
            W5[w6] = W5[w6++ - a2];
          }
          w6 = z4;
        }
      }
    }
    return W5.length == w6 ? W5 : W5.slice(0, w6);
  };
  H5.H.W = function(N4, W5) {
    var R6 = N4.length;
    if (W5 <= R6)
      return N4;
    var V3 = new Uint8Array(R6 << 1);
    V3.set(N4, 0);
    return V3;
  };
  H5.H.R = function(N4, W5, R6, V3, n3, A4) {
    var l4 = H5.H.e, M4 = H5.H.Z, I4 = 0;
    while (I4 < R6) {
      var e = N4[M4(V3, n3) & W5];
      n3 += e & 15;
      var b4 = e >>> 4;
      if (b4 <= 15) {
        A4[I4] = b4;
        I4++;
      } else {
        var Z4 = 0, m5 = 0;
        if (b4 == 16) {
          m5 = 3 + l4(V3, n3, 2);
          n3 += 2;
          Z4 = A4[I4 - 1];
        } else if (b4 == 17) {
          m5 = 3 + l4(V3, n3, 3);
          n3 += 3;
        } else if (b4 == 18) {
          m5 = 11 + l4(V3, n3, 7);
          n3 += 7;
        }
        var J3 = I4 + m5;
        while (I4 < J3) {
          A4[I4] = Z4;
          I4++;
        }
      }
    }
    return n3;
  };
  H5.H.V = function(N4, W5, R6, V3) {
    var n3 = 0, A4 = 0, l4 = V3.length >>> 1;
    while (A4 < R6) {
      var M4 = N4[A4 + W5];
      V3[A4 << 1] = 0;
      V3[(A4 << 1) + 1] = M4;
      if (M4 > n3)
        n3 = M4;
      A4++;
    }
    while (A4 < l4) {
      V3[A4 << 1] = 0;
      V3[(A4 << 1) + 1] = 0;
      A4++;
    }
    return n3;
  };
  H5.H.n = function(N4, W5) {
    var R6 = H5.H.m, V3 = N4.length, n3, A4, l4, M4, I4, e = R6.j;
    for (var M4 = 0; M4 <= W5; M4++)
      e[M4] = 0;
    for (M4 = 1; M4 < V3; M4 += 2)
      e[N4[M4]]++;
    var b4 = R6.K;
    n3 = 0;
    e[0] = 0;
    for (A4 = 1; A4 <= W5; A4++) {
      n3 = n3 + e[A4 - 1] << 1;
      b4[A4] = n3;
    }
    for (l4 = 0; l4 < V3; l4 += 2) {
      I4 = N4[l4 + 1];
      if (I4 != 0) {
        N4[l4] = b4[I4];
        b4[I4]++;
      }
    }
  };
  H5.H.A = function(N4, W5, R6) {
    var V3 = N4.length, n3 = H5.H.m, A4 = n3.r;
    for (var l4 = 0; l4 < V3; l4 += 2)
      if (N4[l4 + 1] != 0) {
        var M4 = l4 >> 1, I4 = N4[l4 + 1], e = M4 << 4 | I4, b4 = W5 - I4, Z4 = N4[l4] << b4, m5 = Z4 + (1 << b4);
        while (Z4 != m5) {
          var J3 = A4[Z4] >>> 15 - W5;
          R6[J3] = e;
          Z4++;
        }
      }
  };
  H5.H.l = function(N4, W5) {
    var R6 = H5.H.m.r, V3 = 15 - W5;
    for (var n3 = 0; n3 < N4.length; n3 += 2) {
      var A4 = N4[n3] << W5 - N4[n3 + 1];
      N4[n3] = R6[A4] >>> V3;
    }
  };
  H5.H.M = function(N4, W5, R6) {
    R6 = R6 << (W5 & 7);
    var V3 = W5 >>> 3;
    N4[V3] |= R6;
    N4[V3 + 1] |= R6 >>> 8;
  };
  H5.H.I = function(N4, W5, R6) {
    R6 = R6 << (W5 & 7);
    var V3 = W5 >>> 3;
    N4[V3] |= R6;
    N4[V3 + 1] |= R6 >>> 8;
    N4[V3 + 2] |= R6 >>> 16;
  };
  H5.H.e = function(N4, W5, R6) {
    return (N4[W5 >>> 3] | N4[(W5 >>> 3) + 1] << 8) >>> (W5 & 7) & (1 << R6) - 1;
  };
  H5.H.b = function(N4, W5, R6) {
    return (N4[W5 >>> 3] | N4[(W5 >>> 3) + 1] << 8 | N4[(W5 >>> 3) + 2] << 16) >>> (W5 & 7) & (1 << R6) - 1;
  };
  H5.H.Z = function(N4, W5) {
    return (N4[W5 >>> 3] | N4[(W5 >>> 3) + 1] << 8 | N4[(W5 >>> 3) + 2] << 16) >>> (W5 & 7);
  };
  H5.H.i = function(N4, W5) {
    return (N4[W5 >>> 3] | N4[(W5 >>> 3) + 1] << 8 | N4[(W5 >>> 3) + 2] << 16 | N4[(W5 >>> 3) + 3] << 24) >>> (W5 & 7);
  };
  H5.H.m = function() {
    var N4 = Uint16Array, W5 = Uint32Array;
    return { K: new N4(16), j: new N4(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N4(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W5(32), J: new N4(512), _: [], h: new N4(32), $: [], w: new N4(32768), C: [], v: [], d: new N4(32768), D: [], u: new N4(512), Q: [], r: new N4(1 << 15), s: new W5(286), Y: new W5(30), a: new W5(19), t: new W5(15e3), k: new N4(1 << 16), g: new N4(1 << 15) };
  }();
  (function() {
    var N4 = H5.H.m, W5 = 1 << 15;
    for (var R6 = 0; R6 < W5; R6++) {
      var V3 = R6;
      V3 = (V3 & 2863311530) >>> 1 | (V3 & 1431655765) << 1;
      V3 = (V3 & 3435973836) >>> 2 | (V3 & 858993459) << 2;
      V3 = (V3 & 4042322160) >>> 4 | (V3 & 252645135) << 4;
      V3 = (V3 & 4278255360) >>> 8 | (V3 & 16711935) << 8;
      N4.r[R6] = (V3 >>> 16 | V3 << 16) >>> 17;
    }
    function n3(A4, l4, M4) {
      while (l4-- != 0)
        A4.push(0, M4);
    }
    for (var R6 = 0; R6 < 32; R6++) {
      N4.q[R6] = N4.S[R6] << 3 | N4.T[R6];
      N4.c[R6] = N4.p[R6] << 4 | N4.z[R6];
    }
    n3(N4._, 144, 8);
    n3(N4._, 255 - 143, 9);
    n3(N4._, 279 - 255, 7);
    n3(N4._, 287 - 279, 8);
    H5.H.n(N4._, 9);
    H5.H.A(N4._, 9, N4.J);
    H5.H.l(N4._, 9);
    n3(N4.$, 32, 5);
    H5.H.n(N4.$, 5);
    H5.H.A(N4.$, 5, N4.h);
    H5.H.l(N4.$, 5);
    n3(N4.Q, 19, 0);
    n3(N4.C, 286, 0);
    n3(N4.D, 30, 0);
    n3(N4.v, 320, 0);
  })();
  return H5.H.N;
}();
UPNG.decode._readInterlace = function(data, out2) {
  var w6 = out2.width, h3 = out2.height;
  var bpp = UPNG.decode._getBPP(out2), cbpp = bpp >> 3, bpl = Math.ceil(w6 * bpp / 8);
  var img = new Uint8Array(h3 * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr2 = starting_row[pass];
    while (cr2 < h3) {
      cr2 += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w6) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    UPNG.decode._filterZero(data, out2, di, sw, sh);
    var y4 = 0, row = starting_row[pass];
    while (row < h3) {
      var col = starting_col[pass];
      var cdi = di + y4 * bpll << 3;
      while (col < w6) {
        if (bpp == 1) {
          var val = data[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          var val = data[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          var val = data[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j4 = 0; j4 < cbpp; j4++)
            img[ii + j4] = data[(cdi >> 3) + j4];
        }
        cdi += bpp;
        col += ci;
      }
      y4++;
      row += ri;
    }
    if (sw * sh != 0)
      di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
};
UPNG.decode._getBPP = function(out2) {
  var noc = [1, null, 3, 1, 2, null, 4][out2.ctype];
  return noc * out2.depth;
};
UPNG.decode._filterZero = function(data, out2, off, w6, h3) {
  var bpp = UPNG.decode._getBPP(out2), bpl = Math.ceil(w6 * bpp / 8), paeth = UPNG.decode._paeth;
  bpp = Math.ceil(bpp / 8);
  var i3 = 0, di = 1, type = data[off], x4 = 0;
  if (type > 1)
    data[off] = [0, 0, 1][type - 2];
  if (type == 3)
    for (x4 = bpp; x4 < bpl; x4++)
      data[x4 + 1] = data[x4 + 1] + (data[x4 + 1 - bpp] >>> 1) & 255;
  for (var y4 = 0; y4 < h3; y4++) {
    i3 = off + y4 * bpl;
    di = i3 + y4 + 1;
    type = data[di - 1];
    x4 = 0;
    if (type == 0)
      for (; x4 < bpl; x4++)
        data[i3 + x4] = data[di + x4];
    else if (type == 1) {
      for (; x4 < bpp; x4++)
        data[i3 + x4] = data[di + x4];
      for (; x4 < bpl; x4++)
        data[i3 + x4] = data[di + x4] + data[i3 + x4 - bpp];
    } else if (type == 2) {
      for (; x4 < bpl; x4++)
        data[i3 + x4] = data[di + x4] + data[i3 + x4 - bpl];
    } else if (type == 3) {
      for (; x4 < bpp; x4++)
        data[i3 + x4] = data[di + x4] + (data[i3 + x4 - bpl] >>> 1);
      for (; x4 < bpl; x4++)
        data[i3 + x4] = data[di + x4] + (data[i3 + x4 - bpl] + data[i3 + x4 - bpp] >>> 1);
    } else {
      for (; x4 < bpp; x4++)
        data[i3 + x4] = data[di + x4] + paeth(0, data[i3 + x4 - bpl], 0);
      for (; x4 < bpl; x4++)
        data[i3 + x4] = data[di + x4] + paeth(data[i3 + x4 - bpp], data[i3 + x4 - bpl], data[i3 + x4 - bpp - bpl]);
    }
  }
  return data;
};
UPNG.decode._paeth = function(a2, b4, c2) {
  var p5 = a2 + b4 - c2, pa = p5 - a2, pb = p5 - b4, pc = p5 - c2;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc)
    return a2;
  else if (pb * pb <= pc * pc)
    return b4;
  return c2;
};
UPNG.decode._IHDR = function(data, offset, out2) {
  var bin = UPNG._bin;
  out2.width = bin.readUint(data, offset);
  offset += 4;
  out2.height = bin.readUint(data, offset);
  offset += 4;
  out2.depth = data[offset];
  offset++;
  out2.ctype = data[offset];
  offset++;
  out2.compress = data[offset];
  offset++;
  out2.filter = data[offset];
  offset++;
  out2.interlace = data[offset];
  offset++;
};
UPNG._bin = {
  nextZero: function(data, p5) {
    while (data[p5] != 0)
      p5++;
    return p5;
  },
  readUshort: function(buff, p5) {
    return buff[p5] << 8 | buff[p5 + 1];
  },
  writeUshort: function(buff, p5, n3) {
    buff[p5] = n3 >> 8 & 255;
    buff[p5 + 1] = n3 & 255;
  },
  readUint: function(buff, p5) {
    return buff[p5] * (256 * 256 * 256) + (buff[p5 + 1] << 16 | buff[p5 + 2] << 8 | buff[p5 + 3]);
  },
  writeUint: function(buff, p5, n3) {
    buff[p5] = n3 >> 24 & 255;
    buff[p5 + 1] = n3 >> 16 & 255;
    buff[p5 + 2] = n3 >> 8 & 255;
    buff[p5 + 3] = n3 & 255;
  },
  readASCII: function(buff, p5, l4) {
    var s5 = "";
    for (var i3 = 0; i3 < l4; i3++)
      s5 += String.fromCharCode(buff[p5 + i3]);
    return s5;
  },
  writeASCII: function(data, p5, s5) {
    for (var i3 = 0; i3 < s5.length; i3++)
      data[p5 + i3] = s5.charCodeAt(i3);
  },
  readBytes: function(buff, p5, l4) {
    var arr = [];
    for (var i3 = 0; i3 < l4; i3++)
      arr.push(buff[p5 + i3]);
    return arr;
  },
  pad: function(n3) {
    return n3.length < 2 ? "0" + n3 : n3;
  },
  readUTF8: function(buff, p5, l4) {
    var s5 = "", ns;
    for (var i3 = 0; i3 < l4; i3++)
      s5 += "%" + UPNG._bin.pad(buff[p5 + i3].toString(16));
    try {
      ns = decodeURIComponent(s5);
    } catch (e) {
      return UPNG._bin.readASCII(buff, p5, l4);
    }
    return ns;
  }
};
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w6 = Math.min(sw, tw), h3 = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y4 = 0; y4 < h3; y4++)
    for (var x4 = 0; x4 < w6; x4++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y4 * sw + x4 << 2;
        ti = (yoff + y4) * tw + xoff + x4 << 2;
      } else {
        si = (-yoff + y4) * sw - xoff + x4 << 2;
        ti = y4 * tw + x4 << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb)
          continue;
        if (fa < 220 && ba > 20)
          return false;
      }
    }
  return true;
};
UPNG.encode = function(bufs, w6, h3, ps, dels, tabs, forbidPlte) {
  if (ps == null)
    ps = 0;
  if (forbidPlte == null)
    forbidPlte = false;
  var nimg = UPNG.encode.compress(bufs, w6, h3, ps, [false, false, false, 0, forbidPlte]);
  UPNG.encode.compressPNG(nimg, -1);
  return UPNG.encode._main(nimg, w6, h3, dels, tabs);
};
UPNG.encodeLL = function(bufs, w6, h3, cc, ac, depth, dels, tabs) {
  var nimg = { ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4), depth, frames: [] };
  var time = Date.now();
  var bipp = (cc + ac) * depth, bipl = bipp * w6;
  for (var i3 = 0; i3 < bufs.length; i3++)
    nimg.frames.push({ rect: { x: 0, y: 0, width: w6, height: h3 }, img: new Uint8Array(bufs[i3]), blend: 0, dispose: 1, bpp: Math.ceil(bipp / 8), bpl: Math.ceil(bipl / 8) });
  UPNG.encode.compressPNG(nimg, 0, true);
  var out2 = UPNG.encode._main(nimg, w6, h3, dels, tabs);
  return out2;
};
UPNG.encode._main = function(nimg, w6, h3, dels, tabs) {
  if (tabs == null)
    tabs = {};
  var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
  var offset = 8, anim = nimg.frames.length > 1, pltAlpha = false;
  var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);
  if (tabs["sRGB"] != null)
    leng += 8 + 1 + 4;
  if (tabs["pHYs"] != null)
    leng += 8 + 9 + 4;
  if (nimg.ctype == 3) {
    var dl = nimg.plte.length;
    for (var i3 = 0; i3 < dl; i3++)
      if (nimg.plte[i3] >>> 24 != 255)
        pltAlpha = true;
    leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);
  }
  for (var j4 = 0; j4 < nimg.frames.length; j4++) {
    var fr = nimg.frames[j4];
    if (anim)
      leng += 38;
    leng += fr.cimg.length + 12;
    if (j4 != 0)
      leng += 4;
  }
  leng += 12;
  var data = new Uint8Array(leng);
  var wr = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i3 = 0; i3 < 8; i3++)
    data[i3] = wr[i3];
  wUi(data, offset, 13);
  offset += 4;
  wAs(data, offset, "IHDR");
  offset += 4;
  wUi(data, offset, w6);
  offset += 4;
  wUi(data, offset, h3);
  offset += 4;
  data[offset] = nimg.depth;
  offset++;
  data[offset] = nimg.ctype;
  offset++;
  data[offset] = 0;
  offset++;
  data[offset] = 0;
  offset++;
  data[offset] = 0;
  offset++;
  wUi(data, offset, crc(data, offset - 17, 17));
  offset += 4;
  if (tabs["sRGB"] != null) {
    wUi(data, offset, 1);
    offset += 4;
    wAs(data, offset, "sRGB");
    offset += 4;
    data[offset] = tabs["sRGB"];
    offset++;
    wUi(data, offset, crc(data, offset - 5, 5));
    offset += 4;
  }
  if (tabs["pHYs"] != null) {
    wUi(data, offset, 9);
    offset += 4;
    wAs(data, offset, "pHYs");
    offset += 4;
    wUi(data, offset, tabs["pHYs"][0]);
    offset += 4;
    wUi(data, offset, tabs["pHYs"][1]);
    offset += 4;
    data[offset] = tabs["pHYs"][2];
    offset++;
    wUi(data, offset, crc(data, offset - 13, 13));
    offset += 4;
  }
  if (anim) {
    wUi(data, offset, 8);
    offset += 4;
    wAs(data, offset, "acTL");
    offset += 4;
    wUi(data, offset, nimg.frames.length);
    offset += 4;
    wUi(data, offset, tabs["loop"] != null ? tabs["loop"] : 0);
    offset += 4;
    wUi(data, offset, crc(data, offset - 12, 12));
    offset += 4;
  }
  if (nimg.ctype == 3) {
    var dl = nimg.plte.length;
    wUi(data, offset, dl * 3);
    offset += 4;
    wAs(data, offset, "PLTE");
    offset += 4;
    for (var i3 = 0; i3 < dl; i3++) {
      var ti = i3 * 3, c2 = nimg.plte[i3], r = c2 & 255, g5 = c2 >>> 8 & 255, b4 = c2 >>> 16 & 255;
      data[offset + ti + 0] = r;
      data[offset + ti + 1] = g5;
      data[offset + ti + 2] = b4;
    }
    offset += dl * 3;
    wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));
    offset += 4;
    if (pltAlpha) {
      wUi(data, offset, dl);
      offset += 4;
      wAs(data, offset, "tRNS");
      offset += 4;
      for (var i3 = 0; i3 < dl; i3++)
        data[offset + i3] = nimg.plte[i3] >>> 24 & 255;
      offset += dl;
      wUi(data, offset, crc(data, offset - dl - 4, dl + 4));
      offset += 4;
    }
  }
  var fi = 0;
  for (var j4 = 0; j4 < nimg.frames.length; j4++) {
    var fr = nimg.frames[j4];
    if (anim) {
      wUi(data, offset, 26);
      offset += 4;
      wAs(data, offset, "fcTL");
      offset += 4;
      wUi(data, offset, fi++);
      offset += 4;
      wUi(data, offset, fr.rect.width);
      offset += 4;
      wUi(data, offset, fr.rect.height);
      offset += 4;
      wUi(data, offset, fr.rect.x);
      offset += 4;
      wUi(data, offset, fr.rect.y);
      offset += 4;
      wUs(data, offset, dels[j4]);
      offset += 2;
      wUs(data, offset, 1e3);
      offset += 2;
      data[offset] = fr.dispose;
      offset++;
      data[offset] = fr.blend;
      offset++;
      wUi(data, offset, crc(data, offset - 30, 30));
      offset += 4;
    }
    var imgd = fr.cimg, dl = imgd.length;
    wUi(data, offset, dl + (j4 == 0 ? 0 : 4));
    offset += 4;
    var ioff = offset;
    wAs(data, offset, j4 == 0 ? "IDAT" : "fdAT");
    offset += 4;
    if (j4 != 0) {
      wUi(data, offset, fi++);
      offset += 4;
    }
    data.set(imgd, offset);
    offset += dl;
    wUi(data, offset, crc(data, ioff, offset - ioff));
    offset += 4;
  }
  wUi(data, offset, 0);
  offset += 4;
  wAs(data, offset, "IEND");
  offset += 4;
  wUi(data, offset, crc(data, offset - 4, 4));
  offset += 4;
  return data.buffer;
};
UPNG.encode.compressPNG = function(out2, filter, levelZero) {
  for (var i3 = 0; i3 < out2.frames.length; i3++) {
    var frm = out2.frames[i3], nw = frm.rect.width, nh = frm.rect.height;
    var fdata = new Uint8Array(nh * frm.bpl + nh);
    frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);
  }
};
UPNG.encode.compress = function(bufs, w6, h3, ps, prms) {
  var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
  var ctype = 6, depth = 8, alphaAnd = 255;
  for (var j4 = 0; j4 < bufs.length; j4++) {
    var img = new Uint8Array(bufs[j4]), ilen = img.length;
    for (var i3 = 0; i3 < ilen; i3 += 4)
      alphaAnd &= img[i3 + 3];
  }
  var gotAlpha = alphaAnd != 255;
  var frms = UPNG.encode.framize(bufs, w6, h3, onlyBlend, evenCrd, forbidPrev);
  var cmap = {}, plte = [], inds = [];
  if (ps != 0) {
    var nbufs = [];
    for (var i3 = 0; i3 < frms.length; i3++)
      nbufs.push(frms[i3].img.buffer);
    var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);
    var cof = 0, bb = new Uint8Array(qres.abuf);
    for (var i3 = 0; i3 < frms.length; i3++) {
      var ti = frms[i3].img, bln = ti.length;
      inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));
      for (var j4 = 0; j4 < bln; j4 += 4) {
        ti[j4] = bb[cof + j4];
        ti[j4 + 1] = bb[cof + j4 + 1];
        ti[j4 + 2] = bb[cof + j4 + 2];
        ti[j4 + 3] = bb[cof + j4 + 3];
      }
      cof += bln;
    }
    for (var i3 = 0; i3 < qres.plte.length; i3++)
      plte.push(qres.plte[i3].est.rgba);
  } else {
    for (var j4 = 0; j4 < frms.length; j4++) {
      var frm = frms[j4], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;
      var ind = new Uint8Array(ilen);
      inds.push(ind);
      for (var i3 = 0; i3 < ilen; i3++) {
        var c2 = img32[i3];
        if (i3 != 0 && c2 == img32[i3 - 1])
          ind[i3] = ind[i3 - 1];
        else if (i3 > nw && c2 == img32[i3 - nw])
          ind[i3] = ind[i3 - nw];
        else {
          var cmc = cmap[c2];
          if (cmc == null) {
            cmap[c2] = cmc = plte.length;
            plte.push(c2);
            if (plte.length >= 300)
              break;
          }
          ind[i3] = cmc;
        }
      }
    }
  }
  var cc = plte.length;
  if (cc <= 256 && forbidPlte == false) {
    if (cc <= 2)
      depth = 1;
    else if (cc <= 4)
      depth = 2;
    else if (cc <= 16)
      depth = 4;
    else
      depth = 8;
    depth = Math.max(depth, minBits);
  }
  for (var j4 = 0; j4 < frms.length; j4++) {
    var frm = frms[j4], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;
    var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);
    var bpl = 4 * nw, bpp = 4;
    if (cc <= 256 && forbidPlte == false) {
      bpl = Math.ceil(depth * nw / 8);
      var nimg = new Uint8Array(bpl * nh);
      var inj = inds[j4];
      for (var y4 = 0; y4 < nh; y4++) {
        var i3 = y4 * bpl, ii = y4 * nw;
        if (depth == 8)
          for (var x4 = 0; x4 < nw; x4++)
            nimg[i3 + x4] = inj[ii + x4];
        else if (depth == 4)
          for (var x4 = 0; x4 < nw; x4++)
            nimg[i3 + (x4 >> 1)] |= inj[ii + x4] << 4 - (x4 & 1) * 4;
        else if (depth == 2)
          for (var x4 = 0; x4 < nw; x4++)
            nimg[i3 + (x4 >> 2)] |= inj[ii + x4] << 6 - (x4 & 3) * 2;
        else if (depth == 1)
          for (var x4 = 0; x4 < nw; x4++)
            nimg[i3 + (x4 >> 3)] |= inj[ii + x4] << 7 - (x4 & 7) * 1;
      }
      cimg = nimg;
      ctype = 3;
      bpp = 1;
    } else if (gotAlpha == false && frms.length == 1) {
      var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
      for (var i3 = 0; i3 < area; i3++) {
        var ti = i3 * 3, qi = i3 * 4;
        nimg[ti] = cimg[qi];
        nimg[ti + 1] = cimg[qi + 1];
        nimg[ti + 2] = cimg[qi + 2];
      }
      cimg = nimg;
      ctype = 2;
      bpp = 3;
      bpl = 3 * nw;
    }
    frm.img = cimg;
    frm.bpl = bpl;
    frm.bpp = bpp;
  }
  return { ctype, depth, plte, frames: frms };
};
UPNG.encode.framize = function(bufs, w6, h3, alwaysBlend, evenCrd, forbidPrev) {
  var frms = [];
  for (var j4 = 0; j4 < bufs.length; j4++) {
    var cimg = new Uint8Array(bufs[j4]), cimg32 = new Uint32Array(cimg.buffer);
    var nimg;
    var nx = 0, ny = 0, nw = w6, nh = h3, blend = alwaysBlend ? 1 : 0;
    if (j4 != 0) {
      var tlim = forbidPrev || alwaysBlend || j4 == 1 || frms[j4 - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;
      for (var it3 = 0; it3 < tlim; it3++) {
        var pimg = new Uint8Array(bufs[j4 - 1 - it3]), p32 = new Uint32Array(bufs[j4 - 1 - it3]);
        var mix = w6, miy = h3, max = -1, may = -1;
        for (var y4 = 0; y4 < h3; y4++)
          for (var x4 = 0; x4 < w6; x4++) {
            var i3 = y4 * w6 + x4;
            if (cimg32[i3] != p32[i3]) {
              if (x4 < mix)
                mix = x4;
              if (x4 > max)
                max = x4;
              if (y4 < miy)
                miy = y4;
              if (y4 > may)
                may = y4;
            }
          }
        if (max == -1)
          mix = miy = max = may = 0;
        if (evenCrd) {
          if ((mix & 1) == 1)
            mix--;
          if ((miy & 1) == 1)
            miy--;
        }
        var sarea = (max - mix + 1) * (may - miy + 1);
        if (sarea < tarea) {
          tarea = sarea;
          tstp = it3;
          nx = mix;
          ny = miy;
          nw = max - mix + 1;
          nh = may - miy + 1;
        }
      }
      var pimg = new Uint8Array(bufs[j4 - 1 - tstp]);
      if (tstp == 1)
        frms[j4 - 1].dispose = 2;
      nimg = new Uint8Array(nw * nh * 4);
      UPNG._copyTile(pimg, w6, h3, nimg, nw, nh, -nx, -ny, 0);
      blend = UPNG._copyTile(cimg, w6, h3, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;
      if (blend == 1)
        UPNG.encode._prepareDiff(cimg, w6, h3, nimg, { x: nx, y: ny, width: nw, height: nh });
      else
        UPNG._copyTile(cimg, w6, h3, nimg, nw, nh, -nx, -ny, 0);
    } else
      nimg = cimg.slice(0);
    frms.push({ rect: { x: nx, y: ny, width: nw, height: nh }, img: nimg, blend, dispose: 0 });
  }
  if (alwaysBlend)
    for (var j4 = 0; j4 < frms.length; j4++) {
      var frm = frms[j4];
      if (frm.blend == 1)
        continue;
      var r0 = frm.rect, r1 = frms[j4 - 1].rect;
      var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
      var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);
      var r = { x: miX, y: miY, width: maX - miX, height: maY - miY };
      frms[j4 - 1].dispose = 1;
      if (j4 - 1 != 0)
        UPNG.encode._updateFrame(bufs, w6, h3, frms, j4 - 1, r, evenCrd);
      UPNG.encode._updateFrame(bufs, w6, h3, frms, j4, r, evenCrd);
    }
  var area = 0;
  if (bufs.length != 1)
    for (var i3 = 0; i3 < frms.length; i3++) {
      var frm = frms[i3];
      area += frm.rect.width * frm.rect.height;
    }
  return frms;
};
UPNG.encode._updateFrame = function(bufs, w6, h3, frms, i3, r, evenCrd) {
  var U8 = Uint8Array, U32 = Uint32Array;
  var pimg = new U8(bufs[i3 - 1]), pimg32 = new U32(bufs[i3 - 1]), nimg = i3 + 1 < bufs.length ? new U8(bufs[i3 + 1]) : null;
  var cimg = new U8(bufs[i3]), cimg32 = new U32(cimg.buffer);
  var mix = w6, miy = h3, max = -1, may = -1;
  for (var y4 = 0; y4 < r.height; y4++)
    for (var x4 = 0; x4 < r.width; x4++) {
      var cx2 = r.x + x4, cy2 = r.y + y4;
      var j4 = cy2 * w6 + cx2, cc = cimg32[j4];
      if (cc == 0 || frms[i3 - 1].dispose == 0 && pimg32[j4] == cc && (nimg == null || nimg[j4 * 4 + 3] != 0)) {
      } else {
        if (cx2 < mix)
          mix = cx2;
        if (cx2 > max)
          max = cx2;
        if (cy2 < miy)
          miy = cy2;
        if (cy2 > may)
          may = cy2;
      }
    }
  if (max == -1)
    mix = miy = max = may = 0;
  if (evenCrd) {
    if ((mix & 1) == 1)
      mix--;
    if ((miy & 1) == 1)
      miy--;
  }
  r = { x: mix, y: miy, width: max - mix + 1, height: may - miy + 1 };
  var fr = frms[i3];
  fr.rect = r;
  fr.blend = 1;
  fr.img = new Uint8Array(r.width * r.height * 4);
  if (frms[i3 - 1].dispose == 0) {
    UPNG._copyTile(pimg, w6, h3, fr.img, r.width, r.height, -r.x, -r.y, 0);
    UPNG.encode._prepareDiff(cimg, w6, h3, fr.img, r);
  } else
    UPNG._copyTile(cimg, w6, h3, fr.img, r.width, r.height, -r.x, -r.y, 0);
};
UPNG.encode._prepareDiff = function(cimg, w6, h3, nimg, rec) {
  UPNG._copyTile(cimg, w6, h3, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);
};
UPNG.encode._filterZero = function(img, h3, bpp, bpl, data, filter, levelZero) {
  var fls = [], ftry = [0, 1, 2, 3, 4];
  if (filter != -1)
    ftry = [filter];
  else if (h3 * bpl > 5e5 || bpp == 1)
    ftry = [0];
  var opts;
  if (levelZero)
    opts = { level: 0 };
  var CMPR = levelZero && UZIP != null ? UZIP : import_pako4.default;
  for (var i3 = 0; i3 < ftry.length; i3++) {
    for (var y4 = 0; y4 < h3; y4++)
      UPNG.encode._filterLine(data, img, y4, bpl, bpp, ftry[i3]);
    fls.push(CMPR["deflate"](data, opts));
  }
  var ti, tsize = 1e9;
  for (var i3 = 0; i3 < fls.length; i3++)
    if (fls[i3].length < tsize) {
      ti = i3;
      tsize = fls[i3].length;
    }
  return fls[ti];
};
UPNG.encode._filterLine = function(data, img, y4, bpl, bpp, type) {
  var i3 = y4 * bpl, di = i3 + y4, paeth = UPNG.decode._paeth;
  data[di] = type;
  di++;
  if (type == 0) {
    if (bpl < 500)
      for (var x4 = 0; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4];
    else
      data.set(new Uint8Array(img.buffer, i3, bpl), di);
  } else if (type == 1) {
    for (var x4 = 0; x4 < bpp; x4++)
      data[di + x4] = img[i3 + x4];
    for (var x4 = bpp; x4 < bpl; x4++)
      data[di + x4] = img[i3 + x4] - img[i3 + x4 - bpp] + 256 & 255;
  } else if (y4 == 0) {
    for (var x4 = 0; x4 < bpp; x4++)
      data[di + x4] = img[i3 + x4];
    if (type == 2)
      for (var x4 = bpp; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4];
    if (type == 3)
      for (var x4 = bpp; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4] - (img[i3 + x4 - bpp] >> 1) + 256 & 255;
    if (type == 4)
      for (var x4 = bpp; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4] - paeth(img[i3 + x4 - bpp], 0, 0) + 256 & 255;
  } else {
    if (type == 2) {
      for (var x4 = 0; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4] + 256 - img[i3 + x4 - bpl] & 255;
    }
    if (type == 3) {
      for (var x4 = 0; x4 < bpp; x4++)
        data[di + x4] = img[i3 + x4] + 256 - (img[i3 + x4 - bpl] >> 1) & 255;
      for (var x4 = bpp; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4] + 256 - (img[i3 + x4 - bpl] + img[i3 + x4 - bpp] >> 1) & 255;
    }
    if (type == 4) {
      for (var x4 = 0; x4 < bpp; x4++)
        data[di + x4] = img[i3 + x4] + 256 - paeth(0, img[i3 + x4 - bpl], 0) & 255;
      for (var x4 = bpp; x4 < bpl; x4++)
        data[di + x4] = img[i3 + x4] + 256 - paeth(img[i3 + x4 - bpp], img[i3 + x4 - bpl], img[i3 + x4 - bpp - bpl]) & 255;
    }
  }
};
UPNG.crc = {
  table: function() {
    var tab = new Uint32Array(256);
    for (var n3 = 0; n3 < 256; n3++) {
      var c2 = n3;
      for (var k5 = 0; k5 < 8; k5++) {
        if (c2 & 1)
          c2 = 3988292384 ^ c2 >>> 1;
        else
          c2 = c2 >>> 1;
      }
      tab[n3] = c2;
    }
    return tab;
  }(),
  update: function(c2, buf, off, len) {
    for (var i3 = 0; i3 < len; i3++)
      c2 = UPNG.crc.table[(c2 ^ buf[off + i3]) & 255] ^ c2 >>> 8;
    return c2;
  },
  crc: function(b4, o5, l4) {
    return UPNG.crc.update(4294967295, b4, o5, l4) ^ 4294967295;
  }
};
UPNG.quantize = function(abuf, ps) {
  var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
  var KD = UPNG.quantize.getKDtree(nimg, ps);
  var root = KD[0], leafs = KD[1];
  var planeDst = UPNG.quantize.planeDst;
  var sb = oimg, tb = nimg32, len = sb.length;
  var inds = new Uint8Array(oimg.length >> 2);
  for (var i3 = 0; i3 < len; i3 += 4) {
    var r = sb[i3] * (1 / 255), g5 = sb[i3 + 1] * (1 / 255), b4 = sb[i3 + 2] * (1 / 255), a2 = sb[i3 + 3] * (1 / 255);
    var nd = UPNG.quantize.getNearest(root, r, g5, b4, a2);
    inds[i3 >> 2] = nd.ind;
    tb[i3 >> 2] = nd.est.rgba;
  }
  return { abuf: nimg.buffer, inds, plte: leafs };
};
UPNG.quantize.getKDtree = function(nimg, ps, err2) {
  if (err2 == null)
    err2 = 1e-4;
  var nimg32 = new Uint32Array(nimg.buffer);
  var root = { i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null };
  root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);
  root.est = UPNG.quantize.estats(root.bst);
  var leafs = [root];
  while (leafs.length < ps) {
    var maxL = 0, mi = 0;
    for (var i3 = 0; i3 < leafs.length; i3++)
      if (leafs[i3].est.L > maxL) {
        maxL = leafs[i3].est.L;
        mi = i3;
      }
    if (maxL < err2)
      break;
    var node = leafs[mi];
    var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
    var s0wrong = node.i0 >= s0 || node.i1 <= s0;
    if (s0wrong) {
      node.est.L = 0;
      continue;
    }
    var ln2 = { i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null };
    ln2.bst = UPNG.quantize.stats(nimg, ln2.i0, ln2.i1);
    ln2.est = UPNG.quantize.estats(ln2.bst);
    var rn2 = { i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null };
    rn2.bst = { R: [], m: [], N: node.bst.N - ln2.bst.N };
    for (var i3 = 0; i3 < 16; i3++)
      rn2.bst.R[i3] = node.bst.R[i3] - ln2.bst.R[i3];
    for (var i3 = 0; i3 < 4; i3++)
      rn2.bst.m[i3] = node.bst.m[i3] - ln2.bst.m[i3];
    rn2.est = UPNG.quantize.estats(rn2.bst);
    node.left = ln2;
    node.right = rn2;
    leafs[mi] = ln2;
    leafs.push(rn2);
  }
  leafs.sort(function(a2, b4) {
    return b4.bst.N - a2.bst.N;
  });
  for (var i3 = 0; i3 < leafs.length; i3++)
    leafs[i3].ind = i3;
  return [root, leafs];
};
UPNG.quantize.getNearest = function(nd, r, g5, b4, a2) {
  if (nd.left == null) {
    nd.tdst = UPNG.quantize.dist(nd.est.q, r, g5, b4, a2);
    return nd;
  }
  var planeDst = UPNG.quantize.planeDst(nd.est, r, g5, b4, a2);
  var node0 = nd.left, node1 = nd.right;
  if (planeDst > 0) {
    node0 = nd.right;
    node1 = nd.left;
  }
  var ln2 = UPNG.quantize.getNearest(node0, r, g5, b4, a2);
  if (ln2.tdst <= planeDst * planeDst)
    return ln2;
  var rn2 = UPNG.quantize.getNearest(node1, r, g5, b4, a2);
  return rn2.tdst < ln2.tdst ? rn2 : ln2;
};
UPNG.quantize.planeDst = function(est, r, g5, b4, a2) {
  var e = est.e;
  return e[0] * r + e[1] * g5 + e[2] * b4 + e[3] * a2 - est.eMq;
};
UPNG.quantize.dist = function(q4, r, g5, b4, a2) {
  var d0 = r - q4[0], d1 = g5 - q4[1], d22 = b4 - q4[2], d3 = a2 - q4[3];
  return d0 * d0 + d1 * d1 + d22 * d22 + d3 * d3;
};
UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
  var vecDot = UPNG.quantize.vecDot;
  i1 -= 4;
  var shfs = 0;
  while (i0 < i1) {
    while (vecDot(nimg, i0, e) <= eMq)
      i0 += 4;
    while (vecDot(nimg, i1, e) > eMq)
      i1 -= 4;
    if (i0 >= i1)
      break;
    var t2 = nimg32[i0 >> 2];
    nimg32[i0 >> 2] = nimg32[i1 >> 2];
    nimg32[i1 >> 2] = t2;
    i0 += 4;
    i1 -= 4;
  }
  while (vecDot(nimg, i0, e) > eMq)
    i0 -= 4;
  return i0 + 4;
};
UPNG.quantize.vecDot = function(nimg, i3, e) {
  return nimg[i3] * e[0] + nimg[i3 + 1] * e[1] + nimg[i3 + 2] * e[2] + nimg[i3 + 3] * e[3];
};
UPNG.quantize.stats = function(nimg, i0, i1) {
  var R6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var m5 = [0, 0, 0, 0];
  var N4 = i1 - i0 >> 2;
  for (var i3 = i0; i3 < i1; i3 += 4) {
    var r = nimg[i3] * (1 / 255), g5 = nimg[i3 + 1] * (1 / 255), b4 = nimg[i3 + 2] * (1 / 255), a2 = nimg[i3 + 3] * (1 / 255);
    m5[0] += r;
    m5[1] += g5;
    m5[2] += b4;
    m5[3] += a2;
    R6[0] += r * r;
    R6[1] += r * g5;
    R6[2] += r * b4;
    R6[3] += r * a2;
    R6[5] += g5 * g5;
    R6[6] += g5 * b4;
    R6[7] += g5 * a2;
    R6[10] += b4 * b4;
    R6[11] += b4 * a2;
    R6[15] += a2 * a2;
  }
  R6[4] = R6[1];
  R6[8] = R6[2];
  R6[9] = R6[6];
  R6[12] = R6[3];
  R6[13] = R6[7];
  R6[14] = R6[11];
  return { R: R6, m: m5, N: N4 };
};
UPNG.quantize.estats = function(stats) {
  var R6 = stats.R, m5 = stats.m, N4 = stats.N;
  var m0 = m5[0], m1 = m5[1], m22 = m5[2], m32 = m5[3], iN = N4 == 0 ? 0 : 1 / N4;
  var Rj = [
    R6[0] - m0 * m0 * iN,
    R6[1] - m0 * m1 * iN,
    R6[2] - m0 * m22 * iN,
    R6[3] - m0 * m32 * iN,
    R6[4] - m1 * m0 * iN,
    R6[5] - m1 * m1 * iN,
    R6[6] - m1 * m22 * iN,
    R6[7] - m1 * m32 * iN,
    R6[8] - m22 * m0 * iN,
    R6[9] - m22 * m1 * iN,
    R6[10] - m22 * m22 * iN,
    R6[11] - m22 * m32 * iN,
    R6[12] - m32 * m0 * iN,
    R6[13] - m32 * m1 * iN,
    R6[14] - m32 * m22 * iN,
    R6[15] - m32 * m32 * iN
  ];
  var A4 = Rj, M4 = UPNG.M4;
  var b4 = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
  if (N4 != 0)
    for (var i3 = 0; i3 < 10; i3++) {
      b4 = M4.multVec(A4, b4);
      tmi = Math.sqrt(M4.dot(b4, b4));
      b4 = M4.sml(1 / tmi, b4);
      if (Math.abs(tmi - mi) < 1e-9)
        break;
      mi = tmi;
    }
  var q4 = [m0 * iN, m1 * iN, m22 * iN, m32 * iN];
  var eMq255 = M4.dot(M4.sml(255, q4), b4);
  return {
    Cov: Rj,
    q: q4,
    e: b4,
    L: mi,
    eMq255,
    eMq: M4.dot(b4, q4),
    rgba: (Math.round(255 * q4[3]) << 24 | Math.round(255 * q4[2]) << 16 | Math.round(255 * q4[1]) << 8 | Math.round(255 * q4[0]) << 0) >>> 0
  };
};
UPNG.M4 = {
  multVec: function(m5, v4) {
    return [
      m5[0] * v4[0] + m5[1] * v4[1] + m5[2] * v4[2] + m5[3] * v4[3],
      m5[4] * v4[0] + m5[5] * v4[1] + m5[6] * v4[2] + m5[7] * v4[3],
      m5[8] * v4[0] + m5[9] * v4[1] + m5[10] * v4[2] + m5[11] * v4[3],
      m5[12] * v4[0] + m5[13] * v4[1] + m5[14] * v4[2] + m5[15] * v4[3]
    ];
  },
  dot: function(x4, y4) {
    return x4[0] * y4[0] + x4[1] * y4[1] + x4[2] * y4[2] + x4[3] * y4[3];
  },
  sml: function(a2, y4) {
    return [a2 * y4[0], a2 * y4[1], a2 * y4[2], a2 * y4[3]];
  }
};
UPNG.encode.concatRGBA = function(bufs) {
  var tlen = 0;
  for (var i3 = 0; i3 < bufs.length; i3++)
    tlen += bufs[i3].byteLength;
  var nimg = new Uint8Array(tlen), noff = 0;
  for (var i3 = 0; i3 < bufs.length; i3++) {
    var img = new Uint8Array(bufs[i3]), il = img.length;
    for (var j4 = 0; j4 < il; j4 += 4) {
      var r = img[j4], g5 = img[j4 + 1], b4 = img[j4 + 2], a2 = img[j4 + 3];
      if (a2 == 0)
        r = g5 = b4 = 0;
      nimg[noff + j4] = r;
      nimg[noff + j4 + 1] = g5;
      nimg[noff + j4 + 2] = b4;
      nimg[noff + j4 + 3] = a2;
    }
    noff += il;
  }
  return nimg.buffer;
};
var UPNG_default = UPNG;

// node_modules/pdf-lib/es/utils/png.js
var getImageType = function(ctype) {
  if (ctype === 0)
    return PngType.Greyscale;
  if (ctype === 2)
    return PngType.Truecolour;
  if (ctype === 3)
    return PngType.IndexedColour;
  if (ctype === 4)
    return PngType.GreyscaleWithAlpha;
  if (ctype === 6)
    return PngType.TruecolourWithAlpha;
  throw new Error("Unknown color type: " + ctype);
};
var splitAlphaChannel = function(rgbaChannel) {
  var pixelCount = Math.floor(rgbaChannel.length / 4);
  var rgbChannel = new Uint8Array(pixelCount * 3);
  var alphaChannel = new Uint8Array(pixelCount * 1);
  var rgbaOffset = 0;
  var rgbOffset = 0;
  var alphaOffset = 0;
  while (rgbaOffset < rgbaChannel.length) {
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
  }
  return { rgbChannel, alphaChannel };
};
var PngType;
(function(PngType2) {
  PngType2["Greyscale"] = "Greyscale";
  PngType2["Truecolour"] = "Truecolour";
  PngType2["IndexedColour"] = "IndexedColour";
  PngType2["GreyscaleWithAlpha"] = "GreyscaleWithAlpha";
  PngType2["TruecolourWithAlpha"] = "TruecolourWithAlpha";
})(PngType || (PngType = {}));
var PNG = (
  /** @class */
  function() {
    function PNG2(pngData) {
      var upng = UPNG_default.decode(pngData);
      var frames = UPNG_default.toRGBA8(upng);
      if (frames.length > 1)
        throw new Error("Animated PNGs are not supported");
      var frame = new Uint8Array(frames[0]);
      var _a = splitAlphaChannel(frame), rgbChannel = _a.rgbChannel, alphaChannel = _a.alphaChannel;
      this.rgbChannel = rgbChannel;
      var hasAlphaValues = alphaChannel.some(function(a2) {
        return a2 < 255;
      });
      if (hasAlphaValues)
        this.alphaChannel = alphaChannel;
      this.type = getImageType(upng.ctype);
      this.width = upng.width;
      this.height = upng.height;
      this.bitsPerComponent = 8;
    }
    PNG2.load = function(pngData) {
      return new PNG2(pngData);
    };
    return PNG2;
  }()
);

// node_modules/pdf-lib/es/core/embedders/PngEmbedder.js
var PngEmbedder = (
  /** @class */
  function() {
    function PngEmbedder2(png) {
      this.image = png;
      this.bitsPerComponent = png.bitsPerComponent;
      this.width = png.width;
      this.height = png.height;
      this.colorSpace = "DeviceRGB";
    }
    PngEmbedder2.for = function(imageData) {
      return __awaiter(this, void 0, void 0, function() {
        var png;
        return __generator(this, function(_a) {
          png = PNG.load(imageData);
          return [2, new PngEmbedder2(png)];
        });
      });
    };
    PngEmbedder2.prototype.embedIntoContext = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var SMask, xObject;
        return __generator(this, function(_a) {
          SMask = this.embedAlphaChannel(context);
          xObject = context.flateStream(this.image.rgbChannel, {
            Type: "XObject",
            Subtype: "Image",
            BitsPerComponent: this.image.bitsPerComponent,
            Width: this.image.width,
            Height: this.image.height,
            ColorSpace: this.colorSpace,
            SMask
          });
          if (ref) {
            context.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context.register(xObject)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    PngEmbedder2.prototype.embedAlphaChannel = function(context) {
      if (!this.image.alphaChannel)
        return void 0;
      var xObject = context.flateStream(this.image.alphaChannel, {
        Type: "XObject",
        Subtype: "Image",
        Height: this.image.height,
        Width: this.image.width,
        BitsPerComponent: this.image.bitsPerComponent,
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      return context.register(xObject);
    };
    return PngEmbedder2;
  }()
);
var PngEmbedder_default = PngEmbedder;

// node_modules/pdf-lib/es/core/streams/Stream.js
var Stream = (
  /** @class */
  function() {
    function Stream2(buffer, start2, length) {
      this.bytes = buffer;
      this.start = start2 || 0;
      this.pos = this.start;
      this.end = !!start2 && !!length ? start2 + length : this.bytes.length;
    }
    Object.defineProperty(Stream2.prototype, "length", {
      get: function() {
        return this.end - this.start;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Stream2.prototype, "isEmpty", {
      get: function() {
        return this.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Stream2.prototype.getByte = function() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.bytes[this.pos++];
    };
    Stream2.prototype.getUint16 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    };
    Stream2.prototype.getInt32 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b22 = this.getByte();
      var b32 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b22 << 8) + b32;
    };
    Stream2.prototype.getBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        var subarray = bytes.subarray(pos, strEnd);
        return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
      } else {
        var end = pos + length;
        if (end > strEnd) {
          end = strEnd;
        }
        this.pos = end;
        var subarray = bytes.subarray(pos, end);
        return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
      }
    };
    Stream2.prototype.peekByte = function() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    };
    Stream2.prototype.peekBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes = this.getBytes(length, forceClamped);
      this.pos -= bytes.length;
      return bytes;
    };
    Stream2.prototype.skip = function(n3) {
      if (!n3) {
        n3 = 1;
      }
      this.pos += n3;
    };
    Stream2.prototype.reset = function() {
      this.pos = this.start;
    };
    Stream2.prototype.moveStart = function() {
      this.start = this.pos;
    };
    Stream2.prototype.makeSubStream = function(start2, length) {
      return new Stream2(this.bytes, start2, length);
    };
    Stream2.prototype.decode = function() {
      return this.bytes;
    };
    return Stream2;
  }()
);
var Stream_default = Stream;

// node_modules/pdf-lib/es/core/streams/DecodeStream.js
var emptyBuffer = new Uint8Array(0);
var DecodeStream = (
  /** @class */
  function() {
    function DecodeStream2(maybeMinBufferLength) {
      this.pos = 0;
      this.bufferLength = 0;
      this.eof = false;
      this.buffer = emptyBuffer;
      this.minBufferLength = 512;
      if (maybeMinBufferLength) {
        while (this.minBufferLength < maybeMinBufferLength) {
          this.minBufferLength *= 2;
        }
      }
    }
    Object.defineProperty(DecodeStream2.prototype, "isEmpty", {
      get: function() {
        while (!this.eof && this.bufferLength === 0) {
          this.readBlock();
        }
        return this.bufferLength === 0;
      },
      enumerable: false,
      configurable: true
    });
    DecodeStream2.prototype.getByte = function() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof) {
          return -1;
        }
        this.readBlock();
      }
      return this.buffer[this.pos++];
    };
    DecodeStream2.prototype.getUint16 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    };
    DecodeStream2.prototype.getInt32 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b22 = this.getByte();
      var b32 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b22 << 8) + b32;
    };
    DecodeStream2.prototype.getBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var end;
      var pos = this.pos;
      if (length) {
        this.ensureBuffer(pos + length);
        end = pos + length;
        while (!this.eof && this.bufferLength < end) {
          this.readBlock();
        }
        var bufEnd = this.bufferLength;
        if (end > bufEnd) {
          end = bufEnd;
        }
      } else {
        while (!this.eof) {
          this.readBlock();
        }
        end = this.bufferLength;
      }
      this.pos = end;
      var subarray = this.buffer.subarray(pos, end);
      return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
    };
    DecodeStream2.prototype.peekByte = function() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    };
    DecodeStream2.prototype.peekBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes = this.getBytes(length, forceClamped);
      this.pos -= bytes.length;
      return bytes;
    };
    DecodeStream2.prototype.skip = function(n3) {
      if (!n3) {
        n3 = 1;
      }
      this.pos += n3;
    };
    DecodeStream2.prototype.reset = function() {
      this.pos = 0;
    };
    DecodeStream2.prototype.makeSubStream = function(start2, length) {
      var end = start2 + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
      return new Stream_default(
        this.buffer,
        start2,
        length
        /* dict */
      );
    };
    DecodeStream2.prototype.decode = function() {
      while (!this.eof)
        this.readBlock();
      return this.buffer.subarray(0, this.bufferLength);
    };
    DecodeStream2.prototype.readBlock = function() {
      throw new MethodNotImplementedError(this.constructor.name, "readBlock");
    };
    DecodeStream2.prototype.ensureBuffer = function(requested) {
      var buffer = this.buffer;
      if (requested <= buffer.byteLength) {
        return buffer;
      }
      var size = this.minBufferLength;
      while (size < requested) {
        size *= 2;
      }
      var buffer2 = new Uint8Array(size);
      buffer2.set(buffer);
      return this.buffer = buffer2;
    };
    return DecodeStream2;
  }()
);
var DecodeStream_default = DecodeStream;

// node_modules/pdf-lib/es/core/streams/Ascii85Stream.js
var isSpace = function(ch) {
  return ch === 32 || ch === 9 || ch === 13 || ch === 10;
};
var Ascii85Stream = (
  /** @class */
  function(_super) {
    __extends(Ascii85Stream2, _super);
    function Ascii85Stream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.input = new Uint8Array(5);
      if (maybeLength) {
        maybeLength = 0.8 * maybeLength;
      }
      return _this;
    }
    Ascii85Stream2.prototype.readBlock = function() {
      var TILDA_CHAR = 126;
      var Z_LOWER_CHAR = 122;
      var EOF = -1;
      var stream2 = this.stream;
      var c2 = stream2.getByte();
      while (isSpace(c2)) {
        c2 = stream2.getByte();
      }
      if (c2 === EOF || c2 === TILDA_CHAR) {
        this.eof = true;
        return;
      }
      var bufferLength = this.bufferLength;
      var buffer;
      var i3;
      if (c2 === Z_LOWER_CHAR) {
        buffer = this.ensureBuffer(bufferLength + 4);
        for (i3 = 0; i3 < 4; ++i3) {
          buffer[bufferLength + i3] = 0;
        }
        this.bufferLength += 4;
      } else {
        var input = this.input;
        input[0] = c2;
        for (i3 = 1; i3 < 5; ++i3) {
          c2 = stream2.getByte();
          while (isSpace(c2)) {
            c2 = stream2.getByte();
          }
          input[i3] = c2;
          if (c2 === EOF || c2 === TILDA_CHAR) {
            break;
          }
        }
        buffer = this.ensureBuffer(bufferLength + i3 - 1);
        this.bufferLength += i3 - 1;
        if (i3 < 5) {
          for (; i3 < 5; ++i3) {
            input[i3] = 33 + 84;
          }
          this.eof = true;
        }
        var t2 = 0;
        for (i3 = 0; i3 < 5; ++i3) {
          t2 = t2 * 85 + (input[i3] - 33);
        }
        for (i3 = 3; i3 >= 0; --i3) {
          buffer[bufferLength + i3] = t2 & 255;
          t2 >>= 8;
        }
      }
    };
    return Ascii85Stream2;
  }(DecodeStream_default)
);
var Ascii85Stream_default = Ascii85Stream;

// node_modules/pdf-lib/es/core/streams/AsciiHexStream.js
var AsciiHexStream = (
  /** @class */
  function(_super) {
    __extends(AsciiHexStream2, _super);
    function AsciiHexStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.firstDigit = -1;
      if (maybeLength) {
        maybeLength = 0.5 * maybeLength;
      }
      return _this;
    }
    AsciiHexStream2.prototype.readBlock = function() {
      var UPSTREAM_BLOCK_SIZE = 8e3;
      var bytes = this.stream.getBytes(UPSTREAM_BLOCK_SIZE);
      if (!bytes.length) {
        this.eof = true;
        return;
      }
      var maxDecodeLength = bytes.length + 1 >> 1;
      var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
      var bufferLength = this.bufferLength;
      var firstDigit = this.firstDigit;
      for (var i3 = 0, ii = bytes.length; i3 < ii; i3++) {
        var ch = bytes[i3];
        var digit = void 0;
        if (ch >= 48 && ch <= 57) {
          digit = ch & 15;
        } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
          digit = (ch & 15) + 9;
        } else if (ch === 62) {
          this.eof = true;
          break;
        } else {
          continue;
        }
        if (firstDigit < 0) {
          firstDigit = digit;
        } else {
          buffer[bufferLength++] = firstDigit << 4 | digit;
          firstDigit = -1;
        }
      }
      if (firstDigit >= 0 && this.eof) {
        buffer[bufferLength++] = firstDigit << 4;
        firstDigit = -1;
      }
      this.firstDigit = firstDigit;
      this.bufferLength = bufferLength;
    };
    return AsciiHexStream2;
  }(DecodeStream_default)
);
var AsciiHexStream_default = AsciiHexStream;

// node_modules/pdf-lib/es/core/streams/FlateStream.js
var codeLenCodeMap = new Int32Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var lengthDecode = new Int32Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  65547,
  65549,
  65551,
  65553,
  131091,
  131095,
  131099,
  131103,
  196643,
  196651,
  196659,
  196667,
  262211,
  262227,
  262243,
  262259,
  327811,
  327843,
  327875,
  327907,
  258,
  258,
  258
]);
var distDecode = new Int32Array([
  1,
  2,
  3,
  4,
  65541,
  65543,
  131081,
  131085,
  196625,
  196633,
  262177,
  262193,
  327745,
  327777,
  393345,
  393409,
  459009,
  459137,
  524801,
  525057,
  590849,
  591361,
  657409,
  658433,
  724993,
  727041,
  794625,
  798721,
  868353,
  876545
]);
var fixedLitCodeTab = [new Int32Array([
  459008,
  524368,
  524304,
  524568,
  459024,
  524400,
  524336,
  590016,
  459016,
  524384,
  524320,
  589984,
  524288,
  524416,
  524352,
  590048,
  459012,
  524376,
  524312,
  589968,
  459028,
  524408,
  524344,
  590032,
  459020,
  524392,
  524328,
  59e4,
  524296,
  524424,
  524360,
  590064,
  459010,
  524372,
  524308,
  524572,
  459026,
  524404,
  524340,
  590024,
  459018,
  524388,
  524324,
  589992,
  524292,
  524420,
  524356,
  590056,
  459014,
  524380,
  524316,
  589976,
  459030,
  524412,
  524348,
  590040,
  459022,
  524396,
  524332,
  590008,
  524300,
  524428,
  524364,
  590072,
  459009,
  524370,
  524306,
  524570,
  459025,
  524402,
  524338,
  590020,
  459017,
  524386,
  524322,
  589988,
  524290,
  524418,
  524354,
  590052,
  459013,
  524378,
  524314,
  589972,
  459029,
  524410,
  524346,
  590036,
  459021,
  524394,
  524330,
  590004,
  524298,
  524426,
  524362,
  590068,
  459011,
  524374,
  524310,
  524574,
  459027,
  524406,
  524342,
  590028,
  459019,
  524390,
  524326,
  589996,
  524294,
  524422,
  524358,
  590060,
  459015,
  524382,
  524318,
  589980,
  459031,
  524414,
  524350,
  590044,
  459023,
  524398,
  524334,
  590012,
  524302,
  524430,
  524366,
  590076,
  459008,
  524369,
  524305,
  524569,
  459024,
  524401,
  524337,
  590018,
  459016,
  524385,
  524321,
  589986,
  524289,
  524417,
  524353,
  590050,
  459012,
  524377,
  524313,
  589970,
  459028,
  524409,
  524345,
  590034,
  459020,
  524393,
  524329,
  590002,
  524297,
  524425,
  524361,
  590066,
  459010,
  524373,
  524309,
  524573,
  459026,
  524405,
  524341,
  590026,
  459018,
  524389,
  524325,
  589994,
  524293,
  524421,
  524357,
  590058,
  459014,
  524381,
  524317,
  589978,
  459030,
  524413,
  524349,
  590042,
  459022,
  524397,
  524333,
  590010,
  524301,
  524429,
  524365,
  590074,
  459009,
  524371,
  524307,
  524571,
  459025,
  524403,
  524339,
  590022,
  459017,
  524387,
  524323,
  589990,
  524291,
  524419,
  524355,
  590054,
  459013,
  524379,
  524315,
  589974,
  459029,
  524411,
  524347,
  590038,
  459021,
  524395,
  524331,
  590006,
  524299,
  524427,
  524363,
  590070,
  459011,
  524375,
  524311,
  524575,
  459027,
  524407,
  524343,
  590030,
  459019,
  524391,
  524327,
  589998,
  524295,
  524423,
  524359,
  590062,
  459015,
  524383,
  524319,
  589982,
  459031,
  524415,
  524351,
  590046,
  459023,
  524399,
  524335,
  590014,
  524303,
  524431,
  524367,
  590078,
  459008,
  524368,
  524304,
  524568,
  459024,
  524400,
  524336,
  590017,
  459016,
  524384,
  524320,
  589985,
  524288,
  524416,
  524352,
  590049,
  459012,
  524376,
  524312,
  589969,
  459028,
  524408,
  524344,
  590033,
  459020,
  524392,
  524328,
  590001,
  524296,
  524424,
  524360,
  590065,
  459010,
  524372,
  524308,
  524572,
  459026,
  524404,
  524340,
  590025,
  459018,
  524388,
  524324,
  589993,
  524292,
  524420,
  524356,
  590057,
  459014,
  524380,
  524316,
  589977,
  459030,
  524412,
  524348,
  590041,
  459022,
  524396,
  524332,
  590009,
  524300,
  524428,
  524364,
  590073,
  459009,
  524370,
  524306,
  524570,
  459025,
  524402,
  524338,
  590021,
  459017,
  524386,
  524322,
  589989,
  524290,
  524418,
  524354,
  590053,
  459013,
  524378,
  524314,
  589973,
  459029,
  524410,
  524346,
  590037,
  459021,
  524394,
  524330,
  590005,
  524298,
  524426,
  524362,
  590069,
  459011,
  524374,
  524310,
  524574,
  459027,
  524406,
  524342,
  590029,
  459019,
  524390,
  524326,
  589997,
  524294,
  524422,
  524358,
  590061,
  459015,
  524382,
  524318,
  589981,
  459031,
  524414,
  524350,
  590045,
  459023,
  524398,
  524334,
  590013,
  524302,
  524430,
  524366,
  590077,
  459008,
  524369,
  524305,
  524569,
  459024,
  524401,
  524337,
  590019,
  459016,
  524385,
  524321,
  589987,
  524289,
  524417,
  524353,
  590051,
  459012,
  524377,
  524313,
  589971,
  459028,
  524409,
  524345,
  590035,
  459020,
  524393,
  524329,
  590003,
  524297,
  524425,
  524361,
  590067,
  459010,
  524373,
  524309,
  524573,
  459026,
  524405,
  524341,
  590027,
  459018,
  524389,
  524325,
  589995,
  524293,
  524421,
  524357,
  590059,
  459014,
  524381,
  524317,
  589979,
  459030,
  524413,
  524349,
  590043,
  459022,
  524397,
  524333,
  590011,
  524301,
  524429,
  524365,
  590075,
  459009,
  524371,
  524307,
  524571,
  459025,
  524403,
  524339,
  590023,
  459017,
  524387,
  524323,
  589991,
  524291,
  524419,
  524355,
  590055,
  459013,
  524379,
  524315,
  589975,
  459029,
  524411,
  524347,
  590039,
  459021,
  524395,
  524331,
  590007,
  524299,
  524427,
  524363,
  590071,
  459011,
  524375,
  524311,
  524575,
  459027,
  524407,
  524343,
  590031,
  459019,
  524391,
  524327,
  589999,
  524295,
  524423,
  524359,
  590063,
  459015,
  524383,
  524319,
  589983,
  459031,
  524415,
  524351,
  590047,
  459023,
  524399,
  524335,
  590015,
  524303,
  524431,
  524367,
  590079
]), 9];
var fixedDistCodeTab = [new Int32Array([
  327680,
  327696,
  327688,
  327704,
  327684,
  327700,
  327692,
  327708,
  327682,
  327698,
  327690,
  327706,
  327686,
  327702,
  327694,
  0,
  327681,
  327697,
  327689,
  327705,
  327685,
  327701,
  327693,
  327709,
  327683,
  327699,
  327691,
  327707,
  327687,
  327703,
  327695,
  0
]), 5];
var FlateStream = (
  /** @class */
  function(_super) {
    __extends(FlateStream2, _super);
    function FlateStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      var cmf = stream2.getByte();
      var flg = stream2.getByte();
      if (cmf === -1 || flg === -1) {
        throw new Error("Invalid header in flate stream: " + cmf + ", " + flg);
      }
      if ((cmf & 15) !== 8) {
        throw new Error("Unknown compression method in flate stream: " + cmf + ", " + flg);
      }
      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error("Bad FCHECK in flate stream: " + cmf + ", " + flg);
      }
      if (flg & 32) {
        throw new Error("FDICT bit set in flate stream: " + cmf + ", " + flg);
      }
      _this.codeSize = 0;
      _this.codeBuf = 0;
      return _this;
    }
    FlateStream2.prototype.readBlock = function() {
      var buffer;
      var len;
      var str = this.stream;
      var hdr = this.getBits(3);
      if (hdr & 1) {
        this.eof = true;
      }
      hdr >>= 1;
      if (hdr === 0) {
        var b4 = void 0;
        if ((b4 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        var blockLen = b4;
        if ((b4 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        blockLen |= b4 << 8;
        if ((b4 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        var check = b4;
        if ((b4 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        check |= b4 << 8;
        if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
          throw new Error("Bad uncompressed block length in flate stream");
        }
        this.codeBuf = 0;
        this.codeSize = 0;
        var bufferLength = this.bufferLength;
        buffer = this.ensureBuffer(bufferLength + blockLen);
        var end = bufferLength + blockLen;
        this.bufferLength = end;
        if (blockLen === 0) {
          if (str.peekByte() === -1) {
            this.eof = true;
          }
        } else {
          for (var n3 = bufferLength; n3 < end; ++n3) {
            if ((b4 = str.getByte()) === -1) {
              this.eof = true;
              break;
            }
            buffer[n3] = b4;
          }
        }
        return;
      }
      var litCodeTable;
      var distCodeTable;
      if (hdr === 1) {
        litCodeTable = fixedLitCodeTab;
        distCodeTable = fixedDistCodeTab;
      } else if (hdr === 2) {
        var numLitCodes = this.getBits(5) + 257;
        var numDistCodes = this.getBits(5) + 1;
        var numCodeLenCodes = this.getBits(4) + 4;
        var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
        var i3 = void 0;
        for (i3 = 0; i3 < numCodeLenCodes; ++i3) {
          codeLenCodeLengths[codeLenCodeMap[i3]] = this.getBits(3);
        }
        var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
        len = 0;
        i3 = 0;
        var codes = numLitCodes + numDistCodes;
        var codeLengths = new Uint8Array(codes);
        var bitsLength = void 0;
        var bitsOffset = void 0;
        var what = void 0;
        while (i3 < codes) {
          var code = this.getCode(codeLenCodeTab);
          if (code === 16) {
            bitsLength = 2;
            bitsOffset = 3;
            what = len;
          } else if (code === 17) {
            bitsLength = 3;
            bitsOffset = 3;
            what = len = 0;
          } else if (code === 18) {
            bitsLength = 7;
            bitsOffset = 11;
            what = len = 0;
          } else {
            codeLengths[i3++] = len = code;
            continue;
          }
          var repeatLength = this.getBits(bitsLength) + bitsOffset;
          while (repeatLength-- > 0) {
            codeLengths[i3++] = what;
          }
        }
        litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
        distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
      } else {
        throw new Error("Unknown block type in flate stream");
      }
      buffer = this.buffer;
      var limit = buffer ? buffer.length : 0;
      var pos = this.bufferLength;
      while (true) {
        var code1 = this.getCode(litCodeTable);
        if (code1 < 256) {
          if (pos + 1 >= limit) {
            buffer = this.ensureBuffer(pos + 1);
            limit = buffer.length;
          }
          buffer[pos++] = code1;
          continue;
        }
        if (code1 === 256) {
          this.bufferLength = pos;
          return;
        }
        code1 -= 257;
        code1 = lengthDecode[code1];
        var code2 = code1 >> 16;
        if (code2 > 0) {
          code2 = this.getBits(code2);
        }
        len = (code1 & 65535) + code2;
        code1 = this.getCode(distCodeTable);
        code1 = distDecode[code1];
        code2 = code1 >> 16;
        if (code2 > 0) {
          code2 = this.getBits(code2);
        }
        var dist = (code1 & 65535) + code2;
        if (pos + len >= limit) {
          buffer = this.ensureBuffer(pos + len);
          limit = buffer.length;
        }
        for (var k5 = 0; k5 < len; ++k5, ++pos) {
          buffer[pos] = buffer[pos - dist];
        }
      }
    };
    FlateStream2.prototype.getBits = function(bits) {
      var str = this.stream;
      var codeSize = this.codeSize;
      var codeBuf = this.codeBuf;
      var b4;
      while (codeSize < bits) {
        if ((b4 = str.getByte()) === -1) {
          throw new Error("Bad encoding in flate stream");
        }
        codeBuf |= b4 << codeSize;
        codeSize += 8;
      }
      b4 = codeBuf & (1 << bits) - 1;
      this.codeBuf = codeBuf >> bits;
      this.codeSize = codeSize -= bits;
      return b4;
    };
    FlateStream2.prototype.getCode = function(table) {
      var str = this.stream;
      var codes = table[0];
      var maxLen = table[1];
      var codeSize = this.codeSize;
      var codeBuf = this.codeBuf;
      var b4;
      while (codeSize < maxLen) {
        if ((b4 = str.getByte()) === -1) {
          break;
        }
        codeBuf |= b4 << codeSize;
        codeSize += 8;
      }
      var code = codes[codeBuf & (1 << maxLen) - 1];
      if (typeof codes === "number") {
        console.log("FLATE:", code);
      }
      var codeLen = code >> 16;
      var codeVal = code & 65535;
      if (codeLen < 1 || codeSize < codeLen) {
        throw new Error("Bad encoding in flate stream");
      }
      this.codeBuf = codeBuf >> codeLen;
      this.codeSize = codeSize - codeLen;
      return codeVal;
    };
    FlateStream2.prototype.generateHuffmanTable = function(lengths) {
      var n3 = lengths.length;
      var maxLen = 0;
      var i3;
      for (i3 = 0; i3 < n3; ++i3) {
        if (lengths[i3] > maxLen) {
          maxLen = lengths[i3];
        }
      }
      var size = 1 << maxLen;
      var codes = new Int32Array(size);
      for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
        for (var val = 0; val < n3; ++val) {
          if (lengths[val] === len) {
            var code2 = 0;
            var t2 = code;
            for (i3 = 0; i3 < len; ++i3) {
              code2 = code2 << 1 | t2 & 1;
              t2 >>= 1;
            }
            for (i3 = code2; i3 < size; i3 += skip) {
              codes[i3] = len << 16 | val;
            }
            ++code;
          }
        }
      }
      return [codes, maxLen];
    };
    return FlateStream2;
  }(DecodeStream_default)
);
var FlateStream_default = FlateStream;

// node_modules/pdf-lib/es/core/streams/LZWStream.js
var LZWStream = (
  /** @class */
  function(_super) {
    __extends(LZWStream2, _super);
    function LZWStream2(stream2, maybeLength, earlyChange) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.cachedData = 0;
      _this.bitsCached = 0;
      var maxLzwDictionarySize = 4096;
      var lzwState = {
        earlyChange,
        codeLength: 9,
        nextCode: 258,
        dictionaryValues: new Uint8Array(maxLzwDictionarySize),
        dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
        dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
        currentSequence: new Uint8Array(maxLzwDictionarySize),
        currentSequenceLength: 0
      };
      for (var i3 = 0; i3 < 256; ++i3) {
        lzwState.dictionaryValues[i3] = i3;
        lzwState.dictionaryLengths[i3] = 1;
      }
      _this.lzwState = lzwState;
      return _this;
    }
    LZWStream2.prototype.readBlock = function() {
      var blockSize = 512;
      var estimatedDecodedSize = blockSize * 2;
      var decodedSizeDelta = blockSize;
      var i3;
      var j4;
      var q4;
      var lzwState = this.lzwState;
      if (!lzwState) {
        return;
      }
      var earlyChange = lzwState.earlyChange;
      var nextCode = lzwState.nextCode;
      var dictionaryValues = lzwState.dictionaryValues;
      var dictionaryLengths = lzwState.dictionaryLengths;
      var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
      var codeLength = lzwState.codeLength;
      var prevCode = lzwState.prevCode;
      var currentSequence = lzwState.currentSequence;
      var currentSequenceLength = lzwState.currentSequenceLength;
      var decodedLength = 0;
      var currentBufferLength = this.bufferLength;
      var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      for (i3 = 0; i3 < blockSize; i3++) {
        var code = this.readBits(codeLength);
        var hasPrev = currentSequenceLength > 0;
        if (!code || code < 256) {
          currentSequence[0] = code;
          currentSequenceLength = 1;
        } else if (code >= 258) {
          if (code < nextCode) {
            currentSequenceLength = dictionaryLengths[code];
            for (j4 = currentSequenceLength - 1, q4 = code; j4 >= 0; j4--) {
              currentSequence[j4] = dictionaryValues[q4];
              q4 = dictionaryPrevCodes[q4];
            }
          } else {
            currentSequence[currentSequenceLength++] = currentSequence[0];
          }
        } else if (code === 256) {
          codeLength = 9;
          nextCode = 258;
          currentSequenceLength = 0;
          continue;
        } else {
          this.eof = true;
          delete this.lzwState;
          break;
        }
        if (hasPrev) {
          dictionaryPrevCodes[nextCode] = prevCode;
          dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
          dictionaryValues[nextCode] = currentSequence[0];
          nextCode++;
          codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
        }
        prevCode = code;
        decodedLength += currentSequenceLength;
        if (estimatedDecodedSize < decodedLength) {
          do {
            estimatedDecodedSize += decodedSizeDelta;
          } while (estimatedDecodedSize < decodedLength);
          buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
        }
        for (j4 = 0; j4 < currentSequenceLength; j4++) {
          buffer[currentBufferLength++] = currentSequence[j4];
        }
      }
      lzwState.nextCode = nextCode;
      lzwState.codeLength = codeLength;
      lzwState.prevCode = prevCode;
      lzwState.currentSequenceLength = currentSequenceLength;
      this.bufferLength = currentBufferLength;
    };
    LZWStream2.prototype.readBits = function(n3) {
      var bitsCached = this.bitsCached;
      var cachedData = this.cachedData;
      while (bitsCached < n3) {
        var c2 = this.stream.getByte();
        if (c2 === -1) {
          this.eof = true;
          return null;
        }
        cachedData = cachedData << 8 | c2;
        bitsCached += 8;
      }
      this.bitsCached = bitsCached -= n3;
      this.cachedData = cachedData;
      return cachedData >>> bitsCached & (1 << n3) - 1;
    };
    return LZWStream2;
  }(DecodeStream_default)
);
var LZWStream_default = LZWStream;

// node_modules/pdf-lib/es/core/streams/RunLengthStream.js
var RunLengthStream = (
  /** @class */
  function(_super) {
    __extends(RunLengthStream2, _super);
    function RunLengthStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      return _this;
    }
    RunLengthStream2.prototype.readBlock = function() {
      var repeatHeader = this.stream.getBytes(2);
      if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
        this.eof = true;
        return;
      }
      var buffer;
      var bufferLength = this.bufferLength;
      var n3 = repeatHeader[0];
      if (n3 < 128) {
        buffer = this.ensureBuffer(bufferLength + n3 + 1);
        buffer[bufferLength++] = repeatHeader[1];
        if (n3 > 0) {
          var source = this.stream.getBytes(n3);
          buffer.set(source, bufferLength);
          bufferLength += n3;
        }
      } else {
        n3 = 257 - n3;
        var b4 = repeatHeader[1];
        buffer = this.ensureBuffer(bufferLength + n3 + 1);
        for (var i3 = 0; i3 < n3; i3++) {
          buffer[bufferLength++] = b4;
        }
      }
      this.bufferLength = bufferLength;
    };
    return RunLengthStream2;
  }(DecodeStream_default)
);
var RunLengthStream_default = RunLengthStream;

// node_modules/pdf-lib/es/core/streams/decode.js
var decodeStream = function(stream2, encoding, params) {
  if (encoding === PDFName_default.of("FlateDecode")) {
    return new FlateStream_default(stream2);
  }
  if (encoding === PDFName_default.of("LZWDecode")) {
    var earlyChange = 1;
    if (params instanceof PDFDict_default) {
      var EarlyChange = params.lookup(PDFName_default.of("EarlyChange"));
      if (EarlyChange instanceof PDFNumber_default) {
        earlyChange = EarlyChange.asNumber();
      }
    }
    return new LZWStream_default(stream2, void 0, earlyChange);
  }
  if (encoding === PDFName_default.of("ASCII85Decode")) {
    return new Ascii85Stream_default(stream2);
  }
  if (encoding === PDFName_default.of("ASCIIHexDecode")) {
    return new AsciiHexStream_default(stream2);
  }
  if (encoding === PDFName_default.of("RunLengthDecode")) {
    return new RunLengthStream_default(stream2);
  }
  throw new UnsupportedEncodingError(encoding.asString());
};
var decodePDFRawStream = function(_a) {
  var dict = _a.dict, contents = _a.contents;
  var stream2 = new Stream_default(contents);
  var Filter = dict.lookup(PDFName_default.of("Filter"));
  var DecodeParms = dict.lookup(PDFName_default.of("DecodeParms"));
  if (Filter instanceof PDFName_default) {
    stream2 = decodeStream(stream2, Filter, DecodeParms);
  } else if (Filter instanceof PDFArray_default) {
    for (var idx = 0, len = Filter.size(); idx < len; idx++) {
      stream2 = decodeStream(stream2, Filter.lookup(idx, PDFName_default), DecodeParms && DecodeParms.lookupMaybe(idx, PDFDict_default));
    }
  } else if (!!Filter) {
    throw new UnexpectedObjectTypeError([PDFName_default, PDFArray_default], Filter);
  }
  return stream2;
};

// node_modules/pdf-lib/es/core/embedders/PDFPageEmbedder.js
var fullPageBoundingBox = function(page) {
  var mediaBox = page.MediaBox();
  var width = mediaBox.lookup(2, PDFNumber_default).asNumber() - mediaBox.lookup(0, PDFNumber_default).asNumber();
  var height = mediaBox.lookup(3, PDFNumber_default).asNumber() - mediaBox.lookup(1, PDFNumber_default).asNumber();
  return { left: 0, bottom: 0, right: width, top: height };
};
var boundingBoxAdjustedMatrix = function(bb) {
  return [1, 0, 0, 1, -bb.left, -bb.bottom];
};
var PDFPageEmbedder = (
  /** @class */
  function() {
    function PDFPageEmbedder2(page, boundingBox, transformationMatrix) {
      this.page = page;
      var bb = boundingBox !== null && boundingBox !== void 0 ? boundingBox : fullPageBoundingBox(page);
      this.width = bb.right - bb.left;
      this.height = bb.top - bb.bottom;
      this.boundingBox = bb;
      this.transformationMatrix = transformationMatrix !== null && transformationMatrix !== void 0 ? transformationMatrix : boundingBoxAdjustedMatrix(bb);
    }
    PDFPageEmbedder2.for = function(page, boundingBox, transformationMatrix) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, new PDFPageEmbedder2(page, boundingBox, transformationMatrix)];
        });
      });
    };
    PDFPageEmbedder2.prototype.embedIntoContext = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, Contents, Resources, decodedContents, _b, left, bottom, right, top, xObject;
        return __generator(this, function(_c) {
          _a = this.page.normalizedEntries(), Contents = _a.Contents, Resources = _a.Resources;
          if (!Contents)
            throw new MissingPageContentsEmbeddingError();
          decodedContents = this.decodeContents(Contents);
          _b = this.boundingBox, left = _b.left, bottom = _b.bottom, right = _b.right, top = _b.top;
          xObject = context.flateStream(decodedContents, {
            Type: "XObject",
            Subtype: "Form",
            FormType: 1,
            BBox: [left, bottom, right, top],
            Matrix: this.transformationMatrix,
            Resources
          });
          if (ref) {
            context.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context.register(xObject)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    PDFPageEmbedder2.prototype.decodeContents = function(contents) {
      var newline = Uint8Array.of(CharCodes_default.Newline);
      var decodedContents = [];
      for (var idx = 0, len = contents.size(); idx < len; idx++) {
        var stream2 = contents.lookup(idx, PDFStream_default);
        var content = void 0;
        if (stream2 instanceof PDFRawStream_default) {
          content = decodePDFRawStream(stream2).decode();
        } else if (stream2 instanceof PDFContentStream_default) {
          content = stream2.getUnencodedContents();
        } else {
          throw new UnrecognizedStreamTypeError(stream2);
        }
        decodedContents.push(content, newline);
      }
      return mergeIntoTypedArray.apply(void 0, decodedContents);
    };
    return PDFPageEmbedder2;
  }()
);
var PDFPageEmbedder_default = PDFPageEmbedder;

// node_modules/pdf-lib/es/core/interactive/ViewerPreferences.js
var asEnum = function(rawValue, enumType) {
  if (rawValue === void 0)
    return void 0;
  return enumType[rawValue];
};
var NonFullScreenPageMode;
(function(NonFullScreenPageMode2) {
  NonFullScreenPageMode2["UseNone"] = "UseNone";
  NonFullScreenPageMode2["UseOutlines"] = "UseOutlines";
  NonFullScreenPageMode2["UseThumbs"] = "UseThumbs";
  NonFullScreenPageMode2["UseOC"] = "UseOC";
})(NonFullScreenPageMode || (NonFullScreenPageMode = {}));
var ReadingDirection;
(function(ReadingDirection2) {
  ReadingDirection2["L2R"] = "L2R";
  ReadingDirection2["R2L"] = "R2L";
})(ReadingDirection || (ReadingDirection = {}));
var PrintScaling;
(function(PrintScaling2) {
  PrintScaling2["None"] = "None";
  PrintScaling2["AppDefault"] = "AppDefault";
})(PrintScaling || (PrintScaling = {}));
var Duplex;
(function(Duplex2) {
  Duplex2["Simplex"] = "Simplex";
  Duplex2["DuplexFlipShortEdge"] = "DuplexFlipShortEdge";
  Duplex2["DuplexFlipLongEdge"] = "DuplexFlipLongEdge";
})(Duplex || (Duplex = {}));
var ViewerPreferences = (
  /** @class */
  function() {
    function ViewerPreferences2(dict) {
      this.dict = dict;
    }
    ViewerPreferences2.prototype.lookupBool = function(key) {
      var returnObj = this.dict.lookup(PDFName_default.of(key));
      if (returnObj instanceof PDFBool_default)
        return returnObj;
      return void 0;
    };
    ViewerPreferences2.prototype.lookupName = function(key) {
      var returnObj = this.dict.lookup(PDFName_default.of(key));
      if (returnObj instanceof PDFName_default)
        return returnObj;
      return void 0;
    };
    ViewerPreferences2.prototype.HideToolbar = function() {
      return this.lookupBool("HideToolbar");
    };
    ViewerPreferences2.prototype.HideMenubar = function() {
      return this.lookupBool("HideMenubar");
    };
    ViewerPreferences2.prototype.HideWindowUI = function() {
      return this.lookupBool("HideWindowUI");
    };
    ViewerPreferences2.prototype.FitWindow = function() {
      return this.lookupBool("FitWindow");
    };
    ViewerPreferences2.prototype.CenterWindow = function() {
      return this.lookupBool("CenterWindow");
    };
    ViewerPreferences2.prototype.DisplayDocTitle = function() {
      return this.lookupBool("DisplayDocTitle");
    };
    ViewerPreferences2.prototype.NonFullScreenPageMode = function() {
      return this.lookupName("NonFullScreenPageMode");
    };
    ViewerPreferences2.prototype.Direction = function() {
      return this.lookupName("Direction");
    };
    ViewerPreferences2.prototype.PrintScaling = function() {
      return this.lookupName("PrintScaling");
    };
    ViewerPreferences2.prototype.Duplex = function() {
      return this.lookupName("Duplex");
    };
    ViewerPreferences2.prototype.PickTrayByPDFSize = function() {
      return this.lookupBool("PickTrayByPDFSize");
    };
    ViewerPreferences2.prototype.PrintPageRange = function() {
      var PrintPageRange = this.dict.lookup(PDFName_default.of("PrintPageRange"));
      if (PrintPageRange instanceof PDFArray_default)
        return PrintPageRange;
      return void 0;
    };
    ViewerPreferences2.prototype.NumCopies = function() {
      var NumCopies = this.dict.lookup(PDFName_default.of("NumCopies"));
      if (NumCopies instanceof PDFNumber_default)
        return NumCopies;
      return void 0;
    };
    ViewerPreferences2.prototype.getHideToolbar = function() {
      var _a, _b;
      return (_b = (_a = this.HideToolbar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getHideMenubar = function() {
      var _a, _b;
      return (_b = (_a = this.HideMenubar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getHideWindowUI = function() {
      var _a, _b;
      return (_b = (_a = this.HideWindowUI()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getFitWindow = function() {
      var _a, _b;
      return (_b = (_a = this.FitWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getCenterWindow = function() {
      var _a, _b;
      return (_b = (_a = this.CenterWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getDisplayDocTitle = function() {
      var _a, _b;
      return (_b = (_a = this.DisplayDocTitle()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
    };
    ViewerPreferences2.prototype.getNonFullScreenPageMode = function() {
      var _a, _b;
      var mode = (_a = this.NonFullScreenPageMode()) === null || _a === void 0 ? void 0 : _a.decodeText();
      return (_b = asEnum(mode, NonFullScreenPageMode)) !== null && _b !== void 0 ? _b : NonFullScreenPageMode.UseNone;
    };
    ViewerPreferences2.prototype.getReadingDirection = function() {
      var _a, _b;
      var direction = (_a = this.Direction()) === null || _a === void 0 ? void 0 : _a.decodeText();
      return (_b = asEnum(direction, ReadingDirection)) !== null && _b !== void 0 ? _b : ReadingDirection.L2R;
    };
    ViewerPreferences2.prototype.getPrintScaling = function() {
      var _a, _b;
      var scaling = (_a = this.PrintScaling()) === null || _a === void 0 ? void 0 : _a.decodeText();
      return (_b = asEnum(scaling, PrintScaling)) !== null && _b !== void 0 ? _b : PrintScaling.AppDefault;
    };
    ViewerPreferences2.prototype.getDuplex = function() {
      var _a;
      var duplex = (_a = this.Duplex()) === null || _a === void 0 ? void 0 : _a.decodeText();
      return asEnum(duplex, Duplex);
    };
    ViewerPreferences2.prototype.getPickTrayByPDFSize = function() {
      var _a;
      return (_a = this.PickTrayByPDFSize()) === null || _a === void 0 ? void 0 : _a.asBoolean();
    };
    ViewerPreferences2.prototype.getPrintPageRange = function() {
      var rng = this.PrintPageRange();
      if (!rng)
        return [];
      var pageRanges = [];
      for (var i3 = 0; i3 < rng.size(); i3 += 2) {
        var start2 = rng.lookup(i3, PDFNumber_default).asNumber();
        var end = rng.lookup(i3 + 1, PDFNumber_default).asNumber();
        pageRanges.push({ start: start2, end });
      }
      return pageRanges;
    };
    ViewerPreferences2.prototype.getNumCopies = function() {
      var _a, _b;
      return (_b = (_a = this.NumCopies()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
    };
    ViewerPreferences2.prototype.setHideToolbar = function(hideToolbar) {
      var HideToolbar = this.dict.context.obj(hideToolbar);
      this.dict.set(PDFName_default.of("HideToolbar"), HideToolbar);
    };
    ViewerPreferences2.prototype.setHideMenubar = function(hideMenubar) {
      var HideMenubar = this.dict.context.obj(hideMenubar);
      this.dict.set(PDFName_default.of("HideMenubar"), HideMenubar);
    };
    ViewerPreferences2.prototype.setHideWindowUI = function(hideWindowUI) {
      var HideWindowUI = this.dict.context.obj(hideWindowUI);
      this.dict.set(PDFName_default.of("HideWindowUI"), HideWindowUI);
    };
    ViewerPreferences2.prototype.setFitWindow = function(fitWindow) {
      var FitWindow = this.dict.context.obj(fitWindow);
      this.dict.set(PDFName_default.of("FitWindow"), FitWindow);
    };
    ViewerPreferences2.prototype.setCenterWindow = function(centerWindow) {
      var CenterWindow = this.dict.context.obj(centerWindow);
      this.dict.set(PDFName_default.of("CenterWindow"), CenterWindow);
    };
    ViewerPreferences2.prototype.setDisplayDocTitle = function(displayTitle) {
      var DisplayDocTitle = this.dict.context.obj(displayTitle);
      this.dict.set(PDFName_default.of("DisplayDocTitle"), DisplayDocTitle);
    };
    ViewerPreferences2.prototype.setNonFullScreenPageMode = function(nonFullScreenPageMode) {
      assertIsOneOf(nonFullScreenPageMode, "nonFullScreenPageMode", NonFullScreenPageMode);
      var mode = PDFName_default.of(nonFullScreenPageMode);
      this.dict.set(PDFName_default.of("NonFullScreenPageMode"), mode);
    };
    ViewerPreferences2.prototype.setReadingDirection = function(readingDirection) {
      assertIsOneOf(readingDirection, "readingDirection", ReadingDirection);
      var direction = PDFName_default.of(readingDirection);
      this.dict.set(PDFName_default.of("Direction"), direction);
    };
    ViewerPreferences2.prototype.setPrintScaling = function(printScaling) {
      assertIsOneOf(printScaling, "printScaling", PrintScaling);
      var scaling = PDFName_default.of(printScaling);
      this.dict.set(PDFName_default.of("PrintScaling"), scaling);
    };
    ViewerPreferences2.prototype.setDuplex = function(duplex) {
      assertIsOneOf(duplex, "duplex", Duplex);
      var dup = PDFName_default.of(duplex);
      this.dict.set(PDFName_default.of("Duplex"), dup);
    };
    ViewerPreferences2.prototype.setPickTrayByPDFSize = function(pickTrayByPDFSize) {
      var PickTrayByPDFSize = this.dict.context.obj(pickTrayByPDFSize);
      this.dict.set(PDFName_default.of("PickTrayByPDFSize"), PickTrayByPDFSize);
    };
    ViewerPreferences2.prototype.setPrintPageRange = function(printPageRange) {
      if (!Array.isArray(printPageRange))
        printPageRange = [printPageRange];
      var flatRange = [];
      for (var idx = 0, len = printPageRange.length; idx < len; idx++) {
        flatRange.push(printPageRange[idx].start);
        flatRange.push(printPageRange[idx].end);
      }
      assertEachIs(flatRange, "printPageRange", ["number"]);
      var pageRanges = this.dict.context.obj(flatRange);
      this.dict.set(PDFName_default.of("PrintPageRange"), pageRanges);
    };
    ViewerPreferences2.prototype.setNumCopies = function(numCopies) {
      assertRange(numCopies, "numCopies", 1, Number.MAX_VALUE);
      assertInteger(numCopies, "numCopies");
      var NumCopies = this.dict.context.obj(numCopies);
      this.dict.set(PDFName_default.of("NumCopies"), NumCopies);
    };
    ViewerPreferences2.fromDict = function(dict) {
      return new ViewerPreferences2(dict);
    };
    ViewerPreferences2.create = function(context) {
      var dict = context.obj({});
      return new ViewerPreferences2(dict);
    };
    return ViewerPreferences2;
  }()
);
var ViewerPreferences_default = ViewerPreferences;

// node_modules/pdf-lib/es/core/acroform/PDFAcroField.js
var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;
var PDFAcroField = (
  /** @class */
  function() {
    function PDFAcroField2(dict, ref) {
      this.dict = dict;
      this.ref = ref;
    }
    PDFAcroField2.prototype.T = function() {
      return this.dict.lookupMaybe(PDFName_default.of("T"), PDFString_default, PDFHexString_default);
    };
    PDFAcroField2.prototype.Ff = function() {
      var numberOrRef = this.getInheritableAttribute(PDFName_default.of("Ff"));
      return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_default);
    };
    PDFAcroField2.prototype.V = function() {
      var valueOrRef = this.getInheritableAttribute(PDFName_default.of("V"));
      return this.dict.context.lookup(valueOrRef);
    };
    PDFAcroField2.prototype.Kids = function() {
      return this.dict.lookupMaybe(PDFName_default.of("Kids"), PDFArray_default);
    };
    PDFAcroField2.prototype.DA = function() {
      var da = this.dict.lookup(PDFName_default.of("DA"));
      if (da instanceof PDFString_default || da instanceof PDFHexString_default)
        return da;
      return void 0;
    };
    PDFAcroField2.prototype.setKids = function(kids) {
      this.dict.set(PDFName_default.of("Kids"), this.dict.context.obj(kids));
    };
    PDFAcroField2.prototype.getParent = function() {
      var parentRef = this.dict.get(PDFName_default.of("Parent"));
      if (parentRef instanceof PDFRef_default) {
        var parent_1 = this.dict.lookup(PDFName_default.of("Parent"), PDFDict_default);
        return new PDFAcroField2(parent_1, parentRef);
      }
      return void 0;
    };
    PDFAcroField2.prototype.setParent = function(parent) {
      if (!parent)
        this.dict.delete(PDFName_default.of("Parent"));
      else
        this.dict.set(PDFName_default.of("Parent"), parent);
    };
    PDFAcroField2.prototype.getFullyQualifiedName = function() {
      var parent = this.getParent();
      if (!parent)
        return this.getPartialName();
      return parent.getFullyQualifiedName() + "." + this.getPartialName();
    };
    PDFAcroField2.prototype.getPartialName = function() {
      var _a;
      return (_a = this.T()) === null || _a === void 0 ? void 0 : _a.decodeText();
    };
    PDFAcroField2.prototype.setPartialName = function(partialName) {
      if (!partialName)
        this.dict.delete(PDFName_default.of("T"));
      else
        this.dict.set(PDFName_default.of("T"), PDFHexString_default.fromText(partialName));
    };
    PDFAcroField2.prototype.setDefaultAppearance = function(appearance) {
      this.dict.set(PDFName_default.of("DA"), PDFString_default.of(appearance));
    };
    PDFAcroField2.prototype.getDefaultAppearance = function() {
      var DA = this.DA();
      if (DA instanceof PDFHexString_default) {
        return DA.decodeText();
      }
      return DA === null || DA === void 0 ? void 0 : DA.asString();
    };
    PDFAcroField2.prototype.setFontSize = function(fontSize) {
      var _a;
      var name2 = (_a = this.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
      var da = this.getDefaultAppearance();
      if (!da)
        throw new MissingDAEntryError(name2);
      var daMatch = findLastMatch(da, tfRegex);
      if (!daMatch.match)
        throw new MissingTfOperatorError(name2);
      var daStart = da.slice(0, daMatch.pos - daMatch.match[0].length);
      var daEnd = daMatch.pos <= da.length ? da.slice(daMatch.pos) : "";
      var fontName = daMatch.match[1];
      var modifiedDa = daStart + " /" + fontName + " " + fontSize + " Tf " + daEnd;
      this.setDefaultAppearance(modifiedDa);
    };
    PDFAcroField2.prototype.getFlags = function() {
      var _a, _b;
      return (_b = (_a = this.Ff()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
    };
    PDFAcroField2.prototype.setFlags = function(flags2) {
      this.dict.set(PDFName_default.of("Ff"), PDFNumber_default.of(flags2));
    };
    PDFAcroField2.prototype.hasFlag = function(flag3) {
      var flags2 = this.getFlags();
      return (flags2 & flag3) !== 0;
    };
    PDFAcroField2.prototype.setFlag = function(flag3) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 | flag3);
    };
    PDFAcroField2.prototype.clearFlag = function(flag3) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 & ~flag3);
    };
    PDFAcroField2.prototype.setFlagTo = function(flag3, enable) {
      if (enable)
        this.setFlag(flag3);
      else
        this.clearFlag(flag3);
    };
    PDFAcroField2.prototype.getInheritableAttribute = function(name2) {
      var attribute;
      this.ascend(function(node) {
        if (!attribute)
          attribute = node.dict.get(name2);
      });
      return attribute;
    };
    PDFAcroField2.prototype.ascend = function(visitor) {
      visitor(this);
      var parent = this.getParent();
      if (parent)
        parent.ascend(visitor);
    };
    return PDFAcroField2;
  }()
);
var PDFAcroField_default = PDFAcroField;

// node_modules/pdf-lib/es/core/annotation/BorderStyle.js
var BorderStyle = (
  /** @class */
  function() {
    function BorderStyle2(dict) {
      this.dict = dict;
    }
    BorderStyle2.prototype.W = function() {
      var W5 = this.dict.lookup(PDFName_default.of("W"));
      if (W5 instanceof PDFNumber_default)
        return W5;
      return void 0;
    };
    BorderStyle2.prototype.getWidth = function() {
      var _a, _b;
      return (_b = (_a = this.W()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
    };
    BorderStyle2.prototype.setWidth = function(width) {
      var W5 = this.dict.context.obj(width);
      this.dict.set(PDFName_default.of("W"), W5);
    };
    BorderStyle2.fromDict = function(dict) {
      return new BorderStyle2(dict);
    };
    return BorderStyle2;
  }()
);
var BorderStyle_default = BorderStyle;

// node_modules/pdf-lib/es/core/annotation/PDFAnnotation.js
var PDFAnnotation = (
  /** @class */
  function() {
    function PDFAnnotation2(dict) {
      this.dict = dict;
    }
    PDFAnnotation2.prototype.Rect = function() {
      return this.dict.lookup(PDFName_default.of("Rect"), PDFArray_default);
    };
    PDFAnnotation2.prototype.AP = function() {
      return this.dict.lookupMaybe(PDFName_default.of("AP"), PDFDict_default);
    };
    PDFAnnotation2.prototype.F = function() {
      var numberOrRef = this.dict.lookup(PDFName_default.of("F"));
      return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_default);
    };
    PDFAnnotation2.prototype.getRectangle = function() {
      var _a;
      var Rect = this.Rect();
      return (_a = Rect === null || Rect === void 0 ? void 0 : Rect.asRectangle()) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: 0, height: 0 };
    };
    PDFAnnotation2.prototype.setRectangle = function(rect) {
      var x4 = rect.x, y4 = rect.y, width = rect.width, height = rect.height;
      var Rect = this.dict.context.obj([x4, y4, x4 + width, y4 + height]);
      this.dict.set(PDFName_default.of("Rect"), Rect);
    };
    PDFAnnotation2.prototype.getAppearanceState = function() {
      var AS = this.dict.lookup(PDFName_default.of("AS"));
      if (AS instanceof PDFName_default)
        return AS;
      return void 0;
    };
    PDFAnnotation2.prototype.setAppearanceState = function(state) {
      this.dict.set(PDFName_default.of("AS"), state);
    };
    PDFAnnotation2.prototype.setAppearances = function(appearances) {
      this.dict.set(PDFName_default.of("AP"), appearances);
    };
    PDFAnnotation2.prototype.ensureAP = function() {
      var AP = this.AP();
      if (!AP) {
        AP = this.dict.context.obj({});
        this.dict.set(PDFName_default.of("AP"), AP);
      }
      return AP;
    };
    PDFAnnotation2.prototype.getNormalAppearance = function() {
      var AP = this.ensureAP();
      var N4 = AP.get(PDFName_default.of("N"));
      if (N4 instanceof PDFRef_default || N4 instanceof PDFDict_default)
        return N4;
      throw new Error("Unexpected N type: " + (N4 === null || N4 === void 0 ? void 0 : N4.constructor.name));
    };
    PDFAnnotation2.prototype.setNormalAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName_default.of("N"), appearance);
    };
    PDFAnnotation2.prototype.setRolloverAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName_default.of("R"), appearance);
    };
    PDFAnnotation2.prototype.setDownAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName_default.of("D"), appearance);
    };
    PDFAnnotation2.prototype.removeRolloverAppearance = function() {
      var AP = this.AP();
      AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_default.of("R"));
    };
    PDFAnnotation2.prototype.removeDownAppearance = function() {
      var AP = this.AP();
      AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_default.of("D"));
    };
    PDFAnnotation2.prototype.getAppearances = function() {
      var AP = this.AP();
      if (!AP)
        return void 0;
      var N4 = AP.lookup(PDFName_default.of("N"), PDFDict_default, PDFStream_default);
      var R6 = AP.lookupMaybe(PDFName_default.of("R"), PDFDict_default, PDFStream_default);
      var D6 = AP.lookupMaybe(PDFName_default.of("D"), PDFDict_default, PDFStream_default);
      return { normal: N4, rollover: R6, down: D6 };
    };
    PDFAnnotation2.prototype.getFlags = function() {
      var _a, _b;
      return (_b = (_a = this.F()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
    };
    PDFAnnotation2.prototype.setFlags = function(flags2) {
      this.dict.set(PDFName_default.of("F"), PDFNumber_default.of(flags2));
    };
    PDFAnnotation2.prototype.hasFlag = function(flag3) {
      var flags2 = this.getFlags();
      return (flags2 & flag3) !== 0;
    };
    PDFAnnotation2.prototype.setFlag = function(flag3) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 | flag3);
    };
    PDFAnnotation2.prototype.clearFlag = function(flag3) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 & ~flag3);
    };
    PDFAnnotation2.prototype.setFlagTo = function(flag3, enable) {
      if (enable)
        this.setFlag(flag3);
      else
        this.clearFlag(flag3);
    };
    PDFAnnotation2.fromDict = function(dict) {
      return new PDFAnnotation2(dict);
    };
    return PDFAnnotation2;
  }()
);
var PDFAnnotation_default = PDFAnnotation;

// node_modules/pdf-lib/es/core/annotation/AppearanceCharacteristics.js
var AppearanceCharacteristics = (
  /** @class */
  function() {
    function AppearanceCharacteristics2(dict) {
      this.dict = dict;
    }
    AppearanceCharacteristics2.prototype.R = function() {
      var R6 = this.dict.lookup(PDFName_default.of("R"));
      if (R6 instanceof PDFNumber_default)
        return R6;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.BC = function() {
      var BC = this.dict.lookup(PDFName_default.of("BC"));
      if (BC instanceof PDFArray_default)
        return BC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.BG = function() {
      var BG = this.dict.lookup(PDFName_default.of("BG"));
      if (BG instanceof PDFArray_default)
        return BG;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.CA = function() {
      var CA = this.dict.lookup(PDFName_default.of("CA"));
      if (CA instanceof PDFHexString_default || CA instanceof PDFString_default)
        return CA;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.RC = function() {
      var RC = this.dict.lookup(PDFName_default.of("RC"));
      if (RC instanceof PDFHexString_default || RC instanceof PDFString_default)
        return RC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.AC = function() {
      var AC = this.dict.lookup(PDFName_default.of("AC"));
      if (AC instanceof PDFHexString_default || AC instanceof PDFString_default)
        return AC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.getRotation = function() {
      var _a;
      return (_a = this.R()) === null || _a === void 0 ? void 0 : _a.asNumber();
    };
    AppearanceCharacteristics2.prototype.getBorderColor = function() {
      var BC = this.BC();
      if (!BC)
        return void 0;
      var components = [];
      for (var idx = 0, len = BC === null || BC === void 0 ? void 0 : BC.size(); idx < len; idx++) {
        var component = BC.get(idx);
        if (component instanceof PDFNumber_default)
          components.push(component.asNumber());
      }
      return components;
    };
    AppearanceCharacteristics2.prototype.getBackgroundColor = function() {
      var BG = this.BG();
      if (!BG)
        return void 0;
      var components = [];
      for (var idx = 0, len = BG === null || BG === void 0 ? void 0 : BG.size(); idx < len; idx++) {
        var component = BG.get(idx);
        if (component instanceof PDFNumber_default)
          components.push(component.asNumber());
      }
      return components;
    };
    AppearanceCharacteristics2.prototype.getCaptions = function() {
      var CA = this.CA();
      var RC = this.RC();
      var AC = this.AC();
      return {
        normal: CA === null || CA === void 0 ? void 0 : CA.decodeText(),
        rollover: RC === null || RC === void 0 ? void 0 : RC.decodeText(),
        down: AC === null || AC === void 0 ? void 0 : AC.decodeText()
      };
    };
    AppearanceCharacteristics2.prototype.setRotation = function(rotation) {
      var R6 = this.dict.context.obj(rotation);
      this.dict.set(PDFName_default.of("R"), R6);
    };
    AppearanceCharacteristics2.prototype.setBorderColor = function(color) {
      var BC = this.dict.context.obj(color);
      this.dict.set(PDFName_default.of("BC"), BC);
    };
    AppearanceCharacteristics2.prototype.setBackgroundColor = function(color) {
      var BG = this.dict.context.obj(color);
      this.dict.set(PDFName_default.of("BG"), BG);
    };
    AppearanceCharacteristics2.prototype.setCaptions = function(captions) {
      var CA = PDFHexString_default.fromText(captions.normal);
      this.dict.set(PDFName_default.of("CA"), CA);
      if (captions.rollover) {
        var RC = PDFHexString_default.fromText(captions.rollover);
        this.dict.set(PDFName_default.of("RC"), RC);
      } else {
        this.dict.delete(PDFName_default.of("RC"));
      }
      if (captions.down) {
        var AC = PDFHexString_default.fromText(captions.down);
        this.dict.set(PDFName_default.of("AC"), AC);
      } else {
        this.dict.delete(PDFName_default.of("AC"));
      }
    };
    AppearanceCharacteristics2.fromDict = function(dict) {
      return new AppearanceCharacteristics2(dict);
    };
    return AppearanceCharacteristics2;
  }()
);
var AppearanceCharacteristics_default = AppearanceCharacteristics;

// node_modules/pdf-lib/es/core/annotation/PDFWidgetAnnotation.js
var PDFWidgetAnnotation = (
  /** @class */
  function(_super) {
    __extends(PDFWidgetAnnotation2, _super);
    function PDFWidgetAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFWidgetAnnotation2.prototype.MK = function() {
      var MK = this.dict.lookup(PDFName_default.of("MK"));
      if (MK instanceof PDFDict_default)
        return MK;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.BS = function() {
      var BS = this.dict.lookup(PDFName_default.of("BS"));
      if (BS instanceof PDFDict_default)
        return BS;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.DA = function() {
      var da = this.dict.lookup(PDFName_default.of("DA"));
      if (da instanceof PDFString_default || da instanceof PDFHexString_default)
        return da;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.P = function() {
      var P6 = this.dict.get(PDFName_default.of("P"));
      if (P6 instanceof PDFRef_default)
        return P6;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.setP = function(page) {
      this.dict.set(PDFName_default.of("P"), page);
    };
    PDFWidgetAnnotation2.prototype.setDefaultAppearance = function(appearance) {
      this.dict.set(PDFName_default.of("DA"), PDFString_default.of(appearance));
    };
    PDFWidgetAnnotation2.prototype.getDefaultAppearance = function() {
      var DA = this.DA();
      if (DA instanceof PDFHexString_default) {
        return DA.decodeText();
      }
      return DA === null || DA === void 0 ? void 0 : DA.asString();
    };
    PDFWidgetAnnotation2.prototype.getAppearanceCharacteristics = function() {
      var MK = this.MK();
      if (MK)
        return AppearanceCharacteristics_default.fromDict(MK);
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.getOrCreateAppearanceCharacteristics = function() {
      var MK = this.MK();
      if (MK)
        return AppearanceCharacteristics_default.fromDict(MK);
      var ac = AppearanceCharacteristics_default.fromDict(this.dict.context.obj({}));
      this.dict.set(PDFName_default.of("MK"), ac.dict);
      return ac;
    };
    PDFWidgetAnnotation2.prototype.getBorderStyle = function() {
      var BS = this.BS();
      if (BS)
        return BorderStyle_default.fromDict(BS);
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.getOrCreateBorderStyle = function() {
      var BS = this.BS();
      if (BS)
        return BorderStyle_default.fromDict(BS);
      var bs = BorderStyle_default.fromDict(this.dict.context.obj({}));
      this.dict.set(PDFName_default.of("BS"), bs.dict);
      return bs;
    };
    PDFWidgetAnnotation2.prototype.getOnValue = function() {
      var _a;
      var normal = (_a = this.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
      if (normal instanceof PDFDict_default) {
        var keys = normal.keys();
        for (var idx = 0, len = keys.length; idx < len; idx++) {
          var key = keys[idx];
          if (key !== PDFName_default.of("Off"))
            return key;
        }
      }
      return void 0;
    };
    PDFWidgetAnnotation2.fromDict = function(dict) {
      return new PDFWidgetAnnotation2(dict);
    };
    PDFWidgetAnnotation2.create = function(context, parent) {
      var dict = context.obj({
        Type: "Annot",
        Subtype: "Widget",
        Rect: [0, 0, 0, 0],
        Parent: parent
      });
      return new PDFWidgetAnnotation2(dict);
    };
    return PDFWidgetAnnotation2;
  }(PDFAnnotation_default)
);
var PDFWidgetAnnotation_default = PDFWidgetAnnotation;

// node_modules/pdf-lib/es/core/acroform/PDFAcroTerminal.js
var PDFAcroTerminal = (
  /** @class */
  function(_super) {
    __extends(PDFAcroTerminal2, _super);
    function PDFAcroTerminal2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroTerminal2.prototype.FT = function() {
      var nameOrRef = this.getInheritableAttribute(PDFName_default.of("FT"));
      return this.dict.context.lookup(nameOrRef, PDFName_default);
    };
    PDFAcroTerminal2.prototype.getWidgets = function() {
      var kidDicts = this.Kids();
      if (!kidDicts)
        return [PDFWidgetAnnotation_default.fromDict(this.dict)];
      var widgets = new Array(kidDicts.size());
      for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
        var dict = kidDicts.lookup(idx, PDFDict_default);
        widgets[idx] = PDFWidgetAnnotation_default.fromDict(dict);
      }
      return widgets;
    };
    PDFAcroTerminal2.prototype.addWidget = function(ref) {
      var Kids = this.normalizedEntries().Kids;
      Kids.push(ref);
    };
    PDFAcroTerminal2.prototype.removeWidget = function(idx) {
      var kidDicts = this.Kids();
      if (!kidDicts) {
        if (idx !== 0)
          throw new IndexOutOfBoundsError(idx, 0, 0);
        this.setKids([]);
      } else {
        if (idx < 0 || idx > kidDicts.size()) {
          throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());
        }
        kidDicts.remove(idx);
      }
    };
    PDFAcroTerminal2.prototype.normalizedEntries = function() {
      var Kids = this.Kids();
      if (!Kids) {
        Kids = this.dict.context.obj([this.ref]);
        this.dict.set(PDFName_default.of("Kids"), Kids);
      }
      return { Kids };
    };
    PDFAcroTerminal2.fromDict = function(dict, ref) {
      return new PDFAcroTerminal2(dict, ref);
    };
    return PDFAcroTerminal2;
  }(PDFAcroField_default)
);
var PDFAcroTerminal_default = PDFAcroTerminal;

// node_modules/pdf-lib/es/core/acroform/PDFAcroButton.js
var PDFAcroButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroButton2, _super);
    function PDFAcroButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroButton2.prototype.Opt = function() {
      return this.dict.lookupMaybe(PDFName_default.of("Opt"), PDFString_default, PDFHexString_default, PDFArray_default);
    };
    PDFAcroButton2.prototype.setOpt = function(opt) {
      this.dict.set(PDFName_default.of("Opt"), this.dict.context.obj(opt));
    };
    PDFAcroButton2.prototype.getExportValues = function() {
      var opt = this.Opt();
      if (!opt)
        return void 0;
      if (opt instanceof PDFString_default || opt instanceof PDFHexString_default) {
        return [opt];
      }
      var values2 = [];
      for (var idx = 0, len = opt.size(); idx < len; idx++) {
        var value = opt.lookup(idx);
        if (value instanceof PDFString_default || value instanceof PDFHexString_default) {
          values2.push(value);
        }
      }
      return values2;
    };
    PDFAcroButton2.prototype.removeExportValue = function(idx) {
      var opt = this.Opt();
      if (!opt)
        return;
      if (opt instanceof PDFString_default || opt instanceof PDFHexString_default) {
        if (idx !== 0)
          throw new IndexOutOfBoundsError(idx, 0, 0);
        this.setOpt([]);
      } else {
        if (idx < 0 || idx > opt.size()) {
          throw new IndexOutOfBoundsError(idx, 0, opt.size());
        }
        opt.remove(idx);
      }
    };
    PDFAcroButton2.prototype.normalizeExportValues = function() {
      var _a, _b, _c, _d;
      var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
      var Opt = [];
      var widgets = this.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var exportVal = (_b = exportValues[idx]) !== null && _b !== void 0 ? _b : PDFHexString_default.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : "");
        Opt.push(exportVal);
      }
      this.setOpt(Opt);
    };
    PDFAcroButton2.prototype.addOpt = function(opt, useExistingOptIdx) {
      var _a;
      this.normalizeExportValues();
      var optText = opt.decodeText();
      var existingIdx;
      if (useExistingOptIdx) {
        var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
        for (var idx = 0, len = exportValues.length; idx < len; idx++) {
          var exportVal = exportValues[idx];
          if (exportVal.decodeText() === optText)
            existingIdx = idx;
        }
      }
      var Opt = this.Opt();
      Opt.push(opt);
      return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;
    };
    PDFAcroButton2.prototype.addWidgetWithOpt = function(widget, opt, useExistingOptIdx) {
      var optIdx = this.addOpt(opt, useExistingOptIdx);
      var apStateValue = PDFName_default.of(String(optIdx));
      this.addWidget(widget);
      return apStateValue;
    };
    return PDFAcroButton2;
  }(PDFAcroTerminal_default)
);
var PDFAcroButton_default = PDFAcroButton;

// node_modules/pdf-lib/es/core/acroform/PDFAcroCheckBox.js
var PDFAcroCheckBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroCheckBox2, _super);
    function PDFAcroCheckBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroCheckBox2.prototype.setValue = function(value) {
      var _a;
      var onValue = (_a = this.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
      if (value !== onValue && value !== PDFName_default.of("Off")) {
        throw new InvalidAcroFieldValueError();
      }
      this.dict.set(PDFName_default.of("V"), value);
      var widgets = this.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var state = widget.getOnValue() === value ? value : PDFName_default.of("Off");
        widget.setAppearanceState(state);
      }
    };
    PDFAcroCheckBox2.prototype.getValue = function() {
      var v4 = this.V();
      if (v4 instanceof PDFName_default)
        return v4;
      return PDFName_default.of("Off");
    };
    PDFAcroCheckBox2.prototype.getOnValue = function() {
      var widget = this.getWidgets()[0];
      return widget === null || widget === void 0 ? void 0 : widget.getOnValue();
    };
    PDFAcroCheckBox2.fromDict = function(dict, ref) {
      return new PDFAcroCheckBox2(dict, ref);
    };
    PDFAcroCheckBox2.create = function(context) {
      var dict = context.obj({
        FT: "Btn",
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroCheckBox2(dict, ref);
    };
    return PDFAcroCheckBox2;
  }(PDFAcroButton_default)
);
var PDFAcroCheckBox_default = PDFAcroCheckBox;

// node_modules/pdf-lib/es/core/acroform/flags.js
var flag = function(bitIndex) {
  return 1 << bitIndex;
};
var AcroFieldFlags;
(function(AcroFieldFlags2) {
  AcroFieldFlags2[AcroFieldFlags2["ReadOnly"] = flag(1 - 1)] = "ReadOnly";
  AcroFieldFlags2[AcroFieldFlags2["Required"] = flag(2 - 1)] = "Required";
  AcroFieldFlags2[AcroFieldFlags2["NoExport"] = flag(3 - 1)] = "NoExport";
})(AcroFieldFlags || (AcroFieldFlags = {}));
var AcroButtonFlags;
(function(AcroButtonFlags2) {
  AcroButtonFlags2[AcroButtonFlags2["NoToggleToOff"] = flag(15 - 1)] = "NoToggleToOff";
  AcroButtonFlags2[AcroButtonFlags2["Radio"] = flag(16 - 1)] = "Radio";
  AcroButtonFlags2[AcroButtonFlags2["PushButton"] = flag(17 - 1)] = "PushButton";
  AcroButtonFlags2[AcroButtonFlags2["RadiosInUnison"] = flag(26 - 1)] = "RadiosInUnison";
})(AcroButtonFlags || (AcroButtonFlags = {}));
var AcroTextFlags;
(function(AcroTextFlags2) {
  AcroTextFlags2[AcroTextFlags2["Multiline"] = flag(13 - 1)] = "Multiline";
  AcroTextFlags2[AcroTextFlags2["Password"] = flag(14 - 1)] = "Password";
  AcroTextFlags2[AcroTextFlags2["FileSelect"] = flag(21 - 1)] = "FileSelect";
  AcroTextFlags2[AcroTextFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
  AcroTextFlags2[AcroTextFlags2["DoNotScroll"] = flag(24 - 1)] = "DoNotScroll";
  AcroTextFlags2[AcroTextFlags2["Comb"] = flag(25 - 1)] = "Comb";
  AcroTextFlags2[AcroTextFlags2["RichText"] = flag(26 - 1)] = "RichText";
})(AcroTextFlags || (AcroTextFlags = {}));
var AcroChoiceFlags;
(function(AcroChoiceFlags2) {
  AcroChoiceFlags2[AcroChoiceFlags2["Combo"] = flag(18 - 1)] = "Combo";
  AcroChoiceFlags2[AcroChoiceFlags2["Edit"] = flag(19 - 1)] = "Edit";
  AcroChoiceFlags2[AcroChoiceFlags2["Sort"] = flag(20 - 1)] = "Sort";
  AcroChoiceFlags2[AcroChoiceFlags2["MultiSelect"] = flag(22 - 1)] = "MultiSelect";
  AcroChoiceFlags2[AcroChoiceFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
  AcroChoiceFlags2[AcroChoiceFlags2["CommitOnSelChange"] = flag(27 - 1)] = "CommitOnSelChange";
})(AcroChoiceFlags || (AcroChoiceFlags = {}));

// node_modules/pdf-lib/es/core/acroform/PDFAcroChoice.js
var PDFAcroChoice = (
  /** @class */
  function(_super) {
    __extends(PDFAcroChoice2, _super);
    function PDFAcroChoice2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroChoice2.prototype.setValues = function(values2) {
      if (this.hasFlag(AcroChoiceFlags.Combo) && !this.hasFlag(AcroChoiceFlags.Edit) && !this.valuesAreValid(values2)) {
        throw new InvalidAcroFieldValueError();
      }
      if (values2.length === 0) {
        this.dict.delete(PDFName_default.of("V"));
      }
      if (values2.length === 1) {
        this.dict.set(PDFName_default.of("V"), values2[0]);
      }
      if (values2.length > 1) {
        if (!this.hasFlag(AcroChoiceFlags.MultiSelect)) {
          throw new MultiSelectValueError();
        }
        this.dict.set(PDFName_default.of("V"), this.dict.context.obj(values2));
      }
      this.updateSelectedIndices(values2);
    };
    PDFAcroChoice2.prototype.valuesAreValid = function(values2) {
      var options = this.getOptions();
      var _loop_1 = function(idx2, len2) {
        var val = values2[idx2].decodeText();
        if (!options.find(function(o5) {
          return val === (o5.display || o5.value).decodeText();
        })) {
          return { value: false };
        }
      };
      for (var idx = 0, len = values2.length; idx < len; idx++) {
        var state_1 = _loop_1(idx, len);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      return true;
    };
    PDFAcroChoice2.prototype.updateSelectedIndices = function(values2) {
      if (values2.length > 1) {
        var indices = new Array(values2.length);
        var options = this.getOptions();
        var _loop_2 = function(idx2, len2) {
          var val = values2[idx2].decodeText();
          indices[idx2] = options.findIndex(function(o5) {
            return val === (o5.display || o5.value).decodeText();
          });
        };
        for (var idx = 0, len = values2.length; idx < len; idx++) {
          _loop_2(idx, len);
        }
        this.dict.set(PDFName_default.of("I"), this.dict.context.obj(indices.sort()));
      } else {
        this.dict.delete(PDFName_default.of("I"));
      }
    };
    PDFAcroChoice2.prototype.getValues = function() {
      var v4 = this.V();
      if (v4 instanceof PDFString_default || v4 instanceof PDFHexString_default)
        return [v4];
      if (v4 instanceof PDFArray_default) {
        var values2 = [];
        for (var idx = 0, len = v4.size(); idx < len; idx++) {
          var value = v4.lookup(idx);
          if (value instanceof PDFString_default || value instanceof PDFHexString_default) {
            values2.push(value);
          }
        }
        return values2;
      }
      return [];
    };
    PDFAcroChoice2.prototype.Opt = function() {
      return this.dict.lookupMaybe(PDFName_default.of("Opt"), PDFString_default, PDFHexString_default, PDFArray_default);
    };
    PDFAcroChoice2.prototype.setOptions = function(options) {
      var newOpt = new Array(options.length);
      for (var idx = 0, len = options.length; idx < len; idx++) {
        var _a = options[idx], value = _a.value, display = _a.display;
        newOpt[idx] = this.dict.context.obj([value, display || value]);
      }
      this.dict.set(PDFName_default.of("Opt"), this.dict.context.obj(newOpt));
    };
    PDFAcroChoice2.prototype.getOptions = function() {
      var Opt = this.Opt();
      if (Opt instanceof PDFString_default || Opt instanceof PDFHexString_default) {
        return [{ value: Opt, display: Opt }];
      }
      if (Opt instanceof PDFArray_default) {
        var res = [];
        for (var idx = 0, len = Opt.size(); idx < len; idx++) {
          var item = Opt.lookup(idx);
          if (item instanceof PDFString_default || item instanceof PDFHexString_default) {
            res.push({ value: item, display: item });
          }
          if (item instanceof PDFArray_default) {
            if (item.size() > 0) {
              var first = item.lookup(0, PDFString_default, PDFHexString_default);
              var second = item.lookupMaybe(1, PDFString_default, PDFHexString_default);
              res.push({ value: first, display: second || first });
            }
          }
        }
        return res;
      }
      return [];
    };
    return PDFAcroChoice2;
  }(PDFAcroTerminal_default)
);
var PDFAcroChoice_default = PDFAcroChoice;

// node_modules/pdf-lib/es/core/acroform/PDFAcroComboBox.js
var PDFAcroComboBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroComboBox2, _super);
    function PDFAcroComboBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroComboBox2.fromDict = function(dict, ref) {
      return new PDFAcroComboBox2(dict, ref);
    };
    PDFAcroComboBox2.create = function(context) {
      var dict = context.obj({
        FT: "Ch",
        Ff: AcroChoiceFlags.Combo,
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroComboBox2(dict, ref);
    };
    return PDFAcroComboBox2;
  }(PDFAcroChoice_default)
);
var PDFAcroComboBox_default = PDFAcroComboBox;

// node_modules/pdf-lib/es/core/acroform/PDFAcroNonTerminal.js
var PDFAcroNonTerminal = (
  /** @class */
  function(_super) {
    __extends(PDFAcroNonTerminal2, _super);
    function PDFAcroNonTerminal2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroNonTerminal2.prototype.addField = function(field) {
      var Kids = this.normalizedEntries().Kids;
      Kids === null || Kids === void 0 ? void 0 : Kids.push(field);
    };
    PDFAcroNonTerminal2.prototype.normalizedEntries = function() {
      var Kids = this.Kids();
      if (!Kids) {
        Kids = this.dict.context.obj([]);
        this.dict.set(PDFName_default.of("Kids"), Kids);
      }
      return { Kids };
    };
    PDFAcroNonTerminal2.fromDict = function(dict, ref) {
      return new PDFAcroNonTerminal2(dict, ref);
    };
    PDFAcroNonTerminal2.create = function(context) {
      var dict = context.obj({});
      var ref = context.register(dict);
      return new PDFAcroNonTerminal2(dict, ref);
    };
    return PDFAcroNonTerminal2;
  }(PDFAcroField_default)
);
var PDFAcroNonTerminal_default = PDFAcroNonTerminal;

// node_modules/pdf-lib/es/core/acroform/PDFAcroSignature.js
var PDFAcroSignature = (
  /** @class */
  function(_super) {
    __extends(PDFAcroSignature2, _super);
    function PDFAcroSignature2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroSignature2.fromDict = function(dict, ref) {
      return new PDFAcroSignature2(dict, ref);
    };
    return PDFAcroSignature2;
  }(PDFAcroTerminal_default)
);
var PDFAcroSignature_default = PDFAcroSignature;

// node_modules/pdf-lib/es/core/acroform/PDFAcroText.js
var PDFAcroText = (
  /** @class */
  function(_super) {
    __extends(PDFAcroText2, _super);
    function PDFAcroText2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroText2.prototype.MaxLen = function() {
      var maxLen = this.dict.lookup(PDFName_default.of("MaxLen"));
      if (maxLen instanceof PDFNumber_default)
        return maxLen;
      return void 0;
    };
    PDFAcroText2.prototype.Q = function() {
      var q4 = this.dict.lookup(PDFName_default.of("Q"));
      if (q4 instanceof PDFNumber_default)
        return q4;
      return void 0;
    };
    PDFAcroText2.prototype.setMaxLength = function(maxLength) {
      this.dict.set(PDFName_default.of("MaxLen"), PDFNumber_default.of(maxLength));
    };
    PDFAcroText2.prototype.removeMaxLength = function() {
      this.dict.delete(PDFName_default.of("MaxLen"));
    };
    PDFAcroText2.prototype.getMaxLength = function() {
      var _a;
      return (_a = this.MaxLen()) === null || _a === void 0 ? void 0 : _a.asNumber();
    };
    PDFAcroText2.prototype.setQuadding = function(quadding) {
      this.dict.set(PDFName_default.of("Q"), PDFNumber_default.of(quadding));
    };
    PDFAcroText2.prototype.getQuadding = function() {
      var _a;
      return (_a = this.Q()) === null || _a === void 0 ? void 0 : _a.asNumber();
    };
    PDFAcroText2.prototype.setValue = function(value) {
      this.dict.set(PDFName_default.of("V"), value);
    };
    PDFAcroText2.prototype.removeValue = function() {
      this.dict.delete(PDFName_default.of("V"));
    };
    PDFAcroText2.prototype.getValue = function() {
      var v4 = this.V();
      if (v4 instanceof PDFString_default || v4 instanceof PDFHexString_default)
        return v4;
      return void 0;
    };
    PDFAcroText2.fromDict = function(dict, ref) {
      return new PDFAcroText2(dict, ref);
    };
    PDFAcroText2.create = function(context) {
      var dict = context.obj({
        FT: "Tx",
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroText2(dict, ref);
    };
    return PDFAcroText2;
  }(PDFAcroTerminal_default)
);
var PDFAcroText_default = PDFAcroText;

// node_modules/pdf-lib/es/core/acroform/PDFAcroPushButton.js
var PDFAcroPushButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroPushButton2, _super);
    function PDFAcroPushButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroPushButton2.fromDict = function(dict, ref) {
      return new PDFAcroPushButton2(dict, ref);
    };
    PDFAcroPushButton2.create = function(context) {
      var dict = context.obj({
        FT: "Btn",
        Ff: AcroButtonFlags.PushButton,
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroPushButton2(dict, ref);
    };
    return PDFAcroPushButton2;
  }(PDFAcroButton_default)
);
var PDFAcroPushButton_default = PDFAcroPushButton;

// node_modules/pdf-lib/es/core/acroform/PDFAcroRadioButton.js
var PDFAcroRadioButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroRadioButton2, _super);
    function PDFAcroRadioButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroRadioButton2.prototype.setValue = function(value) {
      var onValues = this.getOnValues();
      if (!onValues.includes(value) && value !== PDFName_default.of("Off")) {
        throw new InvalidAcroFieldValueError();
      }
      this.dict.set(PDFName_default.of("V"), value);
      var widgets = this.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var state = widget.getOnValue() === value ? value : PDFName_default.of("Off");
        widget.setAppearanceState(state);
      }
    };
    PDFAcroRadioButton2.prototype.getValue = function() {
      var v4 = this.V();
      if (v4 instanceof PDFName_default)
        return v4;
      return PDFName_default.of("Off");
    };
    PDFAcroRadioButton2.prototype.getOnValues = function() {
      var widgets = this.getWidgets();
      var onValues = [];
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var onValue = widgets[idx].getOnValue();
        if (onValue)
          onValues.push(onValue);
      }
      return onValues;
    };
    PDFAcroRadioButton2.fromDict = function(dict, ref) {
      return new PDFAcroRadioButton2(dict, ref);
    };
    PDFAcroRadioButton2.create = function(context) {
      var dict = context.obj({
        FT: "Btn",
        Ff: AcroButtonFlags.Radio,
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroRadioButton2(dict, ref);
    };
    return PDFAcroRadioButton2;
  }(PDFAcroButton_default)
);
var PDFAcroRadioButton_default = PDFAcroRadioButton;

// node_modules/pdf-lib/es/core/acroform/PDFAcroListBox.js
var PDFAcroListBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroListBox2, _super);
    function PDFAcroListBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroListBox2.fromDict = function(dict, ref) {
      return new PDFAcroListBox2(dict, ref);
    };
    PDFAcroListBox2.create = function(context) {
      var dict = context.obj({
        FT: "Ch",
        Kids: []
      });
      var ref = context.register(dict);
      return new PDFAcroListBox2(dict, ref);
    };
    return PDFAcroListBox2;
  }(PDFAcroChoice_default)
);
var PDFAcroListBox_default = PDFAcroListBox;

// node_modules/pdf-lib/es/core/acroform/utils.js
var createPDFAcroFields = function(kidDicts) {
  if (!kidDicts)
    return [];
  var kids = [];
  for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
    var ref = kidDicts.get(idx);
    var dict = kidDicts.lookup(idx);
    if (ref instanceof PDFRef_default && dict instanceof PDFDict_default) {
      kids.push([createPDFAcroField(dict, ref), ref]);
    }
  }
  return kids;
};
var createPDFAcroField = function(dict, ref) {
  var isNonTerminal = isNonTerminalAcroField(dict);
  if (isNonTerminal)
    return PDFAcroNonTerminal_default.fromDict(dict, ref);
  return createPDFAcroTerminal(dict, ref);
};
var isNonTerminalAcroField = function(dict) {
  var kids = dict.lookup(PDFName_default.of("Kids"));
  if (kids instanceof PDFArray_default) {
    for (var idx = 0, len = kids.size(); idx < len; idx++) {
      var kid = kids.lookup(idx);
      var kidIsField = kid instanceof PDFDict_default && kid.has(PDFName_default.of("T"));
      if (kidIsField)
        return true;
    }
  }
  return false;
};
var createPDFAcroTerminal = function(dict, ref) {
  var ftNameOrRef = getInheritableAttribute(dict, PDFName_default.of("FT"));
  var type = dict.context.lookup(ftNameOrRef, PDFName_default);
  if (type === PDFName_default.of("Btn"))
    return createPDFAcroButton(dict, ref);
  if (type === PDFName_default.of("Ch"))
    return createPDFAcroChoice(dict, ref);
  if (type === PDFName_default.of("Tx"))
    return PDFAcroText_default.fromDict(dict, ref);
  if (type === PDFName_default.of("Sig"))
    return PDFAcroSignature_default.fromDict(dict, ref);
  return PDFAcroTerminal_default.fromDict(dict, ref);
};
var createPDFAcroButton = function(dict, ref) {
  var _a;
  var ffNumberOrRef = getInheritableAttribute(dict, PDFName_default.of("Ff"));
  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_default);
  var flags2 = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
  if (flagIsSet(flags2, AcroButtonFlags.PushButton)) {
    return PDFAcroPushButton_default.fromDict(dict, ref);
  } else if (flagIsSet(flags2, AcroButtonFlags.Radio)) {
    return PDFAcroRadioButton_default.fromDict(dict, ref);
  } else {
    return PDFAcroCheckBox_default.fromDict(dict, ref);
  }
};
var createPDFAcroChoice = function(dict, ref) {
  var _a;
  var ffNumberOrRef = getInheritableAttribute(dict, PDFName_default.of("Ff"));
  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_default);
  var flags2 = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
  if (flagIsSet(flags2, AcroChoiceFlags.Combo)) {
    return PDFAcroComboBox_default.fromDict(dict, ref);
  } else {
    return PDFAcroListBox_default.fromDict(dict, ref);
  }
};
var flagIsSet = function(flags2, flag3) {
  return (flags2 & flag3) !== 0;
};
var getInheritableAttribute = function(startNode, name2) {
  var attribute;
  ascend(startNode, function(node) {
    if (!attribute)
      attribute = node.get(name2);
  });
  return attribute;
};
var ascend = function(startNode, visitor) {
  visitor(startNode);
  var Parent = startNode.lookupMaybe(PDFName_default.of("Parent"), PDFDict_default);
  if (Parent)
    ascend(Parent, visitor);
};

// node_modules/pdf-lib/es/core/acroform/PDFAcroForm.js
var PDFAcroForm = (
  /** @class */
  function() {
    function PDFAcroForm2(dict) {
      this.dict = dict;
    }
    PDFAcroForm2.prototype.Fields = function() {
      var fields = this.dict.lookup(PDFName_default.of("Fields"));
      if (fields instanceof PDFArray_default)
        return fields;
      return void 0;
    };
    PDFAcroForm2.prototype.getFields = function() {
      var Fields = this.normalizedEntries().Fields;
      var fields = new Array(Fields.size());
      for (var idx = 0, len = Fields.size(); idx < len; idx++) {
        var ref = Fields.get(idx);
        var dict = Fields.lookup(idx, PDFDict_default);
        fields[idx] = [createPDFAcroField(dict, ref), ref];
      }
      return fields;
    };
    PDFAcroForm2.prototype.getAllFields = function() {
      var allFields = [];
      var pushFields = function(fields) {
        if (!fields)
          return;
        for (var idx = 0, len = fields.length; idx < len; idx++) {
          var field = fields[idx];
          allFields.push(field);
          var fieldModel = field[0];
          if (fieldModel instanceof PDFAcroNonTerminal_default) {
            pushFields(createPDFAcroFields(fieldModel.Kids()));
          }
        }
      };
      pushFields(this.getFields());
      return allFields;
    };
    PDFAcroForm2.prototype.addField = function(field) {
      var Fields = this.normalizedEntries().Fields;
      Fields === null || Fields === void 0 ? void 0 : Fields.push(field);
    };
    PDFAcroForm2.prototype.removeField = function(field) {
      var parent = field.getParent();
      var fields = parent === void 0 ? this.normalizedEntries().Fields : parent.Kids();
      var index = fields === null || fields === void 0 ? void 0 : fields.indexOf(field.ref);
      if (fields === void 0 || index === void 0) {
        throw new Error("Tried to remove inexistent field " + field.getFullyQualifiedName());
      }
      fields.remove(index);
      if (parent !== void 0 && fields.size() === 0) {
        this.removeField(parent);
      }
    };
    PDFAcroForm2.prototype.normalizedEntries = function() {
      var Fields = this.Fields();
      if (!Fields) {
        Fields = this.dict.context.obj([]);
        this.dict.set(PDFName_default.of("Fields"), Fields);
      }
      return { Fields };
    };
    PDFAcroForm2.fromDict = function(dict) {
      return new PDFAcroForm2(dict);
    };
    PDFAcroForm2.create = function(context) {
      var dict = context.obj({ Fields: [] });
      return new PDFAcroForm2(dict);
    };
    return PDFAcroForm2;
  }()
);
var PDFAcroForm_default = PDFAcroForm;

// node_modules/pdf-lib/es/core/structures/PDFCatalog.js
var PDFCatalog = (
  /** @class */
  function(_super) {
    __extends(PDFCatalog2, _super);
    function PDFCatalog2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFCatalog2.prototype.Pages = function() {
      return this.lookup(PDFName_default.of("Pages"), PDFDict_default);
    };
    PDFCatalog2.prototype.AcroForm = function() {
      return this.lookupMaybe(PDFName_default.of("AcroForm"), PDFDict_default);
    };
    PDFCatalog2.prototype.getAcroForm = function() {
      var dict = this.AcroForm();
      if (!dict)
        return void 0;
      return PDFAcroForm_default.fromDict(dict);
    };
    PDFCatalog2.prototype.getOrCreateAcroForm = function() {
      var acroForm = this.getAcroForm();
      if (!acroForm) {
        acroForm = PDFAcroForm_default.create(this.context);
        var acroFormRef = this.context.register(acroForm.dict);
        this.set(PDFName_default.of("AcroForm"), acroFormRef);
      }
      return acroForm;
    };
    PDFCatalog2.prototype.ViewerPreferences = function() {
      return this.lookupMaybe(PDFName_default.of("ViewerPreferences"), PDFDict_default);
    };
    PDFCatalog2.prototype.getViewerPreferences = function() {
      var dict = this.ViewerPreferences();
      if (!dict)
        return void 0;
      return ViewerPreferences_default.fromDict(dict);
    };
    PDFCatalog2.prototype.getOrCreateViewerPreferences = function() {
      var viewerPrefs = this.getViewerPreferences();
      if (!viewerPrefs) {
        viewerPrefs = ViewerPreferences_default.create(this.context);
        var viewerPrefsRef = this.context.register(viewerPrefs.dict);
        this.set(PDFName_default.of("ViewerPreferences"), viewerPrefsRef);
      }
      return viewerPrefs;
    };
    PDFCatalog2.prototype.insertLeafNode = function(leafRef, index) {
      var pagesRef = this.get(PDFName_default.of("Pages"));
      var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);
      return maybeParentRef || pagesRef;
    };
    PDFCatalog2.prototype.removeLeafNode = function(index) {
      this.Pages().removeLeafNode(index);
    };
    PDFCatalog2.withContextAndPages = function(context, pages) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName_default.of("Type"), PDFName_default.of("Catalog"));
      dict.set(PDFName_default.of("Pages"), pages);
      return new PDFCatalog2(dict, context);
    };
    PDFCatalog2.fromMapWithContext = function(map, context) {
      return new PDFCatalog2(map, context);
    };
    return PDFCatalog2;
  }(PDFDict_default)
);
var PDFCatalog_default = PDFCatalog;

// node_modules/pdf-lib/es/core/structures/PDFPageTree.js
var PDFPageTree = (
  /** @class */
  function(_super) {
    __extends(PDFPageTree2, _super);
    function PDFPageTree2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFPageTree2.prototype.Parent = function() {
      return this.lookup(PDFName_default.of("Parent"));
    };
    PDFPageTree2.prototype.Kids = function() {
      return this.lookup(PDFName_default.of("Kids"), PDFArray_default);
    };
    PDFPageTree2.prototype.Count = function() {
      return this.lookup(PDFName_default.of("Count"), PDFNumber_default);
    };
    PDFPageTree2.prototype.pushTreeNode = function(treeRef) {
      var Kids = this.Kids();
      Kids.push(treeRef);
    };
    PDFPageTree2.prototype.pushLeafNode = function(leafRef) {
      var Kids = this.Kids();
      this.insertLeafKid(Kids.size(), leafRef);
    };
    PDFPageTree2.prototype.insertLeafNode = function(leafRef, targetIndex) {
      var Kids = this.Kids();
      var Count = this.Count().asNumber();
      if (targetIndex > Count) {
        throw new InvalidTargetIndexError(targetIndex, Count);
      }
      var leafsRemainingUntilTarget = targetIndex;
      for (var idx = 0, len = Kids.size(); idx < len; idx++) {
        if (leafsRemainingUntilTarget === 0) {
          this.insertLeafKid(idx, leafRef);
          return void 0;
        }
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2) {
          if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
            return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;
          } else {
            leafsRemainingUntilTarget -= kid.Count().asNumber();
          }
        }
        if (kid instanceof PDFPageLeaf_default) {
          leafsRemainingUntilTarget -= 1;
        }
      }
      if (leafsRemainingUntilTarget === 0) {
        this.insertLeafKid(Kids.size(), leafRef);
        return void 0;
      }
      throw new CorruptPageTreeError(targetIndex, "insertLeafNode");
    };
    PDFPageTree2.prototype.removeLeafNode = function(targetIndex, prune) {
      if (prune === void 0) {
        prune = true;
      }
      var Kids = this.Kids();
      var Count = this.Count().asNumber();
      if (targetIndex >= Count) {
        throw new InvalidTargetIndexError(targetIndex, Count);
      }
      var leafsRemainingUntilTarget = targetIndex;
      for (var idx = 0, len = Kids.size(); idx < len; idx++) {
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2) {
          if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
            kid.removeLeafNode(leafsRemainingUntilTarget, prune);
            if (prune && kid.Kids().size() === 0)
              Kids.remove(idx);
            return;
          } else {
            leafsRemainingUntilTarget -= kid.Count().asNumber();
          }
        }
        if (kid instanceof PDFPageLeaf_default) {
          if (leafsRemainingUntilTarget === 0) {
            this.removeKid(idx);
            return;
          } else {
            leafsRemainingUntilTarget -= 1;
          }
        }
      }
      throw new CorruptPageTreeError(targetIndex, "removeLeafNode");
    };
    PDFPageTree2.prototype.ascend = function(visitor) {
      visitor(this);
      var Parent = this.Parent();
      if (Parent)
        Parent.ascend(visitor);
    };
    PDFPageTree2.prototype.traverse = function(visitor) {
      var Kids = this.Kids();
      for (var idx = 0, len = Kids.size(); idx < len; idx++) {
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2)
          kid.traverse(visitor);
        visitor(kid, kidRef);
      }
    };
    PDFPageTree2.prototype.insertLeafKid = function(kidIdx, leafRef) {
      var Kids = this.Kids();
      this.ascend(function(node) {
        var newCount = node.Count().asNumber() + 1;
        node.set(PDFName_default.of("Count"), PDFNumber_default.of(newCount));
      });
      Kids.insert(kidIdx, leafRef);
    };
    PDFPageTree2.prototype.removeKid = function(kidIdx) {
      var Kids = this.Kids();
      var kid = Kids.lookup(kidIdx);
      if (kid instanceof PDFPageLeaf_default) {
        this.ascend(function(node) {
          var newCount = node.Count().asNumber() - 1;
          node.set(PDFName_default.of("Count"), PDFNumber_default.of(newCount));
        });
      }
      Kids.remove(kidIdx);
    };
    PDFPageTree2.withContext = function(context, parent) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName_default.of("Type"), PDFName_default.of("Pages"));
      dict.set(PDFName_default.of("Kids"), context.obj([]));
      dict.set(PDFName_default.of("Count"), context.obj(0));
      if (parent)
        dict.set(PDFName_default.of("Parent"), parent);
      return new PDFPageTree2(dict, context);
    };
    PDFPageTree2.fromMapWithContext = function(map, context) {
      return new PDFPageTree2(map, context);
    };
    return PDFPageTree2;
  }(PDFDict_default)
);
var PDFPageTree_default = PDFPageTree;

// node_modules/pdf-lib/es/core/syntax/Numeric.js
var IsDigit = new Uint8Array(256);
IsDigit[CharCodes_default.Zero] = 1;
IsDigit[CharCodes_default.One] = 1;
IsDigit[CharCodes_default.Two] = 1;
IsDigit[CharCodes_default.Three] = 1;
IsDigit[CharCodes_default.Four] = 1;
IsDigit[CharCodes_default.Five] = 1;
IsDigit[CharCodes_default.Six] = 1;
IsDigit[CharCodes_default.Seven] = 1;
IsDigit[CharCodes_default.Eight] = 1;
IsDigit[CharCodes_default.Nine] = 1;
var IsNumericPrefix = new Uint8Array(256);
IsNumericPrefix[CharCodes_default.Period] = 1;
IsNumericPrefix[CharCodes_default.Plus] = 1;
IsNumericPrefix[CharCodes_default.Minus] = 1;
var IsNumeric = new Uint8Array(256);
for (idx = 0, len = 256; idx < len; idx++) {
  IsNumeric[idx] = IsDigit[idx] || IsNumericPrefix[idx] ? 1 : 0;
}
var idx;
var len;

// node_modules/pdf-lib/es/core/parser/BaseParser.js
var Newline = CharCodes_default.Newline;
var CarriageReturn = CharCodes_default.CarriageReturn;
var BaseParser = (
  /** @class */
  function() {
    function BaseParser2(bytes, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      this.bytes = bytes;
      this.capNumbers = capNumbers;
    }
    BaseParser2.prototype.parseRawInt = function() {
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsDigit[byte])
          break;
        value += charFromCode(this.bytes.next());
      }
      var numberValue = Number(value);
      if (!value || !isFinite(numberValue)) {
        throw new NumberParsingError(this.bytes.position(), value);
      }
      return numberValue;
    };
    BaseParser2.prototype.parseRawNumber = function() {
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsNumeric[byte])
          break;
        value += charFromCode(this.bytes.next());
        if (byte === CharCodes_default.Period)
          break;
      }
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsDigit[byte])
          break;
        value += charFromCode(this.bytes.next());
      }
      var numberValue = Number(value);
      if (!value || !isFinite(numberValue)) {
        throw new NumberParsingError(this.bytes.position(), value);
      }
      if (numberValue > Number.MAX_SAFE_INTEGER) {
        if (this.capNumbers) {
          var msg = "Parsed number that is too large for some PDF readers: " + value + ", using Number.MAX_SAFE_INTEGER instead.";
          console.warn(msg);
          return Number.MAX_SAFE_INTEGER;
        } else {
          var msg = "Parsed number that is too large for some PDF readers: " + value + ", not capping.";
          console.warn(msg);
        }
      }
      return numberValue;
    };
    BaseParser2.prototype.skipWhitespace = function() {
      while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {
        this.bytes.next();
      }
    };
    BaseParser2.prototype.skipLine = function() {
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (byte === Newline || byte === CarriageReturn)
          return;
        this.bytes.next();
      }
    };
    BaseParser2.prototype.skipComment = function() {
      if (this.bytes.peek() !== CharCodes_default.Percent)
        return false;
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (byte === Newline || byte === CarriageReturn)
          return true;
        this.bytes.next();
      }
      return true;
    };
    BaseParser2.prototype.skipWhitespaceAndComments = function() {
      this.skipWhitespace();
      while (this.skipComment())
        this.skipWhitespace();
    };
    BaseParser2.prototype.matchKeyword = function(keyword) {
      var initialOffset = this.bytes.offset();
      for (var idx = 0, len = keyword.length; idx < len; idx++) {
        if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {
          this.bytes.moveTo(initialOffset);
          return false;
        }
      }
      return true;
    };
    return BaseParser2;
  }()
);
var BaseParser_default = BaseParser;

// node_modules/pdf-lib/es/core/parser/ByteStream.js
var ByteStream = (
  /** @class */
  function() {
    function ByteStream2(bytes) {
      this.idx = 0;
      this.line = 0;
      this.column = 0;
      this.bytes = bytes;
      this.length = this.bytes.length;
    }
    ByteStream2.prototype.moveTo = function(offset) {
      this.idx = offset;
    };
    ByteStream2.prototype.next = function() {
      var byte = this.bytes[this.idx++];
      if (byte === CharCodes_default.Newline) {
        this.line += 1;
        this.column = 0;
      } else {
        this.column += 1;
      }
      return byte;
    };
    ByteStream2.prototype.assertNext = function(expected) {
      if (this.peek() !== expected) {
        throw new NextByteAssertionError(this.position(), expected, this.peek());
      }
      return this.next();
    };
    ByteStream2.prototype.peek = function() {
      return this.bytes[this.idx];
    };
    ByteStream2.prototype.peekAhead = function(steps) {
      return this.bytes[this.idx + steps];
    };
    ByteStream2.prototype.peekAt = function(offset) {
      return this.bytes[offset];
    };
    ByteStream2.prototype.done = function() {
      return this.idx >= this.length;
    };
    ByteStream2.prototype.offset = function() {
      return this.idx;
    };
    ByteStream2.prototype.slice = function(start2, end) {
      return this.bytes.slice(start2, end);
    };
    ByteStream2.prototype.position = function() {
      return { line: this.line, column: this.column, offset: this.idx };
    };
    ByteStream2.of = function(bytes) {
      return new ByteStream2(bytes);
    };
    ByteStream2.fromPDFRawStream = function(rawStream) {
      return ByteStream2.of(decodePDFRawStream(rawStream).decode());
    };
    return ByteStream2;
  }()
);
var ByteStream_default = ByteStream;

// node_modules/pdf-lib/es/core/syntax/Keywords.js
var Space = CharCodes_default.Space;
var CarriageReturn2 = CharCodes_default.CarriageReturn;
var Newline2 = CharCodes_default.Newline;
var stream = [
  CharCodes_default.s,
  CharCodes_default.t,
  CharCodes_default.r,
  CharCodes_default.e,
  CharCodes_default.a,
  CharCodes_default.m
];
var endstream = [
  CharCodes_default.e,
  CharCodes_default.n,
  CharCodes_default.d,
  CharCodes_default.s,
  CharCodes_default.t,
  CharCodes_default.r,
  CharCodes_default.e,
  CharCodes_default.a,
  CharCodes_default.m
];
var Keywords = {
  header: [
    CharCodes_default.Percent,
    CharCodes_default.P,
    CharCodes_default.D,
    CharCodes_default.F,
    CharCodes_default.Dash
  ],
  eof: [
    CharCodes_default.Percent,
    CharCodes_default.Percent,
    CharCodes_default.E,
    CharCodes_default.O,
    CharCodes_default.F
  ],
  obj: [CharCodes_default.o, CharCodes_default.b, CharCodes_default.j],
  endobj: [
    CharCodes_default.e,
    CharCodes_default.n,
    CharCodes_default.d,
    CharCodes_default.o,
    CharCodes_default.b,
    CharCodes_default.j
  ],
  xref: [CharCodes_default.x, CharCodes_default.r, CharCodes_default.e, CharCodes_default.f],
  trailer: [
    CharCodes_default.t,
    CharCodes_default.r,
    CharCodes_default.a,
    CharCodes_default.i,
    CharCodes_default.l,
    CharCodes_default.e,
    CharCodes_default.r
  ],
  startxref: [
    CharCodes_default.s,
    CharCodes_default.t,
    CharCodes_default.a,
    CharCodes_default.r,
    CharCodes_default.t,
    CharCodes_default.x,
    CharCodes_default.r,
    CharCodes_default.e,
    CharCodes_default.f
  ],
  true: [CharCodes_default.t, CharCodes_default.r, CharCodes_default.u, CharCodes_default.e],
  false: [CharCodes_default.f, CharCodes_default.a, CharCodes_default.l, CharCodes_default.s, CharCodes_default.e],
  null: [CharCodes_default.n, CharCodes_default.u, CharCodes_default.l, CharCodes_default.l],
  stream,
  streamEOF1: __spreadArrays(stream, [Space, CarriageReturn2, Newline2]),
  streamEOF2: __spreadArrays(stream, [CarriageReturn2, Newline2]),
  streamEOF3: __spreadArrays(stream, [CarriageReturn2]),
  streamEOF4: __spreadArrays(stream, [Newline2]),
  endstream,
  EOF1endstream: __spreadArrays([CarriageReturn2, Newline2], endstream),
  EOF2endstream: __spreadArrays([CarriageReturn2], endstream),
  EOF3endstream: __spreadArrays([Newline2], endstream)
};

// node_modules/pdf-lib/es/core/parser/PDFObjectParser.js
var PDFObjectParser = (
  /** @class */
  function(_super) {
    __extends(PDFObjectParser2, _super);
    function PDFObjectParser2(byteStream, context, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      var _this = _super.call(this, byteStream, capNumbers) || this;
      _this.context = context;
      return _this;
    }
    PDFObjectParser2.prototype.parseObject = function() {
      this.skipWhitespaceAndComments();
      if (this.matchKeyword(Keywords.true))
        return PDFBool_default.True;
      if (this.matchKeyword(Keywords.false))
        return PDFBool_default.False;
      if (this.matchKeyword(Keywords.null))
        return PDFNull_default;
      var byte = this.bytes.peek();
      if (byte === CharCodes_default.LessThan && this.bytes.peekAhead(1) === CharCodes_default.LessThan) {
        return this.parseDictOrStream();
      }
      if (byte === CharCodes_default.LessThan)
        return this.parseHexString();
      if (byte === CharCodes_default.LeftParen)
        return this.parseString();
      if (byte === CharCodes_default.ForwardSlash)
        return this.parseName();
      if (byte === CharCodes_default.LeftSquareBracket)
        return this.parseArray();
      if (IsNumeric[byte])
        return this.parseNumberOrRef();
      throw new PDFObjectParsingError(this.bytes.position(), byte);
    };
    PDFObjectParser2.prototype.parseNumberOrRef = function() {
      var firstNum = this.parseRawNumber();
      this.skipWhitespaceAndComments();
      var lookaheadStart = this.bytes.offset();
      if (IsDigit[this.bytes.peek()]) {
        var secondNum = this.parseRawNumber();
        this.skipWhitespaceAndComments();
        if (this.bytes.peek() === CharCodes_default.R) {
          this.bytes.assertNext(CharCodes_default.R);
          return PDFRef_default.of(firstNum, secondNum);
        }
      }
      this.bytes.moveTo(lookaheadStart);
      return PDFNumber_default.of(firstNum);
    };
    PDFObjectParser2.prototype.parseHexString = function() {
      var value = "";
      this.bytes.assertNext(CharCodes_default.LessThan);
      while (!this.bytes.done() && this.bytes.peek() !== CharCodes_default.GreaterThan) {
        value += charFromCode(this.bytes.next());
      }
      this.bytes.assertNext(CharCodes_default.GreaterThan);
      return PDFHexString_default.of(value);
    };
    PDFObjectParser2.prototype.parseString = function() {
      var nestingLvl = 0;
      var isEscaped = false;
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.next();
        value += charFromCode(byte);
        if (!isEscaped) {
          if (byte === CharCodes_default.LeftParen)
            nestingLvl += 1;
          if (byte === CharCodes_default.RightParen)
            nestingLvl -= 1;
        }
        if (byte === CharCodes_default.BackSlash) {
          isEscaped = !isEscaped;
        } else if (isEscaped) {
          isEscaped = false;
        }
        if (nestingLvl === 0) {
          return PDFString_default.of(value.substring(1, value.length - 1));
        }
      }
      throw new UnbalancedParenthesisError(this.bytes.position());
    };
    PDFObjectParser2.prototype.parseName = function() {
      this.bytes.assertNext(CharCodes_default.ForwardSlash);
      var name2 = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (IsWhitespace[byte] || IsDelimiter[byte])
          break;
        name2 += charFromCode(byte);
        this.bytes.next();
      }
      return PDFName_default.of(name2);
    };
    PDFObjectParser2.prototype.parseArray = function() {
      this.bytes.assertNext(CharCodes_default.LeftSquareBracket);
      this.skipWhitespaceAndComments();
      var pdfArray = PDFArray_default.withContext(this.context);
      while (this.bytes.peek() !== CharCodes_default.RightSquareBracket) {
        var element = this.parseObject();
        pdfArray.push(element);
        this.skipWhitespaceAndComments();
      }
      this.bytes.assertNext(CharCodes_default.RightSquareBracket);
      return pdfArray;
    };
    PDFObjectParser2.prototype.parseDict = function() {
      this.bytes.assertNext(CharCodes_default.LessThan);
      this.bytes.assertNext(CharCodes_default.LessThan);
      this.skipWhitespaceAndComments();
      var dict = /* @__PURE__ */ new Map();
      while (!this.bytes.done() && this.bytes.peek() !== CharCodes_default.GreaterThan && this.bytes.peekAhead(1) !== CharCodes_default.GreaterThan) {
        var key = this.parseName();
        var value = this.parseObject();
        dict.set(key, value);
        this.skipWhitespaceAndComments();
      }
      this.skipWhitespaceAndComments();
      this.bytes.assertNext(CharCodes_default.GreaterThan);
      this.bytes.assertNext(CharCodes_default.GreaterThan);
      var Type = dict.get(PDFName_default.of("Type"));
      if (Type === PDFName_default.of("Catalog")) {
        return PDFCatalog_default.fromMapWithContext(dict, this.context);
      } else if (Type === PDFName_default.of("Pages")) {
        return PDFPageTree_default.fromMapWithContext(dict, this.context);
      } else if (Type === PDFName_default.of("Page")) {
        return PDFPageLeaf_default.fromMapWithContext(dict, this.context);
      } else {
        return PDFDict_default.fromMapWithContext(dict, this.context);
      }
    };
    PDFObjectParser2.prototype.parseDictOrStream = function() {
      var startPos = this.bytes.position();
      var dict = this.parseDict();
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {
        return dict;
      }
      var start2 = this.bytes.offset();
      var end;
      var Length = dict.get(PDFName_default.of("Length"));
      if (Length instanceof PDFNumber_default) {
        end = start2 + Length.asNumber();
        this.bytes.moveTo(end);
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.endstream)) {
          this.bytes.moveTo(start2);
          end = this.findEndOfStreamFallback(startPos);
        }
      } else {
        end = this.findEndOfStreamFallback(startPos);
      }
      var contents = this.bytes.slice(start2, end);
      return PDFRawStream_default.of(dict, contents);
    };
    PDFObjectParser2.prototype.findEndOfStreamFallback = function(startPos) {
      var nestingLvl = 1;
      var end = this.bytes.offset();
      while (!this.bytes.done()) {
        end = this.bytes.offset();
        if (this.matchKeyword(Keywords.stream)) {
          nestingLvl += 1;
        } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {
          nestingLvl -= 1;
        } else {
          this.bytes.next();
        }
        if (nestingLvl === 0)
          break;
      }
      if (nestingLvl !== 0)
        throw new PDFStreamParsingError(startPos);
      return end;
    };
    PDFObjectParser2.forBytes = function(bytes, context, capNumbers) {
      return new PDFObjectParser2(ByteStream_default.of(bytes), context, capNumbers);
    };
    PDFObjectParser2.forByteStream = function(byteStream, context, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      return new PDFObjectParser2(byteStream, context, capNumbers);
    };
    return PDFObjectParser2;
  }(BaseParser_default)
);
var PDFObjectParser_default = PDFObjectParser;

// node_modules/pdf-lib/es/core/parser/PDFObjectStreamParser.js
var PDFObjectStreamParser = (
  /** @class */
  function(_super) {
    __extends(PDFObjectStreamParser2, _super);
    function PDFObjectStreamParser2(rawStream, shouldWaitForTick) {
      var _this = _super.call(this, ByteStream_default.fromPDFRawStream(rawStream), rawStream.dict.context) || this;
      var dict = rawStream.dict;
      _this.alreadyParsed = false;
      _this.shouldWaitForTick = shouldWaitForTick || function() {
        return false;
      };
      _this.firstOffset = dict.lookup(PDFName_default.of("First"), PDFNumber_default).asNumber();
      _this.objectCount = dict.lookup(PDFName_default.of("N"), PDFNumber_default).asNumber();
      return _this;
    }
    PDFObjectStreamParser2.prototype.parseIntoContext = function() {
      return __awaiter(this, void 0, void 0, function() {
        var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset, object, ref;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (this.alreadyParsed) {
                throw new ReparseError("PDFObjectStreamParser", "parseIntoContext");
              }
              this.alreadyParsed = true;
              offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();
              idx = 0, len = offsetsAndObjectNumbers.length;
              _b.label = 1;
            case 1:
              if (!(idx < len))
                return [3, 4];
              _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset = _a.offset;
              this.bytes.moveTo(this.firstOffset + offset);
              object = this.parseObject();
              ref = PDFRef_default.of(objectNumber, 0);
              this.context.assign(ref, object);
              if (!this.shouldWaitForTick())
                return [3, 3];
              return [4, waitForTick()];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFObjectStreamParser2.prototype.parseOffsetsAndObjectNumbers = function() {
      var offsetsAndObjectNumbers = [];
      for (var idx = 0, len = this.objectCount; idx < len; idx++) {
        this.skipWhitespaceAndComments();
        var objectNumber = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var offset = this.parseRawInt();
        offsetsAndObjectNumbers.push({ objectNumber, offset });
      }
      return offsetsAndObjectNumbers;
    };
    PDFObjectStreamParser2.forStream = function(rawStream, shouldWaitForTick) {
      return new PDFObjectStreamParser2(rawStream, shouldWaitForTick);
    };
    return PDFObjectStreamParser2;
  }(PDFObjectParser_default)
);
var PDFObjectStreamParser_default = PDFObjectStreamParser;

// node_modules/pdf-lib/es/core/parser/PDFXRefStreamParser.js
var PDFXRefStreamParser = (
  /** @class */
  function() {
    function PDFXRefStreamParser2(rawStream) {
      this.alreadyParsed = false;
      this.dict = rawStream.dict;
      this.bytes = ByteStream_default.fromPDFRawStream(rawStream);
      this.context = this.dict.context;
      var Size = this.dict.lookup(PDFName_default.of("Size"), PDFNumber_default);
      var Index = this.dict.lookup(PDFName_default.of("Index"));
      if (Index instanceof PDFArray_default) {
        this.subsections = [];
        for (var idx = 0, len = Index.size(); idx < len; idx += 2) {
          var firstObjectNumber = Index.lookup(idx + 0, PDFNumber_default).asNumber();
          var length_1 = Index.lookup(idx + 1, PDFNumber_default).asNumber();
          this.subsections.push({ firstObjectNumber, length: length_1 });
        }
      } else {
        this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];
      }
      var W5 = this.dict.lookup(PDFName_default.of("W"), PDFArray_default);
      this.byteWidths = [-1, -1, -1];
      for (var idx = 0, len = W5.size(); idx < len; idx++) {
        this.byteWidths[idx] = W5.lookup(idx, PDFNumber_default).asNumber();
      }
    }
    PDFXRefStreamParser2.prototype.parseIntoContext = function() {
      if (this.alreadyParsed) {
        throw new ReparseError("PDFXRefStreamParser", "parseIntoContext");
      }
      this.alreadyParsed = true;
      this.context.trailerInfo = {
        Root: this.dict.get(PDFName_default.of("Root")),
        Encrypt: this.dict.get(PDFName_default.of("Encrypt")),
        Info: this.dict.get(PDFName_default.of("Info")),
        ID: this.dict.get(PDFName_default.of("ID"))
      };
      var entries = this.parseEntries();
      return entries;
    };
    PDFXRefStreamParser2.prototype.parseEntries = function() {
      var entries = [];
      var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];
      for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {
        var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;
        for (var objIdx = 0; objIdx < length_2; objIdx++) {
          var type = 0;
          for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {
            type = type << 8 | this.bytes.next();
          }
          var offset = 0;
          for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {
            offset = offset << 8 | this.bytes.next();
          }
          var generationNumber = 0;
          for (var idx = 0, len = genFieldWidth; idx < len; idx++) {
            generationNumber = generationNumber << 8 | this.bytes.next();
          }
          if (typeFieldWidth === 0)
            type = 1;
          var objectNumber = firstObjectNumber + objIdx;
          var entry = {
            ref: PDFRef_default.of(objectNumber, generationNumber),
            offset,
            deleted: type === 0,
            inObjectStream: type === 2
          };
          entries.push(entry);
        }
      }
      return entries;
    };
    PDFXRefStreamParser2.forStream = function(rawStream) {
      return new PDFXRefStreamParser2(rawStream);
    };
    return PDFXRefStreamParser2;
  }()
);
var PDFXRefStreamParser_default = PDFXRefStreamParser;

// node_modules/pdf-lib/es/core/parser/PDFParser.js
var PDFParser = (
  /** @class */
  function(_super) {
    __extends(PDFParser2, _super);
    function PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
      if (objectsPerTick === void 0) {
        objectsPerTick = Infinity;
      }
      if (throwOnInvalidObject === void 0) {
        throwOnInvalidObject = false;
      }
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      var _this = _super.call(this, ByteStream_default.of(pdfBytes), PDFContext_default.create(), capNumbers) || this;
      _this.alreadyParsed = false;
      _this.parsedObjects = 0;
      _this.shouldWaitForTick = function() {
        _this.parsedObjects += 1;
        return _this.parsedObjects % _this.objectsPerTick === 0;
      };
      _this.objectsPerTick = objectsPerTick;
      _this.throwOnInvalidObject = throwOnInvalidObject;
      return _this;
    }
    PDFParser2.prototype.parseDocument = function() {
      return __awaiter(this, void 0, void 0, function() {
        var prevOffset, offset;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (this.alreadyParsed) {
                throw new ReparseError("PDFParser", "parseDocument");
              }
              this.alreadyParsed = true;
              this.context.header = this.parseHeader();
              _a.label = 1;
            case 1:
              if (!!this.bytes.done())
                return [3, 3];
              return [4, this.parseDocumentSection()];
            case 2:
              _a.sent();
              offset = this.bytes.offset();
              if (offset === prevOffset) {
                throw new StalledParserError(this.bytes.position());
              }
              prevOffset = offset;
              return [3, 1];
            case 3:
              this.maybeRecoverRoot();
              if (this.context.lookup(PDFRef_default.of(0))) {
                console.warn("Removing parsed object: 0 0 R");
                this.context.delete(PDFRef_default.of(0));
              }
              return [2, this.context];
          }
        });
      });
    };
    PDFParser2.prototype.maybeRecoverRoot = function() {
      var isValidCatalog = function(obj) {
        return obj instanceof PDFDict_default && obj.lookup(PDFName_default.of("Type")) === PDFName_default.of("Catalog");
      };
      var catalog = this.context.lookup(this.context.trailerInfo.Root);
      if (!isValidCatalog(catalog)) {
        var indirectObjects = this.context.enumerateIndirectObjects();
        for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {
          var _a = indirectObjects[idx], ref = _a[0], object = _a[1];
          if (isValidCatalog(object)) {
            this.context.trailerInfo.Root = ref;
          }
        }
      }
    };
    PDFParser2.prototype.parseHeader = function() {
      while (!this.bytes.done()) {
        if (this.matchKeyword(Keywords.header)) {
          var major = this.parseRawInt();
          this.bytes.assertNext(CharCodes_default.Period);
          var minor = this.parseRawInt();
          var header = PDFHeader_default.forVersion(major, minor);
          this.skipBinaryHeaderComment();
          return header;
        }
        this.bytes.next();
      }
      throw new MissingPDFHeaderError(this.bytes.position());
    };
    PDFParser2.prototype.parseIndirectObjectHeader = function() {
      this.skipWhitespaceAndComments();
      var objectNumber = this.parseRawInt();
      this.skipWhitespaceAndComments();
      var generationNumber = this.parseRawInt();
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.obj)) {
        throw new MissingKeywordError(this.bytes.position(), Keywords.obj);
      }
      return PDFRef_default.of(objectNumber, generationNumber);
    };
    PDFParser2.prototype.matchIndirectObjectHeader = function() {
      var initialOffset = this.bytes.offset();
      try {
        this.parseIndirectObjectHeader();
        return true;
      } catch (e) {
        this.bytes.moveTo(initialOffset);
        return false;
      }
    };
    PDFParser2.prototype.parseIndirectObject = function() {
      return __awaiter(this, void 0, void 0, function() {
        var ref, object;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              ref = this.parseIndirectObjectHeader();
              this.skipWhitespaceAndComments();
              object = this.parseObject();
              this.skipWhitespaceAndComments();
              this.matchKeyword(Keywords.endobj);
              if (!(object instanceof PDFRawStream_default && object.dict.lookup(PDFName_default.of("Type")) === PDFName_default.of("ObjStm")))
                return [3, 2];
              return [4, PDFObjectStreamParser_default.forStream(object, this.shouldWaitForTick).parseIntoContext()];
            case 1:
              _a.sent();
              return [3, 3];
            case 2:
              if (object instanceof PDFRawStream_default && object.dict.lookup(PDFName_default.of("Type")) === PDFName_default.of("XRef")) {
                PDFXRefStreamParser_default.forStream(object).parseIntoContext();
              } else {
                this.context.assign(ref, object);
              }
              _a.label = 3;
            case 3:
              return [2, ref];
          }
        });
      });
    };
    PDFParser2.prototype.tryToParseInvalidIndirectObject = function() {
      var startPos = this.bytes.position();
      var msg = "Trying to parse invalid object: " + JSON.stringify(startPos) + ")";
      if (this.throwOnInvalidObject)
        throw new Error(msg);
      console.warn(msg);
      var ref = this.parseIndirectObjectHeader();
      console.warn("Invalid object ref: " + ref);
      this.skipWhitespaceAndComments();
      var start2 = this.bytes.offset();
      var failed = true;
      while (!this.bytes.done()) {
        if (this.matchKeyword(Keywords.endobj)) {
          failed = false;
        }
        if (!failed)
          break;
        this.bytes.next();
      }
      if (failed)
        throw new PDFInvalidObjectParsingError(startPos);
      var end = this.bytes.offset() - Keywords.endobj.length;
      var object = PDFInvalidObject_default.of(this.bytes.slice(start2, end));
      this.context.assign(ref, object);
      return ref;
    };
    PDFParser2.prototype.parseIndirectObjects = function() {
      return __awaiter(this, void 0, void 0, function() {
        var initialOffset, e_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.skipWhitespaceAndComments();
              _a.label = 1;
            case 1:
              if (!(!this.bytes.done() && IsDigit[this.bytes.peek()]))
                return [3, 8];
              initialOffset = this.bytes.offset();
              _a.label = 2;
            case 2:
              _a.trys.push([2, 4, , 5]);
              return [4, this.parseIndirectObject()];
            case 3:
              _a.sent();
              return [3, 5];
            case 4:
              e_1 = _a.sent();
              this.bytes.moveTo(initialOffset);
              this.tryToParseInvalidIndirectObject();
              return [3, 5];
            case 5:
              this.skipWhitespaceAndComments();
              this.skipJibberish();
              if (!this.shouldWaitForTick())
                return [3, 7];
              return [4, waitForTick()];
            case 6:
              _a.sent();
              _a.label = 7;
            case 7:
              return [3, 1];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFParser2.prototype.maybeParseCrossRefSection = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.xref))
        return;
      this.skipWhitespaceAndComments();
      var objectNumber = -1;
      var xref = PDFCrossRefSection_default.createEmpty();
      while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {
        var firstInt = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var secondInt = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var byte = this.bytes.peek();
        if (byte === CharCodes_default.n || byte === CharCodes_default.f) {
          var ref = PDFRef_default.of(objectNumber, secondInt);
          if (this.bytes.next() === CharCodes_default.n) {
            xref.addEntry(ref, firstInt);
          } else {
            xref.addDeletedEntry(ref, firstInt);
          }
          objectNumber += 1;
        } else {
          objectNumber = firstInt;
        }
        this.skipWhitespaceAndComments();
      }
      return xref;
    };
    PDFParser2.prototype.maybeParseTrailerDict = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.trailer))
        return;
      this.skipWhitespaceAndComments();
      var dict = this.parseDict();
      var context = this.context;
      context.trailerInfo = {
        Root: dict.get(PDFName_default.of("Root")) || context.trailerInfo.Root,
        Encrypt: dict.get(PDFName_default.of("Encrypt")) || context.trailerInfo.Encrypt,
        Info: dict.get(PDFName_default.of("Info")) || context.trailerInfo.Info,
        ID: dict.get(PDFName_default.of("ID")) || context.trailerInfo.ID
      };
    };
    PDFParser2.prototype.maybeParseTrailer = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.startxref))
        return;
      this.skipWhitespaceAndComments();
      var offset = this.parseRawInt();
      this.skipWhitespace();
      this.matchKeyword(Keywords.eof);
      this.skipWhitespaceAndComments();
      this.matchKeyword(Keywords.eof);
      this.skipWhitespaceAndComments();
      return PDFTrailer_default.forLastCrossRefSectionOffset(offset);
    };
    PDFParser2.prototype.parseDocumentSection = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.parseIndirectObjects()];
            case 1:
              _a.sent();
              this.maybeParseCrossRefSection();
              this.maybeParseTrailerDict();
              this.maybeParseTrailer();
              this.skipJibberish();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFParser2.prototype.skipJibberish = function() {
      this.skipWhitespaceAndComments();
      while (!this.bytes.done()) {
        var initialOffset = this.bytes.offset();
        var byte = this.bytes.peek();
        var isAlphaNumeric = byte >= CharCodes_default.Space && byte <= CharCodes_default.Tilde;
        if (isAlphaNumeric) {
          if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {
            this.bytes.moveTo(initialOffset);
            break;
          }
        }
        this.bytes.next();
      }
    };
    PDFParser2.prototype.skipBinaryHeaderComment = function() {
      this.skipWhitespaceAndComments();
      try {
        var initialOffset = this.bytes.offset();
        this.parseIndirectObjectHeader();
        this.bytes.moveTo(initialOffset);
      } catch (e) {
        this.bytes.next();
        this.skipWhitespaceAndComments();
      }
    };
    PDFParser2.forBytesWithOptions = function(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
      return new PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);
    };
    return PDFParser2;
  }(PDFObjectParser_default)
);
var PDFParser_default = PDFParser;

// node_modules/pdf-lib/es/core/annotation/flags.js
var flag2 = function(bitIndex) {
  return 1 << bitIndex;
};
var AnnotationFlags;
(function(AnnotationFlags2) {
  AnnotationFlags2[AnnotationFlags2["Invisible"] = flag2(1 - 1)] = "Invisible";
  AnnotationFlags2[AnnotationFlags2["Hidden"] = flag2(2 - 1)] = "Hidden";
  AnnotationFlags2[AnnotationFlags2["Print"] = flag2(3 - 1)] = "Print";
  AnnotationFlags2[AnnotationFlags2["NoZoom"] = flag2(4 - 1)] = "NoZoom";
  AnnotationFlags2[AnnotationFlags2["NoRotate"] = flag2(5 - 1)] = "NoRotate";
  AnnotationFlags2[AnnotationFlags2["NoView"] = flag2(6 - 1)] = "NoView";
  AnnotationFlags2[AnnotationFlags2["ReadOnly"] = flag2(7 - 1)] = "ReadOnly";
  AnnotationFlags2[AnnotationFlags2["Locked"] = flag2(8 - 1)] = "Locked";
  AnnotationFlags2[AnnotationFlags2["ToggleNoView"] = flag2(9 - 1)] = "ToggleNoView";
  AnnotationFlags2[AnnotationFlags2["LockedContents"] = flag2(10 - 1)] = "LockedContents";
})(AnnotationFlags || (AnnotationFlags = {}));

// node_modules/pdf-lib/es/api/objects.js
var asPDFName = function(name2) {
  return name2 instanceof PDFName_default ? name2 : PDFName_default.of(name2);
};
var asPDFNumber = function(num) {
  return num instanceof PDFNumber_default ? num : PDFNumber_default.of(num);
};
var asNumber = function(num) {
  return num instanceof PDFNumber_default ? num.asNumber() : num;
};

// node_modules/pdf-lib/es/api/rotations.js
var RotationTypes;
(function(RotationTypes2) {
  RotationTypes2["Degrees"] = "degrees";
  RotationTypes2["Radians"] = "radians";
})(RotationTypes || (RotationTypes = {}));
var degrees = function(degreeAngle) {
  assertIs(degreeAngle, "degreeAngle", ["number"]);
  return { type: RotationTypes.Degrees, angle: degreeAngle };
};
var Radians = RotationTypes.Radians;
var Degrees = RotationTypes.Degrees;
var degreesToRadians = function(degree) {
  return degree * Math.PI / 180;
};
var radiansToDegrees = function(radian) {
  return radian * 180 / Math.PI;
};
var toRadians = function(rotation) {
  return rotation.type === Radians ? rotation.angle : rotation.type === Degrees ? degreesToRadians(rotation.angle) : error("Invalid rotation: " + JSON.stringify(rotation));
};
var toDegrees = function(rotation) {
  return rotation.type === Radians ? radiansToDegrees(rotation.angle) : rotation.type === Degrees ? rotation.angle : error("Invalid rotation: " + JSON.stringify(rotation));
};
var reduceRotation = function(degreeAngle) {
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var quadrants = degreeAngle / 90 % 4;
  if (quadrants === 0)
    return 0;
  if (quadrants === 1)
    return 90;
  if (quadrants === 2)
    return 180;
  if (quadrants === 3)
    return 270;
  return 0;
};
var adjustDimsForRotation = function(dims, degreeAngle) {
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var rotation = reduceRotation(degreeAngle);
  return rotation === 90 || rotation === 270 ? { width: dims.height, height: dims.width } : { width: dims.width, height: dims.height };
};
var rotateRectangle = function(rectangle, borderWidth, degreeAngle) {
  if (borderWidth === void 0) {
    borderWidth = 0;
  }
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var x4 = rectangle.x, y4 = rectangle.y, w6 = rectangle.width, h3 = rectangle.height;
  var r = reduceRotation(degreeAngle);
  var b4 = borderWidth / 2;
  if (r === 0)
    return { x: x4 - b4, y: y4 - b4, width: w6, height: h3 };
  else if (r === 90)
    return { x: x4 - h3 + b4, y: y4 - b4, width: h3, height: w6 };
  else if (r === 180)
    return { x: x4 - w6 + b4, y: y4 - h3 + b4, width: w6, height: h3 };
  else if (r === 270)
    return { x: x4 - b4, y: y4 - w6 + b4, width: h3, height: w6 };
  else
    return { x: x4 - b4, y: y4 - b4, width: w6, height: h3 };
};

// node_modules/pdf-lib/es/api/operators.js
var clip = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.ClipNonZero);
};
var cos = Math.cos;
var sin = Math.sin;
var tan = Math.tan;
var concatTransformationMatrix = function(a2, b4, c2, d3, e, f3) {
  return PDFOperator_default.of(PDFOperatorNames_default.ConcatTransformationMatrix, [
    asPDFNumber(a2),
    asPDFNumber(b4),
    asPDFNumber(c2),
    asPDFNumber(d3),
    asPDFNumber(e),
    asPDFNumber(f3)
  ]);
};
var translate = function(xPos, yPos) {
  return concatTransformationMatrix(1, 0, 0, 1, xPos, yPos);
};
var scale = function(xPos, yPos) {
  return concatTransformationMatrix(xPos, 0, 0, yPos, 0, 0);
};
var rotateRadians = function(angle) {
  return concatTransformationMatrix(cos(asNumber(angle)), sin(asNumber(angle)), -sin(asNumber(angle)), cos(asNumber(angle)), 0, 0);
};
var rotateDegrees = function(angle) {
  return rotateRadians(degreesToRadians(asNumber(angle)));
};
var skewRadians = function(xSkewAngle, ySkewAngle) {
  return concatTransformationMatrix(1, tan(asNumber(xSkewAngle)), tan(asNumber(ySkewAngle)), 1, 0, 0);
};
var setDashPattern = function(dashArray, dashPhase) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetLineDashPattern, [
    "[" + dashArray.map(asPDFNumber).join(" ") + "]",
    asPDFNumber(dashPhase)
  ]);
};
var LineCapStyle;
(function(LineCapStyle2) {
  LineCapStyle2[LineCapStyle2["Butt"] = 0] = "Butt";
  LineCapStyle2[LineCapStyle2["Round"] = 1] = "Round";
  LineCapStyle2[LineCapStyle2["Projecting"] = 2] = "Projecting";
})(LineCapStyle || (LineCapStyle = {}));
var setLineCap = function(style) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetLineCapStyle, [asPDFNumber(style)]);
};
var LineJoinStyle;
(function(LineJoinStyle2) {
  LineJoinStyle2[LineJoinStyle2["Miter"] = 0] = "Miter";
  LineJoinStyle2[LineJoinStyle2["Round"] = 1] = "Round";
  LineJoinStyle2[LineJoinStyle2["Bevel"] = 2] = "Bevel";
})(LineJoinStyle || (LineJoinStyle = {}));
var setGraphicsState = function(state) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetGraphicsStateParams, [asPDFName(state)]);
};
var pushGraphicsState = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.PushGraphicsState);
};
var popGraphicsState = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.PopGraphicsState);
};
var setLineWidth = function(width) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetLineWidth, [asPDFNumber(width)]);
};
var appendBezierCurve = function(x1, y1, x22, y22, x32, y32) {
  return PDFOperator_default.of(PDFOperatorNames_default.AppendBezierCurve, [
    asPDFNumber(x1),
    asPDFNumber(y1),
    asPDFNumber(x22),
    asPDFNumber(y22),
    asPDFNumber(x32),
    asPDFNumber(y32)
  ]);
};
var appendQuadraticCurve = function(x1, y1, x22, y22) {
  return PDFOperator_default.of(PDFOperatorNames_default.CurveToReplicateInitialPoint, [
    asPDFNumber(x1),
    asPDFNumber(y1),
    asPDFNumber(x22),
    asPDFNumber(y22)
  ]);
};
var closePath = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.ClosePath);
};
var moveTo = function(xPos, yPos) {
  return PDFOperator_default.of(PDFOperatorNames_default.MoveTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
};
var lineTo = function(xPos, yPos) {
  return PDFOperator_default.of(PDFOperatorNames_default.LineTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
};
var stroke = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.StrokePath);
};
var fill = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.FillNonZero);
};
var fillAndStroke = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.FillNonZeroAndStroke);
};
var endPath = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.EndPath);
};
var nextLine = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.NextLine);
};
var showText = function(text) {
  return PDFOperator_default.of(PDFOperatorNames_default.ShowText, [text]);
};
var beginText = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.BeginText);
};
var endText = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.EndText);
};
var setFontAndSize = function(name2, size) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetFontAndSize, [asPDFName(name2), asPDFNumber(size)]);
};
var setLineHeight = function(lineHeight) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetTextLineHeight, [asPDFNumber(lineHeight)]);
};
var TextRenderingMode;
(function(TextRenderingMode2) {
  TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
  TextRenderingMode2[TextRenderingMode2["Outline"] = 1] = "Outline";
  TextRenderingMode2[TextRenderingMode2["FillAndOutline"] = 2] = "FillAndOutline";
  TextRenderingMode2[TextRenderingMode2["Invisible"] = 3] = "Invisible";
  TextRenderingMode2[TextRenderingMode2["FillAndClip"] = 4] = "FillAndClip";
  TextRenderingMode2[TextRenderingMode2["OutlineAndClip"] = 5] = "OutlineAndClip";
  TextRenderingMode2[TextRenderingMode2["FillAndOutlineAndClip"] = 6] = "FillAndOutlineAndClip";
  TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
})(TextRenderingMode || (TextRenderingMode = {}));
var setTextMatrix = function(a2, b4, c2, d3, e, f3) {
  return PDFOperator_default.of(PDFOperatorNames_default.SetTextMatrix, [
    asPDFNumber(a2),
    asPDFNumber(b4),
    asPDFNumber(c2),
    asPDFNumber(d3),
    asPDFNumber(e),
    asPDFNumber(f3)
  ]);
};
var rotateAndSkewTextRadiansAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x4, y4) {
  return setTextMatrix(cos(asNumber(rotationAngle)), sin(asNumber(rotationAngle)) + tan(asNumber(xSkewAngle)), -sin(asNumber(rotationAngle)) + tan(asNumber(ySkewAngle)), cos(asNumber(rotationAngle)), x4, y4);
};
var drawObject = function(name2) {
  return PDFOperator_default.of(PDFOperatorNames_default.DrawObject, [asPDFName(name2)]);
};
var setFillingGrayscaleColor = function(gray) {
  return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorGray, [asPDFNumber(gray)]);
};
var setStrokingGrayscaleColor = function(gray) {
  return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorGray, [asPDFNumber(gray)]);
};
var setFillingRgbColor = function(red, green, blue) {
  return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorRgb, [
    asPDFNumber(red),
    asPDFNumber(green),
    asPDFNumber(blue)
  ]);
};
var setStrokingRgbColor = function(red, green, blue) {
  return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorRgb, [
    asPDFNumber(red),
    asPDFNumber(green),
    asPDFNumber(blue)
  ]);
};
var setFillingCmykColor = function(cyan, magenta, yellow, key) {
  return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorCmyk, [
    asPDFNumber(cyan),
    asPDFNumber(magenta),
    asPDFNumber(yellow),
    asPDFNumber(key)
  ]);
};
var setStrokingCmykColor = function(cyan, magenta, yellow, key) {
  return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorCmyk, [
    asPDFNumber(cyan),
    asPDFNumber(magenta),
    asPDFNumber(yellow),
    asPDFNumber(key)
  ]);
};
var beginMarkedContent = function(tag) {
  return PDFOperator_default.of(PDFOperatorNames_default.BeginMarkedContent, [asPDFName(tag)]);
};
var endMarkedContent = function() {
  return PDFOperator_default.of(PDFOperatorNames_default.EndMarkedContent);
};

// node_modules/pdf-lib/es/api/colors.js
var ColorTypes;
(function(ColorTypes2) {
  ColorTypes2["Grayscale"] = "Grayscale";
  ColorTypes2["RGB"] = "RGB";
  ColorTypes2["CMYK"] = "CMYK";
})(ColorTypes || (ColorTypes = {}));
var grayscale = function(gray) {
  assertRange(gray, "gray", 0, 1);
  return { type: ColorTypes.Grayscale, gray };
};
var rgb = function(red, green, blue) {
  assertRange(red, "red", 0, 1);
  assertRange(green, "green", 0, 1);
  assertRange(blue, "blue", 0, 1);
  return { type: ColorTypes.RGB, red, green, blue };
};
var cmyk = function(cyan, magenta, yellow, key) {
  assertRange(cyan, "cyan", 0, 1);
  assertRange(magenta, "magenta", 0, 1);
  assertRange(yellow, "yellow", 0, 1);
  assertRange(key, "key", 0, 1);
  return { type: ColorTypes.CMYK, cyan, magenta, yellow, key };
};
var Grayscale = ColorTypes.Grayscale;
var RGB = ColorTypes.RGB;
var CMYK = ColorTypes.CMYK;
var setFillingColor = function(color) {
  return color.type === Grayscale ? setFillingGrayscaleColor(color.gray) : color.type === RGB ? setFillingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setFillingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
};
var setStrokingColor = function(color) {
  return color.type === Grayscale ? setStrokingGrayscaleColor(color.gray) : color.type === RGB ? setStrokingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setStrokingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
};
var componentsToColor = function(comps, scale2) {
  if (scale2 === void 0) {
    scale2 = 1;
  }
  return (comps === null || comps === void 0 ? void 0 : comps.length) === 1 ? grayscale(comps[0] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 3 ? rgb(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 4 ? cmyk(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2, comps[3] * scale2) : void 0;
};
var colorToComponents = function(color) {
  return color.type === Grayscale ? [color.gray] : color.type === RGB ? [color.red, color.green, color.blue] : color.type === CMYK ? [color.cyan, color.magenta, color.yellow, color.key] : error("Invalid color: " + JSON.stringify(color));
};

// node_modules/pdf-lib/es/api/svgPath.js
var cx = 0;
var cy = 0;
var px = 0;
var py = 0;
var sx = 0;
var sy = 0;
var parameters = /* @__PURE__ */ new Map([
  ["A", 7],
  ["a", 7],
  ["C", 6],
  ["c", 6],
  ["H", 1],
  ["h", 1],
  ["L", 2],
  ["l", 2],
  ["M", 2],
  ["m", 2],
  ["Q", 4],
  ["q", 4],
  ["S", 4],
  ["s", 4],
  ["T", 2],
  ["t", 2],
  ["V", 1],
  ["v", 1],
  ["Z", 0],
  ["z", 0]
]);
var parse = function(path2) {
  var cmd;
  var ret = [];
  var args2 = [];
  var curArg = "";
  var foundDecimal = false;
  var params = 0;
  for (var _i = 0, path_1 = path2; _i < path_1.length; _i++) {
    var c2 = path_1[_i];
    if (parameters.has(c2)) {
      params = parameters.get(c2);
      if (cmd) {
        if (curArg.length > 0) {
          args2[args2.length] = +curArg;
        }
        ret[ret.length] = { cmd, args: args2 };
        args2 = [];
        curArg = "";
        foundDecimal = false;
      }
      cmd = c2;
    } else if ([" ", ","].includes(c2) || c2 === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c2 === "." && foundDecimal) {
      if (curArg.length === 0) {
        continue;
      }
      if (args2.length === params) {
        ret[ret.length] = { cmd, args: args2 };
        args2 = [+curArg];
        if (cmd === "M") {
          cmd = "L";
        }
        if (cmd === "m") {
          cmd = "l";
        }
      } else {
        args2[args2.length] = +curArg;
      }
      foundDecimal = c2 === ".";
      curArg = ["-", "."].includes(c2) ? c2 : "";
    } else {
      curArg += c2;
      if (c2 === ".") {
        foundDecimal = true;
      }
    }
  }
  if (curArg.length > 0) {
    if (args2.length === params) {
      ret[ret.length] = { cmd, args: args2 };
      args2 = [+curArg];
      if (cmd === "M") {
        cmd = "L";
      }
      if (cmd === "m") {
        cmd = "l";
      }
    } else {
      args2[args2.length] = +curArg;
    }
  }
  ret[ret.length] = { cmd, args: args2 };
  return ret;
};
var apply = function(commands) {
  cx = cy = px = py = sx = sy = 0;
  var cmds = [];
  for (var i3 = 0; i3 < commands.length; i3++) {
    var c2 = commands[i3];
    if (c2.cmd && typeof runners[c2.cmd] === "function") {
      var cmd = runners[c2.cmd](c2.args);
      if (Array.isArray(cmd)) {
        cmds = cmds.concat(cmd);
      } else {
        cmds.push(cmd);
      }
    }
  }
  return cmds;
};
var runners = {
  M: function(a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return moveTo(cx, cy);
  },
  m: function(a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return moveTo(cx, cy);
  },
  C: function(a2) {
    cx = a2[4];
    cy = a2[5];
    px = a2[2];
    py = a2[3];
    return appendBezierCurve(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5]);
  },
  c: function(a2) {
    var cmd = appendBezierCurve(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy, a2[4] + cx, a2[5] + cy);
    px = cx + a2[2];
    py = cy + a2[3];
    cx += a2[4];
    cy += a2[5];
    return cmd;
  },
  S: function(a2) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    }
    var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), a2[0], a2[1], a2[2], a2[3]);
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    cy = a2[3];
    return cmd;
  },
  s: function(a2) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    }
    var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), cx + a2[0], cy + a2[1], cx + a2[2], cy + a2[3]);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    cy += a2[3];
    return cmd;
  },
  Q: function(a2) {
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    cy = a2[3];
    return appendQuadraticCurve(a2[0], a2[1], cx, cy);
  },
  q: function(a2) {
    var cmd = appendQuadraticCurve(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    cy += a2[3];
    return cmd;
  },
  T: function(a2) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    var cmd = appendQuadraticCurve(px, py, a2[0], a2[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a2[0];
    cy = a2[1];
    return cmd;
  },
  t: function(a2) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    var cmd = appendQuadraticCurve(px, py, cx + a2[0], cy + a2[1]);
    cx += a2[0];
    cy += a2[1];
    return cmd;
  },
  A: function(a2) {
    var cmds = solveArc(cx, cy, a2);
    cx = a2[5];
    cy = a2[6];
    return cmds;
  },
  a: function(a2) {
    a2[5] += cx;
    a2[6] += cy;
    var cmds = solveArc(cx, cy, a2);
    cx = a2[5];
    cy = a2[6];
    return cmds;
  },
  L: function(a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    return lineTo(cx, cy);
  },
  l: function(a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    return lineTo(cx, cy);
  },
  H: function(a2) {
    cx = a2[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  h: function(a2) {
    cx += a2[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  V: function(a2) {
    cy = a2[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  v: function(a2) {
    cy += a2[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  Z: function() {
    var cmd = closePath();
    cx = sx;
    cy = sy;
    return cmd;
  },
  z: function() {
    var cmd = closePath();
    cx = sx;
    cy = sy;
    return cmd;
  }
};
var solveArc = function(x4, y4, coords) {
  var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x4, y4);
  var cmds = [];
  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
    var seg = segs_1[_i];
    var bez = segmentToBezier.apply(void 0, seg);
    cmds.push(appendBezierCurve.apply(void 0, bez));
  }
  return cmds;
};
var arcToSegments = function(x4, y4, rx, ry, large, sweep, rotateX, ox, oy) {
  var th = rotateX * (Math.PI / 180);
  var sinTh = Math.sin(th);
  var cosTh = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cosTh * (ox - x4) * 0.5 + sinTh * (oy - y4) * 0.5;
  py = cosTh * (oy - y4) * 0.5 - sinTh * (ox - x4) * 0.5;
  var pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  var a00 = cosTh / rx;
  var a01 = sinTh / rx;
  var a10 = -sinTh / ry;
  var a11 = cosTh / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x4 + a01 * y4;
  var y1 = a10 * x4 + a11 * y4;
  var d3 = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  var sfactorSq = 1 / d3 - 0.25;
  if (sfactorSq < 0) {
    sfactorSq = 0;
  }
  var sfactor = Math.sqrt(sfactorSq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  var th0 = Math.atan2(y0 - yc, x0 - xc);
  var th1 = Math.atan2(y1 - yc, x1 - xc);
  var thArc = th1 - th0;
  if (thArc < 0 && sweep === 1) {
    thArc += 2 * Math.PI;
  } else if (thArc > 0 && sweep === 0) {
    thArc -= 2 * Math.PI;
  }
  var segments = Math.ceil(Math.abs(thArc / (Math.PI * 0.5 + 1e-3)));
  var result = [];
  for (var i3 = 0; i3 < segments; i3++) {
    var th2 = th0 + i3 * thArc / segments;
    var th3 = th0 + (i3 + 1) * thArc / segments;
    result[i3] = [xc, yc, th2, th3, rx, ry, sinTh, cosTh];
  }
  return result;
};
var segmentToBezier = function(cx1, cy1, th0, th1, rx, ry, sinTh, cosTh) {
  var a00 = cosTh * rx;
  var a01 = -sinTh * ry;
  var a10 = sinTh * rx;
  var a11 = cosTh * ry;
  var thHalf = 0.5 * (th1 - th0);
  var t2 = 8 / 3 * Math.sin(thHalf * 0.5) * Math.sin(thHalf * 0.5) / Math.sin(thHalf);
  var x1 = cx1 + Math.cos(th0) - t2 * Math.sin(th0);
  var y1 = cy1 + Math.sin(th0) + t2 * Math.cos(th0);
  var x32 = cx1 + Math.cos(th1);
  var y32 = cy1 + Math.sin(th1);
  var x22 = x32 + t2 * Math.sin(th1);
  var y22 = y32 - t2 * Math.cos(th1);
  var result = [
    a00 * x1 + a01 * y1,
    a10 * x1 + a11 * y1,
    a00 * x22 + a01 * y22,
    a10 * x22 + a11 * y22,
    a00 * x32 + a01 * y32,
    a10 * x32 + a11 * y32
  ];
  return result;
};
var svgPathToOperators = function(path2) {
  return apply(parse(path2));
};

// node_modules/pdf-lib/es/api/operations.js
var drawLinesOfText = function(lines, options) {
  var operators = [
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    beginText(),
    setFillingColor(options.color),
    setFontAndSize(options.font, options.size),
    setLineHeight(options.lineHeight),
    rotateAndSkewTextRadiansAndTranslate(toRadians(options.rotate), toRadians(options.xSkew), toRadians(options.ySkew), options.x, options.y)
  ].filter(Boolean);
  for (var idx = 0, len = lines.length; idx < len; idx++) {
    operators.push(showText(lines[idx]), nextLine());
  }
  operators.push(endText(), popGraphicsState());
  return operators;
};
var drawImage = function(name2, options) {
  return [
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    translate(options.x, options.y),
    rotateRadians(toRadians(options.rotate)),
    scale(options.width, options.height),
    skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
    drawObject(name2),
    popGraphicsState()
  ].filter(Boolean);
};
var drawPage = function(name2, options) {
  return [
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    translate(options.x, options.y),
    rotateRadians(toRadians(options.rotate)),
    scale(options.xScale, options.yScale),
    skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
    drawObject(name2),
    popGraphicsState()
  ].filter(Boolean);
};
var drawLine = function(options) {
  var _a, _b;
  return [
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    options.color && setStrokingColor(options.color),
    setLineWidth(options.thickness),
    setDashPattern((_a = options.dashArray) !== null && _a !== void 0 ? _a : [], (_b = options.dashPhase) !== null && _b !== void 0 ? _b : 0),
    moveTo(options.start.x, options.start.y),
    options.lineCap && setLineCap(options.lineCap),
    moveTo(options.start.x, options.start.y),
    lineTo(options.end.x, options.end.y),
    stroke(),
    popGraphicsState()
  ].filter(Boolean);
};
var drawRectangle = function(options) {
  var _a, _b;
  return [
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    options.color && setFillingColor(options.color),
    options.borderColor && setStrokingColor(options.borderColor),
    setLineWidth(options.borderWidth),
    options.borderLineCap && setLineCap(options.borderLineCap),
    setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0),
    translate(options.x, options.y),
    rotateRadians(toRadians(options.rotate)),
    skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
    moveTo(0, 0),
    lineTo(0, options.height),
    lineTo(options.width, options.height),
    lineTo(options.width, 0),
    closePath(),
    // prettier-ignore
    options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ].filter(Boolean);
};
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipsePath = function(config) {
  var x4 = asNumber(config.x);
  var y4 = asNumber(config.y);
  var xScale = asNumber(config.xScale);
  var yScale = asNumber(config.yScale);
  x4 -= xScale;
  y4 -= yScale;
  var ox = xScale * KAPPA;
  var oy = yScale * KAPPA;
  var xe3 = x4 + xScale * 2;
  var ye3 = y4 + yScale * 2;
  var xm = x4 + xScale;
  var ym = y4 + yScale;
  return [
    pushGraphicsState(),
    moveTo(x4, ym),
    appendBezierCurve(x4, ym - oy, xm - ox, y4, xm, y4),
    appendBezierCurve(xm + ox, y4, xe3, ym - oy, xe3, ym),
    appendBezierCurve(xe3, ym + oy, xm + ox, ye3, xm, ye3),
    appendBezierCurve(xm - ox, ye3, x4, ym + oy, x4, ym),
    popGraphicsState()
  ];
};
var drawEllipseCurves = function(config) {
  var centerX = asNumber(config.x);
  var centerY = asNumber(config.y);
  var xScale = asNumber(config.xScale);
  var yScale = asNumber(config.yScale);
  var x4 = -xScale;
  var y4 = -yScale;
  var ox = xScale * KAPPA;
  var oy = yScale * KAPPA;
  var xe3 = x4 + xScale * 2;
  var ye3 = y4 + yScale * 2;
  var xm = x4 + xScale;
  var ym = y4 + yScale;
  return [
    translate(centerX, centerY),
    rotateRadians(toRadians(config.rotate)),
    moveTo(x4, ym),
    appendBezierCurve(x4, ym - oy, xm - ox, y4, xm, y4),
    appendBezierCurve(xm + ox, y4, xe3, ym - oy, xe3, ym),
    appendBezierCurve(xe3, ym + oy, xm + ox, ye3, xm, ye3),
    appendBezierCurve(xm - ox, ye3, x4, ym + oy, x4, ym)
  ];
};
var drawEllipse = function(options) {
  var _a, _b, _c;
  return __spreadArrays([
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    options.color && setFillingColor(options.color),
    options.borderColor && setStrokingColor(options.borderColor),
    setLineWidth(options.borderWidth),
    options.borderLineCap && setLineCap(options.borderLineCap),
    setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0)
  ], options.rotate === void 0 ? drawEllipsePath({
    x: options.x,
    y: options.y,
    xScale: options.xScale,
    yScale: options.yScale
  }) : drawEllipseCurves({
    x: options.x,
    y: options.y,
    xScale: options.xScale,
    yScale: options.yScale,
    rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0)
  }), [
    // prettier-ignore
    options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ]).filter(Boolean);
};
var drawSvgPath = function(path2, options) {
  var _a, _b, _c;
  return __spreadArrays([
    pushGraphicsState(),
    options.graphicsState && setGraphicsState(options.graphicsState),
    translate(options.x, options.y),
    rotateRadians(toRadians((_a = options.rotate) !== null && _a !== void 0 ? _a : degrees(0))),
    // SVG path Y axis is opposite pdf-lib's
    options.scale ? scale(options.scale, -options.scale) : scale(1, -1),
    options.color && setFillingColor(options.color),
    options.borderColor && setStrokingColor(options.borderColor),
    options.borderWidth && setLineWidth(options.borderWidth),
    options.borderLineCap && setLineCap(options.borderLineCap),
    setDashPattern((_b = options.borderDashArray) !== null && _b !== void 0 ? _b : [], (_c = options.borderDashPhase) !== null && _c !== void 0 ? _c : 0)
  ], svgPathToOperators(path2), [
    // prettier-ignore
    options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ]).filter(Boolean);
};
var drawCheckMark = function(options) {
  var size = asNumber(options.size);
  var p2x = -1 + 0.75;
  var p2y = -1 + 0.51;
  var p3y = 1 - 0.525;
  var p3x = 1 - 0.31;
  var p1x = -1 + 0.325;
  var p1y = -((p1x - p2x) * (p3x - p2x)) / (p3y - p2y) + p2y;
  return [
    pushGraphicsState(),
    options.color && setStrokingColor(options.color),
    setLineWidth(options.thickness),
    translate(options.x, options.y),
    moveTo(p1x * size, p1y * size),
    lineTo(p2x * size, p2y * size),
    lineTo(p3x * size, p3y * size),
    stroke(),
    popGraphicsState()
  ].filter(Boolean);
};
var rotateInPlace = function(options) {
  return options.rotation === 0 ? [
    translate(0, 0),
    rotateDegrees(0)
  ] : options.rotation === 90 ? [
    translate(options.width, 0),
    rotateDegrees(90)
  ] : options.rotation === 180 ? [
    translate(options.width, options.height),
    rotateDegrees(180)
  ] : options.rotation === 270 ? [
    translate(0, options.height),
    rotateDegrees(270)
  ] : [];
};
var drawCheckBox = function(options) {
  var outline = drawRectangle({
    x: options.x,
    y: options.y,
    width: options.width,
    height: options.height,
    borderWidth: options.borderWidth,
    color: options.color,
    borderColor: options.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  if (!options.filled)
    return outline;
  var width = asNumber(options.width);
  var height = asNumber(options.height);
  var checkMarkSize = Math.min(width, height) / 2;
  var checkMark = drawCheckMark({
    x: width / 2,
    y: height / 2,
    size: checkMarkSize,
    thickness: options.thickness,
    color: options.markColor
  });
  return __spreadArrays([pushGraphicsState()], outline, checkMark, [popGraphicsState()]);
};
var drawRadioButton = function(options) {
  var width = asNumber(options.width);
  var height = asNumber(options.height);
  var outlineScale = Math.min(width, height) / 2;
  var outline = drawEllipse({
    x: options.x,
    y: options.y,
    xScale: outlineScale,
    yScale: outlineScale,
    color: options.color,
    borderColor: options.borderColor,
    borderWidth: options.borderWidth
  });
  if (!options.filled)
    return outline;
  var dot = drawEllipse({
    x: options.x,
    y: options.y,
    xScale: outlineScale * 0.45,
    yScale: outlineScale * 0.45,
    color: options.dotColor,
    borderColor: void 0,
    borderWidth: 0
  });
  return __spreadArrays([pushGraphicsState()], outline, dot, [popGraphicsState()]);
};
var drawButton = function(options) {
  var x4 = asNumber(options.x);
  var y4 = asNumber(options.y);
  var width = asNumber(options.width);
  var height = asNumber(options.height);
  var background = drawRectangle({
    x: x4,
    y: y4,
    width,
    height,
    borderWidth: options.borderWidth,
    color: options.color,
    borderColor: options.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var lines = drawTextLines(options.textLines, {
    color: options.textColor,
    font: options.font,
    size: options.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  return __spreadArrays([pushGraphicsState()], background, lines, [popGraphicsState()]);
};
var drawTextLines = function(lines, options) {
  var operators = [
    beginText(),
    setFillingColor(options.color),
    setFontAndSize(options.font, options.size)
  ];
  for (var idx = 0, len = lines.length; idx < len; idx++) {
    var _a = lines[idx], encoded = _a.encoded, x4 = _a.x, y4 = _a.y;
    operators.push(rotateAndSkewTextRadiansAndTranslate(toRadians(options.rotate), toRadians(options.xSkew), toRadians(options.ySkew), x4, y4), showText(encoded));
  }
  operators.push(endText());
  return operators;
};
var drawTextField = function(options) {
  var x4 = asNumber(options.x);
  var y4 = asNumber(options.y);
  var width = asNumber(options.width);
  var height = asNumber(options.height);
  var borderWidth = asNumber(options.borderWidth);
  var padding = asNumber(options.padding);
  var clipX = x4 + borderWidth / 2 + padding;
  var clipY = y4 + borderWidth / 2 + padding;
  var clipWidth = width - (borderWidth / 2 + padding) * 2;
  var clipHeight = height - (borderWidth / 2 + padding) * 2;
  var clippingArea = [
    moveTo(clipX, clipY),
    lineTo(clipX, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY),
    closePath(),
    clip(),
    endPath()
  ];
  var background = drawRectangle({
    x: x4,
    y: y4,
    width,
    height,
    borderWidth: options.borderWidth,
    color: options.color,
    borderColor: options.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var lines = drawTextLines(options.textLines, {
    color: options.textColor,
    font: options.font,
    size: options.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var markedContent = __spreadArrays([
    beginMarkedContent("Tx"),
    pushGraphicsState()
  ], lines, [
    popGraphicsState(),
    endMarkedContent()
  ]);
  return __spreadArrays([
    pushGraphicsState()
  ], background, clippingArea, markedContent, [
    popGraphicsState()
  ]);
};
var drawOptionList = function(options) {
  var x4 = asNumber(options.x);
  var y4 = asNumber(options.y);
  var width = asNumber(options.width);
  var height = asNumber(options.height);
  var lineHeight = asNumber(options.lineHeight);
  var borderWidth = asNumber(options.borderWidth);
  var padding = asNumber(options.padding);
  var clipX = x4 + borderWidth / 2 + padding;
  var clipY = y4 + borderWidth / 2 + padding;
  var clipWidth = width - (borderWidth / 2 + padding) * 2;
  var clipHeight = height - (borderWidth / 2 + padding) * 2;
  var clippingArea = [
    moveTo(clipX, clipY),
    lineTo(clipX, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY),
    closePath(),
    clip(),
    endPath()
  ];
  var background = drawRectangle({
    x: x4,
    y: y4,
    width,
    height,
    borderWidth: options.borderWidth,
    color: options.color,
    borderColor: options.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var highlights = [];
  for (var idx = 0, len = options.selectedLines.length; idx < len; idx++) {
    var line = options.textLines[options.selectedLines[idx]];
    highlights.push.apply(highlights, drawRectangle({
      x: line.x - padding,
      y: line.y - (lineHeight - line.height) / 2,
      width: width - borderWidth,
      height: line.height + (lineHeight - line.height) / 2,
      borderWidth: 0,
      color: options.selectedColor,
      borderColor: void 0,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    }));
  }
  var lines = drawTextLines(options.textLines, {
    color: options.textColor,
    font: options.font,
    size: options.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var markedContent = __spreadArrays([
    beginMarkedContent("Tx"),
    pushGraphicsState()
  ], lines, [
    popGraphicsState(),
    endMarkedContent()
  ]);
  return __spreadArrays([
    pushGraphicsState()
  ], background, highlights, clippingArea, markedContent, [
    popGraphicsState()
  ]);
};

// node_modules/pdf-lib/es/api/errors.js
var EncryptedPDFError = (
  /** @class */
  function(_super) {
    __extends(EncryptedPDFError2, _super);
    function EncryptedPDFError2() {
      var _this = this;
      var msg = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return EncryptedPDFError2;
  }(Error)
);
var FontkitNotRegisteredError = (
  /** @class */
  function(_super) {
    __extends(FontkitNotRegisteredError2, _super);
    function FontkitNotRegisteredError2() {
      var _this = this;
      var msg = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return FontkitNotRegisteredError2;
  }(Error)
);
var ForeignPageError = (
  /** @class */
  function(_super) {
    __extends(ForeignPageError2, _super);
    function ForeignPageError2() {
      var _this = this;
      var msg = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return ForeignPageError2;
  }(Error)
);
var RemovePageFromEmptyDocumentError = (
  /** @class */
  function(_super) {
    __extends(RemovePageFromEmptyDocumentError2, _super);
    function RemovePageFromEmptyDocumentError2() {
      var _this = this;
      var msg = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return RemovePageFromEmptyDocumentError2;
  }(Error)
);
var NoSuchFieldError = (
  /** @class */
  function(_super) {
    __extends(NoSuchFieldError2, _super);
    function NoSuchFieldError2(name2) {
      var _this = this;
      var msg = 'PDFDocument has no form field with the name "' + name2 + '"';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return NoSuchFieldError2;
  }(Error)
);
var UnexpectedFieldTypeError = (
  /** @class */
  function(_super) {
    __extends(UnexpectedFieldTypeError2, _super);
    function UnexpectedFieldTypeError2(name2, expected, actual) {
      var _a, _b;
      var _this = this;
      var expectedType = expected === null || expected === void 0 ? void 0 : expected.name;
      var actualType = (_b = (_a = actual === null || actual === void 0 ? void 0 : actual.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : actual;
      var msg = 'Expected field "' + name2 + '" to be of type ' + expectedType + ", " + ("but it is actually of type " + actualType);
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return UnexpectedFieldTypeError2;
  }(Error)
);
var MissingOnValueCheckError = (
  /** @class */
  function(_super) {
    __extends(MissingOnValueCheckError2, _super);
    function MissingOnValueCheckError2(onValue) {
      var _this = this;
      var msg = 'Failed to select check box due to missing onValue: "' + onValue + '"';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return MissingOnValueCheckError2;
  }(Error)
);
var FieldAlreadyExistsError = (
  /** @class */
  function(_super) {
    __extends(FieldAlreadyExistsError2, _super);
    function FieldAlreadyExistsError2(name2) {
      var _this = this;
      var msg = 'A field already exists with the specified name: "' + name2 + '"';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return FieldAlreadyExistsError2;
  }(Error)
);
var InvalidFieldNamePartError = (
  /** @class */
  function(_super) {
    __extends(InvalidFieldNamePartError2, _super);
    function InvalidFieldNamePartError2(namePart) {
      var _this = this;
      var msg = 'Field name contains invalid component: "' + namePart + '"';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return InvalidFieldNamePartError2;
  }(Error)
);
var FieldExistsAsNonTerminalError = (
  /** @class */
  function(_super) {
    __extends(FieldExistsAsNonTerminalError2, _super);
    function FieldExistsAsNonTerminalError2(name2) {
      var _this = this;
      var msg = 'A non-terminal field already exists with the specified name: "' + name2 + '"';
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return FieldExistsAsNonTerminalError2;
  }(Error)
);
var RichTextFieldReadError = (
  /** @class */
  function(_super) {
    __extends(RichTextFieldReadError2, _super);
    function RichTextFieldReadError2(fieldName) {
      var _this = this;
      var msg = "Reading rich text fields is not supported: Attempted to read rich text field: " + fieldName;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return RichTextFieldReadError2;
  }(Error)
);
var CombedTextLayoutError = (
  /** @class */
  function(_super) {
    __extends(CombedTextLayoutError2, _super);
    function CombedTextLayoutError2(lineLength, cellCount) {
      var _this = this;
      var msg = "Failed to layout combed text as lineLength=" + lineLength + " is greater than cellCount=" + cellCount;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return CombedTextLayoutError2;
  }(Error)
);
var ExceededMaxLengthError = (
  /** @class */
  function(_super) {
    __extends(ExceededMaxLengthError2, _super);
    function ExceededMaxLengthError2(textLength, maxLength, name2) {
      var _this = this;
      var msg = "Attempted to set text with length=" + textLength + " for TextField with maxLength=" + maxLength + " and name=" + name2;
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return ExceededMaxLengthError2;
  }(Error)
);
var InvalidMaxLengthError = (
  /** @class */
  function(_super) {
    __extends(InvalidMaxLengthError2, _super);
    function InvalidMaxLengthError2(textLength, maxLength, name2) {
      var _this = this;
      var msg = "Attempted to set maxLength=" + maxLength + ", which is less than " + textLength + ", the length of this field's current value (name=" + name2 + ")";
      _this = _super.call(this, msg) || this;
      return _this;
    }
    return InvalidMaxLengthError2;
  }(Error)
);

// node_modules/pdf-lib/es/api/text/alignment.js
var TextAlignment;
(function(TextAlignment2) {
  TextAlignment2[TextAlignment2["Left"] = 0] = "Left";
  TextAlignment2[TextAlignment2["Center"] = 1] = "Center";
  TextAlignment2[TextAlignment2["Right"] = 2] = "Right";
})(TextAlignment || (TextAlignment = {}));

// node_modules/pdf-lib/es/api/text/layout.js
var MIN_FONT_SIZE = 4;
var MAX_FONT_SIZE = 500;
var computeFontSize = function(lines, font, bounds, multiline) {
  if (multiline === void 0) {
    multiline = false;
  }
  var fontSize = MIN_FONT_SIZE;
  while (fontSize < MAX_FONT_SIZE) {
    var linesUsed = 0;
    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {
      linesUsed += 1;
      var line = lines[lineIdx];
      var words = line.split(" ");
      var spaceInLineRemaining = bounds.width;
      for (var idx = 0, len = words.length; idx < len; idx++) {
        var isLastWord = idx === len - 1;
        var word = isLastWord ? words[idx] : words[idx] + " ";
        var widthOfWord = font.widthOfTextAtSize(word, fontSize);
        spaceInLineRemaining -= widthOfWord;
        if (spaceInLineRemaining <= 0) {
          linesUsed += 1;
          spaceInLineRemaining = bounds.width - widthOfWord;
        }
      }
    }
    if (!multiline && linesUsed > lines.length)
      return fontSize - 1;
    var height = font.heightAtSize(fontSize);
    var lineHeight = height + height * 0.2;
    var totalHeight = lineHeight * linesUsed;
    if (totalHeight > Math.abs(bounds.height))
      return fontSize - 1;
    fontSize += 1;
  }
  return fontSize;
};
var computeCombedFontSize = function(line, font, bounds, cellCount) {
  var cellWidth = bounds.width / cellCount;
  var cellHeight = bounds.height;
  var fontSize = MIN_FONT_SIZE;
  var chars3 = charSplit(line);
  while (fontSize < MAX_FONT_SIZE) {
    for (var idx = 0, len = chars3.length; idx < len; idx++) {
      var c2 = chars3[idx];
      var tooLong = font.widthOfTextAtSize(c2, fontSize) > cellWidth * 0.75;
      if (tooLong)
        return fontSize - 1;
    }
    var height = font.heightAtSize(fontSize, { descender: false });
    if (height > cellHeight)
      return fontSize - 1;
    fontSize += 1;
  }
  return fontSize;
};
var lastIndexOfWhitespace = function(line) {
  for (var idx = line.length; idx > 0; idx--) {
    if (/\s/.test(line[idx]))
      return idx;
  }
  return void 0;
};
var splitOutLines = function(input, maxWidth, font, fontSize) {
  var _a;
  var lastWhitespaceIdx = input.length;
  while (lastWhitespaceIdx > 0) {
    var line = input.substring(0, lastWhitespaceIdx);
    var encoded = font.encodeText(line);
    var width = font.widthOfTextAtSize(line, fontSize);
    if (width < maxWidth) {
      var remainder = input.substring(lastWhitespaceIdx) || void 0;
      return { line, encoded, width, remainder };
    }
    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;
  }
  return {
    line: input,
    encoded: font.encodeText(input),
    width: font.widthOfTextAtSize(input, fontSize),
    remainder: void 0
  };
};
var layoutMultilineText = function(text, _a) {
  var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
  var lines = lineSplit(cleanText(text));
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeFontSize(lines, font, bounds, true);
  }
  var height = font.heightAtSize(fontSize);
  var lineHeight = height + height * 0.2;
  var textLines = [];
  var minX = bounds.x;
  var minY = bounds.y;
  var maxX = bounds.x + bounds.width;
  var maxY = bounds.y + bounds.height;
  var y4 = bounds.y + bounds.height;
  for (var idx = 0, len = lines.length; idx < len; idx++) {
    var prevRemainder = lines[idx];
    while (prevRemainder !== void 0) {
      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;
      var x4 = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
      y4 -= lineHeight;
      if (x4 < minX)
        minX = x4;
      if (y4 < minY)
        minY = y4;
      if (x4 + width > maxX)
        maxX = x4 + width;
      if (y4 + height > maxY)
        maxY = y4 + height;
      textLines.push({ text: line, encoded, width, height, x: x4, y: y4 });
      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();
    }
  }
  return {
    fontSize,
    lineHeight,
    lines: textLines,
    bounds: {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    }
  };
};
var layoutCombedText = function(text, _a) {
  var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;
  var line = mergeLines(cleanText(text));
  if (line.length > cellCount) {
    throw new CombedTextLayoutError(line.length, cellCount);
  }
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeCombedFontSize(line, font, bounds, cellCount);
  }
  var cellWidth = bounds.width / cellCount;
  var height = font.heightAtSize(fontSize, { descender: false });
  var y4 = bounds.y + (bounds.height / 2 - height / 2);
  var cells = [];
  var minX = bounds.x;
  var minY = bounds.y;
  var maxX = bounds.x + bounds.width;
  var maxY = bounds.y + bounds.height;
  var cellOffset = 0;
  var charOffset = 0;
  while (cellOffset < cellCount) {
    var _b = charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];
    var encoded = font.encodeText(char);
    var width = font.widthOfTextAtSize(char, fontSize);
    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);
    var x4 = cellCenter - width / 2;
    if (x4 < minX)
      minX = x4;
    if (y4 < minY)
      minY = y4;
    if (x4 + width > maxX)
      maxX = x4 + width;
    if (y4 + height > maxY)
      maxY = y4 + height;
    cells.push({ text: line, encoded, width, height, x: x4, y: y4 });
    cellOffset += 1;
    charOffset += charLength;
  }
  return {
    fontSize,
    cells,
    bounds: {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    }
  };
};
var layoutSinglelineText = function(text, _a) {
  var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
  var line = mergeLines(cleanText(text));
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeFontSize([line], font, bounds);
  }
  var encoded = font.encodeText(line);
  var width = font.widthOfTextAtSize(line, fontSize);
  var height = font.heightAtSize(fontSize, { descender: false });
  var x4 = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
  var y4 = bounds.y + (bounds.height / 2 - height / 2);
  return {
    fontSize,
    line: { text: line, encoded, width, height, x: x4, y: y4 },
    bounds: { x: x4, y: y4, width, height }
  };
};

// node_modules/pdf-lib/es/api/form/appearances.js
var normalizeAppearance = function(appearance) {
  if ("normal" in appearance)
    return appearance;
  return { normal: appearance };
};
var tfRegex2 = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;
var getDefaultFontSize = function(field) {
  var _a, _b;
  var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
  var daMatch = (_b = findLastMatch(da, tfRegex2).match) !== null && _b !== void 0 ? _b : [];
  var defaultFontSize = Number(daMatch[2]);
  return isFinite(defaultFontSize) ? defaultFontSize : void 0;
};
var colorRegex = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;
var getDefaultColor = function(field) {
  var _a;
  var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
  var daMatch = findLastMatch(da, colorRegex).match;
  var _b = daMatch !== null && daMatch !== void 0 ? daMatch : [], c1 = _b[1], c2 = _b[2], c3 = _b[3], c4 = _b[4], colorSpace = _b[5];
  if (colorSpace === "g" && c1) {
    return grayscale(Number(c1));
  }
  if (colorSpace === "rg" && c1 && c2 && c3) {
    return rgb(Number(c1), Number(c2), Number(c3));
  }
  if (colorSpace === "k" && c1 && c2 && c3 && c4) {
    return cmyk(Number(c1), Number(c2), Number(c3), Number(c4));
  }
  return void 0;
};
var updateDefaultAppearance = function(field, color, font, fontSize) {
  var _a;
  if (fontSize === void 0) {
    fontSize = 0;
  }
  var da = [
    setFillingColor(color).toString(),
    setFontAndSize((_a = font === null || font === void 0 ? void 0 : font.name) !== null && _a !== void 0 ? _a : "dummy__noop", fontSize).toString()
  ].join("\n");
  field.setDefaultAppearance(da);
};
var defaultCheckBoxAppearanceProvider = function(checkBox, widget) {
  var _a, _b, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(checkBox.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = (_b = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor) {
    updateDefaultAppearance(widget, textColor);
  } else {
    updateDefaultAppearance(checkBox.acroField, textColor);
  }
  var options = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    thickness: 1.5,
    borderWidth,
    borderColor,
    markColor: textColor
  };
  return {
    normal: {
      on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: normalBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: normalBackgroundColor, filled: false })))
    },
    down: {
      on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: downBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: downBackgroundColor, filled: false })))
    }
  };
};
var defaultRadioGroupAppearanceProvider = function(radioGroup, widget) {
  var _a, _b, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(radioGroup.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = (_b = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor) {
    updateDefaultAppearance(widget, textColor);
  } else {
    updateDefaultAppearance(radioGroup.acroField, textColor);
  }
  var options = {
    x: width / 2,
    y: height / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth,
    borderColor,
    dotColor: textColor
  };
  return {
    normal: {
      on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: normalBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: normalBackgroundColor, filled: false })))
    },
    down: {
      on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: downBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: downBackgroundColor, filled: false })))
    }
  };
};
var defaultButtonAppearanceProvider = function(button, widget, font) {
  var _a, _b, _c, _d, _e2;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(button.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(button.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var captions = ap === null || ap === void 0 ? void 0 : ap.getCaptions();
  var normalText = (_a = captions === null || captions === void 0 ? void 0 : captions.normal) !== null && _a !== void 0 ? _a : "";
  var downText = (_c = (_b = captions === null || captions === void 0 ? void 0 : captions.down) !== null && _b !== void 0 ? _b : normalText) !== null && _c !== void 0 ? _c : "";
  var borderWidth = (_d = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _d !== void 0 ? _d : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _f = adjustDimsForRotation(rectangle, rotation), width = _f.width, height = _f.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var bounds = {
    x: borderWidth,
    y: borderWidth,
    width: width - borderWidth * 2,
    height: height - borderWidth * 2
  };
  var normalLayout = layoutSinglelineText(normalText, {
    alignment: TextAlignment.Center,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  });
  var downLayout = layoutSinglelineText(downText, {
    alignment: TextAlignment.Center,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  });
  var fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
  var textColor = (_e2 = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _e2 !== void 0 ? _e2 : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(button.acroField, textColor, font, fontSize);
  }
  var options = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth,
    borderColor,
    textColor,
    font: font.name,
    fontSize
  };
  return {
    normal: __spreadArrays(rotate, drawButton(__assign(__assign({}, options), { color: normalBackgroundColor, textLines: [normalLayout.line] }))),
    down: __spreadArrays(rotate, drawButton(__assign(__assign({}, options), { color: downBackgroundColor, textLines: [downLayout.line] })))
  };
};
var defaultTextFieldAppearanceProvider = function(textField, widget, font) {
  var _a, _b, _c, _d;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(textField.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(textField.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var text = (_a = textField.getText()) !== null && _a !== void 0 ? _a : "";
  var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _e2 = adjustDimsForRotation(rectangle, rotation), width = _e2.width, height = _e2.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var textLines;
  var fontSize;
  var padding = textField.isCombed() ? 0 : 1;
  var bounds = {
    x: borderWidth + padding,
    y: borderWidth + padding,
    width: width - (borderWidth + padding) * 2,
    height: height - (borderWidth + padding) * 2
  };
  if (textField.isMultiline()) {
    var layout = layoutMultilineText(text, {
      alignment: textField.getAlignment(),
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    textLines = layout.lines;
    fontSize = layout.fontSize;
  } else if (textField.isCombed()) {
    var layout = layoutCombedText(text, {
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds,
      cellCount: (_c = textField.getMaxLength()) !== null && _c !== void 0 ? _c : 0
    });
    textLines = layout.cells;
    fontSize = layout.fontSize;
  } else {
    var layout = layoutSinglelineText(text, {
      alignment: textField.getAlignment(),
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    textLines = [layout.line];
    fontSize = layout.fontSize;
  }
  var textColor = (_d = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _d !== void 0 ? _d : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
  }
  var options = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines,
    padding
  };
  return __spreadArrays(rotate, drawTextField(options));
};
var defaultDropdownAppearanceProvider = function(dropdown, widget, font) {
  var _a, _b, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(dropdown.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(dropdown.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var text = (_a = dropdown.getSelected()[0]) !== null && _a !== void 0 ? _a : "";
  var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var padding = 1;
  var bounds = {
    x: borderWidth + padding,
    y: borderWidth + padding,
    width: width - (borderWidth + padding) * 2,
    height: height - (borderWidth + padding) * 2
  };
  var _e2 = layoutSinglelineText(text, {
    alignment: TextAlignment.Left,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  }), line = _e2.line, fontSize = _e2.fontSize;
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
  }
  var options = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines: [line],
    padding
  };
  return __spreadArrays(rotate, drawTextField(options));
};
var defaultOptionListAppearanceProvider = function(optionList, widget, font) {
  var _a, _b;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(optionList.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(optionList.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _c = adjustDimsForRotation(rectangle, rotation), width = _c.width, height = _c.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var options = optionList.getOptions();
  var selected = optionList.getSelected();
  if (optionList.isSorted())
    options.sort();
  var text = "";
  for (var idx = 0, len = options.length; idx < len; idx++) {
    text += options[idx];
    if (idx < len - 1)
      text += "\n";
  }
  var padding = 1;
  var bounds = {
    x: borderWidth + padding,
    y: borderWidth + padding,
    width: width - (borderWidth + padding) * 2,
    height: height - (borderWidth + padding) * 2
  };
  var _d = layoutMultilineText(text, {
    alignment: TextAlignment.Left,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  }), lines = _d.lines, fontSize = _d.fontSize, lineHeight = _d.lineHeight;
  var selectedLines = [];
  for (var idx = 0, len = lines.length; idx < len; idx++) {
    var line = lines[idx];
    if (selected.includes(line.text))
      selectedLines.push(idx);
  }
  var blue = rgb(153 / 255, 193 / 255, 218 / 255);
  var textColor = (_b = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _b !== void 0 ? _b : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
  }
  return __spreadArrays(rotate, drawOptionList({
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines: lines,
    lineHeight,
    selectedColor: blue,
    selectedLines,
    padding
  }));
};

// node_modules/pdf-lib/es/api/PDFEmbeddedPage.js
var PDFEmbeddedPage = (
  /** @class */
  function() {
    function PDFEmbeddedPage2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      assertIs(embedder, "embedder", [[PDFPageEmbedder_default, "PDFPageEmbedder"]]);
      this.ref = ref;
      this.doc = doc;
      this.width = embedder.width;
      this.height = embedder.height;
      this.embedder = embedder;
    }
    PDFEmbeddedPage2.prototype.scale = function(factor) {
      assertIs(factor, "factor", ["number"]);
      return { width: this.width * factor, height: this.height * factor };
    };
    PDFEmbeddedPage2.prototype.size = function() {
      return this.scale(1);
    };
    PDFEmbeddedPage2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!!this.alreadyEmbedded)
                return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              _a.sent();
              this.alreadyEmbedded = true;
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFEmbeddedPage2.of = function(ref, doc, embedder) {
      return new PDFEmbeddedPage2(ref, doc, embedder);
    };
    return PDFEmbeddedPage2;
  }()
);
var PDFEmbeddedPage_default = PDFEmbeddedPage;

// node_modules/pdf-lib/es/api/PDFFont.js
var PDFFont = (
  /** @class */
  function() {
    function PDFFont2(ref, doc, embedder) {
      this.modified = true;
      assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      assertIs(embedder, "embedder", [
        [CustomFontEmbedder_default, "CustomFontEmbedder"],
        [StandardFontEmbedder_default, "StandardFontEmbedder"]
      ]);
      this.ref = ref;
      this.doc = doc;
      this.name = embedder.fontName;
      this.embedder = embedder;
    }
    PDFFont2.prototype.encodeText = function(text) {
      assertIs(text, "text", ["string"]);
      this.modified = true;
      return this.embedder.encodeText(text);
    };
    PDFFont2.prototype.widthOfTextAtSize = function(text, size) {
      assertIs(text, "text", ["string"]);
      assertIs(size, "size", ["number"]);
      return this.embedder.widthOfTextAtSize(text, size);
    };
    PDFFont2.prototype.heightAtSize = function(size, options) {
      var _a;
      assertIs(size, "size", ["number"]);
      assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, "options.descender", ["boolean"]);
      return this.embedder.heightOfFontAtSize(size, {
        descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true
      });
    };
    PDFFont2.prototype.sizeAtHeight = function(height) {
      assertIs(height, "height", ["number"]);
      return this.embedder.sizeOfFontAtHeight(height);
    };
    PDFFont2.prototype.getCharacterSet = function() {
      if (this.embedder instanceof StandardFontEmbedder_default) {
        return this.embedder.encoding.supportedCodePoints;
      } else {
        return this.embedder.font.characterSet;
      }
    };
    PDFFont2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!this.modified)
                return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              _a.sent();
              this.modified = false;
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFFont2.of = function(ref, doc, embedder) {
      return new PDFFont2(ref, doc, embedder);
    };
    return PDFFont2;
  }()
);
var PDFFont_default = PDFFont;

// node_modules/pdf-lib/es/api/PDFImage.js
var PDFImage = (
  /** @class */
  function() {
    function PDFImage2(ref, doc, embedder) {
      assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      assertIs(embedder, "embedder", [
        [JpegEmbedder_default, "JpegEmbedder"],
        [PngEmbedder_default, "PngEmbedder"]
      ]);
      this.ref = ref;
      this.doc = doc;
      this.width = embedder.width;
      this.height = embedder.height;
      this.embedder = embedder;
    }
    PDFImage2.prototype.scale = function(factor) {
      assertIs(factor, "factor", ["number"]);
      return { width: this.width * factor, height: this.height * factor };
    };
    PDFImage2.prototype.scaleToFit = function(width, height) {
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var imgWidthScale = width / this.width;
      var imgHeightScale = height / this.height;
      var scale2 = Math.min(imgWidthScale, imgHeightScale);
      return this.scale(scale2);
    };
    PDFImage2.prototype.size = function() {
      return this.scale(1);
    };
    PDFImage2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a, doc, ref;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.embedder)
                return [
                  2
                  /*return*/
                ];
              if (!this.embedTask) {
                _a = this, doc = _a.doc, ref = _a.ref;
                this.embedTask = this.embedder.embedIntoContext(doc.context, ref);
              }
              return [4, this.embedTask];
            case 1:
              _b.sent();
              this.embedder = void 0;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFImage2.of = function(ref, doc, embedder) {
      return new PDFImage2(ref, doc, embedder);
    };
    return PDFImage2;
  }()
);
var PDFImage_default = PDFImage;

// node_modules/pdf-lib/es/api/image/alignment.js
var ImageAlignment;
(function(ImageAlignment2) {
  ImageAlignment2[ImageAlignment2["Left"] = 0] = "Left";
  ImageAlignment2[ImageAlignment2["Center"] = 1] = "Center";
  ImageAlignment2[ImageAlignment2["Right"] = 2] = "Right";
})(ImageAlignment || (ImageAlignment = {}));

// node_modules/pdf-lib/es/api/form/PDFField.js
var assertFieldAppearanceOptions = function(options) {
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, "options.x", ["number"]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, "options.y", ["number"]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, "options.width", ["number"]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, "options.height", ["number"]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, "options.textColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, "options.backgroundColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, "options.borderColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, "options.borderWidth", ["number"]);
  assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, "options.rotate", [[Object, "Rotation"]]);
};
var PDFField = (
  /** @class */
  function() {
    function PDFField2(acroField, ref, doc) {
      assertIs(acroField, "acroField", [[PDFAcroTerminal_default, "PDFAcroTerminal"]]);
      assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      this.acroField = acroField;
      this.ref = ref;
      this.doc = doc;
    }
    PDFField2.prototype.getName = function() {
      var _a;
      return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
    };
    PDFField2.prototype.isReadOnly = function() {
      return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);
    };
    PDFField2.prototype.enableReadOnly = function() {
      this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);
    };
    PDFField2.prototype.disableReadOnly = function() {
      this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);
    };
    PDFField2.prototype.isRequired = function() {
      return this.acroField.hasFlag(AcroFieldFlags.Required);
    };
    PDFField2.prototype.enableRequired = function() {
      this.acroField.setFlagTo(AcroFieldFlags.Required, true);
    };
    PDFField2.prototype.disableRequired = function() {
      this.acroField.setFlagTo(AcroFieldFlags.Required, false);
    };
    PDFField2.prototype.isExported = function() {
      return !this.acroField.hasFlag(AcroFieldFlags.NoExport);
    };
    PDFField2.prototype.enableExporting = function() {
      this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);
    };
    PDFField2.prototype.disableExporting = function() {
      this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);
    };
    PDFField2.prototype.needsAppearancesUpdate = function() {
      throw new MethodNotImplementedError(this.constructor.name, "needsAppearancesUpdate");
    };
    PDFField2.prototype.defaultUpdateAppearances = function(_font) {
      throw new MethodNotImplementedError(this.constructor.name, "defaultUpdateAppearances");
    };
    PDFField2.prototype.markAsDirty = function() {
      this.doc.getForm().markFieldAsDirty(this.ref);
    };
    PDFField2.prototype.markAsClean = function() {
      this.doc.getForm().markFieldAsClean(this.ref);
    };
    PDFField2.prototype.isDirty = function() {
      return this.doc.getForm().fieldIsDirty(this.ref);
    };
    PDFField2.prototype.createWidget = function(options) {
      var _a;
      var textColor = options.textColor;
      var backgroundColor = options.backgroundColor;
      var borderColor = options.borderColor;
      var borderWidth = options.borderWidth;
      var degreesAngle = toDegrees(options.rotate);
      var caption = options.caption;
      var x4 = options.x;
      var y4 = options.y;
      var width = options.width + borderWidth;
      var height = options.height + borderWidth;
      var hidden = Boolean(options.hidden);
      var pageRef = options.page;
      assertMultiple(degreesAngle, "degreesAngle", 90);
      var widget = PDFWidgetAnnotation_default.create(this.doc.context, this.ref);
      var rect = rotateRectangle({ x: x4, y: y4, width, height }, borderWidth, degreesAngle);
      widget.setRectangle(rect);
      if (pageRef)
        widget.setP(pageRef);
      var ac = widget.getOrCreateAppearanceCharacteristics();
      if (backgroundColor) {
        ac.setBackgroundColor(colorToComponents(backgroundColor));
      }
      ac.setRotation(degreesAngle);
      if (caption)
        ac.setCaptions({ normal: caption });
      if (borderColor)
        ac.setBorderColor(colorToComponents(borderColor));
      var bs = widget.getOrCreateBorderStyle();
      if (borderWidth !== void 0)
        bs.setWidth(borderWidth);
      widget.setFlagTo(AnnotationFlags.Print, true);
      widget.setFlagTo(AnnotationFlags.Hidden, hidden);
      widget.setFlagTo(AnnotationFlags.Invisible, false);
      if (textColor) {
        var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
        var newDa = da + "\n" + setFillingColor(textColor).toString();
        this.acroField.setDefaultAppearance(newDa);
      }
      return widget;
    };
    PDFField2.prototype.updateWidgetAppearanceWithFont = function(widget, font, _a) {
      var normal = _a.normal, rollover = _a.rollover, down = _a.down;
      this.updateWidgetAppearances(widget, {
        normal: this.createAppearanceStream(widget, normal, font),
        rollover: rollover && this.createAppearanceStream(widget, rollover, font),
        down: down && this.createAppearanceStream(widget, down, font)
      });
    };
    PDFField2.prototype.updateOnOffWidgetAppearance = function(widget, onValue, _a) {
      var normal = _a.normal, rollover = _a.rollover, down = _a.down;
      this.updateWidgetAppearances(widget, {
        normal: this.createAppearanceDict(widget, normal, onValue),
        rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),
        down: down && this.createAppearanceDict(widget, down, onValue)
      });
    };
    PDFField2.prototype.updateWidgetAppearances = function(widget, _a) {
      var normal = _a.normal, rollover = _a.rollover, down = _a.down;
      widget.setNormalAppearance(normal);
      if (rollover) {
        widget.setRolloverAppearance(rollover);
      } else {
        widget.removeRolloverAppearance();
      }
      if (down) {
        widget.setDownAppearance(down);
      } else {
        widget.removeDownAppearance();
      }
    };
    PDFField2.prototype.createAppearanceStream = function(widget, appearance, font) {
      var _a;
      var context = this.acroField.dict.context;
      var _b = widget.getRectangle(), width = _b.width, height = _b.height;
      var Resources = font && { Font: (_a = {}, _a[font.name] = font.ref, _a) };
      var stream2 = context.formXObject(appearance, {
        Resources,
        BBox: context.obj([0, 0, width, height]),
        Matrix: context.obj([1, 0, 0, 1, 0, 0])
      });
      var streamRef = context.register(stream2);
      return streamRef;
    };
    PDFField2.prototype.createImageAppearanceStream = function(widget, image, alignment) {
      var _a;
      var _b;
      var context = this.acroField.dict.context;
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
      var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
      var adj = adjustDimsForRotation(rectangle, rotation);
      var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);
      var options = {
        x: borderWidth,
        y: borderWidth,
        width: imageDims.width,
        height: imageDims.height,
        //
        rotate: degrees(0),
        xSkew: degrees(0),
        ySkew: degrees(0)
      };
      if (alignment === ImageAlignment.Center) {
        options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;
        options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;
      } else if (alignment === ImageAlignment.Right) {
        options.x = adj.width - borderWidth - imageDims.width;
        options.y = adj.height - borderWidth - imageDims.height;
      }
      var imageName = this.doc.context.addRandomSuffix("Image", 10);
      var appearance = __spreadArrays(rotate, drawImage(imageName, options));
      var Resources = { XObject: (_a = {}, _a[imageName] = image.ref, _a) };
      var stream2 = context.formXObject(appearance, {
        Resources,
        BBox: context.obj([0, 0, rectangle.width, rectangle.height]),
        Matrix: context.obj([1, 0, 0, 1, 0, 0])
      });
      return context.register(stream2);
    };
    PDFField2.prototype.createAppearanceDict = function(widget, appearance, onValue) {
      var context = this.acroField.dict.context;
      var onStreamRef = this.createAppearanceStream(widget, appearance.on);
      var offStreamRef = this.createAppearanceStream(widget, appearance.off);
      var appearanceDict = context.obj({});
      appearanceDict.set(onValue, onStreamRef);
      appearanceDict.set(PDFName_default.of("Off"), offStreamRef);
      return appearanceDict;
    };
    return PDFField2;
  }()
);
var PDFField_default = PDFField;

// node_modules/pdf-lib/es/api/form/PDFCheckBox.js
var PDFCheckBox = (
  /** @class */
  function(_super) {
    __extends(PDFCheckBox2, _super);
    function PDFCheckBox2(acroCheckBox, ref, doc) {
      var _this = _super.call(this, acroCheckBox, ref, doc) || this;
      assertIs(acroCheckBox, "acroCheckBox", [
        [PDFAcroCheckBox_default, "PDFAcroCheckBox"]
      ]);
      _this.acroField = acroCheckBox;
      return _this;
    }
    PDFCheckBox2.prototype.check = function() {
      var _a;
      var onValue = (_a = this.acroField.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
      this.markAsDirty();
      this.acroField.setValue(onValue);
    };
    PDFCheckBox2.prototype.uncheck = function() {
      this.markAsDirty();
      this.acroField.setValue(PDFName_default.of("Off"));
    };
    PDFCheckBox2.prototype.isChecked = function() {
      var onValue = this.acroField.getOnValue();
      return !!onValue && onValue === this.acroField.getValue();
    };
    PDFCheckBox2.prototype.addToPage = function(page, options) {
      var _a, _b, _c, _d, _e2, _f;
      assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      if (!options)
        options = {};
      if (!("textColor" in options))
        options.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options))
        options.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options))
        options.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options))
        options.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : 50,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options.textColor,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: (_e2 = options.borderWidth) !== null && _e2 !== void 0 ? _e2 : 0,
        rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      widget.setAppearanceState(PDFName_default.of("Off"));
      this.updateWidgetAppearance(widget, PDFName_default.of("Yes"));
      page.node.addAnnot(widgetRef);
    };
    PDFCheckBox2.prototype.needsAppearancesUpdate = function() {
      var _a;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var state = widget.getAppearanceState();
        var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
        if (!(normal instanceof PDFDict_default))
          return true;
        if (state && !normal.has(state))
          return true;
      }
      return false;
    };
    PDFCheckBox2.prototype.defaultUpdateAppearances = function() {
      this.updateAppearances();
    };
    PDFCheckBox2.prototype.updateAppearances = function(provider) {
      var _a;
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var onValue = (_a = widget.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
        if (!onValue)
          continue;
        this.updateWidgetAppearance(widget, onValue, provider);
      }
      this.markAsClean();
    };
    PDFCheckBox2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultCheckBoxAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget));
      this.updateOnOffWidgetAppearance(widget, onValue, appearances);
    };
    PDFCheckBox2.of = function(acroCheckBox, ref, doc) {
      return new PDFCheckBox2(acroCheckBox, ref, doc);
    };
    return PDFCheckBox2;
  }(PDFField_default)
);
var PDFCheckBox_default = PDFCheckBox;

// node_modules/pdf-lib/es/api/form/PDFDropdown.js
var PDFDropdown = (
  /** @class */
  function(_super) {
    __extends(PDFDropdown2, _super);
    function PDFDropdown2(acroComboBox, ref, doc) {
      var _this = _super.call(this, acroComboBox, ref, doc) || this;
      assertIs(acroComboBox, "acroComboBox", [
        [PDFAcroComboBox_default, "PDFAcroComboBox"]
      ]);
      _this.acroField = acroComboBox;
      return _this;
    }
    PDFDropdown2.prototype.getOptions = function() {
      var rawOptions = this.acroField.getOptions();
      var options = new Array(rawOptions.length);
      for (var idx = 0, len = options.length; idx < len; idx++) {
        var _a = rawOptions[idx], display = _a.display, value = _a.value;
        options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
      }
      return options;
    };
    PDFDropdown2.prototype.getSelected = function() {
      var values2 = this.acroField.getValues();
      var selected = new Array(values2.length);
      for (var idx = 0, len = values2.length; idx < len; idx++) {
        selected[idx] = values2[idx].decodeText();
      }
      return selected;
    };
    PDFDropdown2.prototype.setOptions = function(options) {
      assertIs(options, "options", [Array]);
      var optionObjects = new Array(options.length);
      for (var idx = 0, len = options.length; idx < len; idx++) {
        optionObjects[idx] = { value: PDFHexString_default.fromText(options[idx]) };
      }
      this.acroField.setOptions(optionObjects);
    };
    PDFDropdown2.prototype.addOptions = function(options) {
      assertIs(options, "options", ["string", Array]);
      var optionsArr = Array.isArray(options) ? options : [options];
      var existingOptions = this.acroField.getOptions();
      var newOptions = new Array(optionsArr.length);
      for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
        newOptions[idx] = { value: PDFHexString_default.fromText(optionsArr[idx]) };
      }
      this.acroField.setOptions(existingOptions.concat(newOptions));
    };
    PDFDropdown2.prototype.select = function(options, merge) {
      if (merge === void 0) {
        merge = false;
      }
      assertIs(options, "options", ["string", Array]);
      assertIs(merge, "merge", ["boolean"]);
      var optionsArr = Array.isArray(options) ? options : [options];
      var validOptions = this.getOptions();
      var hasCustomOption = optionsArr.find(function(option) {
        return !validOptions.includes(option);
      });
      if (hasCustomOption)
        this.enableEditing();
      this.markAsDirty();
      if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
        this.enableMultiselect();
      }
      var values2 = new Array(optionsArr.length);
      for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
        values2[idx] = PDFHexString_default.fromText(optionsArr[idx]);
      }
      if (merge) {
        var existingValues = this.acroField.getValues();
        this.acroField.setValues(existingValues.concat(values2));
      } else {
        this.acroField.setValues(values2);
      }
    };
    PDFDropdown2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValues([]);
    };
    PDFDropdown2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFDropdown2.prototype.isEditable = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Edit);
    };
    PDFDropdown2.prototype.enableEditing = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Edit, true);
    };
    PDFDropdown2.prototype.disableEditing = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Edit, false);
    };
    PDFDropdown2.prototype.isSorted = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Sort);
    };
    PDFDropdown2.prototype.enableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
    };
    PDFDropdown2.prototype.disableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
    };
    PDFDropdown2.prototype.isMultiselect = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
    };
    PDFDropdown2.prototype.enableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
    };
    PDFDropdown2.prototype.disableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
    };
    PDFDropdown2.prototype.isSpellChecked = function() {
      return !this.acroField.hasFlag(AcroChoiceFlags.DoNotSpellCheck);
    };
    PDFDropdown2.prototype.enableSpellChecking = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, false);
    };
    PDFDropdown2.prototype.disableSpellChecking = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, true);
    };
    PDFDropdown2.prototype.isSelectOnClick = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
    };
    PDFDropdown2.prototype.enableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
    };
    PDFDropdown2.prototype.disableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
    };
    PDFDropdown2.prototype.addToPage = function(page, options) {
      var _a, _b, _c, _d, _e2, _f, _g;
      assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      if (!options)
        options = {};
      if (!("textColor" in options))
        options.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options))
        options.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options))
        options.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options))
        options.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options.textColor,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: (_e2 = options.borderWidth) !== null && _e2 !== void 0 ? _e2 : 0,
        rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFDropdown2.prototype.needsAppearancesUpdate = function() {
      var _a;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFDropdown2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFDropdown2.prototype.updateAppearances = function(font, provider) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider);
      }
      this.markAsClean();
    };
    PDFDropdown2.prototype.updateWidgetAppearance = function(widget, font, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultDropdownAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFDropdown2.of = function(acroComboBox, ref, doc) {
      return new PDFDropdown2(acroComboBox, ref, doc);
    };
    return PDFDropdown2;
  }(PDFField_default)
);
var PDFDropdown_default = PDFDropdown;

// node_modules/pdf-lib/es/api/form/PDFOptionList.js
var PDFOptionList = (
  /** @class */
  function(_super) {
    __extends(PDFOptionList2, _super);
    function PDFOptionList2(acroListBox, ref, doc) {
      var _this = _super.call(this, acroListBox, ref, doc) || this;
      assertIs(acroListBox, "acroListBox", [[PDFAcroListBox_default, "PDFAcroListBox"]]);
      _this.acroField = acroListBox;
      return _this;
    }
    PDFOptionList2.prototype.getOptions = function() {
      var rawOptions = this.acroField.getOptions();
      var options = new Array(rawOptions.length);
      for (var idx = 0, len = options.length; idx < len; idx++) {
        var _a = rawOptions[idx], display = _a.display, value = _a.value;
        options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
      }
      return options;
    };
    PDFOptionList2.prototype.getSelected = function() {
      var values2 = this.acroField.getValues();
      var selected = new Array(values2.length);
      for (var idx = 0, len = values2.length; idx < len; idx++) {
        selected[idx] = values2[idx].decodeText();
      }
      return selected;
    };
    PDFOptionList2.prototype.setOptions = function(options) {
      assertIs(options, "options", [Array]);
      this.markAsDirty();
      var optionObjects = new Array(options.length);
      for (var idx = 0, len = options.length; idx < len; idx++) {
        optionObjects[idx] = { value: PDFHexString_default.fromText(options[idx]) };
      }
      this.acroField.setOptions(optionObjects);
    };
    PDFOptionList2.prototype.addOptions = function(options) {
      assertIs(options, "options", ["string", Array]);
      this.markAsDirty();
      var optionsArr = Array.isArray(options) ? options : [options];
      var existingOptions = this.acroField.getOptions();
      var newOptions = new Array(optionsArr.length);
      for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
        newOptions[idx] = { value: PDFHexString_default.fromText(optionsArr[idx]) };
      }
      this.acroField.setOptions(existingOptions.concat(newOptions));
    };
    PDFOptionList2.prototype.select = function(options, merge) {
      if (merge === void 0) {
        merge = false;
      }
      assertIs(options, "options", ["string", Array]);
      assertIs(merge, "merge", ["boolean"]);
      var optionsArr = Array.isArray(options) ? options : [options];
      var validOptions = this.getOptions();
      assertIsSubset(optionsArr, "option", validOptions);
      this.markAsDirty();
      if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
        this.enableMultiselect();
      }
      var values2 = new Array(optionsArr.length);
      for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
        values2[idx] = PDFHexString_default.fromText(optionsArr[idx]);
      }
      if (merge) {
        var existingValues = this.acroField.getValues();
        this.acroField.setValues(existingValues.concat(values2));
      } else {
        this.acroField.setValues(values2);
      }
    };
    PDFOptionList2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValues([]);
    };
    PDFOptionList2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFOptionList2.prototype.isSorted = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Sort);
    };
    PDFOptionList2.prototype.enableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
    };
    PDFOptionList2.prototype.disableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
    };
    PDFOptionList2.prototype.isMultiselect = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
    };
    PDFOptionList2.prototype.enableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
    };
    PDFOptionList2.prototype.disableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
    };
    PDFOptionList2.prototype.isSelectOnClick = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
    };
    PDFOptionList2.prototype.enableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
    };
    PDFOptionList2.prototype.disableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
    };
    PDFOptionList2.prototype.addToPage = function(page, options) {
      var _a, _b, _c, _d, _e2, _f, _g;
      assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      if (!options)
        options = {};
      if (!("textColor" in options))
        options.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options))
        options.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options))
        options.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options))
        options.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
        textColor: options.textColor,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: (_e2 = options.borderWidth) !== null && _e2 !== void 0 ? _e2 : 0,
        rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFOptionList2.prototype.needsAppearancesUpdate = function() {
      var _a;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFOptionList2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFOptionList2.prototype.updateAppearances = function(font, provider) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider);
      }
      this.markAsClean();
    };
    PDFOptionList2.prototype.updateWidgetAppearance = function(widget, font, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultOptionListAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFOptionList2.of = function(acroListBox, ref, doc) {
      return new PDFOptionList2(acroListBox, ref, doc);
    };
    return PDFOptionList2;
  }(PDFField_default)
);
var PDFOptionList_default = PDFOptionList;

// node_modules/pdf-lib/es/api/form/PDFRadioGroup.js
var PDFRadioGroup = (
  /** @class */
  function(_super) {
    __extends(PDFRadioGroup2, _super);
    function PDFRadioGroup2(acroRadioButton, ref, doc) {
      var _this = _super.call(this, acroRadioButton, ref, doc) || this;
      assertIs(acroRadioButton, "acroRadioButton", [
        [PDFAcroRadioButton_default, "PDFAcroRadioButton"]
      ]);
      _this.acroField = acroRadioButton;
      return _this;
    }
    PDFRadioGroup2.prototype.getOptions = function() {
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        var exportOptions = new Array(exportValues.length);
        for (var idx = 0, len = exportValues.length; idx < len; idx++) {
          exportOptions[idx] = exportValues[idx].decodeText();
        }
        return exportOptions;
      }
      var onValues = this.acroField.getOnValues();
      var onOptions = new Array(onValues.length);
      for (var idx = 0, len = onOptions.length; idx < len; idx++) {
        onOptions[idx] = onValues[idx].decodeText();
      }
      return onOptions;
    };
    PDFRadioGroup2.prototype.getSelected = function() {
      var value = this.acroField.getValue();
      if (value === PDFName_default.of("Off"))
        return void 0;
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        var onValues = this.acroField.getOnValues();
        for (var idx = 0, len = onValues.length; idx < len; idx++) {
          if (onValues[idx] === value)
            return exportValues[idx].decodeText();
        }
      }
      return value.decodeText();
    };
    PDFRadioGroup2.prototype.select = function(option) {
      assertIs(option, "option", ["string"]);
      var validOptions = this.getOptions();
      assertIsOneOf(option, "option", validOptions);
      this.markAsDirty();
      var onValues = this.acroField.getOnValues();
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        for (var idx = 0, len = exportValues.length; idx < len; idx++) {
          if (exportValues[idx].decodeText() === option) {
            this.acroField.setValue(onValues[idx]);
          }
        }
      } else {
        for (var idx = 0, len = onValues.length; idx < len; idx++) {
          var value = onValues[idx];
          if (value.decodeText() === option)
            this.acroField.setValue(value);
        }
      }
    };
    PDFRadioGroup2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValue(PDFName_default.of("Off"));
    };
    PDFRadioGroup2.prototype.isOffToggleable = function() {
      return !this.acroField.hasFlag(AcroButtonFlags.NoToggleToOff);
    };
    PDFRadioGroup2.prototype.enableOffToggling = function() {
      this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, false);
    };
    PDFRadioGroup2.prototype.disableOffToggling = function() {
      this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, true);
    };
    PDFRadioGroup2.prototype.isMutuallyExclusive = function() {
      return !this.acroField.hasFlag(AcroButtonFlags.RadiosInUnison);
    };
    PDFRadioGroup2.prototype.enableMutualExclusion = function() {
      this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, false);
    };
    PDFRadioGroup2.prototype.disableMutualExclusion = function() {
      this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, true);
    };
    PDFRadioGroup2.prototype.addOptionToPage = function(option, page, options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j;
      assertIs(option, "option", ["string"]);
      assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      var widget = this.createWidget({
        x: (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0,
        y: (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0,
        width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : 50,
        height: (_d = options === null || options === void 0 ? void 0 : options.height) !== null && _d !== void 0 ? _d : 50,
        textColor: (_e2 = options === null || options === void 0 ? void 0 : options.textColor) !== null && _e2 !== void 0 ? _e2 : rgb(0, 0, 0),
        backgroundColor: (_f = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _f !== void 0 ? _f : rgb(1, 1, 1),
        borderColor: (_g = options === null || options === void 0 ? void 0 : options.borderColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
        borderWidth: (_h = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _h !== void 0 ? _h : 1,
        rotate: (_j = options === null || options === void 0 ? void 0 : options.rotate) !== null && _j !== void 0 ? _j : degrees(0),
        hidden: options === null || options === void 0 ? void 0 : options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      var apStateValue = this.acroField.addWidgetWithOpt(widgetRef, PDFHexString_default.fromText(option), !this.isMutuallyExclusive());
      widget.setAppearanceState(PDFName_default.of("Off"));
      this.updateWidgetAppearance(widget, apStateValue);
      page.node.addAnnot(widgetRef);
    };
    PDFRadioGroup2.prototype.needsAppearancesUpdate = function() {
      var _a;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var state = widget.getAppearanceState();
        var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
        if (!(normal instanceof PDFDict_default))
          return true;
        if (state && !normal.has(state))
          return true;
      }
      return false;
    };
    PDFRadioGroup2.prototype.defaultUpdateAppearances = function() {
      this.updateAppearances();
    };
    PDFRadioGroup2.prototype.updateAppearances = function(provider) {
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var onValue = widget.getOnValue();
        if (!onValue)
          continue;
        this.updateWidgetAppearance(widget, onValue, provider);
      }
    };
    PDFRadioGroup2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultRadioGroupAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget));
      this.updateOnOffWidgetAppearance(widget, onValue, appearances);
    };
    PDFRadioGroup2.of = function(acroRadioButton, ref, doc) {
      return new PDFRadioGroup2(acroRadioButton, ref, doc);
    };
    return PDFRadioGroup2;
  }(PDFField_default)
);
var PDFRadioGroup_default = PDFRadioGroup;

// node_modules/pdf-lib/es/api/form/PDFSignature.js
var PDFSignature = (
  /** @class */
  function(_super) {
    __extends(PDFSignature2, _super);
    function PDFSignature2(acroSignature, ref, doc) {
      var _this = _super.call(this, acroSignature, ref, doc) || this;
      assertIs(acroSignature, "acroSignature", [
        [PDFAcroSignature_default, "PDFAcroSignature"]
      ]);
      _this.acroField = acroSignature;
      return _this;
    }
    PDFSignature2.prototype.needsAppearancesUpdate = function() {
      return false;
    };
    PDFSignature2.of = function(acroSignature, ref, doc) {
      return new PDFSignature2(acroSignature, ref, doc);
    };
    return PDFSignature2;
  }(PDFField_default)
);
var PDFSignature_default = PDFSignature;

// node_modules/pdf-lib/es/api/form/PDFTextField.js
var PDFTextField = (
  /** @class */
  function(_super) {
    __extends(PDFTextField2, _super);
    function PDFTextField2(acroText, ref, doc) {
      var _this = _super.call(this, acroText, ref, doc) || this;
      assertIs(acroText, "acroText", [[PDFAcroText_default, "PDFAcroText"]]);
      _this.acroField = acroText;
      return _this;
    }
    PDFTextField2.prototype.getText = function() {
      var value = this.acroField.getValue();
      if (!value && this.isRichFormatted()) {
        throw new RichTextFieldReadError(this.getName());
      }
      return value === null || value === void 0 ? void 0 : value.decodeText();
    };
    PDFTextField2.prototype.setText = function(text) {
      assertOrUndefined(text, "text", ["string"]);
      var maxLength = this.getMaxLength();
      if (maxLength !== void 0 && text && text.length > maxLength) {
        throw new ExceededMaxLengthError(text.length, maxLength, this.getName());
      }
      this.markAsDirty();
      this.disableRichFormatting();
      if (text) {
        this.acroField.setValue(PDFHexString_default.fromText(text));
      } else {
        this.acroField.removeValue();
      }
    };
    PDFTextField2.prototype.getAlignment = function() {
      var quadding = this.acroField.getQuadding();
      return quadding === 0 ? TextAlignment.Left : quadding === 1 ? TextAlignment.Center : quadding === 2 ? TextAlignment.Right : TextAlignment.Left;
    };
    PDFTextField2.prototype.setAlignment = function(alignment) {
      assertIsOneOf(alignment, "alignment", TextAlignment);
      this.markAsDirty();
      this.acroField.setQuadding(alignment);
    };
    PDFTextField2.prototype.getMaxLength = function() {
      return this.acroField.getMaxLength();
    };
    PDFTextField2.prototype.setMaxLength = function(maxLength) {
      assertRangeOrUndefined(maxLength, "maxLength", 0, Number.MAX_SAFE_INTEGER);
      this.markAsDirty();
      if (maxLength === void 0) {
        this.acroField.removeMaxLength();
      } else {
        var text = this.getText();
        if (text && text.length > maxLength) {
          throw new InvalidMaxLengthError(text.length, maxLength, this.getName());
        }
        this.acroField.setMaxLength(maxLength);
      }
    };
    PDFTextField2.prototype.removeMaxLength = function() {
      this.markAsDirty();
      this.acroField.removeMaxLength();
    };
    PDFTextField2.prototype.setImage = function(image) {
      var fieldAlignment = this.getAlignment();
      var alignment = fieldAlignment === TextAlignment.Center ? ImageAlignment.Center : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right : ImageAlignment.Left;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var streamRef = this.createImageAppearanceStream(widget, image, alignment);
        this.updateWidgetAppearances(widget, { normal: streamRef });
      }
      this.markAsClean();
    };
    PDFTextField2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFTextField2.prototype.isMultiline = function() {
      return this.acroField.hasFlag(AcroTextFlags.Multiline);
    };
    PDFTextField2.prototype.enableMultiline = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Multiline, true);
    };
    PDFTextField2.prototype.disableMultiline = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Multiline, false);
    };
    PDFTextField2.prototype.isPassword = function() {
      return this.acroField.hasFlag(AcroTextFlags.Password);
    };
    PDFTextField2.prototype.enablePassword = function() {
      this.acroField.setFlagTo(AcroTextFlags.Password, true);
    };
    PDFTextField2.prototype.disablePassword = function() {
      this.acroField.setFlagTo(AcroTextFlags.Password, false);
    };
    PDFTextField2.prototype.isFileSelector = function() {
      return this.acroField.hasFlag(AcroTextFlags.FileSelect);
    };
    PDFTextField2.prototype.enableFileSelection = function() {
      this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);
    };
    PDFTextField2.prototype.disableFileSelection = function() {
      this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);
    };
    PDFTextField2.prototype.isSpellChecked = function() {
      return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);
    };
    PDFTextField2.prototype.enableSpellChecking = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);
    };
    PDFTextField2.prototype.disableSpellChecking = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);
    };
    PDFTextField2.prototype.isScrollable = function() {
      return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);
    };
    PDFTextField2.prototype.enableScrolling = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);
    };
    PDFTextField2.prototype.disableScrolling = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);
    };
    PDFTextField2.prototype.isCombed = function() {
      return this.acroField.hasFlag(AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0;
    };
    PDFTextField2.prototype.enableCombing = function() {
      if (this.getMaxLength() === void 0) {
        var msg = "PDFTextFields must have a max length in order to be combed";
        console.warn(msg);
      }
      this.markAsDirty();
      this.disableMultiline();
      this.disablePassword();
      this.disableFileSelection();
      this.acroField.setFlagTo(AcroTextFlags.Comb, true);
    };
    PDFTextField2.prototype.disableCombing = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Comb, false);
    };
    PDFTextField2.prototype.isRichFormatted = function() {
      return this.acroField.hasFlag(AcroTextFlags.RichText);
    };
    PDFTextField2.prototype.enableRichFormatting = function() {
      this.acroField.setFlagTo(AcroTextFlags.RichText, true);
    };
    PDFTextField2.prototype.disableRichFormatting = function() {
      this.acroField.setFlagTo(AcroTextFlags.RichText, false);
    };
    PDFTextField2.prototype.addToPage = function(page, options) {
      var _a, _b, _c, _d, _e2, _f, _g;
      assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      if (!options)
        options = {};
      if (!("textColor" in options))
        options.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options))
        options.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options))
        options.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options))
        options.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options.textColor,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: (_e2 = options.borderWidth) !== null && _e2 !== void 0 ? _e2 : 0,
        rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFTextField2.prototype.needsAppearancesUpdate = function() {
      var _a;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFTextField2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFTextField2.prototype.updateAppearances = function(font, provider) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider);
      }
      this.markAsClean();
    };
    PDFTextField2.prototype.updateWidgetAppearance = function(widget, font, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultTextFieldAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFTextField2.of = function(acroText, ref, doc) {
      return new PDFTextField2(acroText, ref, doc);
    };
    return PDFTextField2;
  }(PDFField_default)
);
var PDFTextField_default = PDFTextField;

// node_modules/pdf-lib/es/api/StandardFonts.js
var StandardFonts;
(function(StandardFonts2) {
  StandardFonts2["Courier"] = "Courier";
  StandardFonts2["CourierBold"] = "Courier-Bold";
  StandardFonts2["CourierOblique"] = "Courier-Oblique";
  StandardFonts2["CourierBoldOblique"] = "Courier-BoldOblique";
  StandardFonts2["Helvetica"] = "Helvetica";
  StandardFonts2["HelveticaBold"] = "Helvetica-Bold";
  StandardFonts2["HelveticaOblique"] = "Helvetica-Oblique";
  StandardFonts2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
  StandardFonts2["TimesRoman"] = "Times-Roman";
  StandardFonts2["TimesRomanBold"] = "Times-Bold";
  StandardFonts2["TimesRomanItalic"] = "Times-Italic";
  StandardFonts2["TimesRomanBoldItalic"] = "Times-BoldItalic";
  StandardFonts2["Symbol"] = "Symbol";
  StandardFonts2["ZapfDingbats"] = "ZapfDingbats";
})(StandardFonts || (StandardFonts = {}));

// node_modules/pdf-lib/es/api/form/PDFForm.js
var PDFForm = (
  /** @class */
  function() {
    function PDFForm2(acroForm, doc) {
      var _this = this;
      this.embedDefaultFont = function() {
        return _this.doc.embedStandardFont(StandardFonts.Helvetica);
      };
      assertIs(acroForm, "acroForm", [[PDFAcroForm_default, "PDFAcroForm"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      this.acroForm = acroForm;
      this.doc = doc;
      this.dirtyFields = /* @__PURE__ */ new Set();
      this.defaultFontCache = Cache_default.populatedBy(this.embedDefaultFont);
    }
    PDFForm2.prototype.hasXFA = function() {
      return this.acroForm.dict.has(PDFName_default.of("XFA"));
    };
    PDFForm2.prototype.deleteXFA = function() {
      this.acroForm.dict.delete(PDFName_default.of("XFA"));
    };
    PDFForm2.prototype.getFields = function() {
      var allFields = this.acroForm.getAllFields();
      var fields = [];
      for (var idx = 0, len = allFields.length; idx < len; idx++) {
        var _a = allFields[idx], acroField = _a[0], ref = _a[1];
        var field = convertToPDFField(acroField, ref, this.doc);
        if (field)
          fields.push(field);
      }
      return fields;
    };
    PDFForm2.prototype.getFieldMaybe = function(name2) {
      assertIs(name2, "name", ["string"]);
      var fields = this.getFields();
      for (var idx = 0, len = fields.length; idx < len; idx++) {
        var field = fields[idx];
        if (field.getName() === name2)
          return field;
      }
      return void 0;
    };
    PDFForm2.prototype.getField = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getFieldMaybe(name2);
      if (field)
        return field;
      throw new NoSuchFieldError(name2);
    };
    PDFForm2.prototype.getButton = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFButton_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFButton_default, field);
    };
    PDFForm2.prototype.getCheckBox = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFCheckBox_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFCheckBox_default, field);
    };
    PDFForm2.prototype.getDropdown = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFDropdown_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFDropdown_default, field);
    };
    PDFForm2.prototype.getOptionList = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFOptionList_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFOptionList_default, field);
    };
    PDFForm2.prototype.getRadioGroup = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFRadioGroup_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFRadioGroup_default, field);
    };
    PDFForm2.prototype.getSignature = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFSignature_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFSignature_default, field);
    };
    PDFForm2.prototype.getTextField = function(name2) {
      assertIs(name2, "name", ["string"]);
      var field = this.getField(name2);
      if (field instanceof PDFTextField_default)
        return field;
      throw new UnexpectedFieldTypeError(name2, PDFTextField_default, field);
    };
    PDFForm2.prototype.createButton = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var button = PDFAcroPushButton_default.create(this.doc.context);
      button.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [button, button.ref], nameParts.terminal);
      return PDFButton_default.of(button, button.ref, this.doc);
    };
    PDFForm2.prototype.createCheckBox = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var checkBox = PDFAcroCheckBox_default.create(this.doc.context);
      checkBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);
      return PDFCheckBox_default.of(checkBox, checkBox.ref, this.doc);
    };
    PDFForm2.prototype.createDropdown = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var comboBox = PDFAcroComboBox_default.create(this.doc.context);
      comboBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);
      return PDFDropdown_default.of(comboBox, comboBox.ref, this.doc);
    };
    PDFForm2.prototype.createOptionList = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var listBox = PDFAcroListBox_default.create(this.doc.context);
      listBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);
      return PDFOptionList_default.of(listBox, listBox.ref, this.doc);
    };
    PDFForm2.prototype.createRadioGroup = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var radioButton = PDFAcroRadioButton_default.create(this.doc.context);
      radioButton.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);
      return PDFRadioGroup_default.of(radioButton, radioButton.ref, this.doc);
    };
    PDFForm2.prototype.createTextField = function(name2) {
      assertIs(name2, "name", ["string"]);
      var nameParts = splitFieldName(name2);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var text = PDFAcroText_default.create(this.doc.context);
      text.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [text, text.ref], nameParts.terminal);
      return PDFTextField_default.of(text, text.ref, this.doc);
    };
    PDFForm2.prototype.flatten = function(options) {
      if (options === void 0) {
        options = { updateFieldAppearances: true };
      }
      if (options.updateFieldAppearances) {
        this.updateFieldAppearances();
      }
      var fields = this.getFields();
      for (var i3 = 0, lenFields = fields.length; i3 < lenFields; i3++) {
        var field = fields[i3];
        var widgets = field.acroField.getWidgets();
        for (var j4 = 0, lenWidgets = widgets.length; j4 < lenWidgets; j4++) {
          var widget = widgets[j4];
          var page = this.findWidgetPage(widget);
          var widgetRef = this.findWidgetAppearanceRef(field, widget);
          var xObjectKey = page.node.newXObject("FlatWidget", widgetRef);
          var rectangle = widget.getRectangle();
          var operators = __spreadArrays([
            pushGraphicsState(),
            translate(rectangle.x, rectangle.y)
          ], rotateInPlace(__assign(__assign({}, rectangle), { rotation: 0 })), [
            drawObject(xObjectKey),
            popGraphicsState()
          ]).filter(Boolean);
          page.pushOperators.apply(page, operators);
        }
        this.removeField(field);
      }
    };
    PDFForm2.prototype.removeField = function(field) {
      var widgets = field.acroField.getWidgets();
      var pages = /* @__PURE__ */ new Set();
      for (var i3 = 0, len = widgets.length; i3 < len; i3++) {
        var widget = widgets[i3];
        var widgetRef = this.findWidgetAppearanceRef(field, widget);
        var page = this.findWidgetPage(widget);
        pages.add(page);
        page.node.removeAnnot(widgetRef);
      }
      pages.forEach(function(page2) {
        return page2.node.removeAnnot(field.ref);
      });
      this.acroForm.removeField(field.acroField);
      var fieldKids = field.acroField.normalizedEntries().Kids;
      var kidsCount = fieldKids.size();
      for (var childIndex = 0; childIndex < kidsCount; childIndex++) {
        var child = fieldKids.get(childIndex);
        if (child instanceof PDFRef_default) {
          this.doc.context.delete(child);
        }
      }
      this.doc.context.delete(field.ref);
    };
    PDFForm2.prototype.updateFieldAppearances = function(font) {
      assertOrUndefined(font, "font", [[PDFFont_default, "PDFFont"]]);
      font = font !== null && font !== void 0 ? font : this.getDefaultFont();
      var fields = this.getFields();
      for (var idx = 0, len = fields.length; idx < len; idx++) {
        var field = fields[idx];
        if (field.needsAppearancesUpdate()) {
          field.defaultUpdateAppearances(font);
        }
      }
    };
    PDFForm2.prototype.markFieldAsDirty = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
      this.dirtyFields.add(fieldRef);
    };
    PDFForm2.prototype.markFieldAsClean = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
      this.dirtyFields.delete(fieldRef);
    };
    PDFForm2.prototype.fieldIsDirty = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
      return this.dirtyFields.has(fieldRef);
    };
    PDFForm2.prototype.getDefaultFont = function() {
      return this.defaultFontCache.access();
    };
    PDFForm2.prototype.findWidgetPage = function(widget) {
      var pageRef = widget.P();
      var page = this.doc.getPages().find(function(x4) {
        return x4.ref === pageRef;
      });
      if (page === void 0) {
        var widgetRef = this.doc.context.getObjectRef(widget.dict);
        if (widgetRef === void 0) {
          throw new Error("Could not find PDFRef for PDFObject");
        }
        page = this.doc.findPageForAnnotationRef(widgetRef);
        if (page === void 0) {
          throw new Error("Could not find page for PDFRef " + widgetRef);
        }
      }
      return page;
    };
    PDFForm2.prototype.findWidgetAppearanceRef = function(field, widget) {
      var _a;
      var refOrDict = widget.getNormalAppearance();
      if (refOrDict instanceof PDFDict_default && (field instanceof PDFCheckBox_default || field instanceof PDFRadioGroup_default)) {
        var value = field.acroField.getValue();
        var ref = (_a = refOrDict.get(value)) !== null && _a !== void 0 ? _a : refOrDict.get(PDFName_default.of("Off"));
        if (ref instanceof PDFRef_default) {
          refOrDict = ref;
        }
      }
      if (!(refOrDict instanceof PDFRef_default)) {
        var name_1 = field.getName();
        throw new Error("Failed to extract appearance ref for: " + name_1);
      }
      return refOrDict;
    };
    PDFForm2.prototype.findOrCreateNonTerminals = function(partialNames) {
      var nonTerminal = [
        this.acroForm
      ];
      for (var idx = 0, len = partialNames.length; idx < len; idx++) {
        var namePart = partialNames[idx];
        if (!namePart)
          throw new InvalidFieldNamePartError(namePart);
        var parent_1 = nonTerminal[0], parentRef = nonTerminal[1];
        var res = this.findNonTerminal(namePart, parent_1);
        if (res) {
          nonTerminal = res;
        } else {
          var node = PDFAcroNonTerminal_default.create(this.doc.context);
          node.setPartialName(namePart);
          node.setParent(parentRef);
          var nodeRef = this.doc.context.register(node.dict);
          parent_1.addField(nodeRef);
          nonTerminal = [node, nodeRef];
        }
      }
      return nonTerminal;
    };
    PDFForm2.prototype.findNonTerminal = function(partialName, parent) {
      var fields = parent instanceof PDFAcroForm_default ? this.acroForm.getFields() : createPDFAcroFields(parent.Kids());
      for (var idx = 0, len = fields.length; idx < len; idx++) {
        var _a = fields[idx], field = _a[0], ref = _a[1];
        if (field.getPartialName() === partialName) {
          if (field instanceof PDFAcroNonTerminal_default)
            return [field, ref];
          throw new FieldAlreadyExistsError(partialName);
        }
      }
      return void 0;
    };
    PDFForm2.of = function(acroForm, doc) {
      return new PDFForm2(acroForm, doc);
    };
    return PDFForm2;
  }()
);
var PDFForm_default = PDFForm;
var convertToPDFField = function(field, ref, doc) {
  if (field instanceof PDFAcroPushButton_default)
    return PDFButton_default.of(field, ref, doc);
  if (field instanceof PDFAcroCheckBox_default)
    return PDFCheckBox_default.of(field, ref, doc);
  if (field instanceof PDFAcroComboBox_default)
    return PDFDropdown_default.of(field, ref, doc);
  if (field instanceof PDFAcroListBox_default)
    return PDFOptionList_default.of(field, ref, doc);
  if (field instanceof PDFAcroText_default)
    return PDFTextField_default.of(field, ref, doc);
  if (field instanceof PDFAcroRadioButton_default) {
    return PDFRadioGroup_default.of(field, ref, doc);
  }
  if (field instanceof PDFAcroSignature_default) {
    return PDFSignature_default.of(field, ref, doc);
  }
  return void 0;
};
var splitFieldName = function(fullyQualifiedName) {
  if (fullyQualifiedName.length === 0) {
    throw new Error("PDF field names must not be empty strings");
  }
  var parts2 = fullyQualifiedName.split(".");
  for (var idx = 0, len = parts2.length; idx < len; idx++) {
    if (parts2[idx] === "") {
      throw new Error('Periods in PDF field names must be separated by at least one character: "' + fullyQualifiedName + '"');
    }
  }
  if (parts2.length === 1)
    return { nonTerminal: [], terminal: parts2[0] };
  return {
    nonTerminal: parts2.slice(0, parts2.length - 1),
    terminal: parts2[parts2.length - 1]
  };
};
var addFieldToParent = function(_a, _b, partialName) {
  var parent = _a[0], parentRef = _a[1];
  var field = _b[0], fieldRef = _b[1];
  var entries = parent.normalizedEntries();
  var fields = createPDFAcroFields("Kids" in entries ? entries.Kids : entries.Fields);
  for (var idx = 0, len = fields.length; idx < len; idx++) {
    if (fields[idx][0].getPartialName() === partialName) {
      throw new FieldAlreadyExistsError(partialName);
    }
  }
  parent.addField(fieldRef);
  field.setParent(parentRef);
};

// node_modules/pdf-lib/es/api/sizes.js
var PageSizes = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  Executive: [521.86, 756],
  Folio: [612, 936],
  Legal: [612, 1008],
  Letter: [612, 792],
  Tabloid: [792, 1224]
};

// node_modules/pdf-lib/es/api/PDFDocumentOptions.js
var ParseSpeeds;
(function(ParseSpeeds2) {
  ParseSpeeds2[ParseSpeeds2["Fastest"] = Infinity] = "Fastest";
  ParseSpeeds2[ParseSpeeds2["Fast"] = 1500] = "Fast";
  ParseSpeeds2[ParseSpeeds2["Medium"] = 500] = "Medium";
  ParseSpeeds2[ParseSpeeds2["Slow"] = 100] = "Slow";
})(ParseSpeeds || (ParseSpeeds = {}));

// node_modules/pdf-lib/es/api/PDFEmbeddedFile.js
var PDFEmbeddedFile = (
  /** @class */
  function() {
    function PDFEmbeddedFile2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      this.ref = ref;
      this.doc = doc;
      this.embedder = embedder;
    }
    PDFEmbeddedFile2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var ref, Names, EmbeddedFiles, EFNames, AF;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!!this.alreadyEmbedded)
                return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              ref = _a.sent();
              if (!this.doc.catalog.has(PDFName_default.of("Names"))) {
                this.doc.catalog.set(PDFName_default.of("Names"), this.doc.context.obj({}));
              }
              Names = this.doc.catalog.lookup(PDFName_default.of("Names"), PDFDict_default);
              if (!Names.has(PDFName_default.of("EmbeddedFiles"))) {
                Names.set(PDFName_default.of("EmbeddedFiles"), this.doc.context.obj({}));
              }
              EmbeddedFiles = Names.lookup(PDFName_default.of("EmbeddedFiles"), PDFDict_default);
              if (!EmbeddedFiles.has(PDFName_default.of("Names"))) {
                EmbeddedFiles.set(PDFName_default.of("Names"), this.doc.context.obj([]));
              }
              EFNames = EmbeddedFiles.lookup(PDFName_default.of("Names"), PDFArray_default);
              EFNames.push(PDFHexString_default.fromText(this.embedder.fileName));
              EFNames.push(ref);
              if (!this.doc.catalog.has(PDFName_default.of("AF"))) {
                this.doc.catalog.set(PDFName_default.of("AF"), this.doc.context.obj([]));
              }
              AF = this.doc.catalog.lookup(PDFName_default.of("AF"), PDFArray_default);
              AF.push(ref);
              this.alreadyEmbedded = true;
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFEmbeddedFile2.of = function(ref, doc, embedder) {
      return new PDFEmbeddedFile2(ref, doc, embedder);
    };
    return PDFEmbeddedFile2;
  }()
);
var PDFEmbeddedFile_default = PDFEmbeddedFile;

// node_modules/pdf-lib/es/api/PDFJavaScript.js
var PDFJavaScript = (
  /** @class */
  function() {
    function PDFJavaScript2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      this.ref = ref;
      this.doc = doc;
      this.embedder = embedder;
    }
    PDFJavaScript2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a, catalog, context, ref, Names, Javascript, JSNames;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!!this.alreadyEmbedded)
                return [3, 2];
              _a = this.doc, catalog = _a.catalog, context = _a.context;
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              ref = _b.sent();
              if (!catalog.has(PDFName_default.of("Names"))) {
                catalog.set(PDFName_default.of("Names"), context.obj({}));
              }
              Names = catalog.lookup(PDFName_default.of("Names"), PDFDict_default);
              if (!Names.has(PDFName_default.of("JavaScript"))) {
                Names.set(PDFName_default.of("JavaScript"), context.obj({}));
              }
              Javascript = Names.lookup(PDFName_default.of("JavaScript"), PDFDict_default);
              if (!Javascript.has(PDFName_default.of("Names"))) {
                Javascript.set(PDFName_default.of("Names"), context.obj([]));
              }
              JSNames = Javascript.lookup(PDFName_default.of("Names"), PDFArray_default);
              JSNames.push(PDFHexString_default.fromText(this.embedder.scriptName));
              JSNames.push(ref);
              this.alreadyEmbedded = true;
              _b.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFJavaScript2.of = function(ref, doc, embedder) {
      return new PDFJavaScript2(ref, doc, embedder);
    };
    return PDFJavaScript2;
  }()
);
var PDFJavaScript_default = PDFJavaScript;

// node_modules/pdf-lib/es/core/embedders/JavaScriptEmbedder.js
var JavaScriptEmbedder = (
  /** @class */
  function() {
    function JavaScriptEmbedder2(script, scriptName) {
      this.script = script;
      this.scriptName = scriptName;
    }
    JavaScriptEmbedder2.for = function(script, scriptName) {
      return new JavaScriptEmbedder2(script, scriptName);
    };
    JavaScriptEmbedder2.prototype.embedIntoContext = function(context, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var jsActionDict;
        return __generator(this, function(_a) {
          jsActionDict = context.obj({
            Type: "Action",
            S: "JavaScript",
            JS: PDFHexString_default.fromText(this.script)
          });
          if (ref) {
            context.assign(ref, jsActionDict);
            return [2, ref];
          } else {
            return [2, context.register(jsActionDict)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    return JavaScriptEmbedder2;
  }()
);
var JavaScriptEmbedder_default = JavaScriptEmbedder;

// node_modules/pdf-lib/es/api/PDFDocument.js
var PDFDocument = (
  /** @class */
  function() {
    function PDFDocument2(context, ignoreEncryption, updateMetadata) {
      var _this = this;
      this.defaultWordBreaks = [" "];
      this.computePages = function() {
        var pages = [];
        _this.catalog.Pages().traverse(function(node, ref) {
          if (node instanceof PDFPageLeaf_default) {
            var page = _this.pageMap.get(node);
            if (!page) {
              page = PDFPage_default.of(node, ref, _this);
              _this.pageMap.set(node, page);
            }
            pages.push(page);
          }
        });
        return pages;
      };
      this.getOrCreateForm = function() {
        var acroForm = _this.catalog.getOrCreateAcroForm();
        return PDFForm_default.of(acroForm, _this);
      };
      assertIs(context, "context", [[PDFContext_default, "PDFContext"]]);
      assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
      this.context = context;
      this.catalog = context.lookup(context.trailerInfo.Root);
      this.isEncrypted = !!context.lookup(context.trailerInfo.Encrypt);
      this.pageCache = Cache_default.populatedBy(this.computePages);
      this.pageMap = /* @__PURE__ */ new Map();
      this.formCache = Cache_default.populatedBy(this.getOrCreateForm);
      this.fonts = [];
      this.images = [];
      this.embeddedPages = [];
      this.embeddedFiles = [];
      this.javaScripts = [];
      if (!ignoreEncryption && this.isEncrypted)
        throw new EncryptedPDFError();
      if (updateMetadata)
        this.updateInfoDict();
    }
    PDFDocument2.load = function(pdf, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, ignoreEncryption, _b, parseSpeed, _c, throwOnInvalidObject, _d, updateMetadata, _e2, capNumbers, bytes, context;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              _a = options.ignoreEncryption, ignoreEncryption = _a === void 0 ? false : _a, _b = options.parseSpeed, parseSpeed = _b === void 0 ? ParseSpeeds.Slow : _b, _c = options.throwOnInvalidObject, throwOnInvalidObject = _c === void 0 ? false : _c, _d = options.updateMetadata, updateMetadata = _d === void 0 ? true : _d, _e2 = options.capNumbers, capNumbers = _e2 === void 0 ? false : _e2;
              assertIs(pdf, "pdf", ["string", Uint8Array, ArrayBuffer]);
              assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
              assertIs(parseSpeed, "parseSpeed", ["number"]);
              assertIs(throwOnInvalidObject, "throwOnInvalidObject", ["boolean"]);
              bytes = toUint8Array(pdf);
              return [4, PDFParser_default.forBytesWithOptions(bytes, parseSpeed, throwOnInvalidObject, capNumbers).parseDocument()];
            case 1:
              context = _f.sent();
              return [2, new PDFDocument2(context, ignoreEncryption, updateMetadata)];
          }
        });
      });
    };
    PDFDocument2.create = function(options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, updateMetadata, context, pageTree, pageTreeRef, catalog;
        return __generator(this, function(_b) {
          _a = options.updateMetadata, updateMetadata = _a === void 0 ? true : _a;
          context = PDFContext_default.create();
          pageTree = PDFPageTree_default.withContext(context);
          pageTreeRef = context.register(pageTree);
          catalog = PDFCatalog_default.withContextAndPages(context, pageTreeRef);
          context.trailerInfo.Root = context.register(catalog);
          return [2, new PDFDocument2(context, false, updateMetadata)];
        });
      });
    };
    PDFDocument2.prototype.registerFontkit = function(fontkit) {
      this.fontkit = fontkit;
    };
    PDFDocument2.prototype.getForm = function() {
      var form = this.formCache.access();
      if (form.hasXFA()) {
        console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA");
        form.deleteXFA();
      }
      return form;
    };
    PDFDocument2.prototype.getTitle = function() {
      var title = this.getInfoDict().lookup(PDFName_default.Title);
      if (!title)
        return void 0;
      assertIsLiteralOrHexString(title);
      return title.decodeText();
    };
    PDFDocument2.prototype.getAuthor = function() {
      var author = this.getInfoDict().lookup(PDFName_default.Author);
      if (!author)
        return void 0;
      assertIsLiteralOrHexString(author);
      return author.decodeText();
    };
    PDFDocument2.prototype.getSubject = function() {
      var subject = this.getInfoDict().lookup(PDFName_default.Subject);
      if (!subject)
        return void 0;
      assertIsLiteralOrHexString(subject);
      return subject.decodeText();
    };
    PDFDocument2.prototype.getKeywords = function() {
      var keywords = this.getInfoDict().lookup(PDFName_default.Keywords);
      if (!keywords)
        return void 0;
      assertIsLiteralOrHexString(keywords);
      return keywords.decodeText();
    };
    PDFDocument2.prototype.getCreator = function() {
      var creator = this.getInfoDict().lookup(PDFName_default.Creator);
      if (!creator)
        return void 0;
      assertIsLiteralOrHexString(creator);
      return creator.decodeText();
    };
    PDFDocument2.prototype.getProducer = function() {
      var producer = this.getInfoDict().lookup(PDFName_default.Producer);
      if (!producer)
        return void 0;
      assertIsLiteralOrHexString(producer);
      return producer.decodeText();
    };
    PDFDocument2.prototype.getCreationDate = function() {
      var creationDate = this.getInfoDict().lookup(PDFName_default.CreationDate);
      if (!creationDate)
        return void 0;
      assertIsLiteralOrHexString(creationDate);
      return creationDate.decodeDate();
    };
    PDFDocument2.prototype.getModificationDate = function() {
      var modificationDate = this.getInfoDict().lookup(PDFName_default.ModDate);
      if (!modificationDate)
        return void 0;
      assertIsLiteralOrHexString(modificationDate);
      return modificationDate.decodeDate();
    };
    PDFDocument2.prototype.setTitle = function(title, options) {
      assertIs(title, "title", ["string"]);
      var key = PDFName_default.of("Title");
      this.getInfoDict().set(key, PDFHexString_default.fromText(title));
      if (options === null || options === void 0 ? void 0 : options.showInWindowTitleBar) {
        var prefs = this.catalog.getOrCreateViewerPreferences();
        prefs.setDisplayDocTitle(true);
      }
    };
    PDFDocument2.prototype.setAuthor = function(author) {
      assertIs(author, "author", ["string"]);
      var key = PDFName_default.of("Author");
      this.getInfoDict().set(key, PDFHexString_default.fromText(author));
    };
    PDFDocument2.prototype.setSubject = function(subject) {
      assertIs(subject, "author", ["string"]);
      var key = PDFName_default.of("Subject");
      this.getInfoDict().set(key, PDFHexString_default.fromText(subject));
    };
    PDFDocument2.prototype.setKeywords = function(keywords) {
      assertIs(keywords, "keywords", [Array]);
      var key = PDFName_default.of("Keywords");
      this.getInfoDict().set(key, PDFHexString_default.fromText(keywords.join(" ")));
    };
    PDFDocument2.prototype.setCreator = function(creator) {
      assertIs(creator, "creator", ["string"]);
      var key = PDFName_default.of("Creator");
      this.getInfoDict().set(key, PDFHexString_default.fromText(creator));
    };
    PDFDocument2.prototype.setProducer = function(producer) {
      assertIs(producer, "creator", ["string"]);
      var key = PDFName_default.of("Producer");
      this.getInfoDict().set(key, PDFHexString_default.fromText(producer));
    };
    PDFDocument2.prototype.setLanguage = function(language) {
      assertIs(language, "language", ["string"]);
      var key = PDFName_default.of("Lang");
      this.catalog.set(key, PDFString_default.of(language));
    };
    PDFDocument2.prototype.setCreationDate = function(creationDate) {
      assertIs(creationDate, "creationDate", [[Date, "Date"]]);
      var key = PDFName_default.of("CreationDate");
      this.getInfoDict().set(key, PDFString_default.fromDate(creationDate));
    };
    PDFDocument2.prototype.setModificationDate = function(modificationDate) {
      assertIs(modificationDate, "modificationDate", [[Date, "Date"]]);
      var key = PDFName_default.of("ModDate");
      this.getInfoDict().set(key, PDFString_default.fromDate(modificationDate));
    };
    PDFDocument2.prototype.getPageCount = function() {
      if (this.pageCount === void 0)
        this.pageCount = this.getPages().length;
      return this.pageCount;
    };
    PDFDocument2.prototype.getPages = function() {
      return this.pageCache.access();
    };
    PDFDocument2.prototype.getPage = function(index) {
      var pages = this.getPages();
      assertRange(index, "index", 0, pages.length - 1);
      return pages[index];
    };
    PDFDocument2.prototype.getPageIndices = function() {
      return range(0, this.getPageCount());
    };
    PDFDocument2.prototype.removePage = function(index) {
      var pageCount = this.getPageCount();
      if (this.pageCount === 0)
        throw new RemovePageFromEmptyDocumentError();
      assertRange(index, "index", 0, pageCount - 1);
      this.catalog.removeLeafNode(index);
      this.pageCount = pageCount - 1;
    };
    PDFDocument2.prototype.addPage = function(page) {
      assertIs(page, "page", ["undefined", [PDFPage_default, "PDFPage"], Array]);
      return this.insertPage(this.getPageCount(), page);
    };
    PDFDocument2.prototype.insertPage = function(index, page) {
      var pageCount = this.getPageCount();
      assertRange(index, "index", 0, pageCount);
      assertIs(page, "page", ["undefined", [PDFPage_default, "PDFPage"], Array]);
      if (!page || Array.isArray(page)) {
        var dims = Array.isArray(page) ? page : PageSizes.A4;
        page = PDFPage_default.create(this);
        page.setSize.apply(page, dims);
      } else if (page.doc !== this) {
        throw new ForeignPageError();
      }
      var parentRef = this.catalog.insertLeafNode(page.ref, index);
      page.node.setParent(parentRef);
      this.pageMap.set(page.node, page);
      this.pageCache.invalidate();
      this.pageCount = pageCount + 1;
      return page;
    };
    PDFDocument2.prototype.copyPages = function(srcDoc, indices) {
      return __awaiter(this, void 0, void 0, function() {
        var copier, srcPages, copiedPages, idx, len, srcPage, copiedPage, ref;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              assertIs(srcDoc, "srcDoc", [[PDFDocument2, "PDFDocument"]]);
              assertIs(indices, "indices", [Array]);
              return [4, srcDoc.flush()];
            case 1:
              _a.sent();
              copier = PDFObjectCopier_default.for(srcDoc.context, this.context);
              srcPages = srcDoc.getPages();
              copiedPages = new Array(indices.length);
              for (idx = 0, len = indices.length; idx < len; idx++) {
                srcPage = srcPages[indices[idx]];
                copiedPage = copier.copy(srcPage.node);
                ref = this.context.register(copiedPage);
                copiedPages[idx] = PDFPage_default.of(copiedPage, ref, this);
              }
              return [2, copiedPages];
          }
        });
      });
    };
    PDFDocument2.prototype.copy = function() {
      return __awaiter(this, void 0, void 0, function() {
        var pdfCopy, contentPages, idx, len;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, PDFDocument2.create()];
            case 1:
              pdfCopy = _a.sent();
              return [4, pdfCopy.copyPages(this, this.getPageIndices())];
            case 2:
              contentPages = _a.sent();
              for (idx = 0, len = contentPages.length; idx < len; idx++) {
                pdfCopy.addPage(contentPages[idx]);
              }
              if (this.getAuthor() !== void 0) {
                pdfCopy.setAuthor(this.getAuthor());
              }
              if (this.getCreationDate() !== void 0) {
                pdfCopy.setCreationDate(this.getCreationDate());
              }
              if (this.getCreator() !== void 0) {
                pdfCopy.setCreator(this.getCreator());
              }
              if (this.getModificationDate() !== void 0) {
                pdfCopy.setModificationDate(this.getModificationDate());
              }
              if (this.getProducer() !== void 0) {
                pdfCopy.setProducer(this.getProducer());
              }
              if (this.getSubject() !== void 0) {
                pdfCopy.setSubject(this.getSubject());
              }
              if (this.getTitle() !== void 0) {
                pdfCopy.setTitle(this.getTitle());
              }
              pdfCopy.defaultWordBreaks = this.defaultWordBreaks;
              return [2, pdfCopy];
          }
        });
      });
    };
    PDFDocument2.prototype.addJavaScript = function(name2, script) {
      assertIs(name2, "name", ["string"]);
      assertIs(script, "script", ["string"]);
      var embedder = JavaScriptEmbedder_default.for(script, name2);
      var ref = this.context.nextRef();
      var javaScript = PDFJavaScript_default.of(ref, this, embedder);
      this.javaScripts.push(javaScript);
    };
    PDFDocument2.prototype.attach = function(attachment, name2, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var bytes, embedder, ref, embeddedFile;
        return __generator(this, function(_a) {
          assertIs(attachment, "attachment", ["string", Uint8Array, ArrayBuffer]);
          assertIs(name2, "name", ["string"]);
          assertOrUndefined(options.mimeType, "mimeType", ["string"]);
          assertOrUndefined(options.description, "description", ["string"]);
          assertOrUndefined(options.creationDate, "options.creationDate", [Date]);
          assertOrUndefined(options.modificationDate, "options.modificationDate", [
            Date
          ]);
          assertIsOneOfOrUndefined(options.afRelationship, "options.afRelationship", AFRelationship);
          bytes = toUint8Array(attachment);
          embedder = FileEmbedder_default.for(bytes, name2, options);
          ref = this.context.nextRef();
          embeddedFile = PDFEmbeddedFile_default.of(ref, this, embedder);
          this.embeddedFiles.push(embeddedFile);
          return [
            2
            /*return*/
          ];
        });
      });
    };
    PDFDocument2.prototype.embedFont = function(font, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, subset, customName, features, embedder, bytes, fontkit, _b, ref, pdfFont;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a = options.subset, subset = _a === void 0 ? false : _a, customName = options.customName, features = options.features;
              assertIs(font, "font", ["string", Uint8Array, ArrayBuffer]);
              assertIs(subset, "subset", ["boolean"]);
              if (!isStandardFont(font))
                return [3, 1];
              embedder = StandardFontEmbedder_default.for(font, customName);
              return [3, 7];
            case 1:
              if (!canBeConvertedToUint8Array(font))
                return [3, 6];
              bytes = toUint8Array(font);
              fontkit = this.assertFontkit();
              if (!subset)
                return [3, 3];
              return [4, CustomFontSubsetEmbedder_default.for(fontkit, bytes, customName, features)];
            case 2:
              _b = _c.sent();
              return [3, 5];
            case 3:
              return [4, CustomFontEmbedder_default.for(fontkit, bytes, customName, features)];
            case 4:
              _b = _c.sent();
              _c.label = 5;
            case 5:
              embedder = _b;
              return [3, 7];
            case 6:
              throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
            case 7:
              ref = this.context.nextRef();
              pdfFont = PDFFont_default.of(ref, this, embedder);
              this.fonts.push(pdfFont);
              return [2, pdfFont];
          }
        });
      });
    };
    PDFDocument2.prototype.embedStandardFont = function(font, customName) {
      assertIs(font, "font", ["string"]);
      if (!isStandardFont(font)) {
        throw new TypeError("`font` must be one of type `StandardFonts`");
      }
      var embedder = StandardFontEmbedder_default.for(font, customName);
      var ref = this.context.nextRef();
      var pdfFont = PDFFont_default.of(ref, this, embedder);
      this.fonts.push(pdfFont);
      return pdfFont;
    };
    PDFDocument2.prototype.embedJpg = function(jpg) {
      return __awaiter(this, void 0, void 0, function() {
        var bytes, embedder, ref, pdfImage;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              assertIs(jpg, "jpg", ["string", Uint8Array, ArrayBuffer]);
              bytes = toUint8Array(jpg);
              return [4, JpegEmbedder_default.for(bytes)];
            case 1:
              embedder = _a.sent();
              ref = this.context.nextRef();
              pdfImage = PDFImage_default.of(ref, this, embedder);
              this.images.push(pdfImage);
              return [2, pdfImage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPng = function(png) {
      return __awaiter(this, void 0, void 0, function() {
        var bytes, embedder, ref, pdfImage;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              assertIs(png, "png", ["string", Uint8Array, ArrayBuffer]);
              bytes = toUint8Array(png);
              return [4, PngEmbedder_default.for(bytes)];
            case 1:
              embedder = _a.sent();
              ref = this.context.nextRef();
              pdfImage = PDFImage_default.of(ref, this, embedder);
              this.images.push(pdfImage);
              return [2, pdfImage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPdf = function(pdf, indices) {
      if (indices === void 0) {
        indices = [0];
      }
      return __awaiter(this, void 0, void 0, function() {
        var srcDoc, _a, srcPages;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              assertIs(pdf, "pdf", [
                "string",
                Uint8Array,
                ArrayBuffer,
                [PDFDocument2, "PDFDocument"]
              ]);
              assertIs(indices, "indices", [Array]);
              if (!(pdf instanceof PDFDocument2))
                return [3, 1];
              _a = pdf;
              return [3, 3];
            case 1:
              return [4, PDFDocument2.load(pdf)];
            case 2:
              _a = _b.sent();
              _b.label = 3;
            case 3:
              srcDoc = _a;
              srcPages = pluckIndices(srcDoc.getPages(), indices);
              return [2, this.embedPages(srcPages)];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPage = function(page, boundingBox, transformationMatrix) {
      return __awaiter(this, void 0, void 0, function() {
        var embeddedPage;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
              return [4, this.embedPages([page], [boundingBox], [transformationMatrix])];
            case 1:
              embeddedPage = _a.sent()[0];
              return [2, embeddedPage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPages = function(pages, boundingBoxes, transformationMatrices) {
      if (boundingBoxes === void 0) {
        boundingBoxes = [];
      }
      if (transformationMatrices === void 0) {
        transformationMatrices = [];
      }
      return __awaiter(this, void 0, void 0, function() {
        var idx, len, currPage, nextPage, context, maybeCopyPage, embeddedPages, idx, len, page, box, matrix, embedder, ref;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (pages.length === 0)
                return [2, []];
              for (idx = 0, len = pages.length - 1; idx < len; idx++) {
                currPage = pages[idx];
                nextPage = pages[idx + 1];
                if (currPage.node.context !== nextPage.node.context) {
                  throw new PageEmbeddingMismatchedContextError();
                }
              }
              context = pages[0].node.context;
              maybeCopyPage = context === this.context ? function(p5) {
                return p5;
              } : PDFObjectCopier_default.for(context, this.context).copy;
              embeddedPages = new Array(pages.length);
              idx = 0, len = pages.length;
              _b.label = 1;
            case 1:
              if (!(idx < len))
                return [3, 4];
              page = maybeCopyPage(pages[idx].node);
              box = boundingBoxes[idx];
              matrix = transformationMatrices[idx];
              return [4, PDFPageEmbedder_default.for(page, box, matrix)];
            case 2:
              embedder = _b.sent();
              ref = this.context.nextRef();
              embeddedPages[idx] = PDFEmbeddedPage_default.of(ref, this, embedder);
              _b.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              (_a = this.embeddedPages).push.apply(_a, embeddedPages);
              return [2, embeddedPages];
          }
        });
      });
    };
    PDFDocument2.prototype.flush = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.embedAll(this.fonts)];
            case 1:
              _a.sent();
              return [4, this.embedAll(this.images)];
            case 2:
              _a.sent();
              return [4, this.embedAll(this.embeddedPages)];
            case 3:
              _a.sent();
              return [4, this.embedAll(this.embeddedFiles)];
            case 4:
              _a.sent();
              return [4, this.embedAll(this.javaScripts)];
            case 5:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFDocument2.prototype.save = function(options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, useObjectStreams, _b, addDefaultPage, _c, objectsPerTick, _d, updateFieldAppearances, form, Writer;
        return __generator(this, function(_e2) {
          switch (_e2.label) {
            case 0:
              _a = options.useObjectStreams, useObjectStreams = _a === void 0 ? true : _a, _b = options.addDefaultPage, addDefaultPage = _b === void 0 ? true : _b, _c = options.objectsPerTick, objectsPerTick = _c === void 0 ? 50 : _c, _d = options.updateFieldAppearances, updateFieldAppearances = _d === void 0 ? true : _d;
              assertIs(useObjectStreams, "useObjectStreams", ["boolean"]);
              assertIs(addDefaultPage, "addDefaultPage", ["boolean"]);
              assertIs(objectsPerTick, "objectsPerTick", ["number"]);
              assertIs(updateFieldAppearances, "updateFieldAppearances", ["boolean"]);
              if (addDefaultPage && this.getPageCount() === 0)
                this.addPage();
              if (updateFieldAppearances) {
                form = this.formCache.getValue();
                if (form)
                  form.updateFieldAppearances();
              }
              return [4, this.flush()];
            case 1:
              _e2.sent();
              Writer = useObjectStreams ? PDFStreamWriter_default : PDFWriter_default;
              return [2, Writer.forContext(this.context, objectsPerTick).serializeToBuffer()];
          }
        });
      });
    };
    PDFDocument2.prototype.saveAsBase64 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, dataUri, otherOptions, bytes, base64;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = options.dataUri, dataUri = _a === void 0 ? false : _a, otherOptions = __rest(options, ["dataUri"]);
              assertIs(dataUri, "dataUri", ["boolean"]);
              return [4, this.save(otherOptions)];
            case 1:
              bytes = _b.sent();
              base64 = encodeToBase64(bytes);
              return [2, dataUri ? "data:application/pdf;base64," + base64 : base64];
          }
        });
      });
    };
    PDFDocument2.prototype.findPageForAnnotationRef = function(ref) {
      var pages = this.getPages();
      for (var idx = 0, len = pages.length; idx < len; idx++) {
        var page = pages[idx];
        var annotations = page.node.Annots();
        if ((annotations === null || annotations === void 0 ? void 0 : annotations.indexOf(ref)) !== void 0) {
          return page;
        }
      }
      return void 0;
    };
    PDFDocument2.prototype.embedAll = function(embeddables) {
      return __awaiter(this, void 0, void 0, function() {
        var idx, len;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              idx = 0, len = embeddables.length;
              _a.label = 1;
            case 1:
              if (!(idx < len))
                return [3, 4];
              return [4, embeddables[idx].embed()];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFDocument2.prototype.updateInfoDict = function() {
      var pdfLib = "pdf-lib (https://github.com/Hopding/pdf-lib)";
      var now = new Date();
      var info2 = this.getInfoDict();
      this.setProducer(pdfLib);
      this.setModificationDate(now);
      if (!info2.get(PDFName_default.of("Creator")))
        this.setCreator(pdfLib);
      if (!info2.get(PDFName_default.of("CreationDate")))
        this.setCreationDate(now);
    };
    PDFDocument2.prototype.getInfoDict = function() {
      var existingInfo = this.context.lookup(this.context.trailerInfo.Info);
      if (existingInfo instanceof PDFDict_default)
        return existingInfo;
      var newInfo = this.context.obj({});
      this.context.trailerInfo.Info = this.context.register(newInfo);
      return newInfo;
    };
    PDFDocument2.prototype.assertFontkit = function() {
      if (!this.fontkit)
        throw new FontkitNotRegisteredError();
      return this.fontkit;
    };
    return PDFDocument2;
  }()
);
var PDFDocument_default = PDFDocument;
function assertIsLiteralOrHexString(pdfObject) {
  if (!(pdfObject instanceof PDFHexString_default) && !(pdfObject instanceof PDFString_default)) {
    throw new UnexpectedObjectTypeError([PDFHexString_default, PDFString_default], pdfObject);
  }
}

// node_modules/pdf-lib/es/api/PDFPageOptions.js
var BlendMode;
(function(BlendMode2) {
  BlendMode2["Normal"] = "Normal";
  BlendMode2["Multiply"] = "Multiply";
  BlendMode2["Screen"] = "Screen";
  BlendMode2["Overlay"] = "Overlay";
  BlendMode2["Darken"] = "Darken";
  BlendMode2["Lighten"] = "Lighten";
  BlendMode2["ColorDodge"] = "ColorDodge";
  BlendMode2["ColorBurn"] = "ColorBurn";
  BlendMode2["HardLight"] = "HardLight";
  BlendMode2["SoftLight"] = "SoftLight";
  BlendMode2["Difference"] = "Difference";
  BlendMode2["Exclusion"] = "Exclusion";
})(BlendMode || (BlendMode = {}));

// node_modules/pdf-lib/es/api/PDFPage.js
var PDFPage = (
  /** @class */
  function() {
    function PDFPage2(leafNode, ref, doc) {
      this.fontSize = 24;
      this.fontColor = rgb(0, 0, 0);
      this.lineHeight = 24;
      this.x = 0;
      this.y = 0;
      assertIs(leafNode, "leafNode", [[PDFPageLeaf_default, "PDFPageLeaf"]]);
      assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      this.node = leafNode;
      this.ref = ref;
      this.doc = doc;
    }
    PDFPage2.prototype.setRotation = function(angle) {
      var degreesAngle = toDegrees(angle);
      assertMultiple(degreesAngle, "degreesAngle", 90);
      this.node.set(PDFName_default.of("Rotate"), this.doc.context.obj(degreesAngle));
    };
    PDFPage2.prototype.getRotation = function() {
      var Rotate = this.node.Rotate();
      return degrees(Rotate ? Rotate.asNumber() : 0);
    };
    PDFPage2.prototype.setSize = function(width, height) {
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var mediaBox = this.getMediaBox();
      this.setMediaBox(mediaBox.x, mediaBox.y, width, height);
      var cropBox = this.getCropBox();
      var bleedBox = this.getBleedBox();
      var trimBox = this.getTrimBox();
      var artBox = this.getArtBox();
      var hasCropBox = this.node.CropBox();
      var hasBleedBox = this.node.BleedBox();
      var hasTrimBox = this.node.TrimBox();
      var hasArtBox = this.node.ArtBox();
      if (hasCropBox && rectanglesAreEqual(cropBox, mediaBox)) {
        this.setCropBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasBleedBox && rectanglesAreEqual(bleedBox, mediaBox)) {
        this.setBleedBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasTrimBox && rectanglesAreEqual(trimBox, mediaBox)) {
        this.setTrimBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasArtBox && rectanglesAreEqual(artBox, mediaBox)) {
        this.setArtBox(mediaBox.x, mediaBox.y, width, height);
      }
    };
    PDFPage2.prototype.setWidth = function(width) {
      assertIs(width, "width", ["number"]);
      this.setSize(width, this.getSize().height);
    };
    PDFPage2.prototype.setHeight = function(height) {
      assertIs(height, "height", ["number"]);
      this.setSize(this.getSize().width, height);
    };
    PDFPage2.prototype.setMediaBox = function(x4, y4, width, height) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var mediaBox = this.doc.context.obj([x4, y4, x4 + width, y4 + height]);
      this.node.set(PDFName_default.MediaBox, mediaBox);
    };
    PDFPage2.prototype.setCropBox = function(x4, y4, width, height) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var cropBox = this.doc.context.obj([x4, y4, x4 + width, y4 + height]);
      this.node.set(PDFName_default.CropBox, cropBox);
    };
    PDFPage2.prototype.setBleedBox = function(x4, y4, width, height) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var bleedBox = this.doc.context.obj([x4, y4, x4 + width, y4 + height]);
      this.node.set(PDFName_default.BleedBox, bleedBox);
    };
    PDFPage2.prototype.setTrimBox = function(x4, y4, width, height) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var trimBox = this.doc.context.obj([x4, y4, x4 + width, y4 + height]);
      this.node.set(PDFName_default.TrimBox, trimBox);
    };
    PDFPage2.prototype.setArtBox = function(x4, y4, width, height) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var artBox = this.doc.context.obj([x4, y4, x4 + width, y4 + height]);
      this.node.set(PDFName_default.ArtBox, artBox);
    };
    PDFPage2.prototype.getSize = function() {
      var _a = this.getMediaBox(), width = _a.width, height = _a.height;
      return { width, height };
    };
    PDFPage2.prototype.getWidth = function() {
      return this.getSize().width;
    };
    PDFPage2.prototype.getHeight = function() {
      return this.getSize().height;
    };
    PDFPage2.prototype.getMediaBox = function() {
      var mediaBox = this.node.MediaBox();
      return mediaBox.asRectangle();
    };
    PDFPage2.prototype.getCropBox = function() {
      var _a;
      var cropBox = this.node.CropBox();
      return (_a = cropBox === null || cropBox === void 0 ? void 0 : cropBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getMediaBox();
    };
    PDFPage2.prototype.getBleedBox = function() {
      var _a;
      var bleedBox = this.node.BleedBox();
      return (_a = bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
    };
    PDFPage2.prototype.getTrimBox = function() {
      var _a;
      var trimBox = this.node.TrimBox();
      return (_a = trimBox === null || trimBox === void 0 ? void 0 : trimBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
    };
    PDFPage2.prototype.getArtBox = function() {
      var _a;
      var artBox = this.node.ArtBox();
      return (_a = artBox === null || artBox === void 0 ? void 0 : artBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
    };
    PDFPage2.prototype.translateContent = function(x4, y4) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      this.node.normalize();
      this.getContentStream();
      var start2 = this.createContentStream(pushGraphicsState(), translate(x4, y4));
      var startRef = this.doc.context.register(start2);
      var end = this.createContentStream(popGraphicsState());
      var endRef = this.doc.context.register(end);
      this.node.wrapContentStreams(startRef, endRef);
    };
    PDFPage2.prototype.scale = function(x4, y4) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      this.setSize(this.getWidth() * x4, this.getHeight() * y4);
      this.scaleContent(x4, y4);
      this.scaleAnnotations(x4, y4);
    };
    PDFPage2.prototype.scaleContent = function(x4, y4) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      this.node.normalize();
      this.getContentStream();
      var start2 = this.createContentStream(pushGraphicsState(), scale(x4, y4));
      var startRef = this.doc.context.register(start2);
      var end = this.createContentStream(popGraphicsState());
      var endRef = this.doc.context.register(end);
      this.node.wrapContentStreams(startRef, endRef);
    };
    PDFPage2.prototype.scaleAnnotations = function(x4, y4) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      var annots = this.node.Annots();
      if (!annots)
        return;
      for (var idx = 0; idx < annots.size(); idx++) {
        var annot = annots.lookup(idx);
        if (annot instanceof PDFDict_default)
          this.scaleAnnot(annot, x4, y4);
      }
    };
    PDFPage2.prototype.resetPosition = function() {
      this.getContentStream(false);
      this.x = 0;
      this.y = 0;
    };
    PDFPage2.prototype.setFont = function(font) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      this.font = font;
      this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref);
    };
    PDFPage2.prototype.setFontSize = function(fontSize) {
      assertIs(fontSize, "fontSize", ["number"]);
      this.fontSize = fontSize;
    };
    PDFPage2.prototype.setFontColor = function(fontColor) {
      assertIs(fontColor, "fontColor", [[Object, "Color"]]);
      this.fontColor = fontColor;
    };
    PDFPage2.prototype.setLineHeight = function(lineHeight) {
      assertIs(lineHeight, "lineHeight", ["number"]);
      this.lineHeight = lineHeight;
    };
    PDFPage2.prototype.getPosition = function() {
      return { x: this.x, y: this.y };
    };
    PDFPage2.prototype.getX = function() {
      return this.x;
    };
    PDFPage2.prototype.getY = function() {
      return this.y;
    };
    PDFPage2.prototype.moveTo = function(x4, y4) {
      assertIs(x4, "x", ["number"]);
      assertIs(y4, "y", ["number"]);
      this.x = x4;
      this.y = y4;
    };
    PDFPage2.prototype.moveDown = function(yDecrease) {
      assertIs(yDecrease, "yDecrease", ["number"]);
      this.y -= yDecrease;
    };
    PDFPage2.prototype.moveUp = function(yIncrease) {
      assertIs(yIncrease, "yIncrease", ["number"]);
      this.y += yIncrease;
    };
    PDFPage2.prototype.moveLeft = function(xDecrease) {
      assertIs(xDecrease, "xDecrease", ["number"]);
      this.x -= xDecrease;
    };
    PDFPage2.prototype.moveRight = function(xIncrease) {
      assertIs(xIncrease, "xIncrease", ["number"]);
      this.x += xIncrease;
    };
    PDFPage2.prototype.pushOperators = function() {
      var operator = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operator[_i] = arguments[_i];
      }
      assertEachIs(operator, "operator", [[PDFOperator_default, "PDFOperator"]]);
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, operator);
    };
    PDFPage2.prototype.drawText = function(text, options) {
      var _a, _b, _c, _d, _e2, _f, _g;
      if (options === void 0) {
        options = {};
      }
      assertIs(text, "text", ["string"]);
      assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options.font, "options.font", [[PDFFont_default, "PDFFont"]]);
      assertOrUndefined(options.size, "options.size", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.lineHeight, "options.lineHeight", ["number"]);
      assertOrUndefined(options.maxWidth, "options.maxWidth", ["number"]);
      assertOrUndefined(options.wordBreaks, "options.wordBreaks", [Array]);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var _h = this.setOrEmbedFont(options.font), oldFont = _h.oldFont, newFont = _h.newFont, newFontKey = _h.newFontKey;
      var fontSize = options.size || this.fontSize;
      var wordBreaks = options.wordBreaks || this.doc.defaultWordBreaks;
      var textWidth = function(t2) {
        return newFont.widthOfTextAtSize(t2, fontSize);
      };
      var lines = options.maxWidth === void 0 ? lineSplit(cleanText(text)) : breakTextIntoLines(text, wordBreaks, options.maxWidth, textWidth);
      var encodedLines = new Array(lines.length);
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        encodedLines[idx] = newFont.encodeText(lines[idx]);
      }
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        blendMode: options.blendMode
      });
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawLinesOfText(encodedLines, {
        color: (_a = options.color) !== null && _a !== void 0 ? _a : this.fontColor,
        font: newFontKey,
        size: fontSize,
        rotate: (_b = options.rotate) !== null && _b !== void 0 ? _b : degrees(0),
        xSkew: (_c = options.xSkew) !== null && _c !== void 0 ? _c : degrees(0),
        ySkew: (_d = options.ySkew) !== null && _d !== void 0 ? _d : degrees(0),
        x: (_e2 = options.x) !== null && _e2 !== void 0 ? _e2 : this.x,
        y: (_f = options.y) !== null && _f !== void 0 ? _f : this.y,
        lineHeight: (_g = options.lineHeight) !== null && _g !== void 0 ? _g : this.lineHeight,
        graphicsState: graphicsStateKey
      }));
      if (options.font) {
        if (oldFont)
          this.setFont(oldFont);
        else
          this.resetFont();
      }
    };
    PDFPage2.prototype.drawImage = function(image, options) {
      var _a, _b, _c, _d, _e2, _f, _g;
      if (options === void 0) {
        options = {};
      }
      assertIs(image, "image", [[PDFImage_default, "PDFImage"]]);
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.width, "options.width", ["number"]);
      assertOrUndefined(options.height, "options.height", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var xObjectKey = this.node.newXObject("Image", image.ref);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        blendMode: options.blendMode
      });
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawImage(xObjectKey, {
        x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : image.size().width,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : image.size().height,
        rotate: (_e2 = options.rotate) !== null && _e2 !== void 0 ? _e2 : degrees(0),
        xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
        ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawPage = function(embeddedPage, options) {
      var _a, _b, _c, _d, _e2;
      if (options === void 0) {
        options = {};
      }
      assertIs(embeddedPage, "embeddedPage", [
        [PDFEmbeddedPage_default, "PDFEmbeddedPage"]
      ]);
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.xScale, "options.xScale", ["number"]);
      assertOrUndefined(options.yScale, "options.yScale", ["number"]);
      assertOrUndefined(options.width, "options.width", ["number"]);
      assertOrUndefined(options.height, "options.height", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var xObjectKey = this.node.newXObject("EmbeddedPdfPage", embeddedPage.ref);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        blendMode: options.blendMode
      });
      var xScale = options.width !== void 0 ? options.width / embeddedPage.width : options.xScale !== void 0 ? options.xScale : 1;
      var yScale = options.height !== void 0 ? options.height / embeddedPage.height : options.yScale !== void 0 ? options.yScale : 1;
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawPage(xObjectKey, {
        x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
        xScale,
        yScale,
        rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0),
        xSkew: (_d = options.xSkew) !== null && _d !== void 0 ? _d : degrees(0),
        ySkew: (_e2 = options.ySkew) !== null && _e2 !== void 0 ? _e2 : degrees(0),
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawSvgPath = function(path2, options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j;
      if (options === void 0) {
        options = {};
      }
      assertIs(path2, "path", ["string"]);
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.scale, "options.scale", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        borderOpacity: options.borderOpacity,
        blendMode: options.blendMode
      });
      if (!("color" in options) && !("borderColor" in options)) {
        options.borderColor = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawSvgPath(path2, {
        x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
        scale: options.scale,
        rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0),
        color: (_d = options.color) !== null && _d !== void 0 ? _d : void 0,
        borderColor: (_e2 = options.borderColor) !== null && _e2 !== void 0 ? _e2 : void 0,
        borderWidth: (_f = options.borderWidth) !== null && _f !== void 0 ? _f : 0,
        borderDashArray: (_g = options.borderDashArray) !== null && _g !== void 0 ? _g : void 0,
        borderDashPhase: (_h = options.borderDashPhase) !== null && _h !== void 0 ? _h : void 0,
        borderLineCap: (_j = options.borderLineCap) !== null && _j !== void 0 ? _j : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawLine = function(options) {
      var _a, _b, _c, _d, _e2;
      assertIs(options.start, "options.start", [
        [Object, "{ x: number, y: number }"]
      ]);
      assertIs(options.end, "options.end", [
        [Object, "{ x: number, y: number }"]
      ]);
      assertIs(options.start.x, "options.start.x", ["number"]);
      assertIs(options.start.y, "options.start.y", ["number"]);
      assertIs(options.end.x, "options.end.x", ["number"]);
      assertIs(options.end.y, "options.end.y", ["number"]);
      assertOrUndefined(options.thickness, "options.thickness", ["number"]);
      assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
      assertOrUndefined(options.dashArray, "options.dashArray", [Array]);
      assertOrUndefined(options.dashPhase, "options.dashPhase", ["number"]);
      assertIsOneOfOrUndefined(options.lineCap, "options.lineCap", LineCapStyle);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        borderOpacity: options.opacity,
        blendMode: options.blendMode
      });
      if (!("color" in options)) {
        options.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawLine({
        start: options.start,
        end: options.end,
        thickness: (_a = options.thickness) !== null && _a !== void 0 ? _a : 1,
        color: (_b = options.color) !== null && _b !== void 0 ? _b : void 0,
        dashArray: (_c = options.dashArray) !== null && _c !== void 0 ? _c : void 0,
        dashPhase: (_d = options.dashPhase) !== null && _d !== void 0 ? _d : void 0,
        lineCap: (_e2 = options.lineCap) !== null && _e2 !== void 0 ? _e2 : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawRectangle = function(options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
      if (options === void 0) {
        options = {};
      }
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.width, "options.width", ["number"]);
      assertOrUndefined(options.height, "options.height", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        borderOpacity: options.borderOpacity,
        blendMode: options.blendMode
      });
      if (!("color" in options) && !("borderColor" in options)) {
        options.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawRectangle({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
        width: (_c = options.width) !== null && _c !== void 0 ? _c : 150,
        height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
        rotate: (_e2 = options.rotate) !== null && _e2 !== void 0 ? _e2 : degrees(0),
        xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
        ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
        borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
        color: (_j = options.color) !== null && _j !== void 0 ? _j : void 0,
        borderColor: (_k = options.borderColor) !== null && _k !== void 0 ? _k : void 0,
        borderDashArray: (_l = options.borderDashArray) !== null && _l !== void 0 ? _l : void 0,
        borderDashPhase: (_m = options.borderDashPhase) !== null && _m !== void 0 ? _m : void 0,
        graphicsState: graphicsStateKey,
        borderLineCap: (_o = options.borderLineCap) !== null && _o !== void 0 ? _o : void 0
      }));
    };
    PDFPage2.prototype.drawSquare = function(options) {
      if (options === void 0) {
        options = {};
      }
      var size = options.size;
      assertOrUndefined(size, "size", ["number"]);
      this.drawRectangle(__assign(__assign({}, options), { width: size, height: size }));
    };
    PDFPage2.prototype.drawEllipse = function(options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l;
      if (options === void 0) {
        options = {};
      }
      assertOrUndefined(options.x, "options.x", ["number"]);
      assertOrUndefined(options.y, "options.y", ["number"]);
      assertOrUndefined(options.xScale, "options.xScale", ["number"]);
      assertOrUndefined(options.yScale, "options.yScale", ["number"]);
      assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
      assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options.opacity,
        borderOpacity: options.borderOpacity,
        blendMode: options.blendMode
      });
      if (!("color" in options) && !("borderColor" in options)) {
        options.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawEllipse({
        x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
        y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
        xScale: (_c = options.xScale) !== null && _c !== void 0 ? _c : 100,
        yScale: (_d = options.yScale) !== null && _d !== void 0 ? _d : 100,
        rotate: (_e2 = options.rotate) !== null && _e2 !== void 0 ? _e2 : void 0,
        color: (_f = options.color) !== null && _f !== void 0 ? _f : void 0,
        borderColor: (_g = options.borderColor) !== null && _g !== void 0 ? _g : void 0,
        borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
        borderDashArray: (_j = options.borderDashArray) !== null && _j !== void 0 ? _j : void 0,
        borderDashPhase: (_k = options.borderDashPhase) !== null && _k !== void 0 ? _k : void 0,
        borderLineCap: (_l = options.borderLineCap) !== null && _l !== void 0 ? _l : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawCircle = function(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.size, size = _a === void 0 ? 100 : _a;
      assertOrUndefined(size, "size", ["number"]);
      this.drawEllipse(__assign(__assign({}, options), { xScale: size, yScale: size }));
    };
    PDFPage2.prototype.setOrEmbedFont = function(font) {
      var oldFont = this.font;
      var oldFontKey = this.fontKey;
      if (font)
        this.setFont(font);
      else
        this.getFont();
      var newFont = this.font;
      var newFontKey = this.fontKey;
      return { oldFont, oldFontKey, newFont, newFontKey };
    };
    PDFPage2.prototype.getFont = function() {
      if (!this.font || !this.fontKey) {
        var font = this.doc.embedStandardFont(StandardFonts.Helvetica);
        this.setFont(font);
      }
      return [this.font, this.fontKey];
    };
    PDFPage2.prototype.resetFont = function() {
      this.font = void 0;
      this.fontKey = void 0;
    };
    PDFPage2.prototype.getContentStream = function(useExisting) {
      if (useExisting === void 0) {
        useExisting = true;
      }
      if (useExisting && this.contentStream)
        return this.contentStream;
      this.contentStream = this.createContentStream();
      this.contentStreamRef = this.doc.context.register(this.contentStream);
      this.node.addContentStream(this.contentStreamRef);
      return this.contentStream;
    };
    PDFPage2.prototype.createContentStream = function() {
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operators[_i] = arguments[_i];
      }
      var dict = this.doc.context.obj({});
      var contentStream = PDFContentStream_default.of(dict, operators);
      return contentStream;
    };
    PDFPage2.prototype.maybeEmbedGraphicsState = function(options) {
      var opacity = options.opacity, borderOpacity = options.borderOpacity, blendMode = options.blendMode;
      if (opacity === void 0 && borderOpacity === void 0 && blendMode === void 0) {
        return void 0;
      }
      var graphicsState = this.doc.context.obj({
        Type: "ExtGState",
        ca: opacity,
        CA: borderOpacity,
        BM: blendMode
      });
      var key = this.node.newExtGState("GS", graphicsState);
      return key;
    };
    PDFPage2.prototype.scaleAnnot = function(annot, x4, y4) {
      var selectors = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"];
      for (var idx = 0, len = selectors.length; idx < len; idx++) {
        var list = annot.lookup(PDFName_default.of(selectors[idx]));
        if (list instanceof PDFArray_default)
          list.scalePDFNumbers(x4, y4);
      }
      var inkLists = annot.lookup(PDFName_default.of("InkList"));
      if (inkLists instanceof PDFArray_default) {
        for (var idx = 0, len = inkLists.size(); idx < len; idx++) {
          var arr = inkLists.lookup(idx);
          if (arr instanceof PDFArray_default)
            arr.scalePDFNumbers(x4, y4);
        }
      }
    };
    PDFPage2.of = function(leafNode, ref, doc) {
      return new PDFPage2(leafNode, ref, doc);
    };
    PDFPage2.create = function(doc) {
      assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
      var dummyRef = PDFRef_default.of(-1);
      var pageLeaf = PDFPageLeaf_default.withContextAndParent(doc.context, dummyRef);
      var pageRef = doc.context.register(pageLeaf);
      return new PDFPage2(pageLeaf, pageRef, doc);
    };
    return PDFPage2;
  }()
);
var PDFPage_default = PDFPage;

// node_modules/pdf-lib/es/api/form/PDFButton.js
var PDFButton = (
  /** @class */
  function(_super) {
    __extends(PDFButton2, _super);
    function PDFButton2(acroPushButton, ref, doc) {
      var _this = _super.call(this, acroPushButton, ref, doc) || this;
      assertIs(acroPushButton, "acroButton", [
        [PDFAcroPushButton_default, "PDFAcroPushButton"]
      ]);
      _this.acroField = acroPushButton;
      return _this;
    }
    PDFButton2.prototype.setImage = function(image, alignment) {
      if (alignment === void 0) {
        alignment = ImageAlignment.Center;
      }
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var streamRef = this.createImageAppearanceStream(widget, image, alignment);
        this.updateWidgetAppearances(widget, { normal: streamRef });
      }
      this.markAsClean();
    };
    PDFButton2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFButton2.prototype.addToPage = function(text, page, options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l;
      assertOrUndefined(text, "text", ["string"]);
      assertOrUndefined(page, "page", [[PDFPage_default, "PDFPage"]]);
      assertFieldAppearanceOptions(options);
      var widget = this.createWidget({
        x: ((_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0) - ((_b = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _b !== void 0 ? _b : 0) / 2,
        y: ((_c = options === null || options === void 0 ? void 0 : options.y) !== null && _c !== void 0 ? _c : 0) - ((_d = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _d !== void 0 ? _d : 0) / 2,
        width: (_e2 = options === null || options === void 0 ? void 0 : options.width) !== null && _e2 !== void 0 ? _e2 : 100,
        height: (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : 50,
        textColor: (_g = options === null || options === void 0 ? void 0 : options.textColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
        backgroundColor: (_h = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _h !== void 0 ? _h : rgb(0.75, 0.75, 0.75),
        borderColor: options === null || options === void 0 ? void 0 : options.borderColor,
        borderWidth: (_j = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _j !== void 0 ? _j : 0,
        rotate: (_k = options === null || options === void 0 ? void 0 : options.rotate) !== null && _k !== void 0 ? _k : degrees(0),
        caption: text,
        hidden: options === null || options === void 0 ? void 0 : options.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_l = options === null || options === void 0 ? void 0 : options.font) !== null && _l !== void 0 ? _l : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFButton2.prototype.needsAppearancesUpdate = function() {
      var _a;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFButton2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFButton2.prototype.updateAppearances = function(font, provider) {
      assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
      assertOrUndefined(provider, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len = widgets.length; idx < len; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider);
      }
    };
    PDFButton2.prototype.updateWidgetAppearance = function(widget, font, provider) {
      var apProvider = provider !== null && provider !== void 0 ? provider : defaultButtonAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFButton2.of = function(acroPushButton, ref, doc) {
      return new PDFButton2(acroPushButton, ref, doc);
    };
    return PDFButton2;
  }(PDFField_default)
);
var PDFButton_default = PDFButton;

// src/utils/pdfViewState.ts
function capturePdfViewerState(child) {
  try {
    const pdfViewer = child?.pdfViewer?.pdfViewer;
    if (pdfViewer) {
      return {
        page: pdfViewer._location?.pageNumber ?? pdfViewer.currentPageNumber,
        left: pdfViewer._location?.left ?? null,
        top: pdfViewer._location?.top ?? null,
        zoom: pdfViewer.currentScale ?? null,
        scaleValue: pdfViewer.currentScaleValue ?? null
      };
    }
  } catch {
  }
  return void 0;
}
function restorePdfViewerState(child, state) {
  if (!child || !state)
    return;
  try {
    const pdfViewer = child?.pdfViewer?.pdfViewer;
    if (!pdfViewer)
      return;
    const { page, left, top, zoom } = state;
    const doRestore = () => {
      if (left !== null && top !== null && zoom !== null) {
        pdfViewer.scrollPageIntoView({
          pageNumber: page,
          destArray: [page, { name: "XYZ" }, left, top, zoom]
        });
      } else {
        pdfViewer.currentPageNumber = page;
      }
    };
    const onAnnotLayerRendered = (data) => {
      if (data.pageNumber === page) {
        pdfViewer.eventBus?.off?.("annotationlayerrendered", onAnnotLayerRendered);
        setTimeout(() => doRestore(), 0);
      }
    };
    pdfViewer.eventBus?.on?.("annotationlayerrendered", onAnnotLayerRendered);
  } catch (e) {
    console.error("Failed to restore PDF view state", e);
  }
}

// src/services/pdf/PdfIOService.ts
var PdfIOService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * 在指定 PDF 页面写入 Highlight 注释。
   * @param file PDF 文件 (TFile)
   * @param pageNumber 从 1 开始的页码
   * @param rects 选区矩形数组 `[l,b,r,t]`
   * @param quadPoints PDF QuadPoints (rectsToQuadPoints 生成)
   * @param child 当前 PDF 视图的 child（用于恢复滚动位置，可为空）
   * @param viewerState 在重新载入文件后需恢复的视图状态
   * @param color 颜色字符串（如 #ffcc00）
   * @param opacity 透明度（0-1）
   */
  async writeHighlightAnnotation(file, pageNumber, rects, quadPoints, color = "#ffff00", opacity = 0.7, child) {
    try {
      const pdfBytes = await this.app.vault.readBinary(file);
      const pdfDoc = await PDFDocument_default.load(pdfBytes);
      const page = pdfDoc.getPage(pageNumber - 1);
      const ctx = page.doc.context;
      let rgb2 = [1, 1, 0];
      if (/^#([0-9a-fA-F]{6})$/.test(color)) {
        rgb2 = [
          parseInt(color.slice(1, 3), 16) / 255,
          parseInt(color.slice(3, 5), 16) / 255,
          parseInt(color.slice(5, 7), 16) / 255
        ];
      }
      const annotRef = ctx.register(
        ctx.obj({
          Type: "Annot",
          Subtype: "Highlight",
          Rect: mergeRects(rects),
          QuadPoints: quadPoints,
          C: rgb2,
          CA: opacity,
          Contents: PDFHexString_default.fromText(""),
          T: PDFHexString_default.fromText("Obsidian"),
          M: PDFString_default.fromDate(new Date()),
          Border: [0, 0, 0]
        })
      );
      page.node.addAnnot(annotRef);
      const viewerState = child ? capturePdfViewerState(child) : void 0;
      await this.app.vault.modifyBinary(file, await pdfDoc.save());
      if (child && viewerState) {
        restorePdfViewerState(child, viewerState);
      }
      return annotRef.objectNumber;
    } catch (e) {
      console.error("Failed to write annotation", e);
      return null;
    }
  }
  /**
   * 删除指定页面上 objectNumber 的高亮注释。
   */
  async deleteHighlightAnnotation(file, pageNumber, objectNumber, child) {
    try {
      const pdfBytes = await this.app.vault.readBinary(file);
      const pdfDoc = await PDFDocument_default.load(pdfBytes);
      const page = pdfDoc.getPage(pageNumber - 1);
      const annots = page.node.Annots?.();
      if (annots) {
        const arr = annots.asArray();
        for (const ref of arr) {
          if (ref instanceof PDFRef_default && ref.objectNumber === objectNumber) {
            page.node.removeAnnot(ref);
            break;
          }
        }
      }
      const viewerState = child ? capturePdfViewerState(child) : void 0;
      await this.app.vault.modifyBinary(file, await pdfDoc.save());
      if (child && viewerState) {
        restorePdfViewerState(child, viewerState);
      }
    } catch (e) {
      console.error("Failed to delete annotation", e);
    }
  }
  /**
   * 批量删除同一PDF文件中的多个注释
   * @param file PDF文件
   * @param annotationsToDelete 要删除的注释数组，每项包含页码和对象编号
   * @param child PDF视图child对象，用于保存和恢复视图状态
   */
  async batchDeleteAnnotations(file, annotationsToDelete, child) {
    if (annotationsToDelete.length === 0)
      return;
    try {
      const pdfBytes = await this.app.vault.readBinary(file);
      const pdfDoc = await PDFDocument_default.load(pdfBytes);
      const pageAnnotMap = /* @__PURE__ */ new Map();
      for (const anno of annotationsToDelete) {
        if (!pageAnnotMap.has(anno.pageNumber)) {
          pageAnnotMap.set(anno.pageNumber, []);
        }
        pageAnnotMap.get(anno.pageNumber)?.push(anno.objectNumber);
      }
      for (const [pageNumber, objectNumbers] of pageAnnotMap.entries()) {
        const page = pdfDoc.getPage(pageNumber - 1);
        const annots = page.node.Annots?.();
        if (annots) {
          const arr = annots.asArray();
          const toRemove = [];
          for (const ref of arr) {
            if (ref instanceof PDFRef_default && objectNumbers.includes(ref.objectNumber)) {
              toRemove.push(ref);
            }
          }
          for (const ref of toRemove) {
            page.node.removeAnnot(ref);
          }
        }
      }
      const viewerState = child ? capturePdfViewerState(child) : void 0;
      await this.app.vault.modifyBinary(file, await pdfDoc.save());
      if (child && viewerState) {
        restorePdfViewerState(child, viewerState);
      }
    } catch (e) {
      console.error("Failed to batch delete annotations", e);
    }
  }
  /**
   * 更新pdf条目的comment字段
   */
  async updateHighlightAnnotationContent(file, pageNumber, objectNumber, comment, child) {
    try {
      const pdfBytes = await this.app.vault.readBinary(file);
      const pdfDoc = await PDFDocument_default.load(pdfBytes);
      const page = pdfDoc.getPage(pageNumber - 1);
      const annots = page.node.Annots?.();
      if (annots) {
        const arr = annots.asArray();
        for (const ref of arr) {
          if (ref instanceof PDFRef_default && ref.objectNumber === objectNumber) {
            const annot = pdfDoc.context.lookup(ref);
            annot.set(PDFName_default.of("Contents"), PDFHexString_default.fromText(comment));
            break;
          }
        }
      }
      const viewerState = child ? capturePdfViewerState(child) : void 0;
      await this.app.vault.modifyBinary(file, await pdfDoc.save());
      if (child && viewerState) {
        restorePdfViewerState(child, viewerState);
      }
    } catch (e) {
      console.error("Failed to update annotation content", e);
    }
  }
};

// src/services/pdf/PdfBacklinkHighlighter.ts
init_utils();
var PdfBacklinkHighlighter = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    // pdf.js ViewerChild
    this.selectionService = new PdfSelectionService();
    /**
     * 控制是否将高亮写入 PDF（内嵌注释）
     * 若为 false，则仅绘制到 `BetterNotes-rect-highlight-layer` 图层，不修改 PDF 文件。
     * 可通过 `setUseEmbeddedHighlights` 动态切换。
     */
    this.useEmbeddedHighlights = true;
    this.annotationService = new PdfIOService(app);
    this.initialize();
  }
  /**
   * 切换高亮模式
   * @param value true = 内嵌高亮，false = 图层高亮
   */
  setUseEmbeddedHighlights(value) {
    this.useEmbeddedHighlights = value;
  }
  /**
   * 初始化工作区监听。
   */
  initialize() {
    this.plugin.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        this.handleActiveLeafChange(leaf);
      })
    );
  }
  /**
   * 清理已绑定到 PDF 容器的事件。
   */
  cleanupPdfContainerEvents() {
    if (this.currentPdfContainerEl && this.boundPointerDown) {
      this.currentPdfContainerEl.removeEventListener("pointerdown", this.boundPointerDown);
    }
    this.currentPdfContainerEl = void 0;
    this.currentPdfFile = void 0;
    this.currentChild = void 0;
    this.boundPointerDown = void 0;
  }
  handleActiveLeafChange(leaf) {
    this.cleanupPdfContainerEvents();
    if (!leaf)
      return;
    const file = leaf?.view?.file;
    if (!file || file.extension !== "pdf")
      return;
    const container = leaf?.view?.containerEl;
    const child = leaf?.view?.viewer?.child;
    if (!container)
      return;
    this.currentPdfContainerEl = container;
    this.currentPdfFile = file;
    this.currentChild = child;
    this.boundPointerDown = () => {
      const onPointerUp = () => {
        this.handleSelection();
        this.currentPdfContainerEl?.removeEventListener("pointerup", onPointerUp);
      };
      this.currentPdfContainerEl?.addEventListener("pointerup", onPointerUp, { once: true });
    };
    container.addEventListener("pointerdown", this.boundPointerDown);
  }
  /**
   * 在 pointerup 后获取选区并写入注释。
   */
  async handleSelection() {
    if (!this.currentPdfContainerEl)
      return;
    const sel = window.getSelection?.();
    if (!sel || sel.isCollapsed)
      return;
    const selectedText = sel.toString();
    if (!selectedText)
      return;
    const selectedSet = this.plugin.setSelectionService?.getSelected?.();
    if (!selectedSet)
      return;
    const info2 = this.selectionService.getPageAndTextRange(sel);
    if (!info2 || !info2.selection)
      return;
    const pageEl = this.selectionService.getPageElementFromSelection(sel);
    if (!pageEl)
      return;
    const pageView = this.currentChild?.getPage?.(info2.page);
    const rects = this.selectionService.computeRectsForSelection(pageEl, info2.selection, pageView);
    if (!rects.length)
      return;
    const quad = rectsToQuadPoints(rects);
    if (!this.currentPdfFile)
      return;
    if (this.useEmbeddedHighlights) {
      let color = "#ffff00";
      if (selectedSet && this.plugin.dataManager) {
        const collection = this.plugin.dataManager.getCollection(selectedSet);
        if (collection && collection.color)
          color = collection.color;
      }
      const opacity = this.plugin?.settings?.highlightOpacity ?? 0.7;
      const objectNum = await this.annotationService.writeHighlightAnnotation(
        this.currentPdfFile,
        info2.page,
        rects,
        quad,
        color,
        opacity,
        this.currentChild
      );
      if (objectNum) {
        const indexLink = `${this.currentPdfFile.path}#page=${info2.page}&annotation=${objectNum}R`;
        try {
          const entry = await this.plugin.createEntry(selectedText, selectedSet, {
            comment: "",
            sourceFile: this.currentPdfFile.path,
            type: "pdf",
            index: indexLink
          });
          await this.plugin.navigateToEntryInComments(entry);
        } catch (e) {
          console.error("Create PDF entry failed", e);
        }
      }
    } else {
      const hash = generateHash();
      const opacity = this.plugin?.settings?.highlightOpacity ?? 0.7;
      let fillColor = hexToRgba("#FFFF00", opacity);
      if (selectedSet && this.plugin.dataManager) {
        const collection = this.plugin.dataManager.getCollection(selectedSet);
        if (collection && collection.color) {
          fillColor = hexToRgba(collection.color, opacity);
        }
      }
      const mgr = this.plugin.rectHighlightManager;
      mgr.setActiveFilePath(this.currentPdfFile.path);
      rects.forEach(
        (r) => mgr.addRect(
          this.currentPdfFile.path,
          info2.page,
          r,
          hash,
          pageView,
          fillColor
        )
      );
      if (!info2.selection)
        return;
      const { beginIndex, beginOffset, endIndex, endOffset } = info2.selection;
      const selectionStr = [beginIndex, beginOffset, endIndex, endOffset].map((n3) => Math.round(n3)).join(",");
      const indexLink = `${this.currentPdfFile.path}#page=${info2.page}&selection=${selectionStr}`;
      try {
        const entry = await this.plugin.createEntryWithHash(selectedText, selectedSet, hash, {
          comment: "",
          sourceFile: this.currentPdfFile.path,
          type: "pdf",
          index: indexLink
        });
        await this.plugin.navigateToEntryInComments(entry);
      } catch (e) {
        console.error("Create PDF entry (layer) failed", e);
      }
    }
  }
};

// src/services/SetSelectionService.ts
var SetSelectionService = class {
  constructor() {
    this.selected = null;
    this.listeners = /* @__PURE__ */ new Set();
  }
  /**
   * 获取当前选中的 set 名称；若未选中则返回 null。
   */
  getSelected() {
    return this.selected;
  }
  /**
   * 选择新的 set；重复选择同一 set 将取消选择（即切换为 null）。
   * 调用后会同步通知所有监听器。
   * @param setName 要选择的集合名称
   */
  select(setName) {
    const newVal = this.selected === setName ? null : setName;
    if (this.selected === newVal)
      return;
    this.selected = newVal;
    this.emit();
  }
  /**
   * 订阅选中变化事件。
   * 返回取消订阅函数。
   */
  onChange(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  emit() {
    for (const l4 of this.listeners) {
      try {
        l4(this.selected);
      } catch (e) {
        console.error("SetSelectionService listener error", e);
      }
    }
  }
};

// src/services/QuickCaptureService.ts
var import_obsidian24 = require("obsidian");
init_utils();
var QuickCaptureService = class {
  constructor(app, plugin, setService) {
    this.app = app;
    this.plugin = plugin;
    this.setService = setService;
    this.boundPointerUp = this.handlePointerUp.bind(this);
    this.boundContextMenu = this.handleContextMenu.bind(this);
    document.addEventListener("pointerup", this.boundPointerUp, true);
    document.addEventListener("contextmenu", this.boundContextMenu, true);
  }
  /** 在插件卸载时调用 */
  cleanup() {
    document.removeEventListener("pointerup", this.boundPointerUp, true);
    document.removeEventListener("contextmenu", this.boundContextMenu, true);
  }
  /** 处理全局 pointerup，若有非空选区则尝试插入条目 */
  async handlePointerUp(_3) {
    const setName = this.setService.getSelected();
    if (!setName)
      return;
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed)
      return;
    const text = selection.toString().trim();
    if (!text)
      return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const filePath = activeFile.path;
    const isPdf = activeFile.extension.toLowerCase() === "pdf";
    const now = Date.now();
    if (this.recent && now - this.recent.timestamp < 1e3 && this.recent.text === text && this.recent.filePath === filePath && this.recent.set === setName) {
      return;
    }
    try {
      if (isPdf) {
        return;
      } else {
        if (!this.plugin.settings.mdImmediateAnnotation) {
          return;
        }
        await this.createMdAnnotation(text, filePath, setName);
      }
    } catch (e) {
      console.error("QuickCaptureService createEntry error", e);
    }
  }
  /** 处理右键菜单，为选中文本提供"加入集合"选项 */
  async handleContextMenu(event) {
    if (this.plugin.settings.mdImmediateAnnotation)
      return;
    const setName = this.setService.getSelected();
    if (!setName)
      return;
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed)
      return;
    const text = selection.toString().trim();
    if (!text)
      return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension.toLowerCase() !== "md")
      return;
    const filePath = activeFile.path;
    const mdView = this.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
    if (!mdView || !mdView.editor)
      return;
    event.preventDefault();
    const menu = new import_obsidian24.Menu();
    const collection = this.plugin.dataManager.getCollection(setName);
    const colorStyle = collection ? `color: ${collection.color};` : "";
    menu.addItem((item) => {
      item.setTitle(`\u52A0\u5165\u96C6\u5408 "${setName}"`).setIcon("note-glyph").setSection("BetterNotes").onClick(async () => {
        await this.createMdAnnotation(text, filePath, setName);
      });
      if (colorStyle) {
        setTimeout(() => {
          const menuItem = document.querySelector('.menu-item[data-section="BetterNotes"] .menu-item-icon');
          if (menuItem) {
            menuItem.setAttribute("style", colorStyle);
          }
        }, 0);
      }
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u526A\u5207").setIcon("scissors").onClick(() => {
        navigator.clipboard.writeText(text);
        mdView.editor.replaceSelection("");
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u590D\u5236").setIcon("copy").onClick(() => {
        navigator.clipboard.writeText(text);
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u7C98\u8D34").setIcon("paste").onClick(async () => {
        try {
          const clipText = await navigator.clipboard.readText();
          mdView.editor.replaceSelection(clipText);
        } catch (e) {
          console.error("\u7C98\u8D34\u5931\u8D25:", e);
        }
      });
    });
    menu.showAtMouseEvent(event);
  }
  /**
   * 创建 Markdown 标注
   * @param text 选中的文本
   * @param filePath 文件路径
   * @param setName 集合名称
   */
  async createMdAnnotation(text, filePath, setName) {
    const hash = generateHash();
    const collection = this.plugin.dataManager.getCollection(setName);
    if (!collection) {
      console.warn("QuickCapture: \u672A\u627E\u5230\u96C6\u5408", setName);
      return;
    }
    const color = collection.color;
    const htmlText = text.replace(/\n/g, "<br>\n");
    const spanHtml = `<span class="BetterNotes-hash-span" style="color:${color}" data-hash="${hash}">${htmlText}</span>`;
    const mdView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
    const editor = mdView?.editor;
    if (editor) {
      editor.replaceSelection(spanHtml);
      setTimeout(() => {
        const active = document.activeElement;
        if (active)
          active.blur();
      }, 0);
    } else {
      console.warn("QuickCapture: \u65E0\u6CD5\u63D2\u5165 span\uFF08\u672A\u5904\u4E8E\u7F16\u8F91\u6A21\u5F0F\uFF09");
    }
    const entry = await this.plugin.createEntryWithHash(text, setName, hash, {
      comment: "",
      sourceFile: filePath,
      type: "md",
      index: spanHtml
    });
    await this.plugin.navigateToEntryInComments(entry);
    this.recent = { text, filePath, set: setName, timestamp: Date.now() };
    window.getSelection()?.removeAllRanges();
  }
};

// src/services/pdf/PdfHighlightHandler.ts
var import_obsidian25 = require("obsidian");
init_i18n();
var PdfHighlightHandler = class {
  constructor(app, plugin) {
    this.app = app;
    this.isModifierKeyPressed = false;
    this.processed = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.boundKeyDown = this.handleKeyDown.bind(this);
    this.boundKeyUp = this.handleKeyUp.bind(this);
    this.boundClick = this.handleClick.bind(this);
    document.addEventListener("keydown", this.boundKeyDown);
    document.addEventListener("keyup", this.boundKeyUp);
    document.addEventListener("click", this.boundClick, true);
  }
  handleKeyDown(e) {
    if (e.metaKey || e.ctrlKey || e.key === "Home")
      this.isModifierKeyPressed = true;
    document.body.classList.add("mod-pressed");
  }
  handleKeyUp(e) {
    if (e.key === "Meta" || e.key === "Control" || e.key === "Home")
      this.isModifierKeyPressed = false;
    document.body.classList.remove("mod-pressed");
  }
  async handleClick(e) {
    if (!this.isModifierKeyPressed)
      return;
    const target = e.target;
    if (target.classList.contains("highlightAnnotation")) {
      const id = target.getAttribute("data-annotation-id") ?? target.id;
      if (!id)
        return;
      const entry = this.findEntryByAnnotation(id);
      if (entry) {
        this.navigateToEntry(e, entry);
        return;
      }
    }
    const rectEl = this.findRectElement(target);
    if (rectEl) {
      const hash = rectEl.dataset.hash;
      if (!hash)
        return;
      const entry = this.findEntryByHash(hash);
      if (entry) {
        this.navigateToEntry(e, entry);
        return;
      }
    }
  }
  findRectElement(target) {
    if (target.classList.contains("rect-capture-highlight")) {
      return target;
    }
    let element = target;
    while (element && element !== document.body) {
      if (element.classList.contains("rect-capture-highlight")) {
        return element;
      }
      element = element.parentElement;
    }
    return null;
  }
  async navigateToEntry(e, entry) {
    e.preventDefault();
    e.stopPropagation();
    await this.plugin.activateSidebarView();
    if (!this.plugin.sidebarView) {
      new import_obsidian25.Notice(t("cannot open sidebar view"));
      return;
    }
    this.plugin.sidebarView.openCommentsViewAndHighlightEntry(entry);
  }
  findEntryByAnnotation(annotId) {
    const all = this.plugin.dataManager.getAllEntries();
    return all.find((e) => e.type === "pdf" && typeof e.index === "string" && e.index.includes(`annotation=${annotId}`));
  }
  findEntryByHash(hash) {
    const all = this.plugin.dataManager.getAllEntries();
    return all.find((e) => e.hash === hash);
  }
  cleanup() {
    document.removeEventListener("keydown", this.boundKeyDown);
    document.removeEventListener("keyup", this.boundKeyUp);
    document.removeEventListener("click", this.boundClick, true);
  }
};

// src/services/pdf/PdfRectCaptureService.ts
var import_obsidian26 = require("obsidian");

// src/services/pdf/RectHighlightManager.ts
var RectHighlightManager = class {
  constructor() {
    /** Map<filePath, Map<pageNumber, RectInfo[]>> */
    this.rects = /* @__PURE__ */ new Map();
    /** 记录已绑定的 eventBus，避免重复绑定 */
    this.boundBuses = /* @__PURE__ */ new WeakSet();
    /** 保存当前活动的 PDF 文件路径，用于 pageRenderedCallback */
    this.activeFilePath = null;
    this.pageRenderedCallback = (data) => {
      if (!this.activeFilePath) {
        console.warn("RectHighlightManager: No active file path for pageRenderedCallback");
        return;
      }
      this.renderPage(this.activeFilePath, data.pageNumber, data.source);
    };
  }
  setActiveFilePath(filePath) {
    this.activeFilePath = filePath;
  }
  /**
   * 添加矩形并立即渲染（若 pageView 提供）。
   * @param filePath PDF 文件路径
   * @param pageNumber 页码（1-based）
   * @param rect 矩形坐标 [left, bottom, right, top]
   * @param hash 唯一标识 selection 的 hash
   * @param pageView 可选，当前页的 PageView
   *
   * 注意：
   * 1. 同一页、同一 hash 允许存在多个 rect（跨行 selection）。
   * 2. 但若 hash + rect 坐标完全相同，则判重跳过，避免重复渲染。
   */
  addRect(filePath, pageNumber, rect, hash, pageView, color) {
    const byPage = this.rects.get(filePath) ?? /* @__PURE__ */ new Map();
    const list = byPage.get(pageNumber) ?? [];
    const exists = list.some(
      (info2) => info2.hash === hash && info2.rect[0] === rect[0] && info2.rect[1] === rect[1] && info2.rect[2] === rect[2] && info2.rect[3] === rect[3]
    );
    if (exists)
      return;
    list.push({ rect, hash, color });
    byPage.set(pageNumber, list);
    this.rects.set(filePath, byPage);
    if (pageView) {
      this.renderPage(filePath, pageNumber, pageView);
      this.ensureEventBusListener(filePath, pageView);
    }
  }
  /**
   * 批量加载矩形（用于打开 PDF 时）。
   */
  loadRects(filePath, rectMap) {
    this.rects.set(filePath, new Map(rectMap));
  }
  /**
   * 当 Viewer 的 pageView 渲染时调用
   */
  renderPage(filePath, pageNumber, pageView) {
    const byPage = this.rects.get(filePath);
    if (!byPage)
      return;
    console.warn("renderPage", filePath, pageNumber);
    const infos = byPage.get(pageNumber) ?? [];
    if (infos.length === 0)
      return;
    const layerEl = this.ensureLayer(pageView);
    layerEl.querySelectorAll(".rect-capture-highlight").forEach((el) => el.remove());
    infos.forEach((info2) => this.placeRectCss(info2.rect, pageView, layerEl, info2.hash, info2.color));
  }
  /**
   * 获取指定文件、页码、hash 对应的所有矩形。
   * @param filePath PDF 文件路径
   * @param pageNumber 页码（1-based）
   * @param hash selection 的 hash
   * @returns 对应的矩形数组，若不存在返回 undefined
   */
  getRects(filePath, pageNumber, hash) {
    const byPage = this.rects.get(filePath);
    if (!byPage)
      return void 0;
    const list = byPage.get(pageNumber);
    if (!list)
      return void 0;
    return list.filter((info2) => info2.hash === hash).map((info2) => info2.rect);
  }
  /** 在 eventBus 上绑定 pagerendered 事件 */
  ensureEventBusListener(filePath, pdfViewer) {
    const eventBus = pdfViewer.eventBus;
    eventBus.on("pagerendered", this.pageRenderedCallback);
    this.boundBuses.add(eventBus);
  }
  /** 创建/获取 per-page highlight layer */
  ensureLayer(pageView) {
    const pageDiv = pageView.div;
    return pageDiv.querySelector("div.BetterNotes-rect-highlight-layer") || pageDiv.createDiv("BetterNotes-rect-highlight-layer", (el) => {
      if (window.pdfjsLib?.setLayerDimensions) {
        window.pdfjsLib.setLayerDimensions(el, pageView.viewport);
      }
    });
  }
  placeRectCss(rect, pageView, layerEl, hash, color) {
    const [left, bottom, right, top] = rect;
    const viewBox = pageView.pdfPage.view;
    const pageX = viewBox[0];
    const pageY = viewBox[1];
    const pageW = viewBox[2] - viewBox[0];
    const pageH = viewBox[3] - viewBox[1];
    const mirrored = window.pdfjsLib?.Util?.normalizeRect ? window.pdfjsLib.Util.normalizeRect([
      left,
      viewBox[3] - bottom + viewBox[1],
      right,
      viewBox[3] - top + viewBox[1]
    ]) : [left, viewBox[3] - bottom + viewBox[1], right, viewBox[3] - top + viewBox[1]];
    const hl = layerEl.createDiv({ cls: "rect-capture-highlight" });
    const baseStyle = {
      position: "absolute",
      left: `${(mirrored[0] - pageX) / pageW * 100}%`,
      top: `${(mirrored[1] - pageY) / pageH * 100}%`,
      width: `${(mirrored[2] - mirrored[0]) / pageW * 100}%`,
      height: `${(mirrored[3] - mirrored[1]) / pageH * 100}%`,
      pointerEvents: "auto",
      cursor: "pointer",
      borderRadius: "0.1em"
    };
    if (color) {
      Object.assign(hl.style, baseStyle, {
        background: color,
        border: "none"
      });
    } else {
      Object.assign(hl.style, baseStyle, {
        border: "2px dashed rgba(255,165,0,0.9)",
        background: "rgba(255, 255, 255, 0)"
      });
    }
    if (hash)
      hl.dataset.hash = hash;
    if (!color) {
      hl.addEventListener("mouseenter", () => {
        hl.style.border = "2px solid rgba(255,165,0,1)";
        hl.style.boxShadow = "0 0 8px rgba(255,165,0,0.5)";
      });
      hl.addEventListener("mouseleave", () => {
        hl.style.border = "2px dashed rgba(255,165,0,0.9)";
        hl.style.boxShadow = "none";
      });
    }
  }
  /**
   * 根据条目的唯一 hash 删除矩形高亮记录，并立即从当前页面移除对应 DOM。
   * 如果记录不存在则返回 false。
   *
   * @param hash 条目哈希，唯一标识一个矩形条目
   * @returns 是否找到并删除成功
   */
  removeRectByHash(hash) {
    let found = false;
    for (const [filePath, pageMap] of this.rects) {
      for (const [page, list] of pageMap) {
        const filtered = list.filter((info2) => info2.hash !== hash);
        if (filtered.length !== list.length) {
          found = true;
          if (filtered.length) {
            pageMap.set(page, filtered);
          } else {
            pageMap.delete(page);
          }
        }
      }
      if (pageMap.size === 0) {
        this.rects.delete(filePath);
      }
    }
    if (found && typeof document !== "undefined") {
      document.querySelectorAll(`.rect-capture-highlight[data-hash="${hash}"]`).forEach((el) => el.remove());
    }
    return found;
  }
  /**
   * 将已加载的 pdfViewer 绑定到管理器，并对已渲染的页面立即绘制矩形。
   * @param filePath 当前 PDF 文件路径
   * @param pdfViewer pdf.js BaseViewer 实例 (child.pdfViewer.pdfViewer)
   */
  attachViewer(filePath, pdfViewer) {
    if (!pdfViewer)
      return;
    this.ensureEventBusListener(filePath, pdfViewer);
  }
};

// src/services/pdf/PdfRectCaptureService.ts
init_i18n();
var PdfRectCaptureService = class {
  constructor(app, plugin) {
    this.highlightManager = new RectHighlightManager();
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * 入口：启动一次矩形截取流程。
   * 若当前活动面板不是 PDF，则会给出提示并直接返回。
   */
  startCapture() {
    const selectedSet = this.plugin.setSelectionService?.getSelected?.();
    if (!selectedSet) {
      new import_obsidian26.Notice(t("please select a set first"));
      return;
    }
    const leaf = this.app.workspace.activeLeaf;
    const child = leaf?.view?.viewer?.child;
    const pdfContainer = leaf?.view?.containerEl;
    const file = leaf?.view?.file;
    if (!child || !pdfContainer || !file || file.extension !== "pdf") {
      new import_obsidian26.Notice(t("current view is not pdf view"));
      return;
    }
    pdfContainer.style.cursor = "crosshair";
    let startX = 0, startY = 0, marquee = null;
    const ensureSelectionStyle = () => {
      if (document.getElementById("BetterNotes-pdf-selecting-style"))
        return;
      const style = document.createElement("style");
      style.id = "BetterNotes-pdf-selecting-style";
      style.textContent = `
      .BetterNotes-pdf-selecting *{cursor:crosshair !important;user-select:none !important;-webkit-user-select:none !important;}
      .BetterNotes-pdf-selecting .textLayer{pointer-events:none;}`;
      document.head.appendChild(style);
    };
    ensureSelectionStyle();
    pdfContainer.classList.add("BetterNotes-pdf-selecting");
    const onPointerDown = (evt) => {
      if (!(evt.target instanceof HTMLElement))
        return;
      if (!evt.target.closest(".pdf-embed, .pdf-viewer-container, .page"))
        return;
      startX = evt.clientX;
      startY = evt.clientY;
      marquee = document.body.createDiv({ cls: "BetterNotes-select-box" });
      Object.assign(marquee.style, {
        position: "fixed",
        border: "2px dashed #3a7bfc",
        background: "rgba(58,123,252,0.1)",
        zIndex: 9999,
        left: `${startX}px`,
        top: `${startY}px`
      });
      const onMove = (e) => {
        const x4 = e.clientX, y4 = e.clientY;
        const rectLeft = Math.min(x4, startX), rectTop = Math.min(y4, startY), w6 = Math.abs(x4 - startX), h3 = Math.abs(y4 - startY);
        Object.assign(marquee.style, {
          left: `${rectLeft}px`,
          top: `${rectTop}px`,
          width: `${w6}px`,
          height: `${h3}px`
        });
      };
      const onUp = async (e) => {
        window.getSelection()?.empty?.();
        document.removeEventListener("pointermove", onMove);
        document.removeEventListener("pointerup", onUp);
        pdfContainer.style.cursor = "";
        pdfContainer.classList.remove("BetterNotes-pdf-selecting");
        if (!marquee)
          return;
        const box = marquee.getBoundingClientRect();
        marquee.remove();
        const centerX = box.left + box.width / 2;
        const centerY = box.top + box.height / 2;
        const elAtCenter = document.elementFromPoint(centerX, centerY);
        const pageEl = elAtCenter?.closest?.(".page");
        if (!pageEl || !pageEl.dataset.pageNumber)
          return;
        const pageNumber = Number(pageEl.dataset.pageNumber);
        const pageView = child.getPage(pageNumber);
        if (!pageView)
          return;
        try {
          const rectPdf = this.browserRectToPdfRect(box, pageEl, pageView);
          const rectArr = rectPdf.map((v4) => Math.round(v4));
          const pngPath = await this.renderAndSaveCroppedPng(file, pageView, rectArr, pageNumber);
          const attachments = [];
          if (pngPath)
            attachments.push(pngPath);
          try {
            const indexLink = `${file.path}#page=${pageNumber}&rect=${rectArr.join(",")}`;
            const entry = await this.plugin.createEntry("", selectedSet, {
              comment: "",
              sourceFile: file.path,
              type: "pdf",
              index: indexLink,
              attachmentFile: attachments
            });
            await this.plugin.navigateToEntryInComments(entry);
            const viewer = leaf?.view?.viewer;
            const mgr = this.plugin.rectHighlightManager;
            if (viewer && !viewer.__snRectMgr)
              viewer.__snRectMgr = mgr;
            mgr.addRect(file.path, pageNumber, rectArr, entry.hash, pageView);
          } catch (e2) {
            console.error("PdfRectCaptureService createEntry error", e2);
          }
        } catch (err2) {
          console.error("PdfRectCaptureService: saveCroppedPng error", err2);
          new import_obsidian26.Notice(t("save cropped png failed"));
        }
      };
      document.addEventListener("pointermove", onMove);
      document.addEventListener("pointerup", onUp, { once: true });
    };
    pdfContainer.addEventListener("pointerdown", onPointerDown, { once: true });
  }
  /**
   * 将浏览器坐标系下的 DOMRect 转换为 PDF 坐标系 Rect
   * 返回 [x1, y1, x2, y2]，对应左、下、右、上 (PDF 坐标系 y 轴向上)
   */
  browserRectToPdfRect(box, pageEl, pageView) {
    const style = window.getComputedStyle(pageEl);
    const borderLeft = parseFloat(style.borderLeftWidth) || 0;
    const paddingLeft = parseFloat(style.paddingLeft) || 0;
    const borderTop = parseFloat(style.borderTopWidth) || 0;
    const paddingTop = parseFloat(style.paddingTop) || 0;
    const pageRect = pageEl.getBoundingClientRect();
    const local = (clientX, clientY) => [
      clientX - (pageRect.left + borderLeft + paddingLeft),
      clientY - (pageRect.top + borderTop + paddingTop)
    ];
    const [lx1, ly1] = local(box.left, box.top);
    const [lx2, ly2] = local(box.right, box.bottom);
    const [x1, y1] = pageView.viewport.convertToPdfPoint(lx1, ly1);
    const [x22, y22] = pageView.viewport.convertToPdfPoint(lx2, ly2);
    return [Math.min(x1, x22), Math.min(y1, y22), Math.max(x1, x22), Math.max(y1, y22)];
  }
  /**
   * 将整个页面以指定 scale 渲染到 canvas，然后裁剪 rect ，保存 PNG
   * @returns 返回保存后的文件路径（相对 Vault 根目录），失败返回空字符串
   */
  async renderAndSaveCroppedPng(origPdf, pageView, rect, pageNumber) {
    const pdfPage = pageView.pdfPage;
    const scale2 = 2;
    const renderVp = pdfPage.getViewport({ scale: scale2 });
    const canvas = document.createElement("canvas");
    canvas.width = renderVp.width;
    canvas.height = renderVp.height;
    const ctx = canvas.getContext("2d");
    await pdfPage.render({ canvasContext: ctx, viewport: renderVp }).promise;
    const viewBox = pdfPage.view;
    const [x1, y1, x22, y22] = rect;
    const crop = {
      sx: (x1 - viewBox[0]) * scale2,
      sy: (viewBox[3] - y22) * scale2,
      // y 轴翻转
      sw: (x22 - x1) * scale2,
      sh: (y22 - y1) * scale2
    };
    if (crop.sw <= 0 || crop.sh <= 0)
      throw new Error("invalid crop size");
    const outCanvas = document.createElement("canvas");
    outCanvas.width = crop.sw;
    outCanvas.height = crop.sh;
    outCanvas.getContext("2d").drawImage(canvas, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, crop.sw, crop.sh);
    const blob = await new Promise((res) => outCanvas.toBlob((b4) => res(b4), "image/png"));
    const arrayBuffer = await blob.arrayBuffer();
    const { AttachmentService: AttachmentService2 } = await Promise.resolve().then(() => (init_AttachmentService(), AttachmentService_exports));
    const svc = new AttachmentService2(this.app);
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const fileName = `${origPdf.basename} p${pageNumber} ${timestamp}-front.png`;
    const targetPath = await svc.saveBinaryAttachment(fileName, arrayBuffer);
    return targetPath;
  }
};

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args2) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args2);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/services/pdf/PdfViewerPatchService.ts
init_utils();
var PdfViewerPatchService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.patched = false;
    this.applySubpathPatched = false;
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", () => {
        if (!this.patched) {
          this.patchAllPdfLeaves();
        }
      })
    );
  }
  /**
   * 已补丁的原型集合，避免重复补丁
   */
  /**
   * 若给定 leaf 是 PDF 视图且其 viewer.prototype 未被补丁，则执行补丁。
   */
  tryPatchPdfViewer(leaf) {
    const viewer = leaf?.view?.viewer;
    const proto = viewer.constructor?.prototype;
    const pluginRef = this.plugin;
    const unpatch = around(proto, {
      loadFile(old) {
        if (typeof old !== "function")
          return old;
        return async function(file, subpath) {
          const ret = await old.call(this, file, subpath);
          pluginRef.pdfViewerPatchService.injectHighlights(this, file);
          return ret;
        };
      }
    });
    const initFile = leaf.view?.file;
    if (initFile)
      this.injectHighlights(viewer, initFile);
    this.patchPdfViewerChildApplySubpath(viewer);
    this.patched = true;
    this.plugin.register(unpatch);
  }
  /**
   * 为 PDF.js 的 ViewerChild 添加 applySubpath 补丁，支持 rect 参数
   * 当链接包含 rect=x,y,w,h 参数时，将使用 FitR 目标类型进行精确定位
   * @param viewer PDF Viewer 对象
   */
  patchPdfViewerChildApplySubpath(viewer) {
    if (this.applySubpathPatched)
      return;
    viewer.then?.((child) => {
      if (!child || typeof child.applySubpath !== "function")
        return;
      const childProto = Object.getPrototypeOf(child);
      if (!childProto)
        return;
      const pluginRef = this.plugin;
      const unpatch = around(childProto, {
        applySubpath(old) {
          if (typeof old !== "function")
            return old;
          return function(subpath) {
            try {
              const params = new URLSearchParams(subpath?.startsWith("#") ? subpath.slice(1) : subpath);
              if (params.has("page") && (params.has("rect") || params.has("selection"))) {
                const page = parseInt(params.get("page") || "1", 10);
                if (params.has("rect")) {
                  const rect = (params.get("rect") || "").split(",").map((n3) => parseFloat(n3));
                  const hash = params.get("hash");
                  if (rect.length === 4 && rect.every((n3) => !isNaN(n3))) {
                    const dest = [page - 1, { name: "FitR" }, ...rect];
                    const pdfViewer = this.pdfViewer?.pdfViewer;
                    if (pdfViewer?.pdfDocument) {
                      const performScroll = () => {
                        try {
                          pdfViewer.scrollPageIntoView({
                            pageNumber: page,
                            destArray: dest,
                            ignoreDestinationZoom: false
                          });
                          if (hash && typeof pluginRef.entryNavigation?.highlightPdfRect === "function") {
                            setTimeout(() => {
                              pluginRef.entryNavigation.highlightPdfRect(hash.replace(/^'|'$/g, ""));
                            }, 200);
                          }
                        } catch (err2) {
                          console.error("BetterNotes: scrollPageIntoView error", err2);
                        }
                      };
                      if (pdfViewer._pages?.length) {
                        performScroll();
                      } else {
                        const onPagesInit = () => {
                          pdfViewer.eventBus.off("pagesloaded", onPagesInit);
                          setTimeout(performScroll, 0);
                        };
                        pdfViewer.eventBus.on("pagesloaded", onPagesInit);
                      }
                    }
                  }
                } else if (params.has("selection")) {
                  const selStr = params.get("selection") || "";
                  const selArr = selStr.split(",").map((n3) => parseInt(n3, 10));
                  const hash = params.get("hash");
                  if (selArr.length === 4 && selArr.every((n3) => !isNaN(n3))) {
                    const [beginIndex, beginOffset, endIndex, endOffset] = selArr;
                    const pdfViewer = this.pdfViewer?.pdfViewer;
                    if (pdfViewer?.pdfDocument) {
                      const scrollToPage = () => {
                        try {
                          pdfViewer.scrollPageIntoView({
                            pageNumber: page - 1,
                            destArray: [page - 1, { name: "FitH" }, 0],
                            ignoreDestinationZoom: false
                          });
                        } catch (err2) {
                          console.error("BetterNotes: selection page scroll error", err2);
                        }
                      };
                      if (pdfViewer._pages?.length) {
                        scrollToPage();
                      } else {
                        const onPagesLoaded = () => {
                          pdfViewer.eventBus.off("textlayerrendered", onPagesLoaded);
                          setTimeout(scrollToPage, 0);
                        };
                        pdfViewer.eventBus.on("textlayerrendered", onPagesLoaded);
                      }
                      if (hash && typeof pluginRef.entryNavigation?.highlightPdfRect === "function") {
                        setTimeout(() => {
                          pluginRef.entryNavigation.highlightPdfRect(hash.replace(/^'|'$/g, ""));
                        }, 200);
                      }
                    }
                  }
                }
                return;
              } else if (params.has("page") && params.has("annotation")) {
                const page = parseInt(params.get("page") || "1", 10);
                const annotationId = params.get("annotation");
                const dest = [page - 1, { name: "FitH" }, 0];
                const pdfViewer = this.pdfViewer?.pdfViewer;
                if (pdfViewer?.pdfDocument) {
                  const performScroll = () => {
                    try {
                      pdfViewer.scrollPageIntoView({
                        pageNumber: page,
                        destArray: dest,
                        ignoreDestinationZoom: false
                      });
                      const highlightAnnotationWhenReady = () => {
                        const pageView = pdfViewer.getPageView(page - 1);
                        if (pageView?.annotationLayer?.div) {
                          setTimeout(() => this.highlightAnnotation(page, annotationId), 100);
                        } else {
                          const onAnnotLayerRendered = (data) => {
                            if (data.pageNumber === page) {
                              pdfViewer.eventBus.off("annotationlayerrendered", onAnnotLayerRendered);
                              setTimeout(() => this.clearAnnotationHighlight(), 0);
                              setTimeout(() => this.highlightAnnotation(page, annotationId), 100);
                            }
                          };
                          pdfViewer.eventBus.on("annotationlayerrendered", onAnnotLayerRendered);
                        }
                      };
                      highlightAnnotationWhenReady();
                    } catch (err2) {
                      console.error("BetterNotes: scrollPageIntoView error", err2);
                    }
                  };
                  if (pdfViewer._pages?.length) {
                    performScroll();
                  } else {
                    const onPagesInit = () => {
                      pdfViewer.eventBus.off("pagesloaded", onPagesInit);
                      setTimeout(performScroll, 0);
                    };
                    pdfViewer.eventBus.on("pagesloaded", onPagesInit);
                  }
                  this.annotationHighlightInfo = {
                    page,
                    annotationId
                  };
                } else {
                }
              } else {
                return old.call(this, subpath);
              }
            } catch (error2) {
              console.error("BetterNotes: PDF applySubpath patch error", error2);
              return old.call(this, subpath);
            }
          };
        }
      });
      this.applySubpathPatched = true;
      this.plugin.register(unpatch);
    });
  }
  /** 遍历全部 leaf，找出 pdf 视图进行补丁 */
  patchAllPdfLeaves() {
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType && leaf.view.getViewType() === "pdf") {
        this.tryPatchPdfViewer(leaf);
      }
    });
  }
  injectHighlights(viewer, file) {
    const pluginRef = this.plugin;
    viewer.then?.((child) => {
      try {
        const pdfViewer = child.pdfViewer?.pdfViewer;
        if (!pdfViewer)
          return;
        const mgr = pluginRef.rectHighlightManager;
        mgr.setActiveFilePath(file.path);
        mgr.attachViewer(file.path, pdfViewer);
        const selectionEntries = pluginRef.dataManager.getAllEntries().filter(
          (e) => e.type === "pdf" && typeof e.index === "string" && e.index.includes("selection=") && e.sourceFile === file.path
        );
        if (selectionEntries.length) {
          const processed = /* @__PURE__ */ new Set();
          pdfViewer.eventBus.on("textlayerrendered", (ev) => {
            const pageNumber = ev.pageNumber;
            const pageView = pdfViewer.getPageView(pageNumber - 1);
            if (!pageView)
              return;
            const pss = new PdfSelectionService();
            selectionEntries.forEach((entry) => {
              if (processed.has(entry.hash))
                return;
              const m5 = entry.index.match(/page=(\d+)&selection=([\d,]+)/);
              if (!m5)
                return;
              const page = Number(m5[1]);
              if (page !== pageNumber)
                return;
              const parts2 = m5[2].split(",").map((n3) => parseInt(n3, 10));
              if (parts2.length !== 4 || parts2.some((n3) => isNaN(n3)))
                return;
              const [beginIndex, beginOffset, endIndex, endOffset] = parts2;
              const selRange = {
                beginIndex,
                beginOffset,
                endIndex,
                endOffset
              };
              let rects = mgr.getRects(file.path, page, entry.hash);
              if (!rects || rects.length === 0) {
                rects = pss.computeRectsForSelection(pageView.div, selRange, pageView);
                if (!rects.length)
                  return;
                const opacity = pluginRef.settings?.highlightOpacity ?? 0.7;
                let fillColor;
                const collection = pluginRef.dataManager?.getCollection?.(entry.set);
                if (collection?.color) {
                  fillColor = hexToRgba(collection.color, opacity);
                } else {
                  fillColor = hexToRgba("#FFFF00", opacity);
                }
                rects.forEach((rect) => {
                  mgr.addRect(file.path, page, rect, entry.hash, pageView, fillColor);
                });
              } else {
                mgr.renderPage(file.path, page, pageView);
              }
              processed.add(entry.hash);
            });
          });
        }
      } catch (err2) {
        console.error("PdfViewerPatchService highlight error", err2);
      }
    });
  }
};

// src/services/openLinkPatch.ts
var import_obsidian27 = require("obsidian");
init_i18n();
var import_url2 = require("url");
var OpenLinkService = class {
  /**
   * 构造函数
   * @param app Obsidian App 实例
   * @param plugin BetterNotes 插件实例
   */
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.isPatched = false;
    this.patchOpenLinkText();
    this.addHighlightStyle();
  }
  /**
   * 对 Workspace.prototype.openLinkText 进行补丁，拦截视频链接和哈希链接
   */
  patchOpenLinkText() {
    if (this.isPatched)
      return;
    const self2 = this;
    const openLinkpatch = around(this.app.workspace.constructor.prototype, {
      openLinkText(old) {
        return function(linktext, sourcePath, newLeaf, openViewState) {
          const videoMatch = linktext.match(/(.+)?#video=(['"])(.+?)\2(?:&timestamp=(\d+(?:\.\d+)?))?/);
          if (videoMatch) {
            const [, filepath, , videoUrl, timestamp] = videoMatch;
            console.warn(`BetterNotes: \u62E6\u622A\u5230\u89C6\u9891\u94FE\u63A5 [${filepath}] \u89C6\u9891: ${videoUrl}, \u65F6\u95F4\u70B9: ${timestamp || "N/A"}`);
            self2.handleVideoLink(filepath, videoUrl, timestamp);
            return;
          }
          const hashMatch = linktext.match(/(.+)?#hash=(['"])(.+?)\2/);
          if (hashMatch) {
            const [, filepath, , hash] = hashMatch;
            console.warn(`BetterNotes: \u62E6\u622A\u5230\u54C8\u5E0C\u94FE\u63A5 [${filepath}] \u54C8\u5E0C: ${hash}`);
            self2.handleHashLink(filepath, hash);
            return;
          }
          return old.call(this, linktext, sourcePath, newLeaf, openViewState);
        };
      }
    });
    this.plugin.register(openLinkpatch);
    this.isPatched = true;
  }
  /**
   * 添加高亮样式到文档
   * 创建一个用于闪烁高亮效果的CSS类
   */
  addHighlightStyle() {
    if (document.getElementById("BetterNotes-highlight-style")) {
      return;
    }
    const styleEl = document.createElement("style");
    styleEl.id = "BetterNotes-highlight-style";
    const css = `
            @keyframes BetterNotes-flash {
                0% { background-color: rgba(255, 255, 0, 0.7); }
                100% { background-color: rgba(255, 255, 0, 0); }
            }
            
            .BetterNotes-flash-highlight {
                background-color: rgba(255, 255, 0, 0);
                animation: BetterNotes-flash 2000ms ease-out;
            }
        `;
    styleEl.textContent = css;
    document.head.appendChild(styleEl);
  }
  /**
   * 处理哈希链接，导航到带有指定hash的span标签
   * @param filepath 文件路径
   * @param hash 条目哈希值
   * @returns 处理是否成功
   */
  async handleHashLink(filepath, hash) {
    try {
      if (!filepath) {
        new import_obsidian27.Notice(t("no file path specified"));
        return false;
      }
      if (!hash) {
        new import_obsidian27.Notice(t("no hash value specified"));
        return false;
      }
      const file = this.app.vault.getAbstractFileByPath(filepath);
      if (!file || !(file instanceof import_obsidian27.TFile)) {
        new import_obsidian27.Notice(t("file not found") + ": " + filepath);
        return false;
      }
      await this.app.workspace.openLinkText("", filepath, false);
      const activeLeaf = this.app.workspace.getLeaf();
      if (!activeLeaf) {
        new import_obsidian27.Notice(t("cannot get active editor"));
        return false;
      }
      const view = activeLeaf.view;
      if (!(view instanceof import_obsidian27.MarkdownView)) {
        new import_obsidian27.Notice(t("current view is not markdown view"));
        return false;
      }
      if (view.getMode() !== "source") {
        await view.setState({ ...view.getState(), mode: "source" }, { history: false });
      }
      const editor = view.editor;
      const position = await this.findHashPosition(editor, hash);
      if (!position) {
        new import_obsidian27.Notice(t("entry not found") + ": " + hash);
        return false;
      }
      editor.scrollIntoView({
        from: position.from,
        to: position.to
      }, true);
      const active = document.activeElement;
      if (active)
        active.blur();
      setTimeout(() => {
        this.highlightEntrySpan(hash);
      }, 200);
      return true;
    } catch (error2) {
      console.error("\u5904\u7406\u54C8\u5E0C\u94FE\u63A5\u65F6\u51FA\u9519:", error2);
      new import_obsidian27.Notice(t("hash link processing failed"));
      return false;
    }
  }
  /**
   * 在编辑器中查找带有特定hash的span标签的位置
   * @param editor 编辑器实例
   * @param hash 条目哈希值
   * @returns 文本位置，如果未找到则返回null
   */
  findHashPosition(editor, hash) {
    const content = editor.getValue();
    const regex = new RegExp(`<span[^>]*data-hash="${hash}"[^>]*>`);
    const match = regex.exec(content);
    if (!match) {
      return null;
    }
    const matchIndex = match.index;
    let lineCount = 0;
    let charCount = 0;
    for (let i3 = 0; i3 < matchIndex; i3++) {
      if (content[i3] === "\n") {
        lineCount++;
        charCount = 0;
      } else {
        charCount++;
      }
    }
    return {
      from: { line: lineCount, ch: charCount },
      to: { line: lineCount, ch: charCount + match[0].length }
    };
  }
  /**
   * 高亮显示带有特定hash的span元素
   * @param hash 条目的哈希值
   */
  highlightEntrySpan(hash) {
    const spans = document.querySelectorAll(`span[data-hash="${hash}"]`);
    if (spans.length === 0) {
      return;
    }
    spans.forEach((span) => {
      span.classList.add("BetterNotes-flash-highlight");
      setTimeout(() => {
        span.classList.remove("BetterNotes-flash-highlight");
      }, 2e3);
    });
  }
  /**
   * 处理视频链接
   * @param filepath 文件路径
   * @param videoUrl 视频URL
   * @param timestamp 时间戳（秒），支持小数形式（如18.08秒）
   * @returns 处理是否成功
   */
  async handleVideoLink(filepath, videoUrl, timestamp) {
    try {
      if (!videoUrl) {
        new import_obsidian27.Notice(t("no video url specified"));
        return false;
      }
      let filePath = videoUrl;
      if (videoUrl.startsWith("file://")) {
        filePath = decodeURIComponent(videoUrl.replace("file://", ""));
      }
      const leaves = this.app.workspace.getLeavesOfType(VIDEO_VIEW_TYPE);
      const existing = leaves.find((leaf2) => {
        const v4 = leaf2.view;
        const st2 = v4.getState();
        return st2?.filePath === filePath;
      });
      if (existing) {
        this.app.workspace.revealLeaf(existing);
        this.app.workspace.setActiveLeaf(existing);
        if (timestamp) {
          const seek = parseFloat(timestamp);
          if (!Number.isNaN(seek)) {
            existing.view.seekTo(seek);
          }
        }
        return true;
      }
      const leaf = this.app.workspace.getLeaf(true);
      const ensuredUrl = videoUrl.startsWith("file://") ? videoUrl : (0, import_url2.pathToFileURL)(filePath).href;
      await leaf.setViewState({
        type: VIDEO_VIEW_TYPE,
        active: true,
        state: {
          fileUrl: ensuredUrl,
          filePath
        }
      });
      this.app.workspace.revealLeaf(leaf);
      if (timestamp) {
        const seek = parseFloat(timestamp);
        if (!Number.isNaN(seek)) {
          leaf.view.seekTo(seek);
        }
      }
      return true;
    } catch (error2) {
      console.error("\u5904\u7406\u89C6\u9891\u94FE\u63A5\u65F6\u51FA\u9519:", error2);
      new import_obsidian27.Notice(t("video link processing failed"));
      return false;
    }
  }
};

// src/services/LinkService.ts
var import_obsidian28 = require("obsidian");
init_utils();
var import_html2canvas = __toESM(require_html2canvas());
init_i18n();
var DEFAULT_LINK_TEMPLATES = {
  pdfTemplate: "[[{index}|{value}]]",
  mdTemplate: "[[{index}|{value}]]",
  videoTemplate: "[[{index}|{value}]]",
  cardTemplate: "> [!note]+ {link}\n>> [!quote]+ \n>> {comment}\n",
  htmlTemplate: `<div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 30px; border-radius: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3); max-width: 520px; position: relative; color: white;">
    <div style="position: absolute; top: 15px; right: 20px; background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px); padding: 8px 16px; border-radius: 25px; font-size: 12px; font-weight: 600; border: 1px solid rgba(255, 255, 255, 0.3);">
        \u2728 {type}
    </div>
    
    <h3 style="margin: 20px 0; color: #FFFFFF; font-size: 28px; font-weight: 300; letter-spacing: 1px;">{value}</h3>
    
    <div style="background: rgba(255, 255, 255, 0.95); padding: 25px; border-radius: 12px; margin: 20px 0; backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.2);">
        <p style="color: #2C3E50; margin: 0; font-size: 20px; font-weight: 500; text-align: center; line-height: 1.5;">{comment}</p>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 25px 0;">
        <div style="background: rgba(255, 255, 255, 0.1); padding: 12px; border-radius: 10px; backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.2);">
            <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">COLLECTION</div>
            <div style="font-weight: 600; font-size: 16px;">{set}</div>
        </div>
        <div style="background: rgba(255, 255, 255, 0.1); padding: 12px; border-radius: 10px; backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.2);">
            <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">DATE ADDED</div>
            <div style="font-weight: 600; font-size: 16px;">{addTime}</div>
        </div>
    </div>
</div>`
};
var LinkService = class {
  /**
   * 构造函数
   * @param plugin BetterNotes插件实例
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * 显示链接操作菜单
   * @param entry 条目对象
   * @param targetEl 触发菜单的目标元素
   */
  showLinkMenu(entry, targetEl) {
    const menu = new import_obsidian28.Menu();
    menu.addItem((item) => {
      item.setTitle(t("copy link")).setIcon("link").onClick(async () => {
        await this.copyEntryLink(entry);
      });
    });
    menu.addItem((item) => {
      item.setTitle(t("copy card")).setIcon("copy").onClick(async () => {
        await this.copyEntryCard(entry);
      });
    });
    menu.addItem((item) => {
      item.setTitle(t("export image")).setIcon("image").onClick(async () => {
        await this.exportEntryAsImage(entry);
      });
    });
    const rect = targetEl.getBoundingClientRect();
    menu.showAtPosition({ x: rect.right, y: rect.top });
  }
  /**
   * 复制条目链接到剪贴板
   * 根据条目类型和用户配置的模板生成链接
   * @param entry 条目对象
   * @returns 是否复制成功
   */
  async copyEntryLink(entry) {
    try {
      const variables = this.extractLinkVariables(entry);
      let template = "";
      switch (entry.type) {
        case "pdf":
          template = this.plugin.settings?.linkTemplates?.pdfTemplate || DEFAULT_LINK_TEMPLATES.pdfTemplate;
          break;
        case "md":
          template = this.plugin.settings?.linkTemplates?.mdTemplate || DEFAULT_LINK_TEMPLATES.mdTemplate;
          break;
        case "video":
          template = this.plugin.settings?.linkTemplates?.videoTemplate || DEFAULT_LINK_TEMPLATES.videoTemplate;
          break;
        default:
          template = "[[{index}|{value}]]";
      }
      const link = this.replaceTemplateVariables(template, variables);
      await navigator.clipboard.writeText(link);
      new import_obsidian28.Notice(t("link copied to clipboard"));
      return true;
    } catch (error2) {
      console.error("\u590D\u5236\u6761\u76EE\u94FE\u63A5\u65F6\u51FA\u9519:", error2);
      new import_obsidian28.Notice(t("copy link failed"));
      return false;
    }
  }
  /**
   * 复制条目卡片到剪贴板
   * 根据用户配置的卡片模板生成卡片内容
   * @param entry 条目对象
   * @returns 是否复制成功
   */
  async copyEntryCard(entry) {
    try {
      const linkVariables = this.extractLinkVariables(entry);
      let linkTemplate = "";
      switch (entry.type) {
        case "pdf":
          linkTemplate = this.plugin.settings?.linkTemplates?.pdfTemplate || DEFAULT_LINK_TEMPLATES.pdfTemplate;
          break;
        case "md":
          linkTemplate = this.plugin.settings?.linkTemplates?.mdTemplate || DEFAULT_LINK_TEMPLATES.mdTemplate;
          break;
        case "video":
          linkTemplate = this.plugin.settings?.linkTemplates?.videoTemplate || DEFAULT_LINK_TEMPLATES.videoTemplate;
          break;
        default:
          linkTemplate = "[[{index}|{value}]]";
      }
      const link = this.replaceTemplateVariables(linkTemplate, linkVariables);
      const cardVariables = this.extractCardVariables(entry, link);
      const cardTemplate = this.plugin.settings?.linkTemplates?.cardTemplate || DEFAULT_LINK_TEMPLATES.cardTemplate;
      const cardContent = this.replaceCardTemplateVariables(cardTemplate, cardVariables);
      await navigator.clipboard.writeText(cardContent);
      new import_obsidian28.Notice(t("copied to clipboard"));
      return true;
    } catch (error2) {
      console.error("\u590D\u5236\u6761\u76EE\u5361\u7247\u65F6\u51FA\u9519:", error2);
      new import_obsidian28.Notice(t("copy failed"));
      return false;
    }
  }
  /**
   * 将条目导出为图片
   * 使用html2canvas将HTML模板渲染为图片
   * @param entry 条目对象
   * @returns 是否导出成功
   */
  async exportEntryAsImage(entry) {
    try {
      const container = document.createElement("div");
      container.style.position = "fixed";
      container.style.left = "-9999px";
      container.style.top = "0";
      document.body.appendChild(container);
      const htmlTemplate = this.plugin.settings?.linkTemplates?.htmlTemplate || DEFAULT_LINK_TEMPLATES.htmlTemplate;
      const linkVariables = this.extractLinkVariables(entry);
      let linkTemplate = "";
      switch (entry.type) {
        case "pdf":
          linkTemplate = this.plugin.settings?.linkTemplates?.pdfTemplate || DEFAULT_LINK_TEMPLATES.pdfTemplate;
          break;
        case "md":
          linkTemplate = this.plugin.settings?.linkTemplates?.mdTemplate || DEFAULT_LINK_TEMPLATES.mdTemplate;
          break;
        case "video":
          linkTemplate = this.plugin.settings?.linkTemplates?.videoTemplate || DEFAULT_LINK_TEMPLATES.videoTemplate;
          break;
        default:
          linkTemplate = "[[{index}|{value}]]";
      }
      const link = this.replaceTemplateVariables(linkTemplate, linkVariables);
      const cardVariables = this.extractCardVariables(entry, link);
      const htmlContent = this.replaceCardTemplateVariables(htmlTemplate, cardVariables);
      container.innerHTML = htmlContent;
      try {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
        const canvas = await (0, import_html2canvas.default)(container, {
          backgroundColor: null,
          scale: 5,
          // 提高清晰度
          logging: false
        });
        const imgUrl = canvas.toDataURL("image/png");
        const downloadLink = document.createElement("a");
        downloadLink.href = imgUrl;
        downloadLink.download = `${entry.hash}-${Date.now()}.png`;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        new import_obsidian28.Notice(t("image exported"));
        return true;
      } finally {
        document.body.removeChild(container);
      }
    } catch (error2) {
      console.error("\u5BFC\u51FA\u56FE\u7247\u65F6\u51FA\u9519:", error2);
      new import_obsidian28.Notice(t("export image failed"));
      return false;
    }
  }
  /**
   * 提取链接变量
   * 根据条目类型提取不同的变量
   * @param entry 条目对象
   * @returns 链接变量对象
   */
  extractLinkVariables(entry) {
    const variables = {
      index: "",
      value: entry.value
    };
    switch (entry.type) {
      case "pdf":
        if (entry.index) {
          variables.index = entry.index;
          if (entry.hash) {
            variables.index += `&hash='${entry.hash}'`;
          }
        }
        if (entry.index) {
          const pageMatch = entry.index.match(/page=(\d+)/);
          if (pageMatch && pageMatch[1]) {
            variables.page = pageMatch[1];
          }
          if (entry.sourceFile) {
            variables.file = extractFilenameFromPath(entry.sourceFile);
          }
        }
        break;
      case "md":
        if (entry.sourceFile && entry.hash) {
          variables.index = `${entry.sourceFile}#hash='${entry.hash}'`;
          variables.file = extractFilenameFromPath(entry.sourceFile);
        }
        break;
      case "video":
        if (entry.sourceFile && entry.index) {
          const parts2 = entry.index.split("&");
          if (parts2.length >= 5) {
            const timeSeconds = parts2[0];
            const videoUrl = parts2[4];
            variables.index = `${entry.sourceFile}#video='${videoUrl}'&timestamp=${timeSeconds}`;
            variables.timestamp = timeSeconds;
            variables.url = videoUrl;
            variables.file = extractFilenameFromPath(entry.sourceFile);
          }
        }
        break;
    }
    return variables;
  }
  /**
   * 提取卡片变量
   * 从条目中提取用于生成卡片的变量
   * @param entry 条目对象
   * @param link 已生成的链接
   * @returns 卡片变量对象
   */
  extractCardVariables(entry, link) {
    const collection = this.plugin.dataManager.getCollection(entry.set);
    const collectionColor = collection ? collection.color : "#7F7F7F";
    return {
      link,
      comment: entry.comment || "",
      value: entry.value,
      addTime: entry.addTime,
      tag: entry.tag ? entry.tag.join(", ") : "",
      type: entry.type,
      proficiency: entry.proficiency !== void 0 ? entry.proficiency.toString() : "0",
      set: entry.set || "",
      color: collectionColor
    };
  }
  /**
   * 替换模板中的变量
   * @param template 模板字符串
   * @param variables 变量对象
   * @returns 替换后的字符串
   */
  replaceTemplateVariables(template, variables) {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      if (value !== void 0) {
        const regex = new RegExp(`\\{${key}\\}`, "g");
        result = result.replace(regex, value);
      }
    }
    result = result.replace(/\{[^{}]+\}/g, "");
    return result;
  }
  /**
   * 替换卡片模板中的变量
   * @param template 卡片模板字符串
   * @param variables 卡片变量对象
   * @returns 替换后的字符串
   */
  replaceCardTemplateVariables(template, variables) {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      if (value !== void 0) {
        const regex = new RegExp(`\\{${key}\\}`, "g");
        if (key === "comment" && typeof value === "string") {
          const htmlValue = value.replace(/\n/g, "<br>");
          result = result.replace(regex, htmlValue);
        } else {
          result = result.replace(regex, value);
        }
      }
    }
    result = result.replace(/\{[^{}]+\}/g, "");
    return result;
  }
};

// src/services/InternalLinkService.ts
var import_obsidian29 = require("obsidian");
init_i18n();
var InternalLinkService = class {
  /**
   * 构造函数
   * @param plugin BetterNotes插件实例
   */
  constructor(plugin) {
    this.plugin = plugin;
    this.state = {
      isLinking: false,
      sourceHash: null,
      targetHash: null,
      timeoutId: null
    };
  }
  /**
   * 处理条目右击事件
   * 如果不在链接模式，则进入链接模式并记录源条目
   * 如果已在链接模式，则尝试与目标条目建立链接
   * @param entry 被右击的条目
   * @returns 是否成功处理
   */
  async handleEntryRightClick(entry) {
    if (!this.state.isLinking) {
      this.startLinking(entry.hash);
      new import_obsidian29.Notice(t("selected entry") + '"' + this.truncateString(entry.value, 20) + '"' + t("please right click another entry to establish a link"));
      return true;
    }
    if (this.state.sourceHash) {
      if (this.state.sourceHash === entry.hash) {
        new import_obsidian29.Notice(t("cannot link to itself"));
        this.resetLinkingState();
        return false;
      }
      this.state.targetHash = entry.hash;
      document.querySelectorAll(`[data-entry-hash="${entry.hash}"]`).forEach((el) => {
        el.classList.add("BetterNotes-linking-target");
      });
      const result = await this.createBidirectionalLink(this.state.sourceHash, entry.hash);
      if (this.state.timeoutId) {
        clearTimeout(this.state.timeoutId);
      }
      this.state.timeoutId = setTimeout(() => {
        this.resetLinkingState();
      }, 1e3);
      return result;
    }
    return false;
  }
  /**
   * 开始链接模式
   * @param sourceHash 源条目的哈希值
   */
  startLinking(sourceHash) {
    if (this.state.isLinking) {
      this.resetLinkingState();
    }
    this.state.isLinking = true;
    this.state.sourceHash = sourceHash;
    document.body.classList.add("BetterNotes-linking-mode");
    document.querySelectorAll(`[data-entry-hash="${sourceHash}"]`).forEach((el) => {
      el.classList.add("BetterNotes-linking-source");
    });
  }
  /**
   * 重置链接状态
   */
  resetLinkingState() {
    if (this.state.timeoutId) {
      clearTimeout(this.state.timeoutId);
      this.state.timeoutId = null;
    }
    if (this.state.sourceHash) {
      document.querySelectorAll(`[data-entry-hash="${this.state.sourceHash}"]`).forEach((el) => {
        el.classList.remove("BetterNotes-linking-source");
      });
    }
    if (this.state.targetHash) {
      document.querySelectorAll(`[data-entry-hash="${this.state.targetHash}"]`).forEach((el) => {
        el.classList.remove("BetterNotes-linking-target");
      });
    }
    document.body.classList.remove("BetterNotes-linking-mode");
    this.state.isLinking = false;
    this.state.sourceHash = null;
    this.state.targetHash = null;
  }
  /**
   * 取消当前的链接操作
   */
  cancelLinking() {
    if (this.state.isLinking) {
      this.resetLinkingState();
      new import_obsidian29.Notice(t("linking operation cancelled"));
    }
  }
  /**
   * 创建双向链接
   * 在两个条目之间建立相互引用关系
   * @param sourceHash 源条目哈希
   * @param targetHash 目标条目哈希
   * @returns 是否成功建立链接
   */
  async createBidirectionalLink(sourceHash, targetHash) {
    try {
      const sourceEntry = this.plugin.dataManager.getEntryByHash(sourceHash);
      const targetEntry = this.plugin.dataManager.getEntryByHash(targetHash);
      if (!sourceEntry || !targetEntry) {
        new import_obsidian29.Notice(t("cannot find entry"));
        return false;
      }
      if (sourceEntry.link && sourceEntry.link.includes(targetHash)) {
        new import_obsidian29.Notice(t("link already exists"));
        return false;
      }
      const sourceLinks = sourceEntry.link || [];
      if (!sourceLinks.includes(targetHash)) {
        sourceLinks.push(targetHash);
      }
      const targetLinks = targetEntry.link || [];
      if (!targetLinks.includes(sourceHash)) {
        targetLinks.push(sourceHash);
      }
      await this.plugin.updateEntry(sourceHash, { link: sourceLinks });
      await this.plugin.updateEntry(targetHash, { link: targetLinks });
      new import_obsidian29.Notice(t("link established successfully"));
      await this.plugin.refreshViews();
      return true;
    } catch (error2) {
      console.error("\u5EFA\u7ACB\u6761\u76EE\u94FE\u63A5\u65F6\u51FA\u9519:", error2);
      new import_obsidian29.Notice(t("link establishment failed"));
      return false;
    }
  }
  /**
   * 移除双向链接
   * 删除两个条目之间的相互引用关系
   * @param sourceHash 源条目哈希
   * @param targetHash 目标条目哈希
   * @returns 是否成功移除链接
   */
  async removeBidirectionalLink(sourceHash, targetHash) {
    try {
      const sourceEntry = this.plugin.dataManager.getEntryByHash(sourceHash);
      const targetEntry = this.plugin.dataManager.getEntryByHash(targetHash);
      if (!sourceEntry || !targetEntry) {
        new import_obsidian29.Notice(t("cannot find entry"));
        return false;
      }
      const sourceLinks = (sourceEntry.link || []).filter((hash) => hash !== targetHash);
      const targetLinks = (targetEntry.link || []).filter((hash) => hash !== sourceHash);
      await this.plugin.updateEntry(sourceHash, { link: sourceLinks });
      await this.plugin.updateEntry(targetHash, { link: targetLinks });
      new import_obsidian29.Notice(t("link removed successfully"));
      await this.plugin.refreshViews();
      return true;
    } catch (error2) {
      console.error("\u79FB\u9664\u6761\u76EE\u94FE\u63A5\u65F6\u51FA\u9519:", error2);
      new import_obsidian29.Notice(t("link removal failed"));
      return false;
    }
  }
  /**
   * 获取条目的所有链接条目
   * @param entryHash 条目哈希
   * @returns 链接的条目数组
   */
  getLinkedEntries(entryHash) {
    const entry = this.plugin.dataManager.getEntryByHash(entryHash);
    if (!entry || !entry.link || entry.link.length === 0) {
      return [];
    }
    return entry.link.map((hash) => this.plugin.dataManager.getEntryByHash(hash)).filter((linkedEntry) => linkedEntry !== void 0);
  }
  /**
   * 检查当前是否处于链接模式
   * @returns 是否处于链接模式
   */
  isInLinkingMode() {
    return this.state.isLinking;
  }
  /**
   * 获取当前链接模式的源条目哈希
   * @returns 源条目哈希，如果不在链接模式则返回null
   */
  getLinkingSourceHash() {
    return this.state.isLinking ? this.state.sourceHash : null;
  }
  /**
   * 截断字符串
   * @param str 原字符串
   * @param maxLength 最大长度
   * @returns 截断后的字符串
   */
  truncateString(str, maxLength) {
    return str.length > maxLength ? str.substring(0, maxLength) + "..." : str;
  }
};

// src/main.ts
init_FSRSTypes();

// node_modules/ts-fsrs/dist/index.mjs
var u = ((a2) => (a2[a2.New = 0] = "New", a2[a2.Learning = 1] = "Learning", a2[a2.Review = 2] = "Review", a2[a2.Relearning = 3] = "Relearning", a2))(u || {});
var l = ((a2) => (a2[a2.Manual = 0] = "Manual", a2[a2.Again = 1] = "Again", a2[a2.Hard = 2] = "Hard", a2[a2.Good = 3] = "Good", a2[a2.Easy = 4] = "Easy", a2))(l || {});
var d = class {
  static card(t2) {
    return { ...t2, state: d.state(t2.state), due: d.time(t2.due), last_review: t2.last_review ? d.time(t2.last_review) : void 0 };
  }
  static rating(t2) {
    if (typeof t2 == "string") {
      const e = t2.charAt(0).toUpperCase(), i3 = t2.slice(1).toLowerCase(), s5 = l[`${e}${i3}`];
      if (s5 === void 0)
        throw new Error(`Invalid rating:[${t2}]`);
      return s5;
    } else if (typeof t2 == "number")
      return t2;
    throw new Error(`Invalid rating:[${t2}]`);
  }
  static state(t2) {
    if (typeof t2 == "string") {
      const e = t2.charAt(0).toUpperCase(), i3 = t2.slice(1).toLowerCase(), s5 = u[`${e}${i3}`];
      if (s5 === void 0)
        throw new Error(`Invalid state:[${t2}]`);
      return s5;
    } else if (typeof t2 == "number")
      return t2;
    throw new Error(`Invalid state:[${t2}]`);
  }
  static time(t2) {
    if (typeof t2 == "object" && t2 instanceof Date)
      return t2;
    if (typeof t2 == "string") {
      const e = Date.parse(t2);
      if (isNaN(e))
        throw new Error(`Invalid date:[${t2}]`);
      return new Date(e);
    } else if (typeof t2 == "number")
      return new Date(t2);
    throw new Error(`Invalid date:[${t2}]`);
  }
  static review_log(t2) {
    return { ...t2, due: d.time(t2.due), rating: d.rating(t2.rating), state: d.state(t2.state), review: d.time(t2.review) };
  }
};
Date.prototype.scheduler = function(a2, t2) {
  return m(this, a2, t2);
}, Date.prototype.diff = function(a2, t2) {
  return v(this, a2, t2);
}, Date.prototype.format = function() {
  return C(this);
}, Date.prototype.dueFormat = function(a2, t2, e) {
  return z(this, a2, t2, e);
};
function m(a2, t2, e) {
  return new Date(e ? d.time(a2).getTime() + t2 * 24 * 60 * 60 * 1e3 : d.time(a2).getTime() + t2 * 60 * 1e3);
}
function v(a2, t2, e) {
  if (!a2 || !t2)
    throw new Error("Invalid date");
  const i3 = d.time(a2).getTime() - d.time(t2).getTime();
  let s5 = 0;
  switch (e) {
    case "days":
      s5 = Math.floor(i3 / (24 * 60 * 60 * 1e3));
      break;
    case "minutes":
      s5 = Math.floor(i3 / (60 * 1e3));
      break;
  }
  return s5;
}
function C(a2) {
  const t2 = d.time(a2), e = t2.getFullYear(), i3 = t2.getMonth() + 1, s5 = t2.getDate(), r = t2.getHours(), n3 = t2.getMinutes(), o5 = t2.getSeconds();
  return `${e}-${b(i3)}-${b(s5)} ${b(r)}:${b(n3)}:${b(o5)}`;
}
function b(a2) {
  return a2 < 10 ? `0${a2}` : `${a2}`;
}
var L = [60, 60, 24, 31, 12];
var N = ["second", "min", "hour", "day", "month", "year"];
function z(a2, t2, e, i3 = N) {
  a2 = d.time(a2), t2 = d.time(t2), i3.length !== N.length && (i3 = N);
  let s5 = a2.getTime() - t2.getTime(), r;
  for (s5 /= 1e3, r = 0; r < L.length && !(s5 < L[r]); r++)
    s5 /= L[r];
  return `${Math.floor(s5)}${e ? i3[r] : ""}`;
}
var T = Object.freeze([l.Again, l.Hard, l.Good, l.Easy]);
var nt = [{ start: 2.5, end: 7, factor: 0.15 }, { start: 7, end: 20, factor: 0.1 }, { start: 20, end: 1 / 0, factor: 0.05 }];
function U(a2, t2, e) {
  let i3 = 1;
  for (const n3 of nt)
    i3 += n3.factor * Math.max(Math.min(a2, n3.end) - n3.start, 0);
  a2 = Math.min(a2, e);
  let s5 = Math.max(2, Math.round(a2 - i3));
  const r = Math.min(Math.round(a2 + i3), e);
  return a2 > t2 && (s5 = Math.max(s5, t2 + 1)), s5 = Math.min(s5, r), { min_ivl: s5, max_ivl: r };
}
function g(a2, t2, e) {
  return Math.min(Math.max(a2, t2), e);
}
function k(a2, t2) {
  const e = Date.UTC(a2.getUTCFullYear(), a2.getUTCMonth(), a2.getUTCDate()), i3 = Date.UTC(t2.getUTCFullYear(), t2.getUTCMonth(), t2.getUTCDate());
  return Math.floor((i3 - e) / 864e5);
}
var lt = "5.2.0";
var q = 0.9;
var P = 36500;
var j = false;
var O = true;
var Y = Object.freeze(["1m", "10m"]);
var W = Object.freeze(["10m"]);
var ot = `v${lt} using FSRS-6.0`;
var p = 1e-3;
var M = 100;
var $ = 0.5;
var B = 0.1542;
var D = Object.freeze([0.212, 1.2931, 2.3065, 8.2956, 6.4133, 0.8334, 3.0194, 1e-3, 1.8722, 0.1666, 0.796, 1.4835, 0.0614, 0.2629, 1.6483, 0.6014, 1.8729, 0.5425, 0.0912, 0.0658, B]);
var X = 2;
var V = (a2) => [[p, M], [p, M], [p, M], [p, M], [1, 10], [1e-3, 4], [1e-3, 4], [1e-3, 0.75], [0, 4.5], [0, 0.8], [1e-3, 3.5], [1e-3, 5], [1e-3, 0.25], [1e-3, 0.9], [0, 4], [0, 1], [1, 6], [0, a2], [0, a2], [0, 0.8], [0.1, 0.8]];
var E = (a2, t2) => {
  let e = X;
  if (Math.max(0, t2) > 1) {
    const i3 = -(Math.log(a2[11]) + Math.log(Math.pow(2, a2[13]) - 1) + a2[14] * 0.3) / t2;
    e = g(+i3.toFixed(8), 0.01, 2);
  }
  return V(e).map(([i3, s5], r) => g(a2[r], i3, s5));
};
var R = (a2) => {
  if (a2 === void 0)
    return [...D];
  switch (a2.length) {
    case 21:
      return [...a2];
    case 19:
      return console.debug("[FSRS-6]auto fill w from 19 to 21 length"), [...a2, 0, $];
    case 17: {
      const t2 = [...a2];
      return t2[4] = +(t2[5] * 2 + t2[4]).toFixed(8), t2[5] = +(Math.log(t2[5] * 3 + 1) / 3).toFixed(8), t2[6] = +(t2[6] + 0.5).toFixed(8), console.debug("[FSRS-6]auto fill w from 17 to 21 length"), t2.concat([0, 0, 0, $]);
    }
    default:
      return console.warn("[FSRS]Invalid parameters length, using default parameters"), [...D];
  }
};
var I = (a2) => {
  const t2 = Array.isArray(a2?.learning_steps) ? a2.learning_steps : Y, e = Array.isArray(a2?.relearning_steps) ? a2.relearning_steps : W, i3 = E(R(a2?.w), e.length);
  return { request_retention: a2?.request_retention || q, maximum_interval: a2?.maximum_interval || P, w: i3, enable_fuzz: a2?.enable_fuzz ?? j, enable_short_term: a2?.enable_short_term ?? O, learning_steps: t2, relearning_steps: e };
};
function F(a2, t2) {
  const e = { due: a2 ? d.time(a2) : new Date(), stability: 0, difficulty: 0, elapsed_days: 0, scheduled_days: 0, reps: 0, lapses: 0, learning_steps: 0, state: u.New, last_review: void 0 };
  return t2 && typeof t2 == "function" ? t2(e) : e;
}
var ut = class {
  constructor(t2) {
    __publicField(this, "c");
    __publicField(this, "s0");
    __publicField(this, "s1");
    __publicField(this, "s2");
    const e = ct();
    this.c = 1, this.s0 = e(" "), this.s1 = e(" "), this.s2 = e(" "), t2 == null && (t2 = +new Date()), this.s0 -= e(t2), this.s0 < 0 && (this.s0 += 1), this.s1 -= e(t2), this.s1 < 0 && (this.s1 += 1), this.s2 -= e(t2), this.s2 < 0 && (this.s2 += 1);
  }
  next() {
    const t2 = 2091639 * this.s0 + this.c * 23283064365386963e-26;
    return this.s0 = this.s1, this.s1 = this.s2, this.s2 = t2 - (this.c = t2 | 0), this.s2;
  }
  set state(t2) {
    this.c = t2.c, this.s0 = t2.s0, this.s1 = t2.s1, this.s2 = t2.s2;
  }
  get state() {
    return { c: this.c, s0: this.s0, s1: this.s1, s2: this.s2 };
  }
};
function ct() {
  let a2 = 4022871197;
  return function(t2) {
    t2 = String(t2);
    for (let e = 0; e < t2.length; e++) {
      a2 += t2.charCodeAt(e);
      let i3 = 0.02519603282416938 * a2;
      a2 = i3 >>> 0, i3 -= a2, i3 *= a2, a2 = i3 >>> 0, i3 -= a2, a2 += i3 * 4294967296;
    }
    return (a2 >>> 0) * 23283064365386963e-26;
  };
}
function _t(a2) {
  const t2 = new ut(a2), e = () => t2.next();
  return e.int32 = () => t2.next() * 4294967296 | 0, e.double = () => e() + (e() * 2097152 | 0) * 11102230246251565e-32, e.state = () => t2.state, e.importState = (i3) => (t2.state = i3, e), e;
}
var H = (a2) => {
  const t2 = typeof a2 == "number" ? -a2 : -a2[20], e = Math.exp(Math.pow(t2, -1) * Math.log(0.9)) - 1;
  return { decay: t2, factor: +e.toFixed(8) };
};
function A(a2, t2, e) {
  const { decay: i3, factor: s5 } = H(a2);
  return +Math.pow(1 + s5 * t2 / e, i3).toFixed(8);
}
var J = class {
  constructor(t2) {
    __publicField(this, "param");
    __publicField(this, "intervalModifier");
    __publicField(this, "_seed");
    __publicField(this, "forgetting_curve");
    this.param = new Proxy(I(t2), this.params_handler_proxy()), this.intervalModifier = this.calculate_interval_modifier(this.param.request_retention), this.forgetting_curve = A.bind(this, this.param.w);
  }
  get interval_modifier() {
    return this.intervalModifier;
  }
  set seed(t2) {
    this._seed = t2;
  }
  calculate_interval_modifier(t2) {
    if (t2 <= 0 || t2 > 1)
      throw new Error("Requested retention rate should be in the range (0,1]");
    const { decay: e, factor: i3 } = H(this.param.w);
    return +((Math.pow(t2, 1 / e) - 1) / i3).toFixed(8);
  }
  get parameters() {
    return this.param;
  }
  set parameters(t2) {
    this.update_parameters(t2);
  }
  params_handler_proxy() {
    const t2 = this;
    return { set: function(e, i3, s5) {
      return i3 === "request_retention" && Number.isFinite(s5) ? t2.intervalModifier = t2.calculate_interval_modifier(Number(s5)) : i3 === "w" && (s5 = E(R(s5), e.relearning_steps.length), t2.forgetting_curve = A.bind(this, s5), t2.intervalModifier = t2.calculate_interval_modifier(Number(e.request_retention))), Reflect.set(e, i3, s5), true;
    } };
  }
  update_parameters(t2) {
    const e = I(t2);
    for (const i3 in e)
      if (i3 in this.param) {
        const s5 = i3;
        this.param[s5] = e[s5];
      }
  }
  init_stability(t2) {
    return Math.max(this.param.w[t2 - 1], 0.1);
  }
  init_difficulty(t2) {
    return +(this.param.w[4] - Math.exp((t2 - 1) * this.param.w[5]) + 1).toFixed(8);
  }
  apply_fuzz(t2, e) {
    if (!this.param.enable_fuzz || t2 < 2.5)
      return Math.round(t2);
    const i3 = _t(this._seed)(), { min_ivl: s5, max_ivl: r } = U(t2, e, this.param.maximum_interval);
    return Math.floor(i3 * (r - s5 + 1) + s5);
  }
  next_interval(t2, e) {
    const i3 = Math.min(Math.max(1, Math.round(t2 * this.intervalModifier)), this.param.maximum_interval);
    return this.apply_fuzz(i3, e);
  }
  linear_damping(t2, e) {
    return +(t2 * (10 - e) / 9).toFixed(8);
  }
  next_difficulty(t2, e) {
    const i3 = -this.param.w[6] * (e - 3), s5 = t2 + this.linear_damping(i3, t2);
    return g(this.mean_reversion(this.init_difficulty(l.Easy), s5), 1, 10);
  }
  mean_reversion(t2, e) {
    return +(this.param.w[7] * t2 + (1 - this.param.w[7]) * e).toFixed(8);
  }
  next_recall_stability(t2, e, i3, s5) {
    const r = l.Hard === s5 ? this.param.w[15] : 1, n3 = l.Easy === s5 ? this.param.w[16] : 1;
    return +g(e * (1 + Math.exp(this.param.w[8]) * (11 - t2) * Math.pow(e, -this.param.w[9]) * (Math.exp((1 - i3) * this.param.w[10]) - 1) * r * n3), p, 36500).toFixed(8);
  }
  next_forget_stability(t2, e, i3) {
    return +g(this.param.w[11] * Math.pow(t2, -this.param.w[12]) * (Math.pow(e + 1, this.param.w[13]) - 1) * Math.exp((1 - i3) * this.param.w[14]), p, 36500).toFixed(8);
  }
  next_short_term_stability(t2, e) {
    const i3 = Math.pow(t2, -this.param.w[19]) * Math.exp(this.param.w[17] * (e - 3 + this.param.w[18])), s5 = e >= 3 ? Math.max(i3, 1) : i3;
    return +g(t2 * s5, p, 36500).toFixed(8);
  }
  next_state(t2, e, i3) {
    const { difficulty: s5, stability: r } = t2 ?? { difficulty: 0, stability: 0 };
    if (e < 0)
      throw new Error(`Invalid delta_t "${e}"`);
    if (i3 < 0 || i3 > 4)
      throw new Error(`Invalid grade "${i3}"`);
    if (s5 === 0 && r === 0)
      return { difficulty: g(this.init_difficulty(i3), 1, 10), stability: this.init_stability(i3) };
    if (i3 === 0)
      return { difficulty: s5, stability: r };
    if (s5 < 1 || r < p)
      throw new Error(`Invalid memory state { difficulty: ${s5}, stability: ${r} }`);
    const n3 = this.forgetting_curve(e, r), o5 = this.next_recall_stability(s5, r, n3, i3), h3 = this.next_forget_stability(s5, r, n3), c2 = this.next_short_term_stability(r, i3);
    let _3 = o5;
    if (i3 === 1) {
      let [y4, w6] = [0, 0];
      this.param.enable_short_term && (y4 = this.param.w[17], w6 = this.param.w[18]);
      const f3 = r / Math.exp(y4 * w6);
      _3 = g(+f3.toFixed(8), p, h3);
    }
    return e === 0 && this.param.enable_short_term && (_3 = c2), { difficulty: this.next_difficulty(s5, i3), stability: _3 };
  }
};
function K() {
  const a2 = this.review_time.getTime(), t2 = this.current.reps, e = this.current.difficulty * this.current.stability;
  return `${a2}_${t2}_${e}`;
}
var Q = (a2) => {
  const t2 = a2.slice(-1), e = parseInt(a2.slice(0, -1), 10);
  if (isNaN(e) || !Number.isFinite(e) || e < 0)
    throw new Error(`Invalid step value: ${a2}`);
  switch (t2) {
    case "m":
      return e;
    case "h":
      return e * 60;
    case "d":
      return e * 1440;
    default:
      throw new Error(`Invalid step unit: ${a2}, expected m/h/d`);
  }
};
var Z = (a2, t2, e) => {
  const i3 = t2 === u.Relearning || t2 === u.Review ? a2.relearning_steps : a2.learning_steps, s5 = i3.length;
  if (s5 === 0 || e >= s5)
    return {};
  const r = i3[0], n3 = Q, o5 = () => n3(r), h3 = () => {
    if (s5 === 1)
      return Math.round(n3(r) * 1.5);
    const f3 = i3[1];
    return Math.round((n3(r) + n3(f3)) / 2);
  }, c2 = (f3) => f3 < 0 || f3 >= s5 ? null : i3[f3], _3 = (f3) => n3(f3), y4 = {}, w6 = c2(Math.max(0, e));
  if (t2 === u.Review)
    return y4[l.Again] = { scheduled_minutes: n3(w6), next_step: 0 }, y4;
  {
    y4[l.Again] = { scheduled_minutes: o5(), next_step: 0 }, y4[l.Hard] = { scheduled_minutes: h3(), next_step: e };
    const f3 = c2(e + 1);
    if (f3) {
      const x4 = _3(f3);
      x4 && (y4[l.Good] = { scheduled_minutes: Math.round(x4), next_step: e + 1 });
    }
  }
  return y4;
};
var S = ((a2) => (a2.SCHEDULER = "Scheduler", a2.LEARNING_STEPS = "LearningSteps", a2.SEED = "Seed", a2))(S || {});
var G = class {
  constructor(t2, e, i3, s5) {
    __publicField(this, "last");
    __publicField(this, "current");
    __publicField(this, "review_time");
    __publicField(this, "next", /* @__PURE__ */ new Map());
    __publicField(this, "algorithm");
    __publicField(this, "strategies");
    __publicField(this, "elapsed_days", 0);
    this.algorithm = i3, this.last = d.card(t2), this.current = d.card(t2), this.review_time = d.time(e), this.strategies = s5, this.init();
  }
  checkGrade(t2) {
    if (!Number.isFinite(t2) || t2 < 0 || t2 > 4)
      throw new Error(`Invalid grade "${t2}",expected 1-4`);
  }
  init() {
    const { state: t2, last_review: e } = this.current;
    let i3 = 0;
    t2 !== u.New && e && (i3 = k(e, this.review_time)), this.current.last_review = this.review_time, this.elapsed_days = i3, this.current.elapsed_days = i3, this.current.reps += 1;
    let s5 = K;
    if (this.strategies) {
      const r = this.strategies.get(S.SEED);
      r && (s5 = r);
    }
    this.algorithm.seed = s5.call(this);
  }
  preview() {
    return { [l.Again]: this.review(l.Again), [l.Hard]: this.review(l.Hard), [l.Good]: this.review(l.Good), [l.Easy]: this.review(l.Easy), [Symbol.iterator]: this.previewIterator.bind(this) };
  }
  *previewIterator() {
    for (const t2 of T)
      yield this.review(t2);
  }
  review(t2) {
    const { state: e } = this.last;
    let i3;
    switch (this.checkGrade(t2), e) {
      case u.New:
        i3 = this.newState(t2);
        break;
      case u.Learning:
      case u.Relearning:
        i3 = this.learningState(t2);
        break;
      case u.Review:
        i3 = this.reviewState(t2);
        break;
    }
    return i3;
  }
  buildLog(t2) {
    const { last_review: e, due: i3, elapsed_days: s5 } = this.last;
    return { rating: t2, state: this.current.state, due: e || i3, stability: this.current.stability, difficulty: this.current.difficulty, elapsed_days: this.elapsed_days, last_elapsed_days: s5, scheduled_days: this.current.scheduled_days, learning_steps: this.current.learning_steps, review: this.review_time };
  }
};
var tt = class extends G {
  constructor(t2, e, i3, s5) {
    super(t2, e, i3, s5);
    __publicField(this, "learningStepsStrategy");
    let r = Z;
    if (this.strategies) {
      const n3 = this.strategies.get(S.LEARNING_STEPS);
      n3 && (r = n3);
    }
    this.learningStepsStrategy = r;
  }
  getLearningInfo(t2, e) {
    const i3 = this.algorithm.parameters;
    t2.learning_steps = t2.learning_steps || 0;
    const s5 = this.learningStepsStrategy(i3, t2.state, this.current.state === u.Learning ? t2.learning_steps + 1 : t2.learning_steps), r = Math.max(0, s5[e]?.scheduled_minutes ?? 0), n3 = Math.max(0, s5[e]?.next_step ?? 0);
    return { scheduled_minutes: r, next_steps: n3 };
  }
  applyLearningSteps(t2, e, i3) {
    const { scheduled_minutes: s5, next_steps: r } = this.getLearningInfo(this.current, e);
    if (s5 > 0 && s5 < 1440)
      t2.learning_steps = r, t2.scheduled_days = 0, t2.state = i3, t2.due = m(this.review_time, Math.round(s5), false);
    else if (t2.state = u.Review, s5 >= 1440)
      t2.learning_steps = r, t2.due = m(this.review_time, Math.round(s5), false), t2.scheduled_days = Math.floor(s5 / 1440);
    else {
      t2.learning_steps = 0;
      const n3 = this.algorithm.next_interval(t2.stability, this.elapsed_days);
      t2.scheduled_days = n3, t2.due = m(this.review_time, n3, true);
    }
  }
  newState(t2) {
    const e = this.next.get(t2);
    if (e)
      return e;
    const i3 = d.card(this.current);
    i3.difficulty = g(this.algorithm.init_difficulty(t2), 1, 10), i3.stability = this.algorithm.init_stability(t2), this.applyLearningSteps(i3, t2, u.Learning);
    const s5 = { card: i3, log: this.buildLog(t2) };
    return this.next.set(t2, s5), s5;
  }
  learningState(t2) {
    const e = this.next.get(t2);
    if (e)
      return e;
    const { state: i3, difficulty: s5, stability: r } = this.last, n3 = d.card(this.current);
    n3.difficulty = this.algorithm.next_difficulty(s5, t2), n3.stability = this.algorithm.next_short_term_stability(r, t2), this.applyLearningSteps(n3, t2, i3);
    const o5 = { card: n3, log: this.buildLog(t2) };
    return this.next.set(t2, o5), o5;
  }
  reviewState(t2) {
    const e = this.next.get(t2);
    if (e)
      return e;
    const i3 = this.elapsed_days, { difficulty: s5, stability: r } = this.last, n3 = this.algorithm.forgetting_curve(i3, r), o5 = d.card(this.current), h3 = d.card(this.current), c2 = d.card(this.current), _3 = d.card(this.current);
    this.next_ds(o5, h3, c2, _3, s5, r, n3), this.next_interval(h3, c2, _3, i3), this.next_state(h3, c2, _3), this.applyLearningSteps(o5, l.Again, u.Relearning), o5.lapses += 1;
    const y4 = { card: o5, log: this.buildLog(l.Again) }, w6 = { card: h3, log: super.buildLog(l.Hard) }, f3 = { card: c2, log: super.buildLog(l.Good) }, x4 = { card: _3, log: super.buildLog(l.Easy) };
    return this.next.set(l.Again, y4), this.next.set(l.Hard, w6), this.next.set(l.Good, f3), this.next.set(l.Easy, x4), this.next.get(t2);
  }
  next_ds(t2, e, i3, s5, r, n3, o5) {
    t2.difficulty = this.algorithm.next_difficulty(r, l.Again);
    const h3 = n3 / Math.exp(this.algorithm.parameters.w[17] * this.algorithm.parameters.w[18]), c2 = this.algorithm.next_forget_stability(r, n3, o5);
    t2.stability = g(+h3.toFixed(8), p, c2), e.difficulty = this.algorithm.next_difficulty(r, l.Hard), e.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Hard), i3.difficulty = this.algorithm.next_difficulty(r, l.Good), i3.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Good), s5.difficulty = this.algorithm.next_difficulty(r, l.Easy), s5.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Easy);
  }
  next_interval(t2, e, i3, s5) {
    let r, n3;
    r = this.algorithm.next_interval(t2.stability, s5), n3 = this.algorithm.next_interval(e.stability, s5), r = Math.min(r, n3), n3 = Math.max(n3, r + 1);
    const o5 = Math.max(this.algorithm.next_interval(i3.stability, s5), n3 + 1);
    t2.scheduled_days = r, t2.due = m(this.review_time, r, true), e.scheduled_days = n3, e.due = m(this.review_time, n3, true), i3.scheduled_days = o5, i3.due = m(this.review_time, o5, true);
  }
  next_state(t2, e, i3) {
    t2.state = u.Review, t2.learning_steps = 0, e.state = u.Review, e.learning_steps = 0, i3.state = u.Review, i3.learning_steps = 0;
  }
};
var et = class extends G {
  newState(t2) {
    const e = this.next.get(t2);
    if (e)
      return e;
    this.current.scheduled_days = 0, this.current.elapsed_days = 0;
    const i3 = d.card(this.current), s5 = d.card(this.current), r = d.card(this.current), n3 = d.card(this.current);
    return this.init_ds(i3, s5, r, n3), this.next_interval(i3, s5, r, n3, 0), this.next_state(i3, s5, r, n3), this.update_next(i3, s5, r, n3), this.next.get(t2);
  }
  init_ds(t2, e, i3, s5) {
    t2.difficulty = g(this.algorithm.init_difficulty(l.Again), 1, 10), t2.stability = this.algorithm.init_stability(l.Again), e.difficulty = g(this.algorithm.init_difficulty(l.Hard), 1, 10), e.stability = this.algorithm.init_stability(l.Hard), i3.difficulty = g(this.algorithm.init_difficulty(l.Good), 1, 10), i3.stability = this.algorithm.init_stability(l.Good), s5.difficulty = g(this.algorithm.init_difficulty(l.Easy), 1, 10), s5.stability = this.algorithm.init_stability(l.Easy);
  }
  learningState(t2) {
    return this.reviewState(t2);
  }
  reviewState(t2) {
    const e = this.next.get(t2);
    if (e)
      return e;
    const i3 = this.elapsed_days, { difficulty: s5, stability: r } = this.last, n3 = this.algorithm.forgetting_curve(i3, r), o5 = d.card(this.current), h3 = d.card(this.current), c2 = d.card(this.current), _3 = d.card(this.current);
    return this.next_ds(o5, h3, c2, _3, s5, r, n3), this.next_interval(o5, h3, c2, _3, i3), this.next_state(o5, h3, c2, _3), o5.lapses += 1, this.update_next(o5, h3, c2, _3), this.next.get(t2);
  }
  next_ds(t2, e, i3, s5, r, n3, o5) {
    t2.difficulty = this.algorithm.next_difficulty(r, l.Again);
    const h3 = this.algorithm.next_forget_stability(r, n3, o5);
    t2.stability = g(n3, p, h3), e.difficulty = this.algorithm.next_difficulty(r, l.Hard), e.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Hard), i3.difficulty = this.algorithm.next_difficulty(r, l.Good), i3.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Good), s5.difficulty = this.algorithm.next_difficulty(r, l.Easy), s5.stability = this.algorithm.next_recall_stability(r, n3, o5, l.Easy);
  }
  next_interval(t2, e, i3, s5, r) {
    let n3, o5, h3, c2;
    n3 = this.algorithm.next_interval(t2.stability, r), o5 = this.algorithm.next_interval(e.stability, r), h3 = this.algorithm.next_interval(i3.stability, r), c2 = this.algorithm.next_interval(s5.stability, r), n3 = Math.min(n3, o5), o5 = Math.max(o5, n3 + 1), h3 = Math.max(h3, o5 + 1), c2 = Math.max(c2, h3 + 1), t2.scheduled_days = n3, t2.due = m(this.review_time, n3, true), e.scheduled_days = o5, e.due = m(this.review_time, o5, true), i3.scheduled_days = h3, i3.due = m(this.review_time, h3, true), s5.scheduled_days = c2, s5.due = m(this.review_time, c2, true);
  }
  next_state(t2, e, i3, s5) {
    t2.state = u.Review, t2.learning_steps = 0, e.state = u.Review, e.learning_steps = 0, i3.state = u.Review, i3.learning_steps = 0, s5.state = u.Review, s5.learning_steps = 0;
  }
  update_next(t2, e, i3, s5) {
    const r = { card: t2, log: this.buildLog(l.Again) }, n3 = { card: e, log: super.buildLog(l.Hard) }, o5 = { card: i3, log: super.buildLog(l.Good) }, h3 = { card: s5, log: super.buildLog(l.Easy) };
    this.next.set(l.Again, r), this.next.set(l.Hard, n3), this.next.set(l.Good, o5), this.next.set(l.Easy, h3);
  }
};
var gt = class {
  constructor(t2) {
    __publicField(this, "fsrs");
    this.fsrs = t2;
  }
  replay(t2, e, i3) {
    return this.fsrs.next(t2, e, i3);
  }
  handleManualRating(t2, e, i3, s5, r, n3, o5) {
    if (typeof e > "u")
      throw new Error("reschedule: state is required for manual rating");
    let h3, c2;
    if (e === u.New)
      h3 = { rating: l.Manual, state: e, due: o5 ?? i3, stability: t2.stability, difficulty: t2.difficulty, elapsed_days: s5, last_elapsed_days: t2.elapsed_days, scheduled_days: t2.scheduled_days, learning_steps: t2.learning_steps, review: i3 }, c2 = F(i3), c2.last_review = i3;
    else {
      if (typeof o5 > "u")
        throw new Error("reschedule: due is required for manual rating");
      const _3 = v(o5, i3, "days");
      h3 = { rating: l.Manual, state: t2.state, due: t2.last_review || t2.due, stability: t2.stability, difficulty: t2.difficulty, elapsed_days: s5, last_elapsed_days: t2.elapsed_days, scheduled_days: t2.scheduled_days, learning_steps: t2.learning_steps, review: i3 }, c2 = { ...t2, state: e, due: o5, last_review: i3, stability: r || t2.stability, difficulty: n3 || t2.difficulty, elapsed_days: s5, scheduled_days: _3, reps: t2.reps + 1 };
    }
    return { card: c2, log: h3 };
  }
  reschedule(t2, e) {
    const i3 = [];
    let s5 = F(t2.due);
    for (const r of e) {
      let n3;
      if (r.review = d.time(r.review), r.rating === l.Manual) {
        let o5 = 0;
        s5.state !== u.New && s5.last_review && (o5 = v(r.review, s5.last_review, "days")), n3 = this.handleManualRating(s5, r.state, r.review, o5, r.stability, r.difficulty, r.due ? d.time(r.due) : void 0);
      } else
        n3 = this.replay(s5, r.review, r.rating);
      i3.push(n3), s5 = n3.card;
    }
    return i3;
  }
  calculateManualRecord(t2, e, i3, s5) {
    if (!i3)
      return null;
    const { card: r, log: n3 } = i3, o5 = d.card(t2);
    return o5.due.getTime() === r.due.getTime() ? null : (o5.scheduled_days = v(r.due, o5.due, "days"), this.handleManualRating(o5, r.state, d.time(e), n3.elapsed_days, s5 ? r.stability : void 0, s5 ? r.difficulty : void 0, r.due));
  }
};
var it = class extends J {
  constructor(t2) {
    super(t2);
    __publicField(this, "strategyHandler", /* @__PURE__ */ new Map());
    __publicField(this, "Scheduler");
    const { enable_short_term: e } = this.parameters;
    this.Scheduler = e ? tt : et;
  }
  params_handler_proxy() {
    const t2 = this;
    return { set: function(e, i3, s5) {
      return i3 === "request_retention" && Number.isFinite(s5) ? t2.intervalModifier = t2.calculate_interval_modifier(Number(s5)) : i3 === "enable_short_term" ? t2.Scheduler = s5 === true ? tt : et : i3 === "w" && (s5 = E(R(s5), e.relearning_steps.length), t2.forgetting_curve = A.bind(this, s5), t2.intervalModifier = t2.calculate_interval_modifier(Number(e.request_retention))), Reflect.set(e, i3, s5), true;
    } };
  }
  useStrategy(t2, e) {
    return this.strategyHandler.set(t2, e), this;
  }
  clearStrategy(t2) {
    return t2 ? this.strategyHandler.delete(t2) : this.strategyHandler.clear(), this;
  }
  getScheduler(t2, e) {
    const i3 = this.strategyHandler.get(S.SCHEDULER) || this.Scheduler;
    return new i3(t2, e, this, this.strategyHandler);
  }
  repeat(t2, e, i3) {
    const s5 = this.getScheduler(t2, e).preview();
    return i3 && typeof i3 == "function" ? i3(s5) : s5;
  }
  next(t2, e, i3, s5) {
    const r = this.getScheduler(t2, e), n3 = d.rating(i3);
    if (n3 === l.Manual)
      throw new Error("Cannot review a manual rating");
    const o5 = r.review(n3);
    return s5 && typeof s5 == "function" ? s5(o5) : o5;
  }
  get_retrievability(t2, e, i3 = true) {
    const s5 = d.card(t2);
    e = e ? d.time(e) : new Date();
    const r = s5.state !== u.New ? Math.max(v(e, s5.last_review, "days"), 0) : 0, n3 = s5.state !== u.New ? this.forgetting_curve(r, +s5.stability.toFixed(8)) : 0;
    return i3 ? `${(n3 * 100).toFixed(2)}%` : n3;
  }
  rollback(t2, e, i3) {
    const s5 = d.card(t2), r = d.review_log(e);
    if (r.rating === l.Manual)
      throw new Error("Cannot rollback a manual rating");
    let n3, o5, h3;
    switch (r.state) {
      case u.New:
        n3 = r.due, o5 = void 0, h3 = 0;
        break;
      case u.Learning:
      case u.Relearning:
      case u.Review:
        n3 = r.review, o5 = r.due, h3 = s5.lapses - (r.rating === l.Again && r.state === u.Review ? 1 : 0);
        break;
    }
    const c2 = { ...s5, due: n3, stability: r.stability, difficulty: r.difficulty, elapsed_days: r.last_elapsed_days, scheduled_days: r.scheduled_days, reps: Math.max(0, s5.reps - 1), lapses: Math.max(0, h3), learning_steps: r.learning_steps, state: r.state, last_review: o5 };
    return i3 && typeof i3 == "function" ? i3(c2) : c2;
  }
  forget(t2, e, i3 = false, s5) {
    const r = d.card(t2);
    e = d.time(e);
    const n3 = r.state === u.New ? 0 : v(e, r.due, "days"), o5 = { rating: l.Manual, state: r.state, due: r.due, stability: r.stability, difficulty: r.difficulty, elapsed_days: 0, last_elapsed_days: r.elapsed_days, scheduled_days: n3, learning_steps: r.learning_steps, review: e }, h3 = { card: { ...r, due: e, stability: 0, difficulty: 0, elapsed_days: 0, scheduled_days: 0, reps: i3 ? 0 : r.reps, lapses: i3 ? 0 : r.lapses, learning_steps: 0, state: u.New, last_review: r.last_review }, log: o5 };
    return s5 && typeof s5 == "function" ? s5(h3) : h3;
  }
  reschedule(t2, e = [], i3 = {}) {
    const { recordLogHandler: s5, reviewsOrderBy: r, skipManual: n3 = true, now: o5 = new Date(), update_memory_state: h3 = false } = i3;
    r && typeof r == "function" && e.sort(r), n3 && (e = e.filter((x4) => x4.rating !== l.Manual));
    const c2 = new gt(this), _3 = c2.reschedule(i3.first_card || F(), e), y4 = _3.length, w6 = d.card(t2), f3 = c2.calculateManualRecord(w6, o5, y4 ? _3[y4 - 1] : void 0, h3);
    return s5 && typeof s5 == "function" ? { collections: _3.map(s5), reschedule_item: f3 ? s5(f3) : null } : { collections: _3, reschedule_item: f3 };
  }
};
var yt = (a2) => new it(a2 || {});

// src/services/fsrs/FSRSAdapter.ts
init_FSRSTypes();
var FSRSAdapter = class {
  constructor(custom = {}) {
    this.params = this.convertParams(custom);
    this.fsrsInstance = yt(this.params);
  }
  convertParams(custom) {
    return I({
      request_retention: custom.request_retention ?? 0.9,
      maximum_interval: custom.maximum_interval ?? 36500,
      enable_fuzz: true,
      enable_short_term: true,
      w: custom.w && custom.w.length ? custom.w : []
    });
  }
  toTsCard(card) {
    if (!card.lastReview) {
      const now = new Date(card.nextReview || Date.now());
      return F(now);
    }
    let state = u.New;
    if (card.reviews > 0)
      state = card.lapses > 0 ? u.Relearning : u.Review;
    const elapsed = card.lastReview ? (Date.now() - card.lastReview) / 864e5 : 0;
    const sched = card.lastReview ? (card.nextReview - card.lastReview) / 864e5 : 0;
    return {
      due: new Date(card.nextReview),
      stability: card.stability,
      difficulty: card.difficulty,
      elapsed_days: elapsed,
      scheduled_days: sched,
      reps: card.reviews,
      lapses: card.lapses,
      state,
      last_review: card.lastReview ? new Date(card.lastReview) : void 0,
      learning_steps: 0
    };
  }
  convertRating(r) {
    switch (r) {
      case FSRS_RATING.AGAIN:
        return l.Again;
      case FSRS_RATING.HARD:
        return l.Hard;
      case FSRS_RATING.GOOD:
        return l.Good;
      case FSRS_RATING.EASY:
        return l.Easy;
      default:
        return l.Good;
    }
  }
  fromTs(cardOld, res) {
    const { card, log } = res;
    return {
      ...cardOld,
      difficulty: card.difficulty,
      stability: card.stability,
      lastReview: log.review.getTime(),
      nextReview: card.due.getTime(),
      reviews: card.reps,
      lapses: card.lapses
    };
  }
  initializeCard() {
    const now = Date.now();
    const empty = F(new Date(now));
    return {
      difficulty: empty.difficulty,
      stability: empty.stability,
      lastReview: 0,
      nextReview: now,
      reviews: 0,
      lapses: 0
    };
  }
  review(cardState, rating) {
    const tsCard = this.toTsCard(cardState);
    const result = this.fsrsInstance.next(tsCard, new Date(), this.convertRating(rating));
    return this.fromTs(cardState, result);
  }
  predict(cardState) {
    const tsCard = this.toTsCard(cardState);
    const rec = this.fsrsInstance.repeat(tsCard, new Date());
    return rec;
  }
  isDue(card) {
    return Date.now() >= card.nextReview;
  }
  updateParams(p5) {
    this.params = this.convertParams(p5);
    this.fsrsInstance = yt(this.params);
  }
};

// src/services/fsrs/FSRSService.ts
init_FSRSTypes();
var FSRSService = class {
  constructor(params = {}) {
    this.params = { ...DEFAULT_FSRS_PARAMETERS, ...params };
    this.adapter = new FSRSAdapter(this.params);
  }
  initializeCard() {
    return this.adapter.initializeCard();
  }
  review(card, rating) {
    return this.adapter.review(card, rating);
  }
  isDue(card) {
    return this.adapter.isDue(card);
  }
  setParameters(p5) {
    this.params = { ...this.params, ...p5 };
    this.adapter.updateParams(this.params);
  }
  getParameters() {
    return { ...this.params };
  }
};

// src/services/AiChatService.ts
var import_obsidian30 = require("obsidian");
var AiChatService = class {
  constructor(cfg) {
    this.cfg = { ...cfg };
  }
  /**
   * 用户保存设置后调用，刷新配置。
   */
  updateConfig(cfg) {
    this.cfg = { ...cfg };
  }
  /**
   * 测试连通性：
   * 1. 拼接 `baseUrl` + `/v1/models`；
   * 2. 附带 `Authorization: Bearer <apiKey>` 头调用；
   * 3. 将返回的模型列表以 Notice 提示，并以数组形式返回。
   */
  async testConnection() {
    if (!this.cfg.enabled) {
      throw new Error("AI \u670D\u52A1\u672A\u542F\u7528");
    }
    if (!this.cfg.baseUrl || !this.cfg.apiKey) {
      throw new Error("AI \u914D\u7F6E\u4E0D\u5B8C\u6574");
    }
    const base = this.cfg.baseUrl.replace(/\/$/, "");
    const url = base.endsWith("/v1") ? `${base}/models` : `${base}/v1/models`;
    const response = await (0, import_obsidian30.requestUrl)({
      url,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.cfg.apiKey}`,
        "Content-Type": "application/json"
      }
    });
    if (response.status !== 200) {
      throw new Error(`\u8BF7\u6C42\u5931\u8D25\uFF0C\u72B6\u6001\u7801\uFF1A${response.status}`);
    }
    const list = (response.json?.data || []).map((m5) => m5.id);
    new import_obsidian30.Notice(`${list.join(", ")}`);
    return list;
  }
  /**
   * 发送 Chat Completion 请求。
   * @param messages   消息历史，需符合 OpenAI Chat schema
   * @param tools      （可选）工具 schema，用于 Function Calling
   * @returns          Assistant 返回的消息对象（包含 content / tool_calls)
   */
  async chat(messages, tools) {
    if (!this.cfg.enabled) {
      throw new Error("AI \u670D\u52A1\u672A\u542F\u7528");
    }
    if (!this.cfg.baseUrl || !this.cfg.apiKey) {
      throw new Error("AI \u914D\u7F6E\u4E0D\u5B8C\u6574");
    }
    const base = this.cfg.baseUrl.replace(/\/$/, "");
    const url = base.endsWith("/v1") ? `${base}/chat/completions` : `${base}/v1/chat/completions`;
    const body2 = {
      model: this.cfg.model,
      messages
    };
    if (tools && tools.length) {
      body2.tools = tools;
      body2.tool_choice = "auto";
    }
    const response = await (0, import_obsidian30.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.cfg.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body2)
    });
    if (response.status !== 200) {
      throw new Error(`\u8BF7\u6C42\u5931\u8D25\uFF0C\u72B6\u6001\u7801\uFF1A${response.status}`);
    }
    const resJson = response.json;
    const assistantMsg = resJson?.choices?.[0]?.message;
    if (!assistantMsg) {
      throw new Error("AI \u54CD\u5E94\u4E3A\u7A7A");
    }
    return assistantMsg;
  }
};

// src/utils/cryptoUtils.ts
function base64ToBytes(b64) {
  const binary2 = atob(b64);
  const len = binary2.length;
  const bytes = new Uint8Array(len);
  for (let i3 = 0; i3 < len; i3++)
    bytes[i3] = binary2.charCodeAt(i3);
  return bytes;
}

// src/utils/license.ts
async function deriveKeyFromCode(code) {
  const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(code));
  return crypto.subtle.importKey("raw", hash, { name: "AES-GCM" }, false, ["decrypt"]);
}
async function decryptLicense(licenseB64, code) {
  if (!licenseB64 || !code)
    return null;
  try {
    const raw = base64ToBytes(licenseB64.trim());
    if (raw.length < 28)
      throw new Error("License \u957F\u5EA6\u4E0D\u8DB3");
    const iv = raw.slice(0, 12);
    const cipherAndTag = raw.slice(12);
    const key = await deriveKeyFromCode(code.trim());
    const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherAndTag);
    return new TextDecoder().decode(plainBuf);
  } catch (e) {
    console.error("[BetterNotes] License \u89E3\u5BC6\u5931\u8D25:", e);
    return null;
  }
}
async function verifyLicense(licenseB64, code, vaultPath) {
  const plain = await decryptLicense(licenseB64, code);
  return plain === vaultPath;
}

// src/services/AI/AiChatView.ts
var import_obsidian32 = require("obsidian");

// src/services/AI/AiChatMessage.ts
var import_obsidian31 = require("obsidian");
init_i18n();
var AiChatMessage = class {
  /**
   * 构造函数
   * @param container 消息容器元素
   * @param content 消息内容
   * @param direction 消息方向
   */
  constructor(container, content, direction, plugin, chips) {
    this.element = null;
    this.isStreaming = false;
    this.container = container;
    this.content = content;
    this.direction = direction;
    this.plugin = plugin;
    this.chips = chips;
  }
  /**
   * 渲染消息到容器中
   */
  render() {
    this.element = this.container.createDiv({
      cls: `BetterNotes-ai-chat-message ${this.direction}`
    });
    if (this.chips && this.chips.length) {
      const chipWrap = this.element.createDiv({ cls: "sn-bubble-chip-wrap" });
      chipWrap.style.display = "flex";
      chipWrap.style.flexWrap = "wrap";
      chipWrap.style.gap = "4px";
      this.chips.forEach((c2) => {
        const chipEl = chipWrap.createDiv("sn-bubble-chip");
        chipEl.setText(c2.label);
      });
    }
    const contentEl = this.element.createDiv({ cls: "BetterNotes-ai-message-content" });
    import_obsidian31.MarkdownRenderer.renderMarkdown(this.content, contentEl, "", this.plugin);
    this.bindInternalLinkClicks(contentEl);
    const copyBtn = this.element.createEl("button", {
      cls: "sn-bubble-copy-btn",
      attr: { "aria-label": "\u590D\u5236" }
    });
    copyBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M16 1H4a2 2 0 0 0-2 2v14h2V3h12V1zm3 4H8a2 2 0 0 0-2 2v16h13a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zm0 18H8V7h11v16z"></path></svg>';
    copyBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        await navigator.clipboard.writeText(this.content);
      } catch (err2) {
        console.error("\u590D\u5236\u5931\u8D25", err2);
        new import_obsidian31.Notice(t("copy failed"));
      }
    });
  }
  /**
   * 更新消息内容
   * @param newContent 新的消息内容
   */
  updateContent(newContent) {
    this.content = newContent;
    if (this.element) {
      const contentEl = this.element.querySelector(".BetterNotes-ai-message-content");
      if (contentEl) {
        contentEl.empty();
        import_obsidian31.MarkdownRenderer.renderMarkdown(this.content, contentEl, "", this.plugin);
        this.bindInternalLinkClicks(contentEl);
      }
    }
  }
  /**
   * 从DOM中移除消息
   */
  remove() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }
  /**
   * 绑定 internal-link 链接点击事件，确保在自定义容器中也能跳转。
   */
  bindInternalLinkClicks(scope) {
    const anchors = scope.querySelectorAll("a.internal-link");
    anchors.forEach((anchorEl) => {
      anchorEl.addEventListener("click", (ev) => {
        ev.preventDefault();
        const a2 = anchorEl;
        const href = (a2.getAttribute("href") || a2.dataset?.href || "").trim();
        if (!href)
          return;
        this.plugin.app.workspace.openLinkText(href, "/", false);
      });
    });
  }
};

// src/services/AI/ChatSessionManager.ts
var genId = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
var ChatSession = class {
  constructor(options = {}) {
    /** 消息数组，最新消息追加在末尾 */
    this.messages = [];
    this.id = genId();
    this.createdAt = Date.now();
    this.updatedAt = this.createdAt;
    this.tokenBudget = options.tokenBudget ?? 12e3;
    if (options.systemPrompt) {
      this.messages.push({ role: "system", content: options.systemPrompt });
    }
  }
  /**
   * 追加一条新消息并刷新更新时间。
   */
  addMessage(msg) {
    this.messages.push(msg);
    this.updatedAt = Date.now();
  }
  /**
   * 获取当前全部消息。
   */
  getHistory() {
    return [...this.messages];
  }
  /**
   * 清空上下文，仅保留可选的 system prompt。
   */
  clear() {
    const systemPrompt = this.messages.find((m5) => m5.role === "system");
    this.messages.length = 0;
    if (systemPrompt)
      this.messages.push(systemPrompt);
    this.updatedAt = Date.now();
  }
};
var ChatSessionManager = class {
  constructor(systemPrompt) {
    this.session = new ChatSession({ systemPrompt });
  }
  addUserMessage(content) {
    this.session.addMessage({ role: "user", content });
  }
  addAssistantMessage(content) {
    this.session.addMessage({ role: "assistant", content });
  }
  addToolMessage(name2, content, tool_call_id) {
    this.session.addMessage({ role: "tool", name: name2, content, tool_call_id });
  }
  /**
   * 直接写入一条自定义消息（用于复杂结构如 assistant tool_calls）。
   */
  addRawMessage(msg) {
    this.session.addMessage(msg);
  }
  history() {
    return this.session.getHistory();
  }
  reset() {
    this.session.clear();
  }
};

// src/services/AI/MentionMenu.ts
var MentionMenu = class {
  constructor(container, onSelect) {
    // 输入框所在容器 (用于定位)
    this.menuEl = null;
    this.items = [];
    this.currentIndex = 0;
    this.container = container;
    this.onSelect = onSelect;
  }
  /**
   * 显示菜单。会在输入框左上角对齐。
   * @param items 列表项
   */
  show(items) {
    this.items = items;
    this.currentIndex = 0;
    if (!this.menuEl) {
      this.createMenu();
    }
    this.renderItems();
    this.menuEl.style.display = "block";
  }
  /** 隐藏菜单 */
  hide() {
    if (this.menuEl) {
      this.menuEl.style.display = "none";
    }
  }
  /** 销毁 */
  destroy() {
    this.menuEl?.remove();
    this.menuEl = null;
  }
  createMenu() {
    this.menuEl = this.container.createDiv("sn-mention-menu");
    this.menuEl.style.position = "absolute";
    this.menuEl.style.left = "0";
    this.menuEl.style.top = "0";
    this.menuEl.style.zIndex = "9999";
    this.menuEl.style.transform = "translateY(-100%)";
  }
  renderItems() {
    if (!this.menuEl)
      return;
    this.menuEl.empty();
    this.items.forEach((item, idx) => {
      const el = this.menuEl.createDiv("sn-mention-item");
      el.setText(item.label);
      if (idx === this.currentIndex)
        el.addClass("selected");
      el.addEventListener("mousedown", (ev) => {
        ev.preventDefault();
        this.onSelect(item);
        this.hide();
      });
    });
  }
  isVisible() {
    return !!this.menuEl && this.menuEl.style.display !== "none";
  }
  move(delta) {
    if (!this.isVisible())
      return;
    const len = this.items.length;
    this.currentIndex = (this.currentIndex + delta + len) % len;
    this.renderItems();
  }
  choose() {
    if (!this.isVisible())
      return;
    const item = this.items[this.currentIndex];
    if (item) {
      this.onSelect(item);
    }
    this.hide();
  }
  /**
   * 获取当前高亮项
   */
  getCurrentItem() {
    return this.items[this.currentIndex];
  }
};

// src/services/AI/AiChatView.ts
init_i18n();
var AI_CHAT_VIEW_TYPE = "BetterNotes-ai-chat-view";
var AiChatView = class extends import_obsidian32.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.selectedSet = /* @__PURE__ */ new Map();
    this.slashActive = false;
    /**
     * 发送锁：在上一次 sendMessage 未完成（等待 AI 回复）时，禁止再次发送，
     * 防止用户连续按 Enter 导致重复消息。
     */
    this.isSending = false;
    // 添加等待条容器引用
    this.loadingBar = null;
    this.plugin = plugin;
  }
  insertChipFromLabel(label) {
  }
  addEntryChip(hash) {
  }
  addSetChip(setName) {
  }
  addTagChip(tagName) {
  }
  /**
   * 获取视图类型标识符
   * @returns 视图类型标识符
   */
  getViewType() {
    return AI_CHAT_VIEW_TYPE;
  }
  /**
   * 获取视图显示名称
   * @returns 视图名称
   */
  getDisplayText() {
    return "AI \u52A9\u624B";
  }
  /**
   * 获取视图图标
   * @returns 视图图标名称
   */
  getIcon() {
    return "message-square";
  }
  /**
   * 初始化视图
   * 创建聊天界面的主要元素：消息容器和输入区域
   */
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("BetterNotes-ai-chat-view");
    const text = "1. You are an intelligent assistant for the Obsidian plugin BetterNotes.         2. You can call functions to get data from BetterNotes. You should call appropriate function in corresponding situations after understanding the user's demandings.            When you get no results after calling a function, you can try another function.          3. You will receive many notes by json, you should focus on the notes themselves like the content, comment, links, tags, sourcePath, not the json structure         4. When analyzing vault or notes, you'd better provide their sources in Obsidian's double-link format, such as [[essay.md|reference]].         5. If users did not mention useing notesSearch function explicitly , you'd better all the vaultSearch function.         ";
    this.sessionManager = new ChatSessionManager(text);
    this.chatContainer = contentEl.createDiv("BetterNotes-ai-chat-container");
    this.messageContainer = this.chatContainer.createDiv("BetterNotes-ai-message-container");
    this.selectedContainer = this.chatContainer.createDiv("sn-selected-list");
    const handleDragOver = (ev) => {
      const dt2 = ev.dataTransfer;
      if (!dt2)
        return;
      if (dt2.types.includes("text/BetterNotes-entry") || dt2.types.includes("text/BetterNotes-set") || dt2.types.includes("text/BetterNotes-tag")) {
        ev.preventDefault();
        dt2.dropEffect = "copy";
      }
    };
    const handleDrop = (ev) => {
      const tagName = ev.dataTransfer?.getData("text/BetterNotes-tag");
      if (tagName) {
        this.addTagChip(tagName);
        return;
      }
      const setName = ev.dataTransfer?.getData("text/BetterNotes-set");
      if (setName) {
        this.addSetChip(setName);
        return;
      }
      const hash = ev.dataTransfer?.getData("text/BetterNotes-entry");
      if (hash) {
        this.addEntryChip(hash);
      }
    };
    this.chatContainer.addEventListener("dragover", handleDragOver);
    this.chatContainer.addEventListener("drop", handleDrop);
    this.createHeader();
    this.loadingBar = this.chatContainer.createDiv("sn-ai-loading-bar");
    this.chatContainer.insertBefore(this.loadingBar, this.messageContainer);
    this.createInputArea();
  }
  /**
   * 创建用户输入区域
   * 包含文本输入框和发送按钮
   */
  createInputArea() {
    this.inputContainer = this.chatContainer.createDiv("BetterNotes-ai-input-container");
    const textarea = this.inputContainer.createEl("textarea", {
      cls: "BetterNotes-ai-chat-input",
      attr: { placeholder: "\u8F93\u5165\u6D88\u606F..." }
    });
    const functionNames = ["curFile", "notesInFile", "allNotes", "notesLinkedBy", "notesNet", "vaultSearch", "notesSearch"];
    let lastPos = 0;
    let mentionActive = false;
    let mentionStart = 0;
    const mentionMenu = new MentionMenu(this.inputContainer, (item) => {
      this.insertChipFromLabel(item.label);
    });
    const addChip = (chipData) => {
      if (chipData.type === "function") {
        for (const v4 of this.selectedSet.values()) {
          if (v4.type === "function")
            return;
        }
      }
      const singleEntryFuncs = ["notesLinkedBy", "notesNet"];
      const hasSingleEntryFunc = Array.from(this.selectedSet.values()).some((v4) => v4.type === "function" && singleEntryFuncs.includes(v4.label));
      if (hasSingleEntryFunc && chipData.type === "entry") {
        const entryCount = Array.from(this.selectedSet.values()).filter((v4) => v4.type === "entry").length;
        if (entryCount >= 1)
          return;
      }
      if (this.selectedSet.has(chipData.id))
        return;
      this.selectedSet.set(chipData.id, chipData);
      const chip = this.selectedContainer.createDiv("sn-selected-chip");
      chip.setText(chipData.label);
      chip.addEventListener("click", () => {
        chip.remove();
        this.selectedSet.delete(chipData.id);
      });
    };
    this.insertChipFromLabel = (label) => {
      const pos = textarea.selectionStart || 0;
      const before = textarea.value.slice(0, mentionStart);
      const after = textarea.value.slice(pos);
      textarea.value = before + after;
      textarea.selectionStart = textarea.selectionEnd = mentionStart;
      if (functionNames.includes(label)) {
        addChip({ id: label, type: "function", label });
        mentionMenu.hide();
        return;
      }
      const presetObj = this.plugin.dataManager.getPreset(label);
      if (presetObj) {
        addChip({ id: presetObj.label, type: "preset", label: presetObj.label });
        mentionMenu.hide();
        return;
      }
      this.addEntryChip(label);
    };
    this.addEntryChip = (hash) => {
      const pos = textarea.selectionStart || 0;
      const before = textarea.value.slice(0, mentionStart);
      const after = textarea.value.slice(pos);
      textarea.value = before + after;
      textarea.selectionStart = textarea.selectionEnd = mentionStart;
      addChip({ id: hash, type: "entry", label: hash });
      mentionMenu.hide();
    };
    this.addSetChip = (setName) => {
      const pos = textarea.selectionStart || 0;
      const before = textarea.value.slice(0, mentionStart);
      const after = textarea.value.slice(pos);
      textarea.value = before + after;
      textarea.selectionStart = textarea.selectionEnd = mentionStart;
      const chipId = `set:${setName}`;
      addChip({ id: chipId, type: "set", label: setName });
      mentionMenu.hide();
    };
    this.addTagChip = (tagName) => {
      const pos = textarea.selectionStart || 0;
      const before = textarea.value.slice(0, mentionStart);
      const after = textarea.value.slice(pos);
      textarea.value = before + after;
      textarea.selectionStart = textarea.selectionEnd = mentionStart;
      const chipId = `tag:${tagName}`;
      addChip({ id: chipId, type: "tag", label: "#" + tagName });
      mentionMenu.hide();
    };
    textarea.addEventListener("input", () => {
      lastPos = textarea.selectionStart || 0;
      const val = textarea.value;
      const charBefore = val[lastPos - 1];
      if (charBefore === "@") {
        mentionActive = true;
        mentionStart = lastPos - 1;
        this.slashActive = false;
      }
      if (charBefore === "/") {
        this.slashActive = true;
        mentionActive = false;
        mentionStart = lastPos - 1;
      }
      if (mentionActive) {
        const token = val.slice(mentionStart + 1, lastPos);
        if (/[^\w]/.test(token) || mentionStart >= val.length || val[mentionStart] !== "@") {
          mentionActive = false;
          mentionMenu.hide();
          return;
        }
        const tokenLower = token.toLowerCase();
        const filtered = functionNames.filter((f3) => f3.toLowerCase().includes(tokenLower)).map((f3, idx) => ({ id: String(idx), label: f3 }));
        if (filtered.length) {
          mentionMenu.show(filtered);
        } else {
          mentionMenu.hide();
        }
        return;
      }
      if (this.slashActive) {
        const token = val.slice(mentionStart + 1, lastPos);
        if (/[\s]/.test(token) || mentionStart >= val.length || val[mentionStart] !== "/") {
          this.slashActive = false;
          mentionMenu.hide();
          return;
        }
        const presets = this.plugin.dataManager.getAllPresets();
        const tokLower = token.toLowerCase();
        const items = presets.filter((p5) => p5.label.toLowerCase().includes(tokLower)).map((p5, idx) => ({ id: String(idx), label: p5.label }));
        if (items.length)
          mentionMenu.show(items);
        else
          mentionMenu.hide();
        return;
      }
    });
    textarea.addEventListener("blur", () => mentionMenu.hide());
    let composing = false;
    textarea.addEventListener("compositionstart", () => composing = true);
    textarea.addEventListener("compositionend", () => composing = false);
    textarea.addEventListener("keydown", (e) => {
      if (mentionMenu.isVisible()) {
        if (e.key === "ArrowDown") {
          mentionMenu.move(1);
          e.preventDefault();
          return;
        }
        if (e.key === "ArrowUp") {
          mentionMenu.move(-1);
          e.preventDefault();
          return;
        }
        if (e.key === "Enter") {
          mentionMenu.choose();
          e.preventDefault();
          return;
        }
      }
      if (e.key === "Enter" && !e.shiftKey && !composing && !e.isComposing) {
        e.preventDefault();
        this.sendMessage();
      }
    });
  }
  /**
   * 发送消息
   * 获取输入框内容，创建新消息，并清空输入框
   */
  async sendMessage() {
    if (this.isSending)
      return;
    this.isSending = true;
    this.loadingBar?.classList.add("running");
    const textarea = this.inputContainer.querySelector("textarea");
    if (!textarea) {
      this.isSending = false;
      return;
    }
    let entrySummaries = this.collectEntrySummaries();
    let toolInstruction = "";
    const presetChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "preset");
    let presetText = "";
    if (presetChips.length) {
      presetText = presetChips.map((p5) => this.plugin.dataManager.getPreset(p5.label)?.prompt || "").filter(Boolean).join("\n");
    }
    const functionChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "function");
    let extraFileData = null;
    const dm = this.plugin.dataManager;
    const activeFile = this.plugin.app.workspace.getActiveFile();
    const entrySet = /* @__PURE__ */ new Set();
    entrySummaries.forEach((es) => entrySet.add(es.hash));
    let userBubbleShown = false;
    for (const fc of functionChips) {
      switch (true) {
        case fc.label === "curFile":
          if (activeFile) {
            extraFileData = {
              path: activeFile.path,
              content: await this.plugin.app.vault.read(activeFile)
            };
          }
          break;
        case fc.label === "notesInFile":
          if (activeFile) {
            dm.getEntriesBySourceFile(activeFile.path).forEach((entry) => {
              if (!entrySet.has(entry.hash)) {
                entrySummaries.push({
                  hash: entry.hash,
                  value: entry.value,
                  comment: entry.comment,
                  link: entry.link,
                  attachmentFile: entry.attachmentFile,
                  tag: entry.tag,
                  sourcePath: entry.sourceFile
                });
                entrySet.add(entry.hash);
              }
            });
          }
          break;
        case fc.label === "allNotes":
          dm.getAllEntries().forEach((entry) => {
            if (!entrySet.has(entry.hash)) {
              entrySummaries.push({
                hash: entry.hash,
                value: entry.value,
                comment: entry.comment,
                link: entry.link,
                attachmentFile: entry.attachmentFile,
                tag: entry.tag,
                sourcePath: entry.sourceFile
              });
              entrySet.add(entry.hash);
            }
          });
          break;
        case fc.label === "notesLinkedBy": {
          const entryChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "entry");
          if (entryChips.length !== 1) {
            new import_obsidian32.Notice('"notesLinkedBy"' + t("need to select only one entry"));
            break;
          }
          const mainHash = entryChips[0].id;
          const mainEntry = dm.getEntryByHash(mainHash);
          if (mainEntry && !entrySet.has(mainHash)) {
            entrySummaries.push({
              hash: mainEntry.hash,
              value: mainEntry.value,
              comment: mainEntry.comment,
              link: mainEntry.link,
              attachmentFile: mainEntry.attachmentFile,
              tag: mainEntry.tag,
              sourcePath: mainEntry.sourceFile
            });
            entrySet.add(mainHash);
          }
          if (mainEntry && Array.isArray(mainEntry.link)) {
            mainEntry.link.forEach((lh) => {
              const le2 = dm.getEntryByHash(lh);
              if (le2 && !entrySet.has(le2.hash)) {
                entrySummaries.push({
                  hash: le2.hash,
                  value: le2.value,
                  comment: le2.comment,
                  link: le2.link,
                  attachmentFile: le2.attachmentFile,
                  tag: le2.tag,
                  sourcePath: le2.sourceFile
                });
                entrySet.add(le2.hash);
              }
            });
          }
          break;
        }
        case fc.label === "notesNet": {
          const entryChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "entry");
          if (entryChips.length !== 1) {
            new import_obsidian32.Notice('"notesNet"' + t("need to select only one entry"));
            break;
          }
          const rootHash = entryChips[0].id;
          const visited = /* @__PURE__ */ new Set();
          const queue = [rootHash];
          while (queue.length) {
            const h3 = queue.shift();
            if (visited.has(h3))
              continue;
            visited.add(h3);
            const e = dm.getEntryByHash(h3);
            if (e) {
              if (!entrySet.has(e.hash)) {
                entrySummaries.push({
                  hash: e.hash,
                  value: e.value,
                  comment: e.comment,
                  link: e.link,
                  attachmentFile: e.attachmentFile,
                  tag: e.tag,
                  sourcePath: e.sourceFile
                });
                entrySet.add(e.hash);
              }
              if (Array.isArray(e.link)) {
                e.link.forEach((lh) => {
                  if (!visited.has(lh))
                    queue.push(lh);
                });
              }
            }
          }
          break;
        }
        case fc.label === "vaultSearch":
        case fc.label === "notesSearch": {
          const queryText = textarea.value.trim();
          const toolName = fc.label;
          if (!queryText) {
            new import_obsidian32.Notice(`"${toolName}"` + t("need to input query content"));
            break;
          }
          if (!userBubbleShown) {
            this.addMessage({
              id: this.generateId(),
              content: queryText,
              timestamp: Date.now(),
              direction: "outgoing" /* OUTGOING */,
              chips: Array.from(this.selectedSet.values())
            });
            userBubbleShown = true;
            textarea.value = "";
            this.selectedContainer.empty();
            this.selectedSet.clear();
            this.slashActive = false;
          }
          toolInstruction = `please call the ${toolName} tool to solve following problem:
\`\`\`
${queryText}
\`\`\``;
          break;
        }
      }
    }
    const setChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "set");
    for (const sc of setChips) {
      const setName = sc.label;
      dm.getEntriesBySet(setName).forEach((entry) => {
        if (!entrySet.has(entry.hash)) {
          entrySummaries.push({
            hash: entry.hash,
            value: entry.value,
            comment: entry.comment,
            link: entry.link,
            attachmentFile: entry.attachmentFile,
            tag: entry.tag,
            sourcePath: entry.sourceFile
          });
          entrySet.add(entry.hash);
        }
      });
    }
    const tagChips = Array.from(this.selectedSet.values()).filter((c2) => c2.type === "tag");
    for (const tc of tagChips) {
      const rawTag = tc.label.startsWith("#") ? tc.label.slice(1) : tc.label;
      dm.getEntriesByTag(rawTag).forEach((entry) => {
        if (!entrySet.has(entry.hash)) {
          entrySummaries.push({
            hash: entry.hash,
            value: entry.value,
            comment: entry.comment,
            link: entry.link,
            attachmentFile: entry.attachmentFile,
            tag: entry.tag,
            sourcePath: entry.sourceFile
          });
          entrySet.add(entry.hash);
        }
      });
    }
    const userText = textarea.value.trim();
    if (!userText && entrySummaries.length === 0 && !presetText && !toolInstruction)
      return;
    const chipVisual = this.buildChipVisualString();
    const displayContent = userText;
    let payload = {};
    if (entrySummaries.length)
      payload.entries = entrySummaries;
    if (extraFileData)
      payload.file = extraFileData;
    const llmContent = (toolInstruction ? toolInstruction + "\n\n" : "") + (Object.keys(payload).length ? "```json\n" + JSON.stringify(payload, null, 2) + "\n```\n\n" : "") + (presetText ? presetText + "\n" : "") + userText;
    if (!userBubbleShown) {
      this.addMessage({
        id: this.generateId(),
        content: displayContent,
        timestamp: Date.now(),
        direction: "outgoing" /* OUTGOING */,
        chips: Array.from(this.selectedSet.values())
      });
    }
    if (!userBubbleShown) {
      textarea.value = "";
      this.selectedContainer.empty();
      this.selectedSet.clear();
      this.slashActive = false;
    }
    this.sessionManager.addUserMessage(llmContent);
    let finalAiComponent = null;
    const handleToolCall = (name2, args2) => {
      const tip = this.buildToolCallBubble(name2, args2);
      if (!tip)
        return;
      this.addMessage({
        id: this.generateId(),
        content: tip,
        timestamp: Date.now(),
        direction: "incoming" /* INCOMING */
      });
      this.scrollToBottom();
    };
    try {
      const { FunctionCallRunner: FunctionCallRunner2 } = await Promise.resolve().then(() => (init_FunctionCallRunner(), FunctionCallRunner_exports));
      const runner = new FunctionCallRunner2(this.plugin, this.sessionManager, { onToolCall: handleToolCall });
      const content = await runner.run();
      const aiMsgMeta = {
        id: this.generateId(),
        content,
        timestamp: Date.now(),
        direction: "incoming" /* INCOMING */
      };
      finalAiComponent = this.addMessage(aiMsgMeta);
      this.sessionManager.addAssistantMessage(content);
      this.scrollToBottom();
    } catch (err2) {
      console.error("AI \u8BF7\u6C42\u5931\u8D25", err2);
      if (finalAiComponent) {
        finalAiComponent.updateContent("**[\u9519\u8BEF]** " + err2.message);
      } else {
        this.addMessage({
          id: this.generateId(),
          content: "**[\u9519\u8BEF]** " + err2.message,
          timestamp: Date.now(),
          direction: "incoming" /* INCOMING */
        });
      }
      new import_obsidian32.Notice(t("AI request failed") + ", " + t("please check network or API configuration"));
    } finally {
      this.isSending = false;
      this.loadingBar?.classList.remove("running");
    }
  }
  /**
   * 根据不同工具函数名称生成对应的提示文本。
   * @param name 工具函数名称（Function Calling 中返回的 name）
   * @param args 解析后的参数对象
   */
  buildToolCallBubble(name2, args2) {
    switch (name2) {
      case "getCurFile": {
        const file = this.plugin.app.workspace.getActiveFile();
        if (file) {
          return `\u{1F916}\u6B63\u5728\u67E5\u770B\u6587\u4EF6[[${file.path}|${file.basename}]]...`;
        }
        return "\u{1F916}\u672A\u627E\u5230\u5F53\u524D\u6587\u4EF6...";
      }
      case "getCurFileNotes":
        return "\u{1F916}\u6B63\u5728\u67E5\u770B\u672C\u6587\u4EF6\u7684\u7B14\u8BB0...";
      case "getAllNotes":
        return "\u{1F916}\u6B63\u5728\u67E5\u770B\u6240\u6709\u7B14\u8BB0...";
      case "getNotesLinkedBy": {
        const hash = args2?.hash || "";
        return `\u{1F916}\u6B63\u5728\u67E5\u770B\u7B14\u8BB0${hash}\u7684\u76F8\u5173\u6761\u76EE...`;
      }
      case "getNotesNet": {
        const hash = args2?.hash || "";
        return `\u{1F916}\u6B63\u5728\u67E5\u770B\u7B14\u8BB0${hash}\u7684\u7F51\u7EDC\u56FE...`;
      }
      case "searchVault": {
        return `\u{1F916}\u6B63\u5728\u68C0\u7D22\u4ED3\u5E93...`;
      }
      case "notesSearch": {
        return `\u{1F916}\u67E5\u8BE2\u5E93\u7B14\u8BB0...`;
      }
      default:
        return null;
    }
  }
  /**
   * 添加新消息到聊天界面
   * @param message 消息对象
   */
  addMessage(message) {
    this.messages.push(message);
    const messageComponent = new AiChatMessage(
      this.messageContainer,
      message.content,
      message.direction,
      this.plugin,
      message.chips
    );
    messageComponent.render();
    this.scrollToBottom();
    return messageComponent;
  }
  /**
   * 滚动到最新消息
   */
  scrollToBottom() {
    this.messageContainer.scrollTo({
      top: this.messageContainer.scrollHeight,
      behavior: "smooth"
    });
  }
  /**
   * 生成唯一消息ID
   * @returns 唯一ID字符串
   */
  generateId() {
    return Date.now().toString() + Math.random().toString(36).substring(2, 9);
  }
  /**
   * 创建顶部渐变 Header，包含标题与刷新按钮
   */
  createHeader() {
    const header = createDiv({ cls: "sn-ai-header" });
    this.chatContainer.prepend(header);
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.padding = "10px 12px";
    const title = header.createDiv();
    title.setText("BetterNotes AI");
    title.style.fontWeight = "600";
    const refresh = header.createEl("button");
    refresh.addClass("sn-ai-refresh-btn");
    refresh.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35a8 8 0 1 0 2.3 6.65h-2.08a6 6 0 1 1-1.64-6.31l-3.29 3.29H22V2l-4.35 4.35z"/></svg>';
    refresh.addEventListener("click", () => {
      this.clearHistory();
    });
  }
  /**
   * 清空对话历史（UI + 内存）
   */
  clearHistory() {
    this.sessionManager.reset();
    this.messages = [];
    this.messageContainer.empty();
  }
  /**
   * 视图关闭时的清理工作
   */
  async onClose() {
    this.chatContainer.empty();
  }
  /**
   * 收集 entry 类型 chip，返回简要信息数组
   */
  collectEntrySummaries() {
    const summaries = [];
    for (const chip of this.selectedSet.values()) {
      if (chip.type === "entry") {
        const entry = this.plugin.dataManager?.getEntryByHash?.(chip.id);
        if (entry) {
          summaries.push({
            hash: entry.hash,
            value: entry.value,
            comment: entry.comment,
            link: entry.link,
            attachmentFile: entry.attachmentFile,
            tag: entry.tag,
            sourcePath: entry.sourceFile
          });
        }
      }
    }
    return summaries;
  }
  /**
   * 构造形如 [[label]] 列表的可视字符串
   */
  buildChipVisualString() {
    if (!this.selectedSet.size)
      return "";
    return Array.from(this.selectedSet.values()).map((c2) => `[[${c2.label}]]`).join(" ");
  }
  /**
   * 将向量检索结果格式化为 Markdown 代码块 Prompt
   */
  buildVaultPrompt(snippets) {
    if (!snippets?.length)
      return "";
    const blocks = snippets.map((s5) => `\`\`\`${s5.path}
${s5.content}
\`\`\``);
    return `## Potentially Relevant Snippets from the vault
${blocks.join("\n")}
`;
  }
};

// src/services/rag/RagService.ts
var import_obsidian34 = require("obsidian");
init_constants();

// src/services/rag/db/Database.ts
var import_obsidian33 = require("obsidian");

// node_modules/@electric-sql/pglite/dist/index.js
init_chunk_RBN4KMJ6();

// node_modules/@electric-sql/pglite/dist/chunk-EL7DUS2A.js
init_chunk_Y3AVQXKT();
x();
var o = { part: "part", container: "container" };
function s2(t2, r, ...e) {
  let a2 = t2.length - 1, p5 = e.length - 1;
  if (p5 !== -1) {
    if (p5 === 0) {
      t2[a2] = t2[a2] + e[0] + r;
      return;
    }
    t2[a2] = t2[a2] + e[0], t2.push(...e.slice(1, p5)), t2.push(e[p5] + r);
  }
}
function y(t2, ...r) {
  let e = [t2[0]];
  e.raw = [t2.raw[0]];
  let a2 = [];
  for (let p5 = 0; p5 < r.length; p5++) {
    let n3 = r[p5], i3 = p5 + 1;
    if (n3?._templateType === o.part) {
      s2(e, t2[i3], n3.str), s2(e.raw, t2.raw[i3], n3.str);
      continue;
    }
    if (n3?._templateType === o.container) {
      s2(e, t2[i3], ...n3.strings), s2(e.raw, t2.raw[i3], ...n3.strings.raw), a2.push(...n3.values);
      continue;
    }
    e.push(t2[i3]), e.raw.push(t2.raw[i3]), a2.push(n3);
  }
  return { _templateType: "container", strings: e, values: a2 };
}
function g3(t2, ...r) {
  let { strings: e, values: a2 } = y(t2, ...r);
  return { query: [e[0], ...a2.flatMap((p5, n3) => [`$${n3 + 1}`, e[n3 + 1]])].join(""), params: a2 };
}

// node_modules/@electric-sql/pglite/dist/chunk-IZM3GSNN.js
init_chunk_Y3AVQXKT();
var import_meta = {};
var process3 = {};
var Ie = {};
D2(Ie, { AuthenticationCleartextPassword: () => v2, AuthenticationMD5Password: () => Q2, AuthenticationOk: () => G2, AuthenticationSASL: () => W2, AuthenticationSASLContinue: () => _2, AuthenticationSASLFinal: () => j2, BackendKeyDataMessage: () => J2, CommandCompleteMessage: () => ee, CopyDataMessage: () => z2, CopyResponse: () => H3, DataRowMessage: () => te, DatabaseError: () => C3, Field: () => q2, NoticeMessage: () => ne, NotificationResponseMessage: () => X2, ParameterDescriptionMessage: () => Y2, ParameterStatusMessage: () => K2, ReadyForQueryMessage: () => Z2, RowDescriptionMessage: () => $2, bindComplete: () => ge, closeComplete: () => we, copyDone: () => xe, emptyQuery: () => Be, noData: () => Ae, parseComplete: () => be, portalSuspended: () => Se, replicationStart: () => De });
x();
var be = { name: "parseComplete", length: 5 };
var ge = { name: "bindComplete", length: 5 };
var we = { name: "closeComplete", length: 5 };
var Ae = { name: "noData", length: 5 };
var Se = { name: "portalSuspended", length: 5 };
var De = { name: "replicationStart", length: 4 };
var Be = { name: "emptyQuery", length: 4 };
var xe = { name: "copyDone", length: 4 };
var G2 = class {
  constructor(t2) {
    this.length = t2;
    this.name = "authenticationOk";
  }
};
var v2 = class {
  constructor(t2) {
    this.length = t2;
    this.name = "authenticationCleartextPassword";
  }
};
var Q2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.salt = n3;
    this.name = "authenticationMD5Password";
  }
};
var W2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.mechanisms = n3;
    this.name = "authenticationSASL";
  }
};
var _2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.data = n3;
    this.name = "authenticationSASLContinue";
  }
};
var j2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.data = n3;
    this.name = "authenticationSASLFinal";
  }
};
var C3 = class extends Error {
  constructor(n3, r, i3) {
    super(n3);
    this.length = r;
    this.name = i3;
  }
};
var z2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.chunk = n3;
    this.name = "copyData";
  }
};
var H3 = class {
  constructor(t2, n3, r, i3) {
    this.length = t2;
    this.name = n3;
    this.binary = r;
    this.columnTypes = new Array(i3);
  }
};
var q2 = class {
  constructor(t2, n3, r, i3, a2, u4, f3) {
    this.name = t2;
    this.tableID = n3;
    this.columnID = r;
    this.dataTypeID = i3;
    this.dataTypeSize = a2;
    this.dataTypeModifier = u4;
    this.format = f3;
  }
};
var $2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.fieldCount = n3;
    this.name = "rowDescription";
    this.fields = new Array(this.fieldCount);
  }
};
var Y2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.parameterCount = n3;
    this.name = "parameterDescription";
    this.dataTypeIDs = new Array(this.parameterCount);
  }
};
var K2 = class {
  constructor(t2, n3, r) {
    this.length = t2;
    this.parameterName = n3;
    this.parameterValue = r;
    this.name = "parameterStatus";
  }
};
var J2 = class {
  constructor(t2, n3, r) {
    this.length = t2;
    this.processID = n3;
    this.secretKey = r;
    this.name = "backendKeyData";
  }
};
var X2 = class {
  constructor(t2, n3, r, i3) {
    this.length = t2;
    this.processId = n3;
    this.channel = r;
    this.payload = i3;
    this.name = "notification";
  }
};
var Z2 = class {
  constructor(t2, n3) {
    this.length = t2;
    this.status = n3;
    this.name = "readyForQuery";
  }
};
var ee = class {
  constructor(t2, n3) {
    this.length = t2;
    this.text = n3;
    this.name = "commandComplete";
  }
};
var te = class {
  constructor(t2, n3) {
    this.length = t2;
    this.fields = n3;
    this.name = "dataRow";
    this.fieldCount = n3.length;
  }
};
var ne = class {
  constructor(t2, n3) {
    this.length = t2;
    this.message = n3;
    this.name = "notice";
  }
};
var _t2 = {};
D2(_t2, { Parser: () => ye, messages: () => Ie, serialize: () => k2 });
x();
x();
x();
x();
function P3(e) {
  let t2 = e.length;
  for (let n3 = e.length - 1; n3 >= 0; n3--) {
    let r = e.charCodeAt(n3);
    r > 127 && r <= 2047 ? t2++ : r > 2047 && r <= 65535 && (t2 += 2), r >= 56320 && r <= 57343 && n3--;
  }
  return t2;
}
var b2;
var g4;
var N2;
var ce2;
var L4;
var S2;
var le;
var U2;
var ve;
var R3 = class {
  constructor(t2 = 256) {
    this.size = t2;
    L2(this, S2);
    L2(this, b2);
    L2(this, g4, 5);
    L2(this, N2, false);
    L2(this, ce2, new TextEncoder());
    L2(this, L4, 0);
    h(this, b2, P2(this, S2, le).call(this, t2));
  }
  addInt32(t2) {
    return P2(this, S2, U2).call(this, 4), g2(this, b2).setInt32(g2(this, g4), t2, g2(this, N2)), h(this, g4, g2(this, g4) + 4), this;
  }
  addInt16(t2) {
    return P2(this, S2, U2).call(this, 2), g2(this, b2).setInt16(g2(this, g4), t2, g2(this, N2)), h(this, g4, g2(this, g4) + 2), this;
  }
  addCString(t2) {
    return t2 && this.addString(t2), P2(this, S2, U2).call(this, 1), g2(this, b2).setUint8(g2(this, g4), 0), R2(this, g4)._++, this;
  }
  addString(t2 = "") {
    let n3 = P3(t2);
    return P2(this, S2, U2).call(this, n3), g2(this, ce2).encodeInto(t2, new Uint8Array(g2(this, b2).buffer, g2(this, g4))), h(this, g4, g2(this, g4) + n3), this;
  }
  add(t2) {
    return P2(this, S2, U2).call(this, t2.byteLength), new Uint8Array(g2(this, b2).buffer).set(new Uint8Array(t2), g2(this, g4)), h(this, g4, g2(this, g4) + t2.byteLength), this;
  }
  flush(t2) {
    let n3 = P2(this, S2, ve).call(this, t2);
    return h(this, g4, 5), h(this, b2, P2(this, S2, le).call(this, this.size)), new Uint8Array(n3);
  }
};
b2 = /* @__PURE__ */ new WeakMap(), g4 = /* @__PURE__ */ new WeakMap(), N2 = /* @__PURE__ */ new WeakMap(), ce2 = /* @__PURE__ */ new WeakMap(), L4 = /* @__PURE__ */ new WeakMap(), S2 = /* @__PURE__ */ new WeakSet(), le = function(t2) {
  return new DataView(new ArrayBuffer(t2));
}, U2 = function(t2) {
  if (g2(this, b2).byteLength - g2(this, g4) < t2) {
    let r = g2(this, b2).buffer, i3 = r.byteLength + (r.byteLength >> 1) + t2;
    h(this, b2, P2(this, S2, le).call(this, i3)), new Uint8Array(g2(this, b2).buffer).set(new Uint8Array(r));
  }
}, ve = function(t2) {
  if (t2) {
    g2(this, b2).setUint8(g2(this, L4), t2);
    let n3 = g2(this, g4) - (g2(this, L4) + 1);
    g2(this, b2).setInt32(g2(this, L4) + 1, n3, g2(this, N2));
  }
  return g2(this, b2).buffer.slice(t2 ? 0 : 5, g2(this, g4));
};
var m2 = new R3();
var gt2 = (e) => {
  m2.addInt16(3).addInt16(0);
  for (let r of Object.keys(e))
    m2.addCString(r).addCString(e[r]);
  m2.addCString("client_encoding").addCString("UTF8");
  let t2 = m2.addCString("").flush(), n3 = t2.byteLength + 4;
  return new R3().addInt32(n3).add(t2).flush();
};
var wt = () => {
  let e = new DataView(new ArrayBuffer(8));
  return e.setInt32(0, 8, false), e.setInt32(4, 80877103, false), new Uint8Array(e.buffer);
};
var At = (e) => m2.addCString(e).flush(112);
var St = (e, t2) => (m2.addCString(e).addInt32(P3(t2)).addString(t2), m2.flush(112));
var Dt = (e) => m2.addString(e).flush(112);
var Bt = (e) => m2.addCString(e).flush(81);
var xt = [];
var It = (e) => {
  let t2 = e.name ?? "";
  t2.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", t2, t2.length), console.error("This can cause conflicts and silent errors executing queries"));
  let n3 = m2.addCString(t2).addCString(e.text).addInt16(e.types?.length ?? 0);
  return e.types?.forEach((r) => n3.addInt32(r)), m2.flush(80);
};
var O2 = new R3();
var Mt = (e, t2) => {
  for (let n3 = 0; n3 < e.length; n3++) {
    let r = t2 ? t2(e[n3], n3) : e[n3];
    if (r === null)
      m2.addInt16(0), O2.addInt32(-1);
    else if (r instanceof ArrayBuffer || ArrayBuffer.isView(r)) {
      let i3 = ArrayBuffer.isView(r) ? r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength) : r;
      m2.addInt16(1), O2.addInt32(i3.byteLength), O2.add(i3);
    } else
      m2.addInt16(0), O2.addInt32(P3(r)), O2.addString(r);
  }
};
var Tt = (e = {}) => {
  let t2 = e.portal ?? "", n3 = e.statement ?? "", r = e.binary ?? false, i3 = e.values ?? xt, a2 = i3.length;
  return m2.addCString(t2).addCString(n3), m2.addInt16(a2), Mt(i3, e.valueMapper), m2.addInt16(a2), m2.add(O2.flush()), m2.addInt16(r ? 1 : 0), m2.flush(66);
};
var Rt = new Uint8Array([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
var Et = (e) => {
  if (!e || !e.portal && !e.rows)
    return Rt;
  let t2 = e.portal ?? "", n3 = e.rows ?? 0, r = P3(t2), i3 = 4 + r + 1 + 4, a2 = new DataView(new ArrayBuffer(1 + i3));
  return a2.setUint8(0, 69), a2.setInt32(1, i3, false), new TextEncoder().encodeInto(t2, new Uint8Array(a2.buffer, 5)), a2.setUint8(r + 5, 0), a2.setUint32(a2.byteLength - 4, n3, false), new Uint8Array(a2.buffer);
};
var Ct = (e, t2) => {
  let n3 = new DataView(new ArrayBuffer(16));
  return n3.setInt32(0, 16, false), n3.setInt16(4, 1234, false), n3.setInt16(6, 5678, false), n3.setInt32(8, e, false), n3.setInt32(12, t2, false), new Uint8Array(n3.buffer);
};
var Me = (e, t2) => {
  let n3 = new R3();
  return n3.addCString(t2), n3.flush(e);
};
var Pt = m2.addCString("P").flush(68);
var Ut = m2.addCString("S").flush(68);
var Nt = (e) => e.name ? Me(68, `${e.type}${e.name ?? ""}`) : e.type === "P" ? Pt : Ut;
var Lt = (e) => {
  let t2 = `${e.type}${e.name ?? ""}`;
  return Me(67, t2);
};
var Ot = (e) => m2.add(e).flush(100);
var kt = (e) => Me(102, e);
var pe = (e) => new Uint8Array([e, 0, 0, 0, 4]);
var Vt = pe(72);
var Ft = pe(83);
var Gt = pe(88);
var vt = pe(99);
var k2 = { startup: gt2, password: At, requestSsl: wt, sendSASLInitialResponseMessage: St, sendSCRAMClientFinalMessage: Dt, query: Bt, parse: It, bind: Tt, execute: Et, describe: Nt, close: Lt, flush: () => Vt, sync: () => Ft, end: () => Gt, copyData: Ot, copyDone: () => vt, copyFail: kt, cancel: Ct };
x();
x();
var Te = { text: 0, binary: 1 };
x();
var Qt = new ArrayBuffer(0);
var T2;
var w2;
var fe;
var me;
var re;
var de = class {
  constructor(t2 = 0) {
    L2(this, T2, new DataView(Qt));
    L2(this, w2);
    L2(this, fe, "utf-8");
    L2(this, me, new TextDecoder(g2(this, fe)));
    L2(this, re, false);
    h(this, w2, t2);
  }
  setBuffer(t2, n3) {
    h(this, w2, t2), h(this, T2, new DataView(n3));
  }
  int16() {
    let t2 = g2(this, T2).getInt16(g2(this, w2), g2(this, re));
    return h(this, w2, g2(this, w2) + 2), t2;
  }
  byte() {
    let t2 = g2(this, T2).getUint8(g2(this, w2));
    return R2(this, w2)._++, t2;
  }
  int32() {
    let t2 = g2(this, T2).getInt32(g2(this, w2), g2(this, re));
    return h(this, w2, g2(this, w2) + 4), t2;
  }
  string(t2) {
    return g2(this, me).decode(this.bytes(t2));
  }
  cstring() {
    let t2 = g2(this, w2), n3 = t2;
    for (; g2(this, T2).getUint8(n3++) !== 0; )
      ;
    let r = this.string(n3 - t2 - 1);
    return h(this, w2, n3), r;
  }
  bytes(t2) {
    let n3 = g2(this, T2).buffer.slice(g2(this, w2), g2(this, w2) + t2);
    return h(this, w2, g2(this, w2) + t2), new Uint8Array(n3);
  }
};
T2 = /* @__PURE__ */ new WeakMap(), w2 = /* @__PURE__ */ new WeakMap(), fe = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap();
var Re = 1;
var Wt = 4;
var Qe = Re + Wt;
var We = new ArrayBuffer(0);
var A2;
var D3;
var B2;
var o2;
var l3;
var _e;
var je;
var ze;
var He;
var qe;
var $e;
var Ye;
var Ee;
var Ke;
var Je;
var Xe;
var Ze;
var et2;
var tt2;
var nt2;
var rt;
var Ce;
var ye = class {
  constructor() {
    L2(this, l3);
    L2(this, A2, new DataView(We));
    L2(this, D3, 0);
    L2(this, B2, 0);
    L2(this, o2, new de());
  }
  parse(t2, n3) {
    P2(this, l3, _e).call(this, ArrayBuffer.isView(t2) ? t2.buffer.slice(t2.byteOffset, t2.byteOffset + t2.byteLength) : t2);
    let r = g2(this, B2) + g2(this, D3), i3 = g2(this, B2);
    for (; i3 + Qe <= r; ) {
      let a2 = g2(this, A2).getUint8(i3), u4 = g2(this, A2).getUint32(i3 + Re, false), f3 = Re + u4;
      if (f3 + i3 <= r) {
        let c2 = P2(this, l3, je).call(this, i3 + Qe, a2, u4, g2(this, A2).buffer);
        n3(c2), i3 += f3;
      } else
        break;
    }
    i3 === r ? (h(this, A2, new DataView(We)), h(this, D3, 0), h(this, B2, 0)) : (h(this, D3, r - i3), h(this, B2, i3));
  }
};
A2 = /* @__PURE__ */ new WeakMap(), D3 = /* @__PURE__ */ new WeakMap(), B2 = /* @__PURE__ */ new WeakMap(), o2 = /* @__PURE__ */ new WeakMap(), l3 = /* @__PURE__ */ new WeakSet(), _e = function(t2) {
  if (g2(this, D3) > 0) {
    let n3 = g2(this, D3) + t2.byteLength;
    if (n3 + g2(this, B2) > g2(this, A2).byteLength) {
      let i3;
      if (n3 <= g2(this, A2).byteLength && g2(this, B2) >= g2(this, D3))
        i3 = g2(this, A2).buffer;
      else {
        let a2 = g2(this, A2).byteLength * 2;
        for (; n3 >= a2; )
          a2 *= 2;
        i3 = new ArrayBuffer(a2);
      }
      new Uint8Array(i3).set(new Uint8Array(g2(this, A2).buffer, g2(this, B2), g2(this, D3))), h(this, A2, new DataView(i3)), h(this, B2, 0);
    }
    new Uint8Array(g2(this, A2).buffer).set(new Uint8Array(t2), g2(this, B2) + g2(this, D3)), h(this, D3, n3);
  } else
    h(this, A2, new DataView(t2)), h(this, B2, 0), h(this, D3, t2.byteLength);
}, je = function(t2, n3, r, i3) {
  switch (n3) {
    case 50:
      return ge;
    case 49:
      return be;
    case 51:
      return we;
    case 110:
      return Ae;
    case 115:
      return Se;
    case 99:
      return xe;
    case 87:
      return De;
    case 73:
      return Be;
    case 68:
      return P2(this, l3, et2).call(this, t2, r, i3);
    case 67:
      return P2(this, l3, He).call(this, t2, r, i3);
    case 90:
      return P2(this, l3, ze).call(this, t2, r, i3);
    case 65:
      return P2(this, l3, Ke).call(this, t2, r, i3);
    case 82:
      return P2(this, l3, rt).call(this, t2, r, i3);
    case 83:
      return P2(this, l3, tt2).call(this, t2, r, i3);
    case 75:
      return P2(this, l3, nt2).call(this, t2, r, i3);
    case 69:
      return P2(this, l3, Ce).call(this, t2, r, i3, "error");
    case 78:
      return P2(this, l3, Ce).call(this, t2, r, i3, "notice");
    case 84:
      return P2(this, l3, Je).call(this, t2, r, i3);
    case 116:
      return P2(this, l3, Ze).call(this, t2, r, i3);
    case 71:
      return P2(this, l3, $e).call(this, t2, r, i3);
    case 72:
      return P2(this, l3, Ye).call(this, t2, r, i3);
    case 100:
      return P2(this, l3, qe).call(this, t2, r, i3);
    default:
      return new C3("received invalid response: " + n3.toString(16), r, "error");
  }
}, ze = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).string(1);
  return new Z2(n3, i3);
}, He = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).cstring();
  return new ee(n3, i3);
}, qe = function(t2, n3, r) {
  let i3 = r.slice(t2, t2 + (n3 - 4));
  return new z2(n3, new Uint8Array(i3));
}, $e = function(t2, n3, r) {
  return P2(this, l3, Ee).call(this, t2, n3, r, "copyInResponse");
}, Ye = function(t2, n3, r) {
  return P2(this, l3, Ee).call(this, t2, n3, r, "copyOutResponse");
}, Ee = function(t2, n3, r, i3) {
  g2(this, o2).setBuffer(t2, r);
  let a2 = g2(this, o2).byte() !== 0, u4 = g2(this, o2).int16(), f3 = new H3(n3, i3, a2, u4);
  for (let c2 = 0; c2 < u4; c2++)
    f3.columnTypes[c2] = g2(this, o2).int16();
  return f3;
}, Ke = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int32(), a2 = g2(this, o2).cstring(), u4 = g2(this, o2).cstring();
  return new X2(n3, i3, a2, u4);
}, Je = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int16(), a2 = new $2(n3, i3);
  for (let u4 = 0; u4 < i3; u4++)
    a2.fields[u4] = P2(this, l3, Xe).call(this);
  return a2;
}, Xe = function() {
  let t2 = g2(this, o2).cstring(), n3 = g2(this, o2).int32(), r = g2(this, o2).int16(), i3 = g2(this, o2).int32(), a2 = g2(this, o2).int16(), u4 = g2(this, o2).int32(), f3 = g2(this, o2).int16() === 0 ? Te.text : Te.binary;
  return new q2(t2, n3, r, i3, a2, u4, f3);
}, Ze = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int16(), a2 = new Y2(n3, i3);
  for (let u4 = 0; u4 < i3; u4++)
    a2.dataTypeIDs[u4] = g2(this, o2).int32();
  return a2;
}, et2 = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int16(), a2 = new Array(i3);
  for (let u4 = 0; u4 < i3; u4++) {
    let f3 = g2(this, o2).int32();
    a2[u4] = f3 === -1 ? null : g2(this, o2).string(f3);
  }
  return new te(n3, a2);
}, tt2 = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).cstring(), a2 = g2(this, o2).cstring();
  return new K2(n3, i3, a2);
}, nt2 = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int32(), a2 = g2(this, o2).int32();
  return new J2(n3, i3, a2);
}, rt = function(t2, n3, r) {
  g2(this, o2).setBuffer(t2, r);
  let i3 = g2(this, o2).int32();
  switch (i3) {
    case 0:
      return new G2(n3);
    case 3:
      return new v2(n3);
    case 5:
      return new Q2(n3, g2(this, o2).bytes(4));
    case 10: {
      let a2 = [];
      for (; ; ) {
        let u4 = g2(this, o2).cstring();
        if (u4.length === 0)
          return new W2(n3, a2);
        a2.push(u4);
      }
    }
    case 11:
      return new _2(n3, g2(this, o2).string(n3 - 8));
    case 12:
      return new j2(n3, g2(this, o2).string(n3 - 8));
    default:
      throw new Error("Unknown authenticationOk message type " + i3);
  }
}, Ce = function(t2, n3, r, i3) {
  g2(this, o2).setBuffer(t2, r);
  let a2 = {}, u4 = g2(this, o2).string(1);
  for (; u4 !== "\0"; )
    a2[u4] = g2(this, o2).cstring(), u4 = g2(this, o2).string(1);
  let f3 = a2.M, c2 = i3 === "notice" ? new ne(n3, f3) : new C3(f3, n3, i3);
  return c2.severity = a2.S, c2.code = a2.C, c2.detail = a2.D, c2.hint = a2.H, c2.position = a2.P, c2.internalPosition = a2.p, c2.internalQuery = a2.q, c2.where = a2.W, c2.schema = a2.s, c2.table = a2.t, c2.column = a2.c, c2.dataType = a2.d, c2.constraint = a2.n, c2.file = a2.F, c2.line = a2.L, c2.routine = a2.R, c2;
};
var jn = {};
D2(jn, { ABSTIME: () => rn, ACLITEM: () => dn, BIT: () => hn, BOOL: () => Ue, BPCHAR: () => lt2, BYTEA: () => Ne, CHAR: () => Ht, CID: () => Kt, CIDR: () => nn, CIRCLE: () => on, DATE: () => pt, FLOAT4: () => ot2, FLOAT8: () => ut2, GTSVECTOR: () => Un, INET: () => pn, INT2: () => st, INT4: () => it2, INT8: () => Le, INTERVAL: () => mn, JSON: () => Oe, JSONB: () => ft, MACADDR: () => cn, MACADDR8: () => un, MONEY: () => ln, NUMERIC: () => gn, OID: () => at, PATH: () => en, PG_DEPENDENCIES: () => En, PG_LSN: () => Tn, PG_NDISTINCT: () => Rn, PG_NODE_TREE: () => Xt, POLYGON: () => tn, REFCURSOR: () => wn, REGCLASS: () => Bn, REGCONFIG: () => Nn, REGDICTIONARY: () => Ln, REGNAMESPACE: () => On, REGOPER: () => Sn, REGOPERATOR: () => Dn, REGPROC: () => qt, REGPROCEDURE: () => An, REGROLE: () => kn, REGTYPE: () => xn, RELTIME: () => sn, SMGR: () => Zt, TEXT: () => se, TID: () => $t, TIME: () => fn, TIMESTAMP: () => dt, TIMESTAMPTZ: () => ke, TIMETZ: () => yn, TINTERVAL: () => an, TSQUERY: () => Pn, TSVECTOR: () => Cn, TXID_SNAPSHOT: () => Mn, UUID: () => In, VARBIT: () => bn, VARCHAR: () => ct2, XID: () => Yt, XML: () => Jt, arrayParser: () => _n, arraySerializer: () => yt2, parseType: () => he, parsers: () => Vn, serializers: () => Fn, types: () => mt });
x();
var jt = globalThis.JSON.parse;
var zt = globalThis.JSON.stringify;
var Ue = 16;
var Ne = 17;
var Ht = 18;
var Le = 20;
var st = 21;
var it2 = 23;
var qt = 24;
var se = 25;
var at = 26;
var $t = 27;
var Yt = 28;
var Kt = 29;
var Oe = 114;
var Jt = 142;
var Xt = 194;
var Zt = 210;
var en = 602;
var tn = 604;
var nn = 650;
var ot2 = 700;
var ut2 = 701;
var rn = 702;
var sn = 703;
var an = 704;
var on = 718;
var un = 774;
var ln = 790;
var cn = 829;
var pn = 869;
var dn = 1033;
var lt2 = 1042;
var ct2 = 1043;
var pt = 1082;
var fn = 1083;
var dt = 1114;
var ke = 1184;
var mn = 1186;
var yn = 1266;
var hn = 1560;
var bn = 1562;
var gn = 1700;
var wn = 1790;
var An = 2202;
var Sn = 2203;
var Dn = 2204;
var Bn = 2205;
var xn = 2206;
var In = 2950;
var Mn = 2970;
var Tn = 3220;
var Rn = 3361;
var En = 3402;
var Cn = 3614;
var Pn = 3615;
var Un = 3642;
var Nn = 3734;
var Ln = 3769;
var ft = 3802;
var On = 4089;
var kn = 4096;
var mt = { string: { to: se, from: [se, ct2, lt2], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return e.toString();
  throw new Error("Invalid input for string type");
}, parse: (e) => e }, number: { to: 0, from: [st, it2, at, ot2, ut2], serialize: (e) => e.toString(), parse: (e) => +e }, bigint: { to: Le, from: [Le], serialize: (e) => e.toString(), parse: (e) => {
  let t2 = BigInt(e);
  return t2 < Number.MIN_SAFE_INTEGER || t2 > Number.MAX_SAFE_INTEGER ? t2 : Number(t2);
} }, json: { to: Oe, from: [Oe, ft], serialize: (e) => typeof e == "string" ? e : zt(e), parse: (e) => jt(e) }, boolean: { to: Ue, from: [Ue], serialize: (e) => {
  if (typeof e != "boolean")
    throw new Error("Invalid input for boolean type");
  return e ? "t" : "f";
}, parse: (e) => e === "t" }, date: { to: ke, from: [pt, dt, ke], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return new Date(e).toISOString();
  if (e instanceof Date)
    return e.toISOString();
  throw new Error("Invalid input for date type");
}, parse: (e) => new Date(e) }, bytea: { to: Ne, from: [Ne], serialize: (e) => {
  if (!(e instanceof Uint8Array))
    throw new Error("Invalid input for bytea type");
  return "\\x" + Array.from(e).map((t2) => t2.toString(16).padStart(2, "0")).join("");
}, parse: (e) => {
  let t2 = e.slice(2);
  return Uint8Array.from({ length: t2.length / 2 }, (n3, r) => parseInt(t2.substring(r * 2, (r + 1) * 2), 16));
} } };
var Ve = Gn(mt);
var Vn = Ve.parsers;
var Fn = Ve.serializers;
function he(e, t2, n3) {
  if (e === null)
    return null;
  let r = n3?.[t2] ?? Ve.parsers[t2];
  return r ? r(e, t2) : e;
}
function Gn(e) {
  return Object.keys(e).reduce(({ parsers: t2, serializers: n3 }, r) => {
    let { to: i3, from: a2, serialize: u4, parse: f3 } = e[r];
    return n3[i3] = u4, n3[r] = u4, t2[r] = f3, Array.isArray(a2) ? a2.forEach((c2) => {
      t2[c2] = f3, n3[c2] = u4;
    }) : (t2[a2] = f3, n3[a2] = u4), { parsers: t2, serializers: n3 };
  }, { parsers: {}, serializers: {} });
}
var vn = /\\/g;
var Qn = /"/g;
function Wn(e) {
  return e.replace(vn, "\\\\").replace(Qn, '\\"');
}
function yt2(e, t2, n3) {
  if (Array.isArray(e) === false)
    return e;
  if (!e.length)
    return "{}";
  let r = e[0], i3 = n3 === 1020 ? ";" : ",";
  return Array.isArray(r) ? `{${e.map((a2) => yt2(a2, t2, n3)).join(i3)}}` : `{${e.map((a2) => (a2 === void 0 && (a2 = null), a2 === null ? "null" : '"' + Wn(t2 ? t2(a2) : a2.toString()) + '"')).join(i3)}}`;
}
var Pe = { i: 0, char: null, str: "", quoted: false, last: 0, p: null };
function _n(e, t2, n3) {
  return Pe.i = Pe.last = 0, ht(Pe, e, t2, n3)[0];
}
function ht(e, t2, n3, r) {
  let i3 = [], a2 = r === 1020 ? ";" : ",";
  for (; e.i < t2.length; e.i++) {
    if (e.char = t2[e.i], e.quoted)
      e.char === "\\" ? e.str += t2[++e.i] : e.char === '"' ? (i3.push(n3 ? n3(e.str) : e.str), e.str = "", e.quoted = t2[e.i + 1] === '"', e.last = e.i + 2) : e.str += e.char;
    else if (e.char === '"')
      e.quoted = true;
    else if (e.char === "{")
      e.last = ++e.i, i3.push(ht(e, t2, n3, r));
    else if (e.char === "}") {
      e.quoted = false, e.last < e.i && i3.push(n3 ? n3(t2.slice(e.last, e.i)) : t2.slice(e.last, e.i)), e.last = e.i + 1;
      break;
    } else
      e.char === a2 && e.p !== "}" && e.p !== '"' && (i3.push(n3 ? n3(t2.slice(e.last, e.i)) : t2.slice(e.last, e.i)), e.last = e.i + 1);
    e.p = e.char;
  }
  return e.last < e.i && i3.push(n3 ? n3(t2.slice(e.last, e.i + 1)) : t2.slice(e.last, e.i + 1)), i3;
}
var qn = {};
D2(qn, { parseDescribeStatementResults: () => Fe, parseResults: () => zn });
x();
function zn(e, t2, n3, r) {
  let i3 = [], a2 = { rows: [], fields: [] }, u4 = 0, f3 = { ...t2, ...n3?.parsers }, c2 = e.filter((x4) => x4.name === "rowDescription" || x4.name === "dataRow" || x4.name === "commandComplete");
  return c2.forEach((x4, bt) => {
    if (x4.name === "rowDescription") {
      let F5 = x4;
      a2.fields = F5.fields.map((E2) => ({ name: E2.name, dataTypeID: E2.dataTypeID }));
    } else if (x4.name === "dataRow" && a2) {
      let F5 = x4;
      n3?.rowMode === "array" ? a2.rows.push(F5.fields.map((E2, ae) => he(E2, a2.fields[ae].dataTypeID, f3))) : a2.rows.push(Object.fromEntries(F5.fields.map((E2, ae) => [a2.fields[ae].name, he(E2, a2.fields[ae].dataTypeID, f3)])));
    } else
      x4.name === "commandComplete" && (u4 += Hn(x4), bt === c2.length - 1 ? i3.push({ ...a2, affectedRows: u4, ...r ? { blob: r } : {} }) : i3.push(a2), a2 = { rows: [], fields: [] });
  }), i3.length === 0 && i3.push({ rows: [], fields: [] }), i3;
}
function Hn(e) {
  let t2 = e.text.split(" ");
  switch (t2[0]) {
    case "INSERT":
      return parseInt(t2[2], 10);
    case "UPDATE":
    case "DELETE":
      return parseInt(t2[1], 10);
    default:
      return 0;
  }
}
function Fe(e) {
  let t2 = e.find((n3) => n3.name === "parameterDescription");
  return t2 ? t2.dataTypeIDs : [];
}
x();
var Ge = typeof process3 == "object" && typeof process3.versions == "object" && typeof process3.versions.node == "string";
var ie;
async function Er() {
  if (Ge || ie)
    return;
  let e = new URL("./postgres.wasm", import_meta.url);
  ie = fetch(e);
}
var V2;
async function Cr(e, t2) {
  if (t2 || V2)
    return WebAssembly.instantiate(t2 || V2, e), { instance: await WebAssembly.instantiate(t2 || V2, e), module: t2 || V2 };
  let n3 = new URL("./postgres.wasm", import_meta.url);
  if (Ge) {
    let i3 = await (await import("fs/promises")).readFile(n3), { module: a2, instance: u4 } = await WebAssembly.instantiate(i3, e);
    return V2 = a2, { instance: u4, module: a2 };
  } else {
    ie || (ie = fetch(n3));
    let r = await ie, { module: i3, instance: a2 } = await WebAssembly.instantiateStreaming(r, e);
    return V2 = i3, { instance: a2, module: i3 };
  }
}
async function Pr() {
  let e = new URL("./postgres.data", import_meta.url);
  return Ge ? (await (await import("fs/promises")).readFile(e)).buffer : (await fetch(e)).arrayBuffer();
}

// node_modules/@electric-sql/pglite/dist/chunk-NMYRYYP2.js
init_chunk_Y3AVQXKT();
x();
var p3;
var y2;
var s3;
var o3;
var w3;
var u3;
var R4;
var z3 = class {
  constructor() {
    L2(this, s3);
    this.serializers = { ...Fn };
    this.parsers = { ...Vn };
    L2(this, p3, false);
    L2(this, y2, false);
  }
  async _initArrayTypes() {
    if (g2(this, p3))
      return;
    h(this, p3, true);
    let a2 = await this.query(`
      SELECT b.oid, b.typarray
      FROM pg_catalog.pg_type a
      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem
      WHERE a.typcategory = 'A'
      GROUP BY b.oid, b.typarray
      ORDER BY b.oid
    `);
    for (let r of a2.rows)
      this.serializers[r.typarray] = (t2) => yt2(t2, this.serializers[r.oid], r.typarray), this.parsers[r.typarray] = (t2) => _n(t2, this.parsers[r.oid], r.typarray);
  }
  async query(a2, r, t2) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await P2(this, s3, w3).call(this, a2, r, t2));
  }
  async sql(a2, ...r) {
    let { query: t2, params: l4 } = g3(a2, ...r);
    return await this.query(t2, l4);
  }
  async exec(a2, r) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await P2(this, s3, u3).call(this, a2, r));
  }
  async transaction(a2) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => {
      await P2(this, s3, u3).call(this, "BEGIN"), h(this, y2, true);
      let r = false, t2 = () => {
        if (r)
          throw new Error("Transaction is closed");
      }, l4 = { query: async (i3, n3, b4) => (t2(), await P2(this, s3, w3).call(this, i3, n3, b4)), sql: async (i3, ...n3) => {
        let { query: b4, params: P6 } = g3(i3, ...n3);
        return await P2(this, s3, w3).call(this, b4, P6);
      }, exec: async (i3, n3) => (t2(), await P2(this, s3, u3).call(this, i3, n3)), rollback: async () => {
        t2(), await P2(this, s3, u3).call(this, "ROLLBACK"), r = true;
      }, get closed() {
        return r;
      } };
      try {
        let i3 = await a2(l4);
        return r || (r = true, await P2(this, s3, u3).call(this, "COMMIT")), h(this, y2, false), i3;
      } catch (i3) {
        throw r || await P2(this, s3, u3).call(this, "ROLLBACK"), h(this, y2, false), i3;
      }
    });
  }
};
p3 = /* @__PURE__ */ new WeakMap(), y2 = /* @__PURE__ */ new WeakMap(), s3 = /* @__PURE__ */ new WeakSet(), o3 = async function(a2, r = {}) {
  return await this.execProtocol(a2, { ...r, syncToFs: false });
}, w3 = async function(a2, r = [], t2) {
  return await this._runExclusiveQuery(async () => {
    P2(this, s3, R4).call(this, "runQuery", a2, r, t2), await this._handleBlob(t2?.blob);
    let l4;
    try {
      let n3 = await P2(this, s3, o3).call(this, k2.parse({ text: a2, types: t2?.paramTypes }), t2), b4 = Fe((await P2(this, s3, o3).call(this, k2.describe({ type: "S" }), t2)).map(([h3]) => h3)), P6 = r.map((h3, Q4) => {
        let q4 = b4[Q4];
        if (h3 == null)
          return null;
        let x4 = this.serializers[q4];
        return x4 ? x4(h3) : h3.toString();
      });
      l4 = [...n3, ...await P2(this, s3, o3).call(this, k2.bind({ values: P6 }), t2), ...await P2(this, s3, o3).call(this, k2.describe({ type: "P" }), t2), ...await P2(this, s3, o3).call(this, k2.execute({}), t2)];
    } finally {
      await P2(this, s3, o3).call(this, k2.sync(), t2);
    }
    await this._cleanupBlob(), g2(this, y2) || await this.syncToFs();
    let i3 = await this._getWrittenBlob();
    return zn(l4.map(([n3]) => n3), this.parsers, t2, i3)[0];
  });
}, u3 = async function(a2, r) {
  return await this._runExclusiveQuery(async () => {
    P2(this, s3, R4).call(this, "runExec", a2, r), await this._handleBlob(r?.blob);
    let t2;
    try {
      t2 = await P2(this, s3, o3).call(this, k2.query(a2), r);
    } finally {
      await P2(this, s3, o3).call(this, k2.sync(), r);
    }
    this._cleanupBlob(), g2(this, y2) || await this.syncToFs();
    let l4 = await this._getWrittenBlob();
    return zn(t2.map(([i3]) => i3), this.parsers, r, l4);
  });
}, R4 = function(...a2) {
  this.debug > 0 && console.log(...a2);
};

// node_modules/@electric-sql/pglite/dist/index.js
init_chunk_Y3AVQXKT();

// node_modules/@electric-sql/pglite/dist/postgres.js
var import_meta2 = {};
var process4 = {};
var Module2 = (() => {
  var _scriptName = import_meta2.url;
  return async function(moduleArg = {}) {
    var moduleRtn;
    var Module = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve2, reject) => {
      readyPromiseResolve = resolve2;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
    var ENVIRONMENT_IS_NODE = typeof process4 == "object" && typeof process4.versions == "object" && typeof process4.versions.node == "string" && process4.type != "renderer";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    if (ENVIRONMENT_IS_NODE) {
      const { createRequire } = await import("module");
      let dirname2 = import_meta2.url;
      if (dirname2.startsWith("data:")) {
        dirname2 = "/";
      }
      var require = createRequire(dirname2);
    }
    if (!Module["expectedDataFileDownloads"]) {
      Module["expectedDataFileDownloads"] = 0;
    }
    Module["expectedDataFileDownloads"]++;
    (() => {
      var isPthread = typeof ENVIRONMENT_IS_PTHREAD != "undefined" && ENVIRONMENT_IS_PTHREAD;
      var isWasmWorker = typeof ENVIRONMENT_IS_WASM_WORKER != "undefined" && ENVIRONMENT_IS_WASM_WORKER;
      if (isPthread || isWasmWorker)
        return;
      function loadPackage(metadata2) {
        var PACKAGE_PATH = "";
        if (typeof window === "object") {
          PACKAGE_PATH = window["encodeURIComponent"](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/");
        } else if (typeof process4 === "undefined" && typeof location !== "undefined") {
          PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/");
        }
        var PACKAGE_NAME = "postgres.data";
        var REMOTE_PACKAGE_BASE = "postgres.data";
        if (typeof Module["locateFilePackage"] === "function" && !Module["locateFile"]) {
          Module["locateFile"] = Module["locateFilePackage"];
          err("warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)");
        }
        var REMOTE_PACKAGE_NAME = Module["locateFile"] ? Module["locateFile"](REMOTE_PACKAGE_BASE, "") : REMOTE_PACKAGE_BASE;
        var REMOTE_PACKAGE_SIZE = metadata2["remote_package_size"];
        function fetchRemotePackage(packageName, packageSize, callback, errback) {
          if (typeof process4 === "object" && typeof process4.versions === "object" && typeof process4.versions.node === "string") {
            require("fs").readFile(packageName, (err2, contents) => {
              if (err2) {
                errback(err2);
              } else {
                callback(contents.buffer);
              }
            });
            return;
          }
          Module["dataFileDownloads"] ?? (Module["dataFileDownloads"] = {});
          fetch(packageName).catch((cause) => Promise.reject(new Error(`Network Error: ${packageName}`, { cause }))).then((response) => {
            if (!response.ok) {
              return Promise.reject(new Error(`${response.status}: ${response.url}`));
            }
            if (!response.body && response.arrayBuffer) {
              return response.arrayBuffer().then(callback);
            }
            const reader = response.body.getReader();
            const iterate = () => reader.read().then(handleChunk).catch((cause) => {
              return Promise.reject(new Error(`Unexpected error while handling : ${response.url} ${cause}`, { cause }));
            });
            const chunks = [];
            const headers = response.headers;
            const total = Number(headers.get("Content-Length") ?? packageSize);
            let loaded = 0;
            const handleChunk = ({ done, value }) => {
              if (!done) {
                chunks.push(value);
                loaded += value.length;
                Module["dataFileDownloads"][packageName] = { loaded, total };
                let totalLoaded = 0;
                let totalSize = 0;
                for (const download of Object.values(Module["dataFileDownloads"])) {
                  totalLoaded += download.loaded;
                  totalSize += download.total;
                }
                Module["setStatus"]?.(`Downloading data... (${totalLoaded}/${totalSize})`);
                return iterate();
              } else {
                const packageData = new Uint8Array(chunks.map((c2) => c2.length).reduce((a2, b4) => a2 + b4, 0));
                let offset = 0;
                for (const chunk of chunks) {
                  packageData.set(chunk, offset);
                  offset += chunk.length;
                }
                callback(packageData.buffer);
              }
            };
            Module["setStatus"]?.("Downloading data...");
            return iterate();
          });
        }
        ;
        function handleError(error2) {
          console.error("package error:", error2);
        }
        ;
        var fetchedCallback = null;
        var fetched = Module["getPreloadedPackage"] ? Module["getPreloadedPackage"](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;
        if (!fetched)
          fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, (data) => {
            if (fetchedCallback) {
              fetchedCallback(data);
              fetchedCallback = null;
            } else {
              fetched = data;
            }
          }, handleError);
        function runWithFS(Module3) {
          function assert2(check, msg) {
            if (!check)
              throw msg + new Error().stack;
          }
          Module3["FS_createPath"]("/", "home", true, true);
          Module3["FS_createPath"]("/home", "web_user", true, true);
          Module3["FS_createPath"]("/", "tmp", true, true);
          Module3["FS_createPath"]("/tmp", "pglite", true, true);
          Module3["FS_createPath"]("/tmp/pglite", "bin", true, true);
          Module3["FS_createPath"]("/tmp/pglite", "lib", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib", "postgresql", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql", "pgxs", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs", "config", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs", "src", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs/src", "makefiles", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs/src", "test", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs/src/test", "isolation", true, true);
          Module3["FS_createPath"]("/tmp/pglite/lib/postgresql/pgxs/src/test", "regress", true, true);
          Module3["FS_createPath"]("/tmp/pglite", "share", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share", "postgresql", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql", "extension", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql", "timezone", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Africa", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "America", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone/America", "Argentina", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone/America", "Indiana", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone/America", "Kentucky", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone/America", "North_Dakota", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Antarctica", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Arctic", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Asia", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Atlantic", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Australia", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Brazil", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Canada", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Chile", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Etc", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Europe", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Indian", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Mexico", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "Pacific", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql/timezone", "US", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql", "timezonesets", true, true);
          Module3["FS_createPath"]("/tmp/pglite/share/postgresql", "tsearch_data", true, true);
          function DataRequest(start2, end, audio) {
            this.start = start2;
            this.end = end;
            this.audio = audio;
          }
          DataRequest.prototype = {
            requests: {},
            open: function(mode, name2) {
              this.name = name2;
              this.requests[name2] = this;
              Module3["addRunDependency"](`fp ${this.name}`);
            },
            send: function() {
            },
            onload: function() {
              var byteArray = this.byteArray.subarray(this.start, this.end);
              this.finish(byteArray);
            },
            finish: function(byteArray) {
              var that = this;
              Module3["FS_createDataFile"](this.name, null, byteArray, true, true, true);
              Module3["removeRunDependency"](`fp ${that.name}`);
              this.requests[this.name] = null;
            }
          };
          var files = metadata2["files"];
          for (var i3 = 0; i3 < files.length; ++i3) {
            new DataRequest(files[i3]["start"], files[i3]["end"], files[i3]["audio"] || 0).open("GET", files[i3]["filename"]);
          }
          function processPackageData(arrayBuffer) {
            assert2(arrayBuffer, "Loading data file failed.");
            assert2(arrayBuffer.constructor.name === ArrayBuffer.name, "bad input to processPackageData");
            var byteArray = new Uint8Array(arrayBuffer);
            var curr;
            DataRequest.prototype.byteArray = byteArray;
            var files2 = metadata2["files"];
            for (var i4 = 0; i4 < files2.length; ++i4) {
              DataRequest.prototype.requests[files2[i4].filename].onload();
            }
            Module3["removeRunDependency"]("datafile_postgres.data");
          }
          ;
          Module3["addRunDependency"]("datafile_postgres.data");
          if (!Module3["preloadResults"])
            Module3["preloadResults"] = {};
          Module3["preloadResults"][PACKAGE_NAME] = { fromCache: false };
          if (fetched) {
            processPackageData(fetched);
            fetched = null;
          } else {
            fetchedCallback = processPackageData;
          }
        }
        if (Module["calledRun"]) {
          runWithFS(Module);
        } else {
          if (!Module["preRun"])
            Module["preRun"] = [];
          Module["preRun"].push(runWithFS);
        }
      }
      loadPackage({ "files": [{ "filename": "/home/web_user/.pgpass", "start": 0, "end": 135 }, { "filename": "/tmp/pglite/bin/initdb", "start": 135, "end": 147 }, { "filename": "/tmp/pglite/bin/postgres", "start": 147, "end": 159 }, { "filename": "/tmp/pglite/lib/postgresql/cyrillic_and_mic.so", "start": 159, "end": 5738 }, { "filename": "/tmp/pglite/lib/postgresql/dict_snowball.so", "start": 5738, "end": 580838 }, { "filename": "/tmp/pglite/lib/postgresql/euc2004_sjis2004.so", "start": 580838, "end": 583216 }, { "filename": "/tmp/pglite/lib/postgresql/euc_cn_and_mic.so", "start": 583216, "end": 584483 }, { "filename": "/tmp/pglite/lib/postgresql/euc_jp_and_sjis.so", "start": 584483, "end": 592223 }, { "filename": "/tmp/pglite/lib/postgresql/euc_kr_and_mic.so", "start": 592223, "end": 593530 }, { "filename": "/tmp/pglite/lib/postgresql/euc_tw_and_big5.so", "start": 593530, "end": 598650 }, { "filename": "/tmp/pglite/lib/postgresql/latin2_and_win1250.so", "start": 598650, "end": 600595 }, { "filename": "/tmp/pglite/lib/postgresql/latin_and_mic.so", "start": 600595, "end": 602068 }, { "filename": "/tmp/pglite/lib/postgresql/libpqwalreceiver.so", "start": 602068, "end": 725255 }, { "filename": "/tmp/pglite/lib/postgresql/pgoutput.so", "start": 725255, "end": 741345 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/config/install-sh", "start": 741345, "end": 755342 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/config/missing", "start": 755342, "end": 756690 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.global", "start": 756690, "end": 792812 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.port", "start": 792812, "end": 793088 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.shlib", "start": 793088, "end": 809126 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/makefiles/pgxs.mk", "start": 809126, "end": 824054 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/nls-global.mk", "start": 824054, "end": 830939 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/isolation/isolationtester.cjs", "start": 830939, "end": 927086 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/isolation/pg_isolation_regress.cjs", "start": 927086, "end": 1003500 }, { "filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/regress/pg_regress.cjs", "start": 1003500, "end": 1079904 }, { "filename": "/tmp/pglite/lib/postgresql/plpgsql.so", "start": 1079904, "end": 1239297 }, { "filename": "/tmp/pglite/password", "start": 1239297, "end": 1239306 }, { "filename": "/tmp/pglite/share/postgresql/errcodes.txt", "start": 1239306, "end": 1272764 }, { "filename": "/tmp/pglite/share/postgresql/extension/plpgsql--1.0.sql", "start": 1272764, "end": 1273422 }, { "filename": "/tmp/pglite/share/postgresql/extension/plpgsql.control", "start": 1273422, "end": 1273615 }, { "filename": "/tmp/pglite/share/postgresql/fix-CVE-2024-4317.sql", "start": 1273615, "end": 1279380 }, { "filename": "/tmp/pglite/share/postgresql/information_schema.sql", "start": 1279380, "end": 1394355 }, { "filename": "/tmp/pglite/share/postgresql/pg_hba.conf.sample", "start": 1394355, "end": 1399980 }, { "filename": "/tmp/pglite/share/postgresql/pg_ident.conf.sample", "start": 1399980, "end": 1402620 }, { "filename": "/tmp/pglite/share/postgresql/pg_service.conf.sample", "start": 1402620, "end": 1403224 }, { "filename": "/tmp/pglite/share/postgresql/postgres.bki", "start": 1403224, "end": 2347328 }, { "filename": "/tmp/pglite/share/postgresql/postgresql.conf.sample", "start": 2347328, "end": 2376975 }, { "filename": "/tmp/pglite/share/postgresql/psqlrc.sample", "start": 2376975, "end": 2377253 }, { "filename": "/tmp/pglite/share/postgresql/snowball_create.sql", "start": 2377253, "end": 2421429 }, { "filename": "/tmp/pglite/share/postgresql/sql_features.txt", "start": 2421429, "end": 2457110 }, { "filename": "/tmp/pglite/share/postgresql/system_constraints.sql", "start": 2457110, "end": 2466005 }, { "filename": "/tmp/pglite/share/postgresql/system_functions.sql", "start": 2466005, "end": 2489320 }, { "filename": "/tmp/pglite/share/postgresql/system_views.sql", "start": 2489320, "end": 2539593 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Abidjan", "start": 2539593, "end": 2539723 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Accra", "start": 2539723, "end": 2539853 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Addis_Ababa", "start": 2539853, "end": 2540044 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Algiers", "start": 2540044, "end": 2540514 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Asmara", "start": 2540514, "end": 2540705 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Asmera", "start": 2540705, "end": 2540896 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bamako", "start": 2540896, "end": 2541026 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bangui", "start": 2541026, "end": 2541206 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Banjul", "start": 2541206, "end": 2541336 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bissau", "start": 2541336, "end": 2541485 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Blantyre", "start": 2541485, "end": 2541616 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Brazzaville", "start": 2541616, "end": 2541796 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bujumbura", "start": 2541796, "end": 2541927 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Cairo", "start": 2541927, "end": 2543236 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Casablanca", "start": 2543236, "end": 2545155 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ceuta", "start": 2545155, "end": 2545717 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Conakry", "start": 2545717, "end": 2545847 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Dakar", "start": 2545847, "end": 2545977 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Dar_es_Salaam", "start": 2545977, "end": 2546168 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Djibouti", "start": 2546168, "end": 2546359 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Douala", "start": 2546359, "end": 2546539 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/El_Aaiun", "start": 2546539, "end": 2548369 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Freetown", "start": 2548369, "end": 2548499 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Gaborone", "start": 2548499, "end": 2548630 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Harare", "start": 2548630, "end": 2548761 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Johannesburg", "start": 2548761, "end": 2548951 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Juba", "start": 2548951, "end": 2549409 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kampala", "start": 2549409, "end": 2549600 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Khartoum", "start": 2549600, "end": 2550058 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kigali", "start": 2550058, "end": 2550189 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kinshasa", "start": 2550189, "end": 2550369 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lagos", "start": 2550369, "end": 2550549 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Libreville", "start": 2550549, "end": 2550729 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lome", "start": 2550729, "end": 2550859 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Luanda", "start": 2550859, "end": 2551039 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lubumbashi", "start": 2551039, "end": 2551170 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lusaka", "start": 2551170, "end": 2551301 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Malabo", "start": 2551301, "end": 2551481 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Maputo", "start": 2551481, "end": 2551612 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Maseru", "start": 2551612, "end": 2551802 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Mbabane", "start": 2551802, "end": 2551992 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Mogadishu", "start": 2551992, "end": 2552183 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Monrovia", "start": 2552183, "end": 2552347 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Nairobi", "start": 2552347, "end": 2552538 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ndjamena", "start": 2552538, "end": 2552698 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Niamey", "start": 2552698, "end": 2552878 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Nouakchott", "start": 2552878, "end": 2553008 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ouagadougou", "start": 2553008, "end": 2553138 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Porto-Novo", "start": 2553138, "end": 2553318 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Sao_Tome", "start": 2553318, "end": 2553491 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Timbuktu", "start": 2553491, "end": 2553621 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Tripoli", "start": 2553621, "end": 2554052 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Tunis", "start": 2554052, "end": 2554501 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Africa/Windhoek", "start": 2554501, "end": 2555139 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Adak", "start": 2555139, "end": 2556108 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Anchorage", "start": 2556108, "end": 2557085 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Anguilla", "start": 2557085, "end": 2557262 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Antigua", "start": 2557262, "end": 2557439 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Araguaina", "start": 2557439, "end": 2558031 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Buenos_Aires", "start": 2558031, "end": 2558739 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Catamarca", "start": 2558739, "end": 2559447 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/ComodRivadavia", "start": 2559447, "end": 2560155 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Cordoba", "start": 2560155, "end": 2560863 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Jujuy", "start": 2560863, "end": 2561553 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/La_Rioja", "start": 2561553, "end": 2562270 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Mendoza", "start": 2562270, "end": 2562978 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Rio_Gallegos", "start": 2562978, "end": 2563686 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Salta", "start": 2563686, "end": 2564376 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Juan", "start": 2564376, "end": 2565093 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Luis", "start": 2565093, "end": 2565810 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Tucuman", "start": 2565810, "end": 2566536 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Ushuaia", "start": 2566536, "end": 2567244 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Aruba", "start": 2567244, "end": 2567421 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Asuncion", "start": 2567421, "end": 2568305 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Atikokan", "start": 2568305, "end": 2568454 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Atka", "start": 2568454, "end": 2569423 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Bahia", "start": 2569423, "end": 2570105 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Bahia_Banderas", "start": 2570105, "end": 2570833 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Barbados", "start": 2570833, "end": 2571111 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Belem", "start": 2571111, "end": 2571505 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Belize", "start": 2571505, "end": 2572550 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Blanc-Sablon", "start": 2572550, "end": 2572727 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Boa_Vista", "start": 2572727, "end": 2573157 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Bogota", "start": 2573157, "end": 2573336 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Boise", "start": 2573336, "end": 2574335 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Buenos_Aires", "start": 2574335, "end": 2575043 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cambridge_Bay", "start": 2575043, "end": 2575926 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Campo_Grande", "start": 2575926, "end": 2576878 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cancun", "start": 2576878, "end": 2577407 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Caracas", "start": 2577407, "end": 2577597 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Catamarca", "start": 2577597, "end": 2578305 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cayenne", "start": 2578305, "end": 2578456 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cayman", "start": 2578456, "end": 2578605 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Chicago", "start": 2578605, "end": 2580359 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Chihuahua", "start": 2580359, "end": 2581050 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Ciudad_Juarez", "start": 2581050, "end": 2581768 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Coral_Harbour", "start": 2581768, "end": 2581917 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cordoba", "start": 2581917, "end": 2582625 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Costa_Rica", "start": 2582625, "end": 2582857 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Creston", "start": 2582857, "end": 2583097 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Cuiaba", "start": 2583097, "end": 2584031 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Curacao", "start": 2584031, "end": 2584208 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Danmarkshavn", "start": 2584208, "end": 2584655 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Dawson", "start": 2584655, "end": 2585684 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Dawson_Creek", "start": 2585684, "end": 2586367 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Denver", "start": 2586367, "end": 2587409 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Detroit", "start": 2587409, "end": 2588308 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Dominica", "start": 2588308, "end": 2588485 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Edmonton", "start": 2588485, "end": 2589455 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Eirunepe", "start": 2589455, "end": 2589891 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/El_Salvador", "start": 2589891, "end": 2590067 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Ensenada", "start": 2590067, "end": 2591092 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Fort_Nelson", "start": 2591092, "end": 2592540 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Fort_Wayne", "start": 2592540, "end": 2593071 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Fortaleza", "start": 2593071, "end": 2593555 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Glace_Bay", "start": 2593555, "end": 2594435 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Godthab", "start": 2594435, "end": 2595400 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Goose_Bay", "start": 2595400, "end": 2596980 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Grand_Turk", "start": 2596980, "end": 2597833 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Grenada", "start": 2597833, "end": 2598010 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Guadeloupe", "start": 2598010, "end": 2598187 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Guatemala", "start": 2598187, "end": 2598399 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Guayaquil", "start": 2598399, "end": 2598578 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Guyana", "start": 2598578, "end": 2598759 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Halifax", "start": 2598759, "end": 2600431 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Havana", "start": 2600431, "end": 2601548 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Hermosillo", "start": 2601548, "end": 2601834 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Indianapolis", "start": 2601834, "end": 2602365 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Knox", "start": 2602365, "end": 2603381 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Marengo", "start": 2603381, "end": 2603948 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Petersburg", "start": 2603948, "end": 2604631 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Tell_City", "start": 2604631, "end": 2605153 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vevay", "start": 2605153, "end": 2605522 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vincennes", "start": 2605522, "end": 2606080 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Winamac", "start": 2606080, "end": 2606692 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Indianapolis", "start": 2606692, "end": 2607223 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Inuvik", "start": 2607223, "end": 2608040 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Iqaluit", "start": 2608040, "end": 2608895 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Jamaica", "start": 2608895, "end": 2609234 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Jujuy", "start": 2609234, "end": 2609924 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Juneau", "start": 2609924, "end": 2610890 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Louisville", "start": 2610890, "end": 2612132 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Monticello", "start": 2612132, "end": 2613104 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Knox_IN", "start": 2613104, "end": 2614120 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Kralendijk", "start": 2614120, "end": 2614297 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/La_Paz", "start": 2614297, "end": 2614467 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Lima", "start": 2614467, "end": 2614750 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Los_Angeles", "start": 2614750, "end": 2616044 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Louisville", "start": 2616044, "end": 2617286 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Lower_Princes", "start": 2617286, "end": 2617463 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Maceio", "start": 2617463, "end": 2617965 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Managua", "start": 2617965, "end": 2618260 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Manaus", "start": 2618260, "end": 2618672 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Marigot", "start": 2618672, "end": 2618849 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Martinique", "start": 2618849, "end": 2619027 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Matamoros", "start": 2619027, "end": 2619464 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Mazatlan", "start": 2619464, "end": 2620182 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Mendoza", "start": 2620182, "end": 2620890 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Menominee", "start": 2620890, "end": 2621807 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Merida", "start": 2621807, "end": 2622461 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Metlakatla", "start": 2622461, "end": 2623056 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Mexico_City", "start": 2623056, "end": 2623829 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Miquelon", "start": 2623829, "end": 2624379 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Moncton", "start": 2624379, "end": 2625872 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Monterrey", "start": 2625872, "end": 2626516 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Montevideo", "start": 2626516, "end": 2627485 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Montreal", "start": 2627485, "end": 2629202 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Montserrat", "start": 2629202, "end": 2629379 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Nassau", "start": 2629379, "end": 2631096 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/New_York", "start": 2631096, "end": 2632840 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Nipigon", "start": 2632840, "end": 2634557 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Nome", "start": 2634557, "end": 2635532 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Noronha", "start": 2635532, "end": 2636016 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Beulah", "start": 2636016, "end": 2637059 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Center", "start": 2637059, "end": 2638049 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/New_Salem", "start": 2638049, "end": 2639039 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Nuuk", "start": 2639039, "end": 2640004 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Ojinaga", "start": 2640004, "end": 2640713 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Panama", "start": 2640713, "end": 2640862 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Pangnirtung", "start": 2640862, "end": 2641717 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Paramaribo", "start": 2641717, "end": 2641904 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Phoenix", "start": 2641904, "end": 2642144 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Port-au-Prince", "start": 2642144, "end": 2642709 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Port_of_Spain", "start": 2642709, "end": 2642886 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Porto_Acre", "start": 2642886, "end": 2643304 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Porto_Velho", "start": 2643304, "end": 2643698 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Puerto_Rico", "start": 2643698, "end": 2643875 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Punta_Arenas", "start": 2643875, "end": 2645093 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Rainy_River", "start": 2645093, "end": 2646387 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Rankin_Inlet", "start": 2646387, "end": 2647194 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Recife", "start": 2647194, "end": 2647678 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Regina", "start": 2647678, "end": 2648316 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Resolute", "start": 2648316, "end": 2649123 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Rio_Branco", "start": 2649123, "end": 2649541 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Rosario", "start": 2649541, "end": 2650249 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Santa_Isabel", "start": 2650249, "end": 2651274 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Santarem", "start": 2651274, "end": 2651683 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Santiago", "start": 2651683, "end": 2653037 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Santo_Domingo", "start": 2653037, "end": 2653354 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Sao_Paulo", "start": 2653354, "end": 2654306 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Scoresbysund", "start": 2654306, "end": 2655290 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Shiprock", "start": 2655290, "end": 2656332 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Sitka", "start": 2656332, "end": 2657288 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Barthelemy", "start": 2657288, "end": 2657465 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Johns", "start": 2657465, "end": 2659343 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Kitts", "start": 2659343, "end": 2659520 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Lucia", "start": 2659520, "end": 2659697 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Thomas", "start": 2659697, "end": 2659874 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/St_Vincent", "start": 2659874, "end": 2660051 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Swift_Current", "start": 2660051, "end": 2660419 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Tegucigalpa", "start": 2660419, "end": 2660613 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Thule", "start": 2660613, "end": 2661068 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Thunder_Bay", "start": 2661068, "end": 2662785 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Tijuana", "start": 2662785, "end": 2663810 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Toronto", "start": 2663810, "end": 2665527 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Tortola", "start": 2665527, "end": 2665704 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Vancouver", "start": 2665704, "end": 2667034 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Virgin", "start": 2667034, "end": 2667211 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Whitehorse", "start": 2667211, "end": 2668240 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Winnipeg", "start": 2668240, "end": 2669534 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Yakutat", "start": 2669534, "end": 2670480 }, { "filename": "/tmp/pglite/share/postgresql/timezone/America/Yellowknife", "start": 2670480, "end": 2671450 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Casey", "start": 2671450, "end": 2671737 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Davis", "start": 2671737, "end": 2671934 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/DumontDUrville", "start": 2671934, "end": 2672088 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Macquarie", "start": 2672088, "end": 2673064 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Mawson", "start": 2673064, "end": 2673216 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/McMurdo", "start": 2673216, "end": 2674259 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Palmer", "start": 2674259, "end": 2675146 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Rothera", "start": 2675146, "end": 2675278 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/South_Pole", "start": 2675278, "end": 2676321 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Syowa", "start": 2676321, "end": 2676454 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Troll", "start": 2676454, "end": 2676631 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Vostok", "start": 2676631, "end": 2676801 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Arctic/Longyearbyen", "start": 2676801, "end": 2677506 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aden", "start": 2677506, "end": 2677639 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Almaty", "start": 2677639, "end": 2678257 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Amman", "start": 2678257, "end": 2679185 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Anadyr", "start": 2679185, "end": 2679928 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aqtau", "start": 2679928, "end": 2680534 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aqtobe", "start": 2680534, "end": 2681149 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ashgabat", "start": 2681149, "end": 2681524 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ashkhabad", "start": 2681524, "end": 2681899 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Atyrau", "start": 2681899, "end": 2682515 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Baghdad", "start": 2682515, "end": 2683145 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bahrain", "start": 2683145, "end": 2683297 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Baku", "start": 2683297, "end": 2684041 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bangkok", "start": 2684041, "end": 2684193 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Barnaul", "start": 2684193, "end": 2684946 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Beirut", "start": 2684946, "end": 2685678 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bishkek", "start": 2685678, "end": 2686296 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Brunei", "start": 2686296, "end": 2686616 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Calcutta", "start": 2686616, "end": 2686836 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chita", "start": 2686836, "end": 2687586 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Choibalsan", "start": 2687586, "end": 2688205 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chongqing", "start": 2688205, "end": 2688598 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chungking", "start": 2688598, "end": 2688991 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Colombo", "start": 2688991, "end": 2689238 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dacca", "start": 2689238, "end": 2689469 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Damascus", "start": 2689469, "end": 2690703 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dhaka", "start": 2690703, "end": 2690934 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dili", "start": 2690934, "end": 2691104 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dubai", "start": 2691104, "end": 2691237 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dushanbe", "start": 2691237, "end": 2691603 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Famagusta", "start": 2691603, "end": 2692543 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Gaza", "start": 2692543, "end": 2694989 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Harbin", "start": 2694989, "end": 2695382 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hebron", "start": 2695382, "end": 2697846 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ho_Chi_Minh", "start": 2697846, "end": 2698082 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hong_Kong", "start": 2698082, "end": 2698857 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hovd", "start": 2698857, "end": 2699451 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Irkutsk", "start": 2699451, "end": 2700211 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Istanbul", "start": 2700211, "end": 2701411 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jakarta", "start": 2701411, "end": 2701659 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jayapura", "start": 2701659, "end": 2701830 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jerusalem", "start": 2701830, "end": 2702904 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kabul", "start": 2702904, "end": 2703063 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kamchatka", "start": 2703063, "end": 2703790 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Karachi", "start": 2703790, "end": 2704056 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kashgar", "start": 2704056, "end": 2704189 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kathmandu", "start": 2704189, "end": 2704350 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Katmandu", "start": 2704350, "end": 2704511 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Khandyga", "start": 2704511, "end": 2705286 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kolkata", "start": 2705286, "end": 2705506 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Krasnoyarsk", "start": 2705506, "end": 2706247 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuala_Lumpur", "start": 2706247, "end": 2706503 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuching", "start": 2706503, "end": 2706823 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuwait", "start": 2706823, "end": 2706956 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Macao", "start": 2706956, "end": 2707747 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Macau", "start": 2707747, "end": 2708538 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Magadan", "start": 2708538, "end": 2709289 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Makassar", "start": 2709289, "end": 2709479 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Manila", "start": 2709479, "end": 2709717 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Muscat", "start": 2709717, "end": 2709850 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Nicosia", "start": 2709850, "end": 2710447 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Novokuznetsk", "start": 2710447, "end": 2711173 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Novosibirsk", "start": 2711173, "end": 2711926 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Omsk", "start": 2711926, "end": 2712667 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Oral", "start": 2712667, "end": 2713292 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Phnom_Penh", "start": 2713292, "end": 2713444 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Pontianak", "start": 2713444, "end": 2713691 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Pyongyang", "start": 2713691, "end": 2713874 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qatar", "start": 2713874, "end": 2714026 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qostanay", "start": 2714026, "end": 2714650 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qyzylorda", "start": 2714650, "end": 2715274 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Rangoon", "start": 2715274, "end": 2715461 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Riyadh", "start": 2715461, "end": 2715594 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Saigon", "start": 2715594, "end": 2715830 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Sakhalin", "start": 2715830, "end": 2716585 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Samarkand", "start": 2716585, "end": 2716951 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Seoul", "start": 2716951, "end": 2717366 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Shanghai", "start": 2717366, "end": 2717759 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Singapore", "start": 2717759, "end": 2718015 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Srednekolymsk", "start": 2718015, "end": 2718757 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Taipei", "start": 2718757, "end": 2719268 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tashkent", "start": 2719268, "end": 2719634 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tbilisi", "start": 2719634, "end": 2720263 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tehran", "start": 2720263, "end": 2721075 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tel_Aviv", "start": 2721075, "end": 2722149 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Thimbu", "start": 2722149, "end": 2722303 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Thimphu", "start": 2722303, "end": 2722457 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tokyo", "start": 2722457, "end": 2722670 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tomsk", "start": 2722670, "end": 2723423 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ujung_Pandang", "start": 2723423, "end": 2723613 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ulaanbaatar", "start": 2723613, "end": 2724207 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ulan_Bator", "start": 2724207, "end": 2724801 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Urumqi", "start": 2724801, "end": 2724934 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ust-Nera", "start": 2724934, "end": 2725705 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Vientiane", "start": 2725705, "end": 2725857 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Vladivostok", "start": 2725857, "end": 2726599 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yakutsk", "start": 2726599, "end": 2727340 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yangon", "start": 2727340, "end": 2727527 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yekaterinburg", "start": 2727527, "end": 2728287 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yerevan", "start": 2728287, "end": 2728995 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Azores", "start": 2728995, "end": 2730448 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Bermuda", "start": 2730448, "end": 2731472 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Canary", "start": 2731472, "end": 2731950 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Cape_Verde", "start": 2731950, "end": 2732125 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Faeroe", "start": 2732125, "end": 2732566 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Faroe", "start": 2732566, "end": 2733007 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Jan_Mayen", "start": 2733007, "end": 2733712 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Madeira", "start": 2733712, "end": 2735165 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Reykjavik", "start": 2735165, "end": 2735295 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/South_Georgia", "start": 2735295, "end": 2735427 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/St_Helena", "start": 2735427, "end": 2735557 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Stanley", "start": 2735557, "end": 2736346 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/ACT", "start": 2736346, "end": 2737250 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Adelaide", "start": 2737250, "end": 2738171 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Brisbane", "start": 2738171, "end": 2738460 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Broken_Hill", "start": 2738460, "end": 2739401 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Canberra", "start": 2739401, "end": 2740305 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Currie", "start": 2740305, "end": 2741308 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Darwin", "start": 2741308, "end": 2741542 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Eucla", "start": 2741542, "end": 2741856 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Hobart", "start": 2741856, "end": 2742859 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/LHI", "start": 2742859, "end": 2743551 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Lindeman", "start": 2743551, "end": 2743876 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Lord_Howe", "start": 2743876, "end": 2744568 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Melbourne", "start": 2744568, "end": 2745472 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/NSW", "start": 2745472, "end": 2746376 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/North", "start": 2746376, "end": 2746610 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Perth", "start": 2746610, "end": 2746916 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Queensland", "start": 2746916, "end": 2747205 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/South", "start": 2747205, "end": 2748126 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Sydney", "start": 2748126, "end": 2749030 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Tasmania", "start": 2749030, "end": 2750033 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Victoria", "start": 2750033, "end": 2750937 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/West", "start": 2750937, "end": 2751243 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Australia/Yancowinna", "start": 2751243, "end": 2752184 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Brazil/Acre", "start": 2752184, "end": 2752602 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Brazil/DeNoronha", "start": 2752602, "end": 2753086 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Brazil/East", "start": 2753086, "end": 2754038 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Brazil/West", "start": 2754038, "end": 2754450 }, { "filename": "/tmp/pglite/share/postgresql/timezone/CET", "start": 2754450, "end": 2755071 }, { "filename": "/tmp/pglite/share/postgresql/timezone/CST6CDT", "start": 2755071, "end": 2756022 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Atlantic", "start": 2756022, "end": 2757694 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Central", "start": 2757694, "end": 2758988 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Eastern", "start": 2758988, "end": 2760705 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Mountain", "start": 2760705, "end": 2761675 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Newfoundland", "start": 2761675, "end": 2763553 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Pacific", "start": 2763553, "end": 2764883 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Saskatchewan", "start": 2764883, "end": 2765521 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Canada/Yukon", "start": 2765521, "end": 2766550 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Chile/Continental", "start": 2766550, "end": 2767904 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Chile/EasterIsland", "start": 2767904, "end": 2769078 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Cuba", "start": 2769078, "end": 2770195 }, { "filename": "/tmp/pglite/share/postgresql/timezone/EET", "start": 2770195, "end": 2770692 }, { "filename": "/tmp/pglite/share/postgresql/timezone/EST", "start": 2770692, "end": 2770803 }, { "filename": "/tmp/pglite/share/postgresql/timezone/EST5EDT", "start": 2770803, "end": 2771754 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Egypt", "start": 2771754, "end": 2773063 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Eire", "start": 2773063, "end": 2774559 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT", "start": 2774559, "end": 2774670 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+0", "start": 2774670, "end": 2774781 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+1", "start": 2774781, "end": 2774894 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+10", "start": 2774894, "end": 2775008 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+11", "start": 2775008, "end": 2775122 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+12", "start": 2775122, "end": 2775236 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+2", "start": 2775236, "end": 2775349 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+3", "start": 2775349, "end": 2775462 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+4", "start": 2775462, "end": 2775575 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+5", "start": 2775575, "end": 2775688 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+6", "start": 2775688, "end": 2775801 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+7", "start": 2775801, "end": 2775914 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+8", "start": 2775914, "end": 2776027 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+9", "start": 2776027, "end": 2776140 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-0", "start": 2776140, "end": 2776251 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-1", "start": 2776251, "end": 2776365 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-10", "start": 2776365, "end": 2776480 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-11", "start": 2776480, "end": 2776595 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-12", "start": 2776595, "end": 2776710 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-13", "start": 2776710, "end": 2776825 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-14", "start": 2776825, "end": 2776940 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-2", "start": 2776940, "end": 2777054 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-3", "start": 2777054, "end": 2777168 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-4", "start": 2777168, "end": 2777282 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-5", "start": 2777282, "end": 2777396 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-6", "start": 2777396, "end": 2777510 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-7", "start": 2777510, "end": 2777624 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-8", "start": 2777624, "end": 2777738 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-9", "start": 2777738, "end": 2777852 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT0", "start": 2777852, "end": 2777963 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/Greenwich", "start": 2777963, "end": 2778074 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/UCT", "start": 2778074, "end": 2778185 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/UTC", "start": 2778185, "end": 2778296 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/Universal", "start": 2778296, "end": 2778407 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Etc/Zulu", "start": 2778407, "end": 2778518 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Amsterdam", "start": 2778518, "end": 2779621 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Andorra", "start": 2779621, "end": 2780010 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Astrakhan", "start": 2780010, "end": 2780736 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Athens", "start": 2780736, "end": 2781418 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Belfast", "start": 2781418, "end": 2783017 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Belgrade", "start": 2783017, "end": 2783495 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Berlin", "start": 2783495, "end": 2784200 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Bratislava", "start": 2784200, "end": 2784923 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Brussels", "start": 2784923, "end": 2786026 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Bucharest", "start": 2786026, "end": 2786687 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Budapest", "start": 2786687, "end": 2787453 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Busingen", "start": 2787453, "end": 2787950 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Chisinau", "start": 2787950, "end": 2788705 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Copenhagen", "start": 2788705, "end": 2789410 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Dublin", "start": 2789410, "end": 2790906 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Gibraltar", "start": 2790906, "end": 2792126 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Guernsey", "start": 2792126, "end": 2793725 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Helsinki", "start": 2793725, "end": 2794206 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Isle_of_Man", "start": 2794206, "end": 2795805 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Istanbul", "start": 2795805, "end": 2797005 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Jersey", "start": 2797005, "end": 2798604 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kaliningrad", "start": 2798604, "end": 2799508 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kiev", "start": 2799508, "end": 2800066 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kirov", "start": 2800066, "end": 2800801 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kyiv", "start": 2800801, "end": 2801359 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Lisbon", "start": 2801359, "end": 2802813 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Ljubljana", "start": 2802813, "end": 2803291 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/London", "start": 2803291, "end": 2804890 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Luxembourg", "start": 2804890, "end": 2805993 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Madrid", "start": 2805993, "end": 2806890 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Malta", "start": 2806890, "end": 2807818 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Mariehamn", "start": 2807818, "end": 2808299 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Minsk", "start": 2808299, "end": 2809107 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Monaco", "start": 2809107, "end": 2810212 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Moscow", "start": 2810212, "end": 2811120 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Nicosia", "start": 2811120, "end": 2811717 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Oslo", "start": 2811717, "end": 2812422 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Paris", "start": 2812422, "end": 2813527 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Podgorica", "start": 2813527, "end": 2814005 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Prague", "start": 2814005, "end": 2814728 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Riga", "start": 2814728, "end": 2815422 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Rome", "start": 2815422, "end": 2816369 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Samara", "start": 2816369, "end": 2817101 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/San_Marino", "start": 2817101, "end": 2818048 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Sarajevo", "start": 2818048, "end": 2818526 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Saratov", "start": 2818526, "end": 2819252 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Simferopol", "start": 2819252, "end": 2820117 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Skopje", "start": 2820117, "end": 2820595 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Sofia", "start": 2820595, "end": 2821187 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Stockholm", "start": 2821187, "end": 2821892 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tallinn", "start": 2821892, "end": 2822567 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tirane", "start": 2822567, "end": 2823171 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tiraspol", "start": 2823171, "end": 2823926 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Ulyanovsk", "start": 2823926, "end": 2824686 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Uzhgorod", "start": 2824686, "end": 2825244 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vaduz", "start": 2825244, "end": 2825741 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vatican", "start": 2825741, "end": 2826688 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vienna", "start": 2826688, "end": 2827346 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vilnius", "start": 2827346, "end": 2828022 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Volgograd", "start": 2828022, "end": 2828775 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Warsaw", "start": 2828775, "end": 2829698 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zagreb", "start": 2829698, "end": 2830176 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zaporozhye", "start": 2830176, "end": 2830734 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zurich", "start": 2830734, "end": 2831231 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Factory", "start": 2831231, "end": 2831344 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GB", "start": 2831344, "end": 2832943 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GB-Eire", "start": 2832943, "end": 2834542 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GMT", "start": 2834542, "end": 2834653 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GMT+0", "start": 2834653, "end": 2834764 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GMT-0", "start": 2834764, "end": 2834875 }, { "filename": "/tmp/pglite/share/postgresql/timezone/GMT0", "start": 2834875, "end": 2834986 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Greenwich", "start": 2834986, "end": 2835097 }, { "filename": "/tmp/pglite/share/postgresql/timezone/HST", "start": 2835097, "end": 2835209 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Hongkong", "start": 2835209, "end": 2835984 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Iceland", "start": 2835984, "end": 2836114 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Antananarivo", "start": 2836114, "end": 2836305 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Chagos", "start": 2836305, "end": 2836457 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Christmas", "start": 2836457, "end": 2836609 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Cocos", "start": 2836609, "end": 2836796 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Comoro", "start": 2836796, "end": 2836987 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Kerguelen", "start": 2836987, "end": 2837139 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mahe", "start": 2837139, "end": 2837272 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Maldives", "start": 2837272, "end": 2837424 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mauritius", "start": 2837424, "end": 2837603 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mayotte", "start": 2837603, "end": 2837794 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Indian/Reunion", "start": 2837794, "end": 2837927 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Iran", "start": 2837927, "end": 2838739 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Israel", "start": 2838739, "end": 2839813 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Jamaica", "start": 2839813, "end": 2840152 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Japan", "start": 2840152, "end": 2840365 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Kwajalein", "start": 2840365, "end": 2840584 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Libya", "start": 2840584, "end": 2841015 }, { "filename": "/tmp/pglite/share/postgresql/timezone/MET", "start": 2841015, "end": 2841636 }, { "filename": "/tmp/pglite/share/postgresql/timezone/MST", "start": 2841636, "end": 2841747 }, { "filename": "/tmp/pglite/share/postgresql/timezone/MST7MDT", "start": 2841747, "end": 2842698 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Mexico/BajaNorte", "start": 2842698, "end": 2843723 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Mexico/BajaSur", "start": 2843723, "end": 2844441 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Mexico/General", "start": 2844441, "end": 2845214 }, { "filename": "/tmp/pglite/share/postgresql/timezone/NZ", "start": 2845214, "end": 2846257 }, { "filename": "/tmp/pglite/share/postgresql/timezone/NZ-CHAT", "start": 2846257, "end": 2847065 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Navajo", "start": 2847065, "end": 2848107 }, { "filename": "/tmp/pglite/share/postgresql/timezone/PRC", "start": 2848107, "end": 2848500 }, { "filename": "/tmp/pglite/share/postgresql/timezone/PST8PDT", "start": 2848500, "end": 2849451 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Apia", "start": 2849451, "end": 2849858 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Auckland", "start": 2849858, "end": 2850901 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Bougainville", "start": 2850901, "end": 2851102 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Chatham", "start": 2851102, "end": 2851910 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Chuuk", "start": 2851910, "end": 2852064 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Easter", "start": 2852064, "end": 2853238 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Efate", "start": 2853238, "end": 2853580 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Enderbury", "start": 2853580, "end": 2853752 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Fakaofo", "start": 2853752, "end": 2853905 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Fiji", "start": 2853905, "end": 2854301 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Funafuti", "start": 2854301, "end": 2854435 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Galapagos", "start": 2854435, "end": 2854610 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Gambier", "start": 2854610, "end": 2854742 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Guadalcanal", "start": 2854742, "end": 2854876 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Guam", "start": 2854876, "end": 2855226 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Honolulu", "start": 2855226, "end": 2855447 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Johnston", "start": 2855447, "end": 2855668 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kanton", "start": 2855668, "end": 2855840 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kiritimati", "start": 2855840, "end": 2856014 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kosrae", "start": 2856014, "end": 2856256 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kwajalein", "start": 2856256, "end": 2856475 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Majuro", "start": 2856475, "end": 2856609 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Marquesas", "start": 2856609, "end": 2856748 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Midway", "start": 2856748, "end": 2856894 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Nauru", "start": 2856894, "end": 2857077 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Niue", "start": 2857077, "end": 2857231 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Norfolk", "start": 2857231, "end": 2857478 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Noumea", "start": 2857478, "end": 2857676 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pago_Pago", "start": 2857676, "end": 2857822 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Palau", "start": 2857822, "end": 2857970 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pitcairn", "start": 2857970, "end": 2858123 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pohnpei", "start": 2858123, "end": 2858257 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Ponape", "start": 2858257, "end": 2858391 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Port_Moresby", "start": 2858391, "end": 2858545 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Rarotonga", "start": 2858545, "end": 2858951 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Saipan", "start": 2858951, "end": 2859301 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Samoa", "start": 2859301, "end": 2859447 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tahiti", "start": 2859447, "end": 2859580 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tarawa", "start": 2859580, "end": 2859714 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tongatapu", "start": 2859714, "end": 2859951 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Truk", "start": 2859951, "end": 2860105 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Wake", "start": 2860105, "end": 2860239 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Wallis", "start": 2860239, "end": 2860373 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Yap", "start": 2860373, "end": 2860527 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Poland", "start": 2860527, "end": 2861450 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Portugal", "start": 2861450, "end": 2862904 }, { "filename": "/tmp/pglite/share/postgresql/timezone/ROC", "start": 2862904, "end": 2863415 }, { "filename": "/tmp/pglite/share/postgresql/timezone/ROK", "start": 2863415, "end": 2863830 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Singapore", "start": 2863830, "end": 2864086 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Turkey", "start": 2864086, "end": 2865286 }, { "filename": "/tmp/pglite/share/postgresql/timezone/UCT", "start": 2865286, "end": 2865397 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Alaska", "start": 2865397, "end": 2866374 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Aleutian", "start": 2866374, "end": 2867343 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Arizona", "start": 2867343, "end": 2867583 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Central", "start": 2867583, "end": 2869337 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/East-Indiana", "start": 2869337, "end": 2869868 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Eastern", "start": 2869868, "end": 2871612 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Hawaii", "start": 2871612, "end": 2871833 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Indiana-Starke", "start": 2871833, "end": 2872849 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Michigan", "start": 2872849, "end": 2873748 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Mountain", "start": 2873748, "end": 2874790 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Pacific", "start": 2874790, "end": 2876084 }, { "filename": "/tmp/pglite/share/postgresql/timezone/US/Samoa", "start": 2876084, "end": 2876230 }, { "filename": "/tmp/pglite/share/postgresql/timezone/UTC", "start": 2876230, "end": 2876341 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Universal", "start": 2876341, "end": 2876452 }, { "filename": "/tmp/pglite/share/postgresql/timezone/W-SU", "start": 2876452, "end": 2877360 }, { "filename": "/tmp/pglite/share/postgresql/timezone/WET", "start": 2877360, "end": 2877854 }, { "filename": "/tmp/pglite/share/postgresql/timezone/Zulu", "start": 2877854, "end": 2877965 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Africa.txt", "start": 2877965, "end": 2884938 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/America.txt", "start": 2884938, "end": 2895945 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Antarctica.txt", "start": 2895945, "end": 2897079 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Asia.txt", "start": 2897079, "end": 2905390 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Atlantic.txt", "start": 2905390, "end": 2908923 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Australia", "start": 2908923, "end": 2910058 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Australia.txt", "start": 2910058, "end": 2913442 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Default", "start": 2913442, "end": 2940692 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Etc.txt", "start": 2940692, "end": 2941942 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Europe.txt", "start": 2941942, "end": 2950724 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/India", "start": 2950724, "end": 2951317 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Indian.txt", "start": 2951317, "end": 2952578 }, { "filename": "/tmp/pglite/share/postgresql/timezonesets/Pacific.txt", "start": 2952578, "end": 2956346 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/danish.stop", "start": 2956346, "end": 2956770 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/dutch.stop", "start": 2956770, "end": 2957223 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/english.stop", "start": 2957223, "end": 2957845 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/finnish.stop", "start": 2957845, "end": 2959424 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/french.stop", "start": 2959424, "end": 2960229 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/german.stop", "start": 2960229, "end": 2961578 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hungarian.stop", "start": 2961578, "end": 2962805 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample.affix", "start": 2962805, "end": 2963048 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.affix", "start": 2963048, "end": 2963681 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.dict", "start": 2963681, "end": 2963779 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.affix", "start": 2963779, "end": 2964241 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.dict", "start": 2964241, "end": 2964370 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.affix", "start": 2964370, "end": 2964835 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.dict", "start": 2964835, "end": 2964916 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/italian.stop", "start": 2964916, "end": 2966570 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/nepali.stop", "start": 2966570, "end": 2970831 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/norwegian.stop", "start": 2970831, "end": 2971682 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/portuguese.stop", "start": 2971682, "end": 2972949 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/russian.stop", "start": 2972949, "end": 2974184 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/spanish.stop", "start": 2974184, "end": 2976362 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/swedish.stop", "start": 2976362, "end": 2976921 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/synonym_sample.syn", "start": 2976921, "end": 2976994 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/thesaurus_sample.ths", "start": 2976994, "end": 2977467 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/turkish.stop", "start": 2977467, "end": 2977727 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/unaccent.rules", "start": 2977727, "end": 2987666 }, { "filename": "/tmp/pglite/share/postgresql/tsearch_data/xsyn_sample.rules", "start": 2987666, "end": 2987805 }], "remote_package_size": 2987805 });
    })();
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var scriptDirectory = "";
    function locateFile(path2) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path2, scriptDirectory);
      }
      return scriptDirectory + path2;
    }
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs");
      var nodePath = require("path");
      if (!import_meta2.url.startsWith("data:")) {
        scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import_meta2.url)) + "/";
      }
      readBinary = (filename) => {
        filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
        var ret = fs.readFileSync(filename);
        return ret;
      };
      readAsync = (filename, binary2 = true) => {
        filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
        return new Promise((resolve2, reject) => {
          fs.readFile(filename, binary2 ? void 0 : "utf8", (err2, data) => {
            if (err2)
              reject(err2);
            else
              resolve2(binary2 ? data.buffer : data);
          });
        });
      };
      if (!Module["thisProgram"] && process4.argv.length > 1) {
        thisProgram = process4.argv[1].replace(/\\/g, "/");
      }
      arguments_ = process4.argv.slice(2);
      quit_ = (status, toThrow) => {
        process4.exitCode = status;
        throw toThrow;
      };
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(
              /** @type{!ArrayBuffer} */
              xhr.response
            );
          };
        }
        readAsync = (url) => {
          if (isFileURI(url)) {
            return new Promise((resolve2, reject) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  resolve2(xhr.response);
                  return;
                }
                reject(xhr.status);
              };
              xhr.onerror = reject;
              xhr.send(null);
            });
          }
          return fetch(url, { credentials: "same-origin" }).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            }
            return Promise.reject(new Error(response.status + " : " + response.url));
          });
        };
      }
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.error.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"])
      arguments_ = Module["arguments"];
    if (Module["thisProgram"])
      thisProgram = Module["thisProgram"];
    var dynamicLibraries = Module["dynamicLibraries"] || [];
    var wasmBinary = Module["wasmBinary"];
    function intArrayFromBase64(s5) {
      if (typeof ENVIRONMENT_IS_NODE != "undefined" && ENVIRONMENT_IS_NODE) {
        var buf = Buffer.from(s5, "base64");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
      var decoded = atob(s5);
      var bytes = new Uint8Array(decoded.length);
      for (var i3 = 0; i3 < decoded.length; ++i3) {
        bytes[i3] = decoded.charCodeAt(i3);
      }
      return bytes;
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var b4 = wasmMemory.buffer;
      Module["HEAP8"] = HEAP8 = new Int8Array(b4);
      Module["HEAP16"] = HEAP16 = new Int16Array(b4);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b4);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b4);
      Module["HEAP32"] = HEAP32 = new Int32Array(b4);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b4);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b4);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b4);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b4);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b4);
    }
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 134217728;
      wasmMemory = new WebAssembly.Memory({
        "initial": INITIAL_MEMORY / 65536,
        // In theory we should not need to emit the maximum if we want "unlimited"
        // or 4GB of memory, but VMs error on that atm, see
        // https://github.com/emscripten-core/emscripten/issues/14130
        // And in the pthreads case we definitely need to emit a maximum. So
        // always emit one.
        "maximum": 32768
      });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];
    var __RELOC_FUNCS__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__RELOC_FUNCS__);
      if (!Module["noFSInit"] && !FS.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      SOCKFS.root = FS.mount(SOCKFS, {}, null);
      PIPEFS.root = FS.mount(PIPEFS, {}, null);
      callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPreMain(cb) {
      __ATMAIN__.unshift(cb);
    }
    function addOnExit(cb) {
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      Module["monitorRunDependencies"]?.(runDependencies);
    }
    function removeRunDependency(id) {
      runDependencies--;
      Module["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      Module["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
    var isFileURI = (filename) => filename.startsWith("file://");
    function findWasmBinary() {
      if (Module["locateFile"]) {
        var f3 = "postgres.wasm";
        if (!isDataURI(f3)) {
          return locateFile(f3);
        }
        return f3;
      }
      return new URL("postgres.wasm", import_meta2.url).href;
    }
    var wasmBinaryFile;
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    function getBinaryPromise(binaryFile) {
      if (!wasmBinary) {
        return readAsync(binaryFile).then(
          (response) => new Uint8Array(
            /** @type{!ArrayBuffer} */
            response
          ),
          // Fall back to getBinarySync if readAsync fails
          () => getBinarySync(binaryFile)
        );
      }
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary2) => {
        return WebAssembly.instantiate(binary2, imports);
      }).then(receiver, (reason) => {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      });
    }
    function instantiateAsync(binary2, binaryFile, imports, callback) {
      if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      !isFileURI(binaryFile) && // Avoid instantiateStreaming() on Node.js environment for now, as while
      // Node.js v18.1.0 implements it, it does not have a full fetch()
      // implementation yet.
      //
      // Reference:
      //   https://github.com/emscripten-core/emscripten/pull/16917
      !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
        return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
          var result = WebAssembly.instantiateStreaming(response, imports);
          return result.then(
            callback,
            function(reason) {
              err(`wasm streaming compile failed: ${reason}`);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            }
          );
        });
      }
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    function getWasmImports() {
      return {
        "env": wasmImports,
        "wasi_snapshot_preview1": wasmImports,
        "GOT.mem": new Proxy(wasmImports, GOTHandler),
        "GOT.func": new Proxy(wasmImports, GOTHandler)
      };
    }
    function createWasm() {
      var info2 = getWasmImports();
      function receiveInstance(instance2, module2) {
        wasmExports = instance2.exports;
        wasmExports = relocateExports(wasmExports, 67108864);
        var metadata2 = getDylinkMetadata(module2);
        if (metadata2.neededDynlibs) {
          dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
        }
        mergeLibSymbols(wasmExports, "main");
        LDSO.init();
        loadDylibs();
        addOnInit(wasmExports["__wasm_call_ctors"]);
        __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"], result["module"]);
      }
      if (Module["instantiateWasm"]) {
        try {
          return Module["instantiateWasm"](info2, receiveInstance);
        } catch (e) {
          err(`Module.instantiateWasm callback failed with error: ${e}`);
          readyPromiseReject(e);
        }
      }
      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
      instantiateAsync(wasmBinary, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
      return {};
    }
    var ASM_CONSTS = {
      69124608: ($0) => {
        Module.is_worker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
        Module.FD_BUFFER_MAX = $0;
        Module.emscripten_copy_to = console.warn;
      },
      69124781: () => {
        Module["postMessage"] = function custom_postMessage(event) {
          console.log("# 1252: onCustomMessage:", __FILE__, event);
        };
      },
      69124906: () => {
        if (Module.is_worker) {
          let onCustomMessage = function(event) {
            console.log("onCustomMessage:", event);
          };
          ;
          Module["onCustomMessage"] = onCustomMessage;
        } else {
          Module["postMessage"] = function custom_postMessage(event) {
            switch (event.type) {
              case "raw": {
                stringToUTF8(event.data, shm_rawinput, Module.FD_BUFFER_MAX);
                break;
              }
              case "stdin": {
                stringToUTF8(event.data, 1, Module.FD_BUFFER_MAX);
                break;
              }
              case "rcon": {
                stringToUTF8(event.data, shm_rcon, Module.FD_BUFFER_MAX);
                break;
              }
              default:
                console.warn("custom_postMessage?", event);
            }
          };
        }
        ;
      }
    };
    function peek_fd(fd) {
      return test_data.length;
    }
    function fnc_getfd(fd) {
      return fnc_stdin();
    }
    function is_web_env() {
      try {
        if (window)
          return 1;
      } catch (x4) {
        return 0;
      }
    }
    is_web_env.sig = "i";
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
    var GOT = {};
    var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
    var GOTHandler = {
      get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({ "value": "i32", "mutable": true });
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          rtn.required = true;
        }
        return rtn;
      }
    };
    var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    };
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u22 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u22;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u22 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    };
    var getDylinkMetadata = (binary2) => {
      var offset = 0;
      var end = 0;
      function getU8() {
        return binary2[offset++];
      }
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary2[offset++];
          ret += (byte & 127) * mul;
          mul *= 128;
          if (!(byte & 128))
            break;
        }
        return ret;
      }
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary2, offset - len, len);
      }
      function failIf(condition, message) {
        if (condition)
          throw new Error(message);
      }
      var name2 = "dylink.0";
      if (binary2 instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
        if (dylinkSection.length === 0) {
          name2 = "dylink";
          dylinkSection = WebAssembly.Module.customSections(binary2, name2);
        }
        failIf(dylinkSection.length === 0, "need dylink section");
        binary2 = new Uint8Array(dylinkSection[0]);
        end = binary2.length;
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 1836278016;
        failIf(!magicNumberFound, "need to see wasm magic number");
        failIf(binary2[8] !== 0, "need the dylink section to be first");
        offset = 9;
        var section_size = getLEB();
        end = offset + section_size;
        name2 = getString();
      }
      var customSection = { neededDynlibs: [], tlsExports: /* @__PURE__ */ new Set(), weakImports: /* @__PURE__ */ new Set() };
      if (name2 == "dylink") {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        var neededDynlibsCount = getLEB();
        for (var i3 = 0; i3 < neededDynlibsCount; ++i3) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name2 !== "dylink.0");
        var WASM_DYLINK_MEM_INFO = 1;
        var WASM_DYLINK_NEEDED = 2;
        var WASM_DYLINK_EXPORT_INFO = 3;
        var WASM_DYLINK_IMPORT_INFO = 4;
        var WASM_SYMBOL_TLS = 256;
        var WASM_SYMBOL_BINDING_MASK = 3;
        var WASM_SYMBOL_BINDING_WEAK = 1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i3 = 0; i3 < neededDynlibsCount; ++i3) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags2 = getLEB();
              if (flags2 & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var modname = getString();
              var symname = getString();
              var flags2 = getLEB();
              if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            offset += subsectionSize;
          }
        }
      }
      return customSection;
    };
    function getValue(ptr, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        case "*":
          return HEAPU32[ptr >> 2];
        default:
          abort(`invalid type for getValue: ${type}`);
      }
    }
    var newDSO = (name2, handle2, syms) => {
      var dso = {
        refcount: Infinity,
        name: name2,
        exports: syms,
        global: true
      };
      LDSO.loadedLibsByName[name2] = dso;
      if (handle2 != void 0) {
        LDSO.loadedLibsByHandle[handle2] = dso;
      }
      return dso;
    };
    var LDSO = {
      loadedLibsByName: {},
      loadedLibsByHandle: {},
      init() {
        newDSO("__main__", 0, wasmImports);
      }
    };
    var ___heap_base = 73476080;
    var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };
    var getMemory = (size) => {
      if (runtimeInitialized) {
        return _calloc(size, 1);
      }
      var ret = ___heap_base;
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT["__heap_base"].value = end;
      return ret;
    };
    var isInternalSym = (symName) => {
      return [
        "__cpp_exception",
        "__c_longjmp",
        "__wasm_apply_data_relocs",
        "__dso_handle",
        "__tls_size",
        "__tls_align",
        "__set_stack_limits",
        "_emscripten_tls_init",
        "__wasm_init_tls",
        "__wasm_call_ctors",
        "__start_em_asm",
        "__stop_em_asm",
        "__start_em_js",
        "__stop_em_js"
      ].includes(symName) || symName.startsWith("__em_js__");
    };
    var uleb128Encode = (n3, target) => {
      if (n3 < 128) {
        target.push(n3);
      } else {
        target.push(n3 % 128 | 128, n3 >> 7);
      }
    };
    var sigToWasmTypes = (sig) => {
      var typeNames = {
        "i": "i32",
        "j": "i64",
        "f": "f32",
        "d": "f64",
        "e": "externref",
        "p": "i32"
      };
      var type = {
        parameters: [],
        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
      };
      for (var i3 = 1; i3 < sig.length; ++i3) {
        type.parameters.push(typeNames[sig[i3]]);
      }
      return type;
    };
    var generateFuncType = (sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        "i": 127,
        // i32
        "p": 127,
        // i32
        "j": 126,
        // i64
        "f": 125,
        // f32
        "d": 124,
        // f64
        "e": 111
        // externref
      };
      target.push(
        96
        /* form: func */
      );
      uleb128Encode(sigParam.length, target);
      for (var i3 = 0; i3 < sigParam.length; ++i3) {
        target.push(typeCodes[sigParam[i3]]);
      }
      if (sigRet == "v") {
        target.push(0);
      } else {
        target.push(1, typeCodes[sigRet]);
      }
    };
    var convertJsFunctionToWasm = (func2, sig) => {
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func2);
      }
      var typeSectionBody = [
        1
        // count: 1
      ];
      generateFuncType(sig, typeSectionBody);
      var bytes = [
        0,
        97,
        115,
        109,
        // magic ("\0asm")
        1,
        0,
        0,
        0,
        // version: 1
        1
        // Type section code
      ];
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
      bytes.push(
        2,
        7,
        // import section
        // (import "e" "f" (func 0 (type 0)))
        1,
        1,
        101,
        1,
        102,
        0,
        0,
        7,
        5,
        // export section
        // (export "f" (func 0 (type 0)))
        1,
        1,
        102,
        0,
        0
      );
      var module2 = new WebAssembly.Module(new Uint8Array(bytes));
      var instance2 = new WebAssembly.Instance(module2, { "e": { "f": func2 } });
      var wrappedFunc = instance2.exports["f"];
      return wrappedFunc;
    };
    var wasmTableMirror = [];
    var wasmTable = new WebAssembly.Table({
      "initial": 5358,
      "element": "anyfunc"
    });
    ;
    var getWasmTableEntry = (funcPtr) => {
      var func2 = wasmTableMirror[funcPtr];
      if (!func2) {
        if (funcPtr >= wasmTableMirror.length)
          wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr);
      }
      return func2;
    };
    var updateTableMap = (offset, count) => {
      if (functionsInTableMap) {
        for (var i3 = offset; i3 < offset + count; i3++) {
          var item = getWasmTableEntry(i3);
          if (item) {
            functionsInTableMap.set(item, i3);
          }
        }
      }
    };
    var functionsInTableMap;
    var getFunctionAddress = (func2) => {
      if (!functionsInTableMap) {
        functionsInTableMap = /* @__PURE__ */ new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func2) || 0;
    };
    var freeTableIndexes = [];
    var getEmptyTableSlot = () => {
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      try {
        wasmTable.grow(1);
      } catch (err2) {
        if (!(err2 instanceof RangeError)) {
          throw err2;
        }
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return wasmTable.length - 1;
    };
    var setWasmTableEntry = (idx, func2) => {
      wasmTable.set(idx, func2);
      wasmTableMirror[idx] = wasmTable.get(idx);
    };
    var addFunction = (func2, sig) => {
      var rtn = getFunctionAddress(func2);
      if (rtn) {
        return rtn;
      }
      var ret = getEmptyTableSlot();
      try {
        setWasmTableEntry(ret, func2);
      } catch (err2) {
        if (!(err2 instanceof TypeError)) {
          throw err2;
        }
        var wrapped = convertJsFunctionToWasm(func2, sig);
        setWasmTableEntry(ret, wrapped);
      }
      functionsInTableMap.set(func2, ret);
      return ret;
    };
    var updateGOT = (exports, replace) => {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }
        var value = exports[symName];
        GOT[symName] || (GOT[symName] = new WebAssembly.Global({ "value": "i32", "mutable": true }));
        if (replace || GOT[symName].value == 0) {
          if (typeof value == "function") {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == "number") {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
    var relocateExports = (exports, memoryBase2, replace) => {
      var relocated = {};
      for (var e in exports) {
        var value = exports[e];
        if (typeof value == "object") {
          value = value.value;
        }
        if (typeof value == "number") {
          value += memoryBase2;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    };
    var isSymbolDefined = (symName) => {
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    };
    var dynCall = (sig, ptr, args2 = []) => {
      var rtn = getWasmTableEntry(ptr)(...args2);
      return rtn;
    };
    var stackSave = () => _emscripten_stack_get_current();
    var stackRestore = (val) => __emscripten_stack_restore(val);
    var createInvokeFunction = (sig) => (ptr, ...args2) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        if (sig[0] == "j")
          return 0n;
      }
    };
    var resolveGlobalSymbol = (symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      } else if (symName.startsWith("invoke_")) {
        sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
      }
      return { sym, name: symName };
    };
    var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    };
    var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var firstLoad = !handle || !HEAP8[handle + 8];
        if (firstLoad) {
          var memAlign = Math.pow(2, metadata.memoryAlign);
          var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
          var tableBase = metadata.tableSize ? wasmTable.length : 0;
          if (handle) {
            HEAP8[handle + 8] = 1;
            HEAPU32[handle + 12 >> 2] = memoryBase;
            HEAP32[handle + 16 >> 2] = metadata.memorySize;
            HEAPU32[handle + 20 >> 2] = tableBase;
            HEAP32[handle + 24 >> 2] = metadata.tableSize;
          }
        } else {
          memoryBase = HEAPU32[handle + 12 >> 2];
          tableBase = HEAPU32[handle + 20 >> 2];
        }
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        if (tableGrowthNeeded > 0) {
          wasmTable.grow(tableGrowthNeeded);
        }
        var moduleExports;
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }
        var proxyHandler = {
          get(stubs, prop) {
            switch (prop) {
              case "__memory_base":
                return memoryBase;
              case "__table_base":
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              return wasmImports[prop];
            }
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args2) => {
                resolved || (resolved = resolveSymbol(prop));
                return resolved(...args2);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          "GOT.mem": new Proxy({}, GOTHandler),
          "GOT.func": new Proxy({}, GOTHandler),
          "env": proxy,
          "wasi_snapshot_preview1": proxy
        };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf("$" + arity) != -1) {
                args.push("$" + arity);
              } else {
                break;
              }
            }
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          if ("__start_em_asm" in moduleExports) {
            var start = moduleExports["__start_em_asm"];
            var stop = moduleExports["__stop_em_asm"];
            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            cSig = cSig.slice(1, -1);
            if (cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replaceAll("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          for (var name in moduleExports) {
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name];
              var jsString = UTF8ToString(start);
              var parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }
          var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
          if (applyRelocs) {
            if (runtimeInitialized) {
              applyRelocs();
            } else {
              __RELOC_FUNCS__.push(applyRelocs);
            }
          }
          var init = moduleExports["__wasm_call_ctors"];
          if (init) {
            if (runtimeInitialized) {
              init();
            } else {
              __ATINIT__.push(init);
            }
          }
          return moduleExports;
        }
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then(
            (result) => postInstantiation(result.module, result.instance)
          );
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(
          () => loadDynamicLibrary(dynNeeded, flags, localScope)
        ), Promise.resolve()).then(loadModule);
      }
      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    };
    var mergeLibSymbols = (exports, libName2) => {
      for (var [sym, exp] of Object.entries(exports)) {
        const setImport = (target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        };
        setImport(sym);
        const main_alias = "__main_argc_argv";
        if (sym == "main") {
          setImport(main_alias);
        }
        if (sym == main_alias) {
          setImport("main");
        }
      }
    };
    var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
      readAsync(url).then(
        (arrayBuffer) => {
          onload(new Uint8Array(arrayBuffer));
          if (dep)
            removeRunDependency(dep);
        },
        (err2) => {
          if (onerror) {
            onerror();
          } else {
            throw `Loading data file "${url}" failed.`;
          }
        }
      );
      if (dep)
        addRunDependency(dep);
    };
    var preloadPlugins = Module["preloadPlugins"] || [];
    var registerWasmPlugin = () => {
      var wasmPlugin = {
        "promiseChainEnd": Promise.resolve(),
        "canHandle": (name2) => {
          return !Module["noWasmDecoding"] && name2.endsWith(".so");
        },
        "handle": (byteArray, name2, onload, onerror) => {
          wasmPlugin["promiseChainEnd"] = wasmPlugin["promiseChainEnd"].then(
            () => loadWebAssemblyModule(byteArray, { loadAsync: true, nodelete: true }, name2, {})
          ).then(
            (exports) => {
              preloadedWasm[name2] = exports;
              onload(byteArray);
            },
            (error2) => {
              err(`failed to instantiate wasm: ${name2}: ${error2}`);
              onerror();
            }
          );
        }
      };
      preloadPlugins.push(wasmPlugin);
    };
    var preloadedWasm = {};
    function loadDynamicLibrary(libName2, flags2 = { global: true, nodelete: true }, localScope2, handle2) {
      var dso = LDSO.loadedLibsByName[libName2];
      if (dso) {
        if (!flags2.global) {
          if (localScope2) {
            Object.assign(localScope2, dso.exports);
          }
        } else if (!dso.global) {
          dso.global = true;
          mergeLibSymbols(dso.exports, libName2);
        }
        if (flags2.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++;
        if (handle2) {
          LDSO.loadedLibsByHandle[handle2] = dso;
        }
        return flags2.loadAsync ? Promise.resolve(true) : true;
      }
      dso = newDSO(libName2, handle2, "loading");
      dso.refcount = flags2.nodelete ? Infinity : 1;
      dso.global = flags2.global;
      function loadLibData() {
        if (handle2) {
          var data = HEAPU32[handle2 + 28 >> 2];
          var dataSize = HEAPU32[handle2 + 32 >> 2];
          if (data && dataSize) {
            var libData = HEAP8.slice(data, data + dataSize);
            return flags2.loadAsync ? Promise.resolve(libData) : libData;
          }
        }
        var libFile = locateFile(libName2);
        if (flags2.loadAsync) {
          return new Promise((resolve2, reject) => asyncLoad(libFile, resolve2, reject));
        }
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }
      function getExports() {
        var preloaded = preloadedWasm[libName2];
        if (preloaded) {
          return flags2.loadAsync ? Promise.resolve(preloaded) : preloaded;
        }
        if (flags2.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
        }
        return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
      }
      function moduleLoaded(exports) {
        if (dso.global) {
          mergeLibSymbols(exports, libName2);
        } else if (localScope2) {
          Object.assign(localScope2, exports);
        }
        dso.exports = exports;
      }
      if (flags2.loadAsync) {
        return getExports().then((exports) => {
          moduleLoaded(exports);
          return true;
        });
      }
      moduleLoaded(getExports());
      return true;
    }
    var reportUndefinedSymbols = () => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            continue;
          }
          if (typeof value == "function") {
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == "number") {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
    var loadDylibs = () => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs");
      dynamicLibraries.reduce((chain, lib) => chain.then(
        () => loadDynamicLibrary(lib, { loadAsync: true, global: true, nodelete: true, allowUndefined: true })
      ), Promise.resolve()).then(() => {
        reportUndefinedSymbols();
        removeRunDependency("loadDylibs");
      });
    };
    var noExitRuntime = Module["noExitRuntime"] || true;
    function setValue(ptr, value, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          HEAP8[ptr] = value;
          break;
        case "i8":
          HEAP8[ptr] = value;
          break;
        case "i16":
          HEAP16[ptr >> 1] = value;
          break;
        case "i32":
          HEAP32[ptr >> 2] = value;
          break;
        case "i64":
          HEAP64[ptr >> 3] = BigInt(value);
          break;
        case "float":
          HEAPF32[ptr >> 2] = value;
          break;
        case "double":
          HEAPF64[ptr >> 3] = value;
          break;
        case "*":
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort(`invalid type for setValue: ${type}`);
      }
    }
    var ___assert_fail = (condition, filename, line, func2) => {
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
    };
    ___assert_fail.sig = "vppip";
    var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
    ___call_sighandler.sig = "vpi";
    var ___memory_base = new WebAssembly.Global({ "value": "i32", "mutable": false }, 67108864);
    var ___stack_pointer = new WebAssembly.Global({ "value": "i32", "mutable": true }, 73476080);
    var PATH = {
      isAbs: (path2) => path2.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts2, allowAboveRoot) => {
        var up = 0;
        for (var i3 = parts2.length - 1; i3 >= 0; i3--) {
          var last2 = parts2[i3];
          if (last2 === ".") {
            parts2.splice(i3, 1);
          } else if (last2 === "..") {
            parts2.splice(i3, 1);
            up++;
          } else if (up) {
            parts2.splice(i3, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts2.unshift("..");
          }
        }
        return parts2;
      },
      normalize: (path2) => {
        var isAbsolute2 = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
        path2 = PATH.normalizeArray(path2.split("/").filter((p5) => !!p5), !isAbsolute2).join("/");
        if (!path2 && !isAbsolute2) {
          path2 = ".";
        }
        if (path2 && trailingSlash) {
          path2 += "/";
        }
        return (isAbsolute2 ? "/" : "") + path2;
      },
      dirname: (path2) => {
        var result = PATH.splitPath(path2), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path2) => {
        if (path2 === "/")
          return "/";
        path2 = PATH.normalize(path2);
        path2 = path2.replace(/\/$/, "");
        var lastSlash = path2.lastIndexOf("/");
        if (lastSlash === -1)
          return path2;
        return path2.substr(lastSlash + 1);
      },
      join: (...paths) => PATH.normalize(paths.join("/")),
      join2: (l4, r) => PATH.normalize(l4 + "/" + r)
    };
    var initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else if (ENVIRONMENT_IS_NODE) {
        try {
          var crypto_module = require("crypto");
          var randomFillSync = crypto_module["randomFillSync"];
          if (randomFillSync) {
            return (view) => crypto_module["randomFillSync"](view);
          }
          var randomBytes = crypto_module["randomBytes"];
          return (view) => (view.set(randomBytes(view.byteLength)), // Return the original view to match modern native implementations.
          view);
        } catch (e) {
        }
      }
      abort("initRandomDevice");
    };
    var randomFill = (view) => {
      return (randomFill = initRandomFill())(view);
    };
    var PATH_FS = {
      resolve: (...args2) => {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i3 = args2.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
          var path2 = i3 >= 0 ? args2[i3] : FS.cwd();
          if (typeof path2 != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path2) {
            return "";
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path2);
        }
        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p5) => !!p5), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start2 = 0;
          for (; start2 < arr.length; start2++) {
            if (arr[start2] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start2 > end)
            return [];
          return arr.slice(start2, end - start2 + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i3 = 0; i3 < length; i3++) {
          if (fromParts[i3] !== toParts[i3]) {
            samePartsLength = i3;
            break;
          }
        }
        var outputParts = [];
        for (var i3 = samePartsLength; i3 < fromParts.length; i3++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    var FS_stdin_getChar_buffer = [];
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i3 = 0; i3 < str.length; ++i3) {
        var c2 = str.charCodeAt(i3);
        if (c2 <= 127) {
          len++;
        } else if (c2 <= 2047) {
          len += 2;
        } else if (c2 >= 55296 && c2 <= 57343) {
          len += 4;
          ++i3;
        } else {
          len += 3;
        }
      }
      return len;
    };
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i3 = 0; i3 < str.length; ++i3) {
        var u4 = str.charCodeAt(i3);
        if (u4 >= 55296 && u4 <= 57343) {
          var u1 = str.charCodeAt(++i3);
          u4 = 65536 + ((u4 & 1023) << 10) | u1 & 1023;
        }
        if (u4 <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u4;
        } else if (u4 <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u4 >> 6;
          heap[outIdx++] = 128 | u4 & 63;
        } else if (u4 <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u4 >> 12;
          heap[outIdx++] = 128 | u4 >> 6 & 63;
          heap[outIdx++] = 128 | u4 & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u4 >> 18;
          heap[outIdx++] = 128 | u4 >> 12 & 63;
          heap[outIdx++] = 128 | u4 >> 6 & 63;
          heap[outIdx++] = 128 | u4 & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          var BUFSIZE = 256;
          var buf = Buffer.alloc(BUFSIZE);
          var bytesRead = 0;
          var fd = process4.stdin.fd;
          try {
            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
          } catch (e) {
            if (e.toString().includes("EOF"))
              bytesRead = 0;
            else
              throw e;
          }
          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString("utf-8");
          }
        } else if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else {
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
    var TTY = {
      ttys: [],
      init() {
      },
      shutdown() {
      },
      register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open(stream2) {
          var tty = TTY.ttys[stream2.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream2.tty = tty;
          stream2.seekable = false;
        },
        close(stream2) {
          stream2.tty.ops.fsync(stream2.tty);
        },
        fsync(stream2) {
          stream2.tty.ops.fsync(stream2.tty);
        },
        read(stream2, buffer, offset, length, pos) {
          if (!stream2.tty || !stream2.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i3 = 0; i3 < length; i3++) {
            var result;
            try {
              result = stream2.tty.ops.get_char(stream2.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i3] = result;
          }
          if (bytesRead) {
            stream2.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream2, buffer, offset, length, pos) {
          if (!stream2.tty || !stream2.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i3 = 0; i3 < length; i3++) {
              stream2.tty.ops.put_char(stream2.tty, buffer[offset + i3]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream2.node.timestamp = Date.now();
          }
          return i3;
        }
      },
      default_tty_ops: {
        get_char(tty) {
          return FS_stdin_getChar();
        },
        put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
        ioctl_tcgets(tty) {
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              3,
              28,
              127,
              21,
              4,
              0,
              1,
              0,
              17,
              19,
              26,
              0,
              18,
              15,
              23,
              22,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          };
        },
        ioctl_tcsets(tty, optional_actions, data) {
          return 0;
        },
        ioctl_tiocgwinsz(tty) {
          return [24, 80];
        }
      },
      default_tty1_ops: {
        put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      }
    };
    var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
      return address;
    };
    var mmapAlloc = (size) => {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr)
        return 0;
      return zeroMemory(ptr, size);
    };
    var MEMFS = {
      ops_table: null,
      mount(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode(parent, name2, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table || (MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        });
        var node = FS.createNode(parent, name2, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name2] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup(parent, name2) {
          throw FS.genericErrors[44];
        },
        mknod(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        },
        rename(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i3 in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
        },
        unlink(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        },
        rmdir(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i3 in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        },
        readdir(node) {
          var entries = [".", ".."];
          for (var key of Object.keys(node.contents)) {
            entries.push(key);
          }
          return entries;
        },
        symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read(stream2, buffer, offset, length, position) {
          var contents = stream2.node.contents;
          if (position >= stream2.node.usedBytes)
            return 0;
          var size = Math.min(stream2.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i3 = 0; i3 < size; i3++)
              buffer[offset + i3] = contents[position + i3];
          }
          return size;
        },
        write(stream2, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream2.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i3 = 0; i3 < length; i3++) {
              node.contents[position + i3] = buffer[offset + i3];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek(stream2, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream2.position;
          } else if (whence === 2) {
            if (FS.isFile(stream2.node.mode)) {
              position += stream2.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate(stream2, offset, length) {
          MEMFS.expandFileStorage(stream2.node, offset + length);
          stream2.node.usedBytes = Math.max(stream2.node.usedBytes, offset + length);
        },
        mmap(stream2, length, position, prot, flags2) {
          if (!FS.isFile(stream2.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream2.node.contents;
          if (!(flags2 & 2) && contents && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
        msync(stream2, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream2, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
    };
    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      if (typeof Browser != "undefined")
        Browser.init();
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled)
          return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
    var FS_createPreloadedFile = (parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`);
      function processData(byteArray) {
        function finish(byteArray2) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == "string") {
        asyncLoad(url, processData, onerror);
      } else {
        processData(url);
      }
    };
    var FS_modeStringToFlags = (str) => {
      var flagModes = {
        "r": 0,
        "r+": 2,
        "w": 512 | 64 | 1,
        "w+": 512 | 64 | 2,
        "a": 1024 | 64 | 1,
        "a+": 1024 | 64 | 2
      };
      var flags2 = flagModes[str];
      if (typeof flags2 == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags2;
    };
    var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead)
        mode |= 292 | 73;
      if (canWrite)
        mode |= 146;
      return mode;
    };
    var IDBFS = {
      dbs: {},
      indexedDB: () => {
        if (typeof indexedDB != "undefined")
          return indexedDB;
        var ret = null;
        if (typeof window == "object")
          ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        return ret;
      },
      DB_VERSION: 21,
      DB_STORE_NAME: "FILE_DATA",
      queuePersist: (mount) => {
        function onPersistComplete() {
          if (mount.idbPersistState === "again")
            startPersist();
          else
            mount.idbPersistState = 0;
        }
        function startPersist() {
          mount.idbPersistState = "idb";
          IDBFS.syncfs(
            mount,
            /*populate:*/
            false,
            onPersistComplete
          );
        }
        if (!mount.idbPersistState) {
          mount.idbPersistState = setTimeout(startPersist, 0);
        } else if (mount.idbPersistState === "idb") {
          mount.idbPersistState = "again";
        }
      },
      mount: (mount) => {
        var mnt = MEMFS.mount(mount);
        if (mount?.opts?.autoPersist) {
          mnt.idbPersistState = 0;
          var memfs_node_ops = mnt.node_ops;
          mnt.node_ops = Object.assign({}, mnt.node_ops);
          mnt.node_ops.mknod = (parent, name2, mode, dev) => {
            var node = memfs_node_ops.mknod(parent, name2, mode, dev);
            node.node_ops = mnt.node_ops;
            node.idbfs_mount = mnt.mount;
            node.memfs_stream_ops = node.stream_ops;
            node.stream_ops = Object.assign({}, node.stream_ops);
            node.stream_ops.write = (stream2, buffer, offset, length, position, canOwn) => {
              stream2.node.isModified = true;
              return node.memfs_stream_ops.write(stream2, buffer, offset, length, position, canOwn);
            };
            node.stream_ops.close = (stream2) => {
              var n3 = stream2.node;
              if (n3.isModified) {
                IDBFS.queuePersist(n3.idbfs_mount);
                n3.isModified = false;
              }
              if (n3.memfs_stream_ops.close)
                return n3.memfs_stream_ops.close(stream2);
            };
            return node;
          };
          mnt.node_ops.mkdir = (...args2) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.mkdir(...args2));
          mnt.node_ops.rmdir = (...args2) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rmdir(...args2));
          mnt.node_ops.symlink = (...args2) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.symlink(...args2));
          mnt.node_ops.unlink = (...args2) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.unlink(...args2));
          mnt.node_ops.rename = (...args2) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rename(...args2));
        }
        return mnt;
      },
      syncfs: (mount, populate, callback) => {
        IDBFS.getLocalSet(mount, (err2, local) => {
          if (err2)
            return callback(err2);
          IDBFS.getRemoteSet(mount, (err3, remote) => {
            if (err3)
              return callback(err3);
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },
      quit: () => {
        Object.values(IDBFS.dbs).forEach((value) => value.close());
        IDBFS.dbs = {};
      },
      getDB: (name2, callback) => {
        var db = IDBFS.dbs[name2];
        if (db) {
          return callback(null, db);
        }
        var req;
        try {
          req = IDBFS.indexedDB().open(name2, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        if (!req) {
          return callback("Unable to connect to IndexedDB");
        }
        req.onupgradeneeded = (e) => {
          var db2 = (
            /** @type {IDBDatabase} */
            e.target.result
          );
          var transaction = e.target.transaction;
          var fileStore;
          if (db2.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db2.createObjectStore(IDBFS.DB_STORE_NAME);
          }
          if (!fileStore.indexNames.contains("timestamp")) {
            fileStore.createIndex("timestamp", "timestamp", { unique: false });
          }
        };
        req.onsuccess = () => {
          db = /** @type {IDBDatabase} */
          req.result;
          IDBFS.dbs[name2] = db;
          callback(null, db);
        };
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
      getLocalSet: (mount, callback) => {
        var entries = {};
        function isRealDir(p5) {
          return p5 !== "." && p5 !== "..";
        }
        ;
        function toAbsolute(root) {
          return (p5) => PATH.join2(root, p5);
        }
        ;
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
        while (check.length) {
          var path2 = check.pop();
          var stat;
          try {
            stat = FS.stat(path2);
          } catch (e) {
            return callback(e);
          }
          if (FS.isDir(stat.mode)) {
            check.push(...FS.readdir(path2).filter(isRealDir).map(toAbsolute(path2)));
          }
          entries[path2] = { "timestamp": stat.mtime };
        }
        return callback(null, { type: "local", entries });
      },
      getRemoteSet: (mount, callback) => {
        var entries = {};
        IDBFS.getDB(mount.mountpoint, (err2, db) => {
          if (err2)
            return callback(err2);
          try {
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");
            transaction.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            var index = store.index("timestamp");
            index.openKeyCursor().onsuccess = (event) => {
              var cursor = event.target.result;
              if (!cursor) {
                return callback(null, { type: "remote", db, entries });
              }
              entries[cursor.primaryKey] = { "timestamp": cursor.key };
              cursor.continue();
            };
          } catch (e) {
            return callback(e);
          }
        });
      },
      loadLocalEntry: (path2, callback) => {
        var stat, node;
        try {
          var lookup3 = FS.lookupPath(path2);
          node = lookup3.node;
          stat = FS.stat(path2);
        } catch (e) {
          return callback(e);
        }
        if (FS.isDir(stat.mode)) {
          return callback(null, { "timestamp": stat.mtime, "mode": stat.mode });
        } else if (FS.isFile(stat.mode)) {
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { "timestamp": stat.mtime, "mode": stat.mode, "contents": node.contents });
        } else {
          return callback(new Error("node type not supported"));
        }
      },
      storeLocalEntry: (path2, entry, callback) => {
        try {
          if (FS.isDir(entry["mode"])) {
            FS.mkdirTree(path2, entry["mode"]);
          } else if (FS.isFile(entry["mode"])) {
            FS.writeFile(path2, entry["contents"], { canOwn: true });
          } else {
            return callback(new Error("node type not supported"));
          }
          FS.chmod(path2, entry["mode"]);
          FS.utime(path2, entry["timestamp"], entry["timestamp"]);
        } catch (e) {
          return callback(e);
        }
        callback(null);
      },
      removeLocalEntry: (path2, callback) => {
        try {
          var stat = FS.stat(path2);
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path2);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path2);
          }
        } catch (e) {
          return callback(e);
        }
        callback(null);
      },
      loadRemoteEntry: (store, path2, callback) => {
        var req = store.get(path2);
        req.onsuccess = (event) => callback(null, event.target.result);
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
      storeRemoteEntry: (store, path2, entry, callback) => {
        try {
          var req = store.put(entry, path2);
        } catch (e) {
          callback(e);
          return;
        }
        req.onsuccess = (event) => callback();
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
      removeRemoteEntry: (store, path2, callback) => {
        var req = store.delete(path2);
        req.onsuccess = (event) => callback();
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
      reconcile: (src, dst, callback) => {
        var total = 0;
        var create = [];
        Object.keys(src.entries).forEach((key) => {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e["timestamp"].getTime() != e2["timestamp"].getTime()) {
            create.push(key);
            total++;
          }
        });
        var remove = [];
        Object.keys(dst.entries).forEach((key) => {
          if (!src.entries[key]) {
            remove.push(key);
            total++;
          }
        });
        if (!total) {
          return callback(null);
        }
        var errored = false;
        var db = src.type === "remote" ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
        function done(err2) {
          if (err2 && !errored) {
            errored = true;
            return callback(err2);
          }
        }
        ;
        transaction.onerror = transaction.onabort = (e) => {
          done(e.target.error);
          e.preventDefault();
        };
        transaction.oncomplete = (e) => {
          if (!errored) {
            callback(null);
          }
        };
        create.sort().forEach((path2) => {
          if (dst.type === "local") {
            IDBFS.loadRemoteEntry(store, path2, (err2, entry) => {
              if (err2)
                return done(err2);
              IDBFS.storeLocalEntry(path2, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path2, (err2, entry) => {
              if (err2)
                return done(err2);
              IDBFS.storeRemoteEntry(store, path2, entry, done);
            });
          }
        });
        remove.sort().reverse().forEach((path2) => {
          if (dst.type === "local") {
            IDBFS.removeLocalEntry(path2, done);
          } else {
            IDBFS.removeRemoteEntry(store, path2, done);
          }
        });
      }
    };
    var ERRNO_CODES = {
      "EPERM": 63,
      "ENOENT": 44,
      "ESRCH": 71,
      "EINTR": 27,
      "EIO": 29,
      "ENXIO": 60,
      "E2BIG": 1,
      "ENOEXEC": 45,
      "EBADF": 8,
      "ECHILD": 12,
      "EAGAIN": 6,
      "EWOULDBLOCK": 6,
      "ENOMEM": 48,
      "EACCES": 2,
      "EFAULT": 21,
      "ENOTBLK": 105,
      "EBUSY": 10,
      "EEXIST": 20,
      "EXDEV": 75,
      "ENODEV": 43,
      "ENOTDIR": 54,
      "EISDIR": 31,
      "EINVAL": 28,
      "ENFILE": 41,
      "EMFILE": 33,
      "ENOTTY": 59,
      "ETXTBSY": 74,
      "EFBIG": 22,
      "ENOSPC": 51,
      "ESPIPE": 70,
      "EROFS": 69,
      "EMLINK": 34,
      "EPIPE": 64,
      "EDOM": 18,
      "ERANGE": 68,
      "ENOMSG": 49,
      "EIDRM": 24,
      "ECHRNG": 106,
      "EL2NSYNC": 156,
      "EL3HLT": 107,
      "EL3RST": 108,
      "ELNRNG": 109,
      "EUNATCH": 110,
      "ENOCSI": 111,
      "EL2HLT": 112,
      "EDEADLK": 16,
      "ENOLCK": 46,
      "EBADE": 113,
      "EBADR": 114,
      "EXFULL": 115,
      "ENOANO": 104,
      "EBADRQC": 103,
      "EBADSLT": 102,
      "EDEADLOCK": 16,
      "EBFONT": 101,
      "ENOSTR": 100,
      "ENODATA": 116,
      "ETIME": 117,
      "ENOSR": 118,
      "ENONET": 119,
      "ENOPKG": 120,
      "EREMOTE": 121,
      "ENOLINK": 47,
      "EADV": 122,
      "ESRMNT": 123,
      "ECOMM": 124,
      "EPROTO": 65,
      "EMULTIHOP": 36,
      "EDOTDOT": 125,
      "EBADMSG": 9,
      "ENOTUNIQ": 126,
      "EBADFD": 127,
      "EREMCHG": 128,
      "ELIBACC": 129,
      "ELIBBAD": 130,
      "ELIBSCN": 131,
      "ELIBMAX": 132,
      "ELIBEXEC": 133,
      "ENOSYS": 52,
      "ENOTEMPTY": 55,
      "ENAMETOOLONG": 37,
      "ELOOP": 32,
      "EOPNOTSUPP": 138,
      "EPFNOSUPPORT": 139,
      "ECONNRESET": 15,
      "ENOBUFS": 42,
      "EAFNOSUPPORT": 5,
      "EPROTOTYPE": 67,
      "ENOTSOCK": 57,
      "ENOPROTOOPT": 50,
      "ESHUTDOWN": 140,
      "ECONNREFUSED": 14,
      "EADDRINUSE": 3,
      "ECONNABORTED": 13,
      "ENETUNREACH": 40,
      "ENETDOWN": 38,
      "ETIMEDOUT": 73,
      "EHOSTDOWN": 142,
      "EHOSTUNREACH": 23,
      "EINPROGRESS": 26,
      "EALREADY": 7,
      "EDESTADDRREQ": 17,
      "EMSGSIZE": 35,
      "EPROTONOSUPPORT": 66,
      "ESOCKTNOSUPPORT": 137,
      "EADDRNOTAVAIL": 4,
      "ENETRESET": 39,
      "EISCONN": 30,
      "ENOTCONN": 53,
      "ETOOMANYREFS": 141,
      "EUSERS": 136,
      "EDQUOT": 19,
      "ESTALE": 72,
      "ENOTSUP": 138,
      "ENOMEDIUM": 148,
      "EILSEQ": 25,
      "EOVERFLOW": 61,
      "ECANCELED": 11,
      "ENOTRECOVERABLE": 56,
      "EOWNERDEAD": 62,
      "ESTRPIPE": 135
    };
    var NODEFS = {
      isWindows: false,
      staticInit() {
        NODEFS.isWindows = !!process4.platform.match(/^win/);
        var flags2 = process4.binding("constants");
        if (flags2["fs"]) {
          flags2 = flags2["fs"];
        }
        NODEFS.flagsForNodeMap = {
          "1024": flags2["O_APPEND"],
          "64": flags2["O_CREAT"],
          "128": flags2["O_EXCL"],
          "256": flags2["O_NOCTTY"],
          "0": flags2["O_RDONLY"],
          "2": flags2["O_RDWR"],
          "4096": flags2["O_SYNC"],
          "512": flags2["O_TRUNC"],
          "1": flags2["O_WRONLY"],
          "131072": flags2["O_NOFOLLOW"]
        };
      },
      convertNodeCode(e) {
        var code = e.code;
        return ERRNO_CODES[code];
      },
      tryFSOperation(f3) {
        try {
          return f3();
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      mount(mount) {
        return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
      },
      createNode(parent, name2, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }
        var node = FS.createNode(parent, name2, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },
      getMode(path2) {
        var stat;
        return NODEFS.tryFSOperation(() => {
          stat = fs.lstatSync(path2);
          if (NODEFS.isWindows) {
            stat.mode |= (stat.mode & 292) >> 2;
          }
          return stat.mode;
        });
      },
      realPath(node) {
        var parts2 = [];
        while (node.parent !== node) {
          parts2.push(node.name);
          node = node.parent;
        }
        parts2.push(node.mount.opts.root);
        parts2.reverse();
        return PATH.join(...parts2);
      },
      flagsForNode(flags2) {
        flags2 &= ~2097152;
        flags2 &= ~2048;
        flags2 &= ~32768;
        flags2 &= ~524288;
        flags2 &= ~65536;
        var newFlags = 0;
        for (var k5 in NODEFS.flagsForNodeMap) {
          if (flags2 & k5) {
            newFlags |= NODEFS.flagsForNodeMap[k5];
            flags2 ^= k5;
          }
        }
        if (flags2) {
          throw new FS.ErrnoError(28);
        }
        return newFlags;
      },
      node_ops: {
        getattr(node) {
          var path2 = NODEFS.realPath(node);
          var stat;
          NODEFS.tryFSOperation(() => stat = fs.lstatSync(path2));
          if (NODEFS.isWindows) {
            if (!stat.blksize) {
              stat.blksize = 4096;
            }
            if (!stat.blocks) {
              stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
            }
            stat.mode |= (stat.mode & 292) >> 2;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },
        setattr(node, attr) {
          var path2 = NODEFS.realPath(node);
          NODEFS.tryFSOperation(() => {
            if (attr.mode !== void 0) {
              fs.chmodSync(path2, attr.mode);
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path2, date, date);
            }
            if (attr.size !== void 0) {
              fs.truncateSync(path2, attr.size);
            }
          });
        },
        lookup(parent, name2) {
          var path2 = PATH.join2(NODEFS.realPath(parent), name2);
          var mode = NODEFS.getMode(path2);
          return NODEFS.createNode(parent, name2, mode);
        },
        mknod(parent, name2, mode, dev) {
          var node = NODEFS.createNode(parent, name2, mode, dev);
          var path2 = NODEFS.realPath(node);
          NODEFS.tryFSOperation(() => {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path2, node.mode);
            } else {
              fs.writeFileSync(path2, "", { mode: node.mode });
            }
          });
          return node;
        },
        rename(oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
          oldNode.name = newName;
        },
        unlink(parent, name2) {
          var path2 = PATH.join2(NODEFS.realPath(parent), name2);
          NODEFS.tryFSOperation(() => fs.unlinkSync(path2));
        },
        rmdir(parent, name2) {
          var path2 = PATH.join2(NODEFS.realPath(parent), name2);
          NODEFS.tryFSOperation(() => fs.rmdirSync(path2));
        },
        readdir(node) {
          var path2 = NODEFS.realPath(node);
          return NODEFS.tryFSOperation(() => fs.readdirSync(path2));
        },
        symlink(parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
        },
        readlink(node) {
          var path2 = NODEFS.realPath(node);
          return NODEFS.tryFSOperation(() => fs.readlinkSync(path2));
        }
      },
      stream_ops: {
        open(stream2) {
          var path2 = NODEFS.realPath(stream2.node);
          NODEFS.tryFSOperation(() => {
            if (FS.isFile(stream2.node.mode)) {
              stream2.shared.refcount = 1;
              stream2.nfd = fs.openSync(path2, NODEFS.flagsForNode(stream2.flags));
            }
          });
        },
        close(stream2) {
          NODEFS.tryFSOperation(() => {
            if (FS.isFile(stream2.node.mode) && stream2.nfd && --stream2.shared.refcount === 0) {
              fs.closeSync(stream2.nfd);
            }
          });
        },
        dup(stream2) {
          stream2.shared.refcount++;
        },
        read(stream2, buffer, offset, length, position) {
          if (length === 0)
            return 0;
          return NODEFS.tryFSOperation(
            () => fs.readSync(stream2.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position)
          );
        },
        write(stream2, buffer, offset, length, position) {
          return NODEFS.tryFSOperation(
            () => fs.writeSync(stream2.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position)
          );
        },
        llseek(stream2, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream2.position;
          } else if (whence === 2) {
            if (FS.isFile(stream2.node.mode)) {
              NODEFS.tryFSOperation(() => {
                var stat = fs.fstatSync(stream2.nfd);
                position += stat.size;
              });
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        mmap(stream2, length, position, prot, flags2) {
          if (!FS.isFile(stream2.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr = mmapAlloc(length);
          NODEFS.stream_ops.read(stream2, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        },
        msync(stream2, buffer, offset, length, mmapFlags) {
          NODEFS.stream_ops.write(stream2, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: class {
        // We set the `name` property to be able to identify `FS.ErrnoError`
        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
        // - when using PROXYFS, an error can come from an underlying FS
        // as different FS objects have their own FS.ErrnoError each,
        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
        // we'll use the reliable test `err.name == "ErrnoError"` instead
        constructor(errno) {
          this.name = "ErrnoError";
          this.errno = errno;
        }
      },
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      readFiles: {},
      FSStream: class {
        constructor() {
          this.shared = {};
        }
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return this.flags & 1024;
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
      FSNode: class {
        constructor(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
          this.readMode = 292 | 73;
          this.writeMode = 146;
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
      lookupPath(path2, opts = {}) {
        path2 = PATH_FS.resolve(path2);
        if (!path2)
          return { path: "", node: null };
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts2 = path2.split("/").filter((p5) => !!p5);
        var current = FS.root;
        var current_path = "/";
        for (var i3 = 0; i3 < parts2.length; i3++) {
          var islast = i3 === parts2.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts2[i3]);
          current_path = PATH.join2(current_path, parts2[i3]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup3 = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup3.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath(node) {
        var path2;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path2)
              return mount;
            return mount[mount.length - 1] !== "/" ? `${mount}/${path2}` : mount + path2;
          }
          path2 = path2 ? `${node.name}/${path2}` : node.name;
          node = node.parent;
        }
      },
      hashName(parentid, name2) {
        var hash = 0;
        for (var i3 = 0; i3 < name2.length; i3++) {
          hash = (hash << 5) - hash + name2.charCodeAt(i3) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode(parent, name2) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name2);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name2) {
            return node;
          }
        }
        return FS.lookup(parent, name2);
      },
      createNode(parent, name2, mode, rdev) {
        var node = new FS.FSNode(parent, name2, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode(node) {
        FS.hashRemoveNode(node);
      },
      isRoot(node) {
        return node === node.parent;
      },
      isMountpoint(node) {
        return !!node.mounted;
      },
      isFile(mode) {
        return (mode & 61440) === 32768;
      },
      isDir(mode) {
        return (mode & 61440) === 16384;
      },
      isLink(mode) {
        return (mode & 61440) === 40960;
      },
      isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
      isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
      isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
      isSocket(mode) {
        return (mode & 49152) === 49152;
      },
      flagsToPermissionString(flag3) {
        var perms = ["r", "w", "rw"][flag3 & 3];
        if (flag3 & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup(dir) {
        if (!FS.isDir(dir.mode))
          return 54;
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      },
      mayCreate(dir, name2) {
        try {
          var node = FS.lookupNode(dir, name2);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete(dir, name2, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name2);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen(node, flags2) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags2) !== "r" || // opening for write
          flags2 & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
      },
      MAX_OPEN_FDS: 4096,
      nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStreamChecked(fd) {
        var stream2 = FS.getStream(fd);
        if (!stream2) {
          throw new FS.ErrnoError(8);
        }
        return stream2;
      },
      getStream: (fd) => FS.streams[fd],
      createStream(stream2, fd = -1) {
        stream2 = Object.assign(new FS.FSStream(), stream2);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream2.fd = fd;
        FS.streams[fd] = stream2;
        return stream2;
      },
      closeStream(fd) {
        FS.streams[fd] = null;
      },
      dupStream(origStream, fd = -1) {
        var stream2 = FS.createStream(origStream, fd);
        stream2.stream_ops?.dup?.(stream2);
        return stream2;
      },
      chrdev_stream_ops: {
        open(stream2) {
          var device = FS.getDevice(stream2.node.rdev);
          stream2.stream_ops = device.stream_ops;
          stream2.stream_ops.open?.(stream2);
        },
        llseek() {
          throw new FS.ErrnoError(70);
        }
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi) => ma << 8 | mi,
      registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m5 = check.pop();
          mounts.push(m5);
          check.push(...m5.mounts);
        }
        return mounts;
      },
      syncfs(populate, callback) {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        ;
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup3 = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup3.path;
          node = lookup3.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount(mountpoint) {
        var lookup3 = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup3.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup3.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup(parent, name2) {
        return parent.node_ops.lookup(parent, name2);
      },
      mknod(path2, mode, dev) {
        var lookup3 = FS.lookupPath(path2, { parent: true });
        var parent = lookup3.node;
        var name2 = PATH.basename(path2);
        if (!name2 || name2 === "." || name2 === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name2);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name2, mode, dev);
      },
      create(path2, mode) {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path2, mode, 0);
      },
      mkdir(path2, mode) {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path2, mode, 0);
      },
      mkdirTree(path2, mode) {
        var dirs = path2.split("/");
        var d3 = "";
        for (var i3 = 0; i3 < dirs.length; ++i3) {
          if (!dirs[i3])
            continue;
          d3 += "/" + dirs[i3];
          try {
            FS.mkdir(d3, mode);
          } catch (e) {
            if (e.errno != 20)
              throw e;
          }
        }
      },
      mkdev(path2, mode, dev) {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path2, mode, dev);
      },
      symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup3 = FS.lookupPath(newpath, { parent: true });
        var parent = lookup3.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup3, old_dir, new_dir;
        lookup3 = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup3.node;
        lookup3 = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup3.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir(path2) {
        var lookup3 = FS.lookupPath(path2, { parent: true });
        var parent = lookup3.node;
        var name2 = PATH.basename(path2);
        var node = FS.lookupNode(parent, name2);
        var errCode = FS.mayDelete(parent, name2, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name2);
        FS.destroyNode(node);
      },
      readdir(path2) {
        var lookup3 = FS.lookupPath(path2, { follow: true });
        var node = lookup3.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink(path2) {
        var lookup3 = FS.lookupPath(path2, { parent: true });
        var parent = lookup3.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name2 = PATH.basename(path2);
        var node = FS.lookupNode(parent, name2);
        var errCode = FS.mayDelete(parent, name2, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name2);
        FS.destroyNode(node);
      },
      readlink(path2) {
        var lookup3 = FS.lookupPath(path2);
        var link = lookup3.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },
      stat(path2, dontFollow) {
        var lookup3 = FS.lookupPath(path2, { follow: !dontFollow });
        var node = lookup3.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat(path2) {
        return FS.stat(path2, true);
      },
      chmod(path2, mode, dontFollow) {
        var node;
        if (typeof path2 == "string") {
          var lookup3 = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup3.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod(path2, mode) {
        FS.chmod(path2, mode, true);
      },
      fchmod(fd, mode) {
        var stream2 = FS.getStreamChecked(fd);
        FS.chmod(stream2.node, mode);
      },
      chown(path2, uid, gid, dontFollow) {
        var node;
        if (typeof path2 == "string") {
          var lookup3 = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup3.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },
      lchown(path2, uid, gid) {
        FS.chown(path2, uid, gid, true);
      },
      fchown(fd, uid, gid) {
        var stream2 = FS.getStreamChecked(fd);
        FS.chown(stream2.node, uid, gid);
      },
      truncate(path2, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path2 == "string") {
          var lookup3 = FS.lookupPath(path2, { follow: true });
          node = lookup3.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate(fd, len) {
        var stream2 = FS.getStreamChecked(fd);
        if ((stream2.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream2.node, len);
      },
      utime(path2, atime, mtime) {
        var lookup3 = FS.lookupPath(path2, { follow: true });
        var node = lookup3.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open(path2, flags2, mode) {
        if (path2 === "") {
          throw new FS.ErrnoError(44);
        }
        flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
        if (flags2 & 64) {
          mode = typeof mode == "undefined" ? 438 : mode;
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path2 == "object") {
          node = path2;
        } else {
          path2 = PATH.normalize(path2);
          try {
            var lookup3 = FS.lookupPath(path2, {
              follow: !(flags2 & 131072)
            });
            node = lookup3.node;
          } catch (e) {
          }
        }
        var created = false;
        if (flags2 & 64) {
          if (node) {
            if (flags2 & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path2, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags2 &= ~512;
        }
        if (flags2 & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags2 & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags2 &= ~(128 | 512 | 131072);
        var stream2 = FS.createStream({
          node,
          path: FS.getPath(node),
          // we want the absolute path to the node
          flags: flags2,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        if (stream2.stream_ops.open) {
          stream2.stream_ops.open(stream2);
        }
        if (Module["logReadFiles"] && !(flags2 & 1)) {
          if (!(path2 in FS.readFiles)) {
            FS.readFiles[path2] = 1;
          }
        }
        return stream2;
      },
      close(stream2) {
        if (FS.isClosed(stream2)) {
          throw new FS.ErrnoError(8);
        }
        if (stream2.getdents)
          stream2.getdents = null;
        try {
          if (stream2.stream_ops.close) {
            stream2.stream_ops.close(stream2);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream2.fd);
        }
        stream2.fd = null;
      },
      isClosed(stream2) {
        return stream2.fd === null;
      },
      llseek(stream2, offset, whence) {
        if (FS.isClosed(stream2)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream2.seekable || !stream2.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream2.position = stream2.stream_ops.llseek(stream2, offset, whence);
        stream2.ungotten = [];
        return stream2.position;
      },
      read(stream2, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream2)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream2.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream2.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream2.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream2.position;
        } else if (!stream2.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream2.stream_ops.read(stream2, buffer, offset, length, position);
        if (!seeking)
          stream2.position += bytesRead;
        return bytesRead;
      },
      write(stream2, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream2)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream2.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream2.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream2.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream2.seekable && stream2.flags & 1024) {
          FS.llseek(stream2, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream2.position;
        } else if (!stream2.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream2.stream_ops.write(stream2, buffer, offset, length, position, canOwn);
        if (!seeking)
          stream2.position += bytesWritten;
        return bytesWritten;
      },
      allocate(stream2, offset, length) {
        if (FS.isClosed(stream2)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream2.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream2.node.mode) && !FS.isDir(stream2.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream2.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream2.stream_ops.allocate(stream2, offset, length);
      },
      mmap(stream2, length, position, prot, flags2) {
        if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream2.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream2.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream2.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream2.stream_ops.mmap(stream2, length, position, prot, flags2);
      },
      msync(stream2, buffer, offset, length, mmapFlags) {
        if (!stream2.stream_ops.msync) {
          return 0;
        }
        return stream2.stream_ops.msync(stream2, buffer, offset, length, mmapFlags);
      },
      ioctl(stream2, cmd, arg) {
        if (!stream2.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream2.stream_ops.ioctl(stream2, cmd, arg);
      },
      readFile(path2, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream2 = FS.open(path2, opts.flags);
        var stat = FS.stat(path2);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream2, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream2);
        return ret;
      },
      writeFile(path2, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream2 = FS.open(path2, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream2, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream2, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream2);
      },
      cwd: () => FS.currentPath,
      chdir(path2) {
        var lookup3 = FS.lookupPath(path2, { follow: true });
        if (lookup3.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup3.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup3.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup3.path;
      },
      createDefaultDirectories() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream2, buffer, offset, length, pos) => length
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice("/dev", "random", randomByte);
        FS.createDevice("/dev", "urandom", randomByte);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories() {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({
          mount() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = {
              lookup(parent, name2) {
                var fd = +name2;
                var stream2 = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: { mountpoint: "fake" },
                  node_ops: { readlink: () => stream2.path }
                };
                ret.parent = ret;
                return ret;
              }
            };
            return node;
          }
        }, {}, "/proc/self/fd");
      },
      createStandardStreams(input, output, error2) {
        if (input) {
          FS.createDevice("/dev", "stdin", input);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (output) {
          FS.createDevice("/dev", "stdout", null, output);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (error2) {
          FS.createDevice("/dev", "stderr", null, error2);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", 0);
        var stdout = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      },
      staticInit() {
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          "MEMFS": MEMFS,
          "IDBFS": IDBFS,
          "NODEFS": NODEFS
        };
      },
      init(input, output, error2) {
        FS.initialized = true;
        input ?? (input = Module["stdin"]);
        output ?? (output = Module["stdout"]);
        error2 ?? (error2 = Module["stderr"]);
        FS.createStandardStreams(input, output, error2);
      },
      quit() {
        FS.initialized = false;
        _fflush(0);
        for (var i3 = 0; i3 < FS.streams.length; i3++) {
          var stream2 = FS.streams[i3];
          if (!stream2) {
            continue;
          }
          FS.close(stream2);
        }
      },
      findObject(path2, dontResolveLastLink) {
        var ret = FS.analyzePath(path2, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath(path2, dontResolveLastLink) {
        try {
          var lookup3 = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          path2 = lookup3.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup3 = FS.lookupPath(path2, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup3.path;
          ret.parentObject = lookup3.node;
          ret.name = PATH.basename(path2);
          lookup3 = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup3.path;
          ret.object = lookup3.node;
          ret.name = lookup3.node.name;
          ret.isRoot = lookup3.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        ;
        return ret;
      },
      createPath(parent, path2, canRead, canWrite) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts2 = path2.split("/").reverse();
        while (parts2.length) {
          var part = parts2.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
          }
          parent = current;
        }
        return current;
      },
      createFile(parent, name2, properties, canRead, canWrite) {
        var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path2, mode);
      },
      createDataFile(parent, name2, data, canRead, canWrite, canOwn) {
        var path2 = name2;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path2 = name2 ? PATH.join2(parent, name2) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path2, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i3 = 0, len = data.length; i3 < len; ++i3)
              arr[i3] = data.charCodeAt(i3);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream2 = FS.open(node, 577);
          FS.write(stream2, data, 0, data.length, 0, canOwn);
          FS.close(stream2);
          FS.chmod(node, mode);
        }
      },
      createDevice(parent, name2, input, output) {
        var _a;
        var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
        var mode = FS_getMode(!!input, !!output);
        (_a = FS.createDevice).major ?? (_a.major = 64);
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open(stream2) {
            stream2.seekable = false;
          },
          close(stream2) {
            if (output?.buffer?.length) {
              output(10);
            }
          },
          read(stream2, buffer, offset, length, pos) {
            var bytesRead = 0;
            for (var i3 = 0; i3 < length; i3++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer[offset + i3] = result;
            }
            if (bytesRead) {
              stream2.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write(stream2, buffer, offset, length, pos) {
            for (var i3 = 0; i3 < length; i3++) {
              try {
                output(buffer[offset + i3]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream2.node.timestamp = Date.now();
            }
            return i3;
          }
        });
        return FS.mkdev(path2, mode, dev);
      },
      forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else {
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      },
      createLazyFile(parent, name2, url, canRead, canWrite) {
        class LazyUint8Array {
          constructor() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(
                  /** @type{Array<number>} */
                  xhr2.response || []
                );
              }
              return intArrayFromString(xhr2.responseText || "", true);
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter((chunkNum) => {
              var start2 = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start2, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name2, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn2 = node.stream_ops[key];
          stream_ops[key] = (...args2) => {
            FS.forceLoadFile(node);
            return fn2(...args2);
          };
        });
        function writeChunks(stream2, buffer, offset, length, position) {
          var contents = stream2.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i3 = 0; i3 < size; i3++) {
              buffer[offset + i3] = contents[position + i3];
            }
          } else {
            for (var i3 = 0; i3 < size; i3++) {
              buffer[offset + i3] = contents.get(position + i3);
            }
          }
          return size;
        }
        stream_ops.read = (stream2, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream2, buffer, offset, length, position);
        };
        stream_ops.mmap = (stream2, length, position, prot, flags2) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream2, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      }
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt(dirfd, path2, allowEmpty) {
        if (PATH.isAbs(path2)) {
          return path2;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path2.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
            ;
          }
          return dir;
        }
        return PATH.join2(dir, path2);
      },
      doStat(func2, path2, buf) {
        var stat = func2(path2);
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = stat.mode;
        HEAPU32[buf + 8 >> 2] = stat.nlink;
        HEAP32[buf + 12 >> 2] = stat.uid;
        HEAP32[buf + 16 >> 2] = stat.gid;
        HEAP32[buf + 20 >> 2] = stat.rdev;
        HEAP64[buf + 24 >> 3] = BigInt(stat.size);
        HEAP32[buf + 32 >> 2] = 4096;
        HEAP32[buf + 36 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
        return 0;
      },
      doMsync(addr2, stream2, len, flags2, offset) {
        if (!FS.isFile(stream2.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags2 & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr2, addr2 + len);
        FS.msync(stream2, buffer, offset, len, flags2);
      },
      getStreamFromFD(fd) {
        var stream2 = FS.getStreamChecked(fd);
        return stream2;
      },
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
      try {
        var total = 0;
        var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
        var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
        var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
        var dstReadLow = 0, dstReadHigh = 0;
        var dstWriteLow = 0, dstWriteHigh = 0;
        var dstExceptLow = 0, dstExceptHigh = 0;
        var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
        var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
        var check = function(fd2, low, high, val) {
          return fd2 < 32 ? low & val : high & val;
        };
        for (var fd = 0; fd < nfds; fd++) {
          var mask = 1 << fd % 32;
          if (!check(fd, allLow, allHigh, mask)) {
            continue;
          }
          var stream2 = SYSCALLS.getStreamFromFD(fd);
          var flags2 = SYSCALLS.DEFAULT_POLLMASK;
          if (stream2.stream_ops.poll) {
            var timeoutInMillis = -1;
            if (timeout) {
              var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 4 >> 2] : 0;
              timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
            }
            flags2 = stream2.stream_ops.poll(stream2, timeoutInMillis);
          }
          if (flags2 & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
            total++;
          }
          if (flags2 & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
            total++;
          }
          if (flags2 & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
            total++;
          }
        }
        if (readfds) {
          HEAP32[readfds >> 2] = dstReadLow;
          HEAP32[readfds + 4 >> 2] = dstReadHigh;
        }
        if (writefds) {
          HEAP32[writefds >> 2] = dstWriteLow;
          HEAP32[writefds + 4 >> 2] = dstWriteHigh;
        }
        if (exceptfds) {
          HEAP32[exceptfds >> 2] = dstExceptLow;
          HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
        }
        return total;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall__newselect.sig = "iipppp";
    var SOCKFS = {
      mount(mount) {
        Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
        Module["websocket"]._callbacks = {};
        Module["websocket"]["on"] = /** @this{Object} */
        function(event, callback) {
          if ("function" === typeof callback) {
            this._callbacks[event] = callback;
          }
          return this;
        };
        Module["websocket"].emit = /** @this{Object} */
        function(event, param) {
          if ("function" === typeof this._callbacks[event]) {
            this._callbacks[event].call(this, param);
          }
        };
        return FS.createNode(null, "/", 16384 | 511, 0);
      },
      createSocket(family, type, protocol) {
        type &= ~526336;
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66);
        }
        var sock = {
          family,
          type,
          protocol,
          server: null,
          error: null,
          // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
        var name2 = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name2, 49152, 0);
        node.sock = sock;
        var stream2 = FS.createStream({
          path: name2,
          node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
        sock.stream = stream2;
        return sock;
      },
      getSocket(fd) {
        var stream2 = FS.getStream(fd);
        if (!stream2 || !FS.isSocket(stream2.node.mode)) {
          return null;
        }
        return stream2.node.sock;
      },
      stream_ops: {
        poll(stream2) {
          var sock = stream2.node.sock;
          return sock.sock_ops.poll(sock);
        },
        ioctl(stream2, request, varargs) {
          var sock = stream2.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },
        read(stream2, buffer, offset, length, position) {
          var sock = stream2.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },
        write(stream2, buffer, offset, length, position) {
          var sock = stream2.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },
        close(stream2) {
          var sock = stream2.node.sock;
          sock.sock_ops.close(sock);
        }
      },
      nextname() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return "socket[" + SOCKFS.nextname.current++ + "]";
      },
      websocket_sock_ops: {
        createPeer(sock, addr2, port) {
          var ws;
          if (typeof addr2 == "object") {
            ws = addr2;
            addr2 = null;
            port = null;
          }
          if (ws) {
            if (ws._socket) {
              addr2 = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            } else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error("WebSocket URL must be in the format ws(s)://address:port");
              }
              addr2 = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            try {
              var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
              var url = "ws:#".replace("#", "//");
              if (runtimeConfig) {
                if ("string" === typeof Module["websocket"]["url"]) {
                  url = Module["websocket"]["url"];
                }
              }
              if (url === "ws://" || url === "wss://") {
                var parts2 = addr2.split("/");
                url = url + parts2[0] + ":" + port + "/" + parts2.slice(1).join("/");
              }
              var subProtocols = "binary";
              if (runtimeConfig) {
                if ("string" === typeof Module["websocket"]["subprotocol"]) {
                  subProtocols = Module["websocket"]["subprotocol"];
                }
              }
              var opts = void 0;
              if (subProtocols !== "null") {
                subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
                opts = subProtocols;
              }
              if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                subProtocols = "null";
                opts = void 0;
              }
              var WebSocketConstructor;
              if (ENVIRONMENT_IS_NODE) {
                WebSocketConstructor = /** @type{(typeof WebSocket)} */
                require("ws");
              } else {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = "arraybuffer";
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }
          var peer = {
            addr: addr2,
            port,
            socket: ws,
            dgram_send_queue: []
          };
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
          if (sock.type === 2 && typeof sock.sport != "undefined") {
            peer.dgram_send_queue.push(new Uint8Array([
              255,
              255,
              255,
              255,
              "p".charCodeAt(0),
              "o".charCodeAt(0),
              "r".charCodeAt(0),
              "t".charCodeAt(0),
              (sock.sport & 65280) >> 8,
              sock.sport & 255
            ]));
          }
          return peer;
        },
        getPeer(sock, addr2, port) {
          return sock.peers[addr2 + ":" + port];
        },
        addPeer(sock, peer) {
          sock.peers[peer.addr + ":" + peer.port] = peer;
        },
        removePeer(sock, peer) {
          delete sock.peers[peer.addr + ":" + peer.port];
        },
        handlePeerEvents(sock, peer) {
          var first = true;
          var handleOpen = function() {
            Module["websocket"].emit("open", sock.stream.fd);
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              peer.socket.close();
            }
          };
          function handleMessage(data) {
            if (typeof data == "string") {
              var encoder = new TextEncoder();
              data = encoder.encode(data);
            } else {
              assert(data.byteLength !== void 0);
              if (data.byteLength == 0) {
                return;
              }
              data = new Uint8Array(data);
            }
            var wasfirst = first;
            first = false;
            if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
              var newport = data[8] << 8 | data[9];
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data });
            Module["websocket"].emit("message", sock.stream.fd);
          }
          ;
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on("open", handleOpen);
            peer.socket.on("message", function(data, isBinary) {
              if (!isBinary) {
                return;
              }
              handleMessage(new Uint8Array(data).buffer);
            });
            peer.socket.on("close", function() {
              Module["websocket"].emit("close", sock.stream.fd);
            });
            peer.socket.on("error", function(error2) {
              sock.error = 14;
              Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module["websocket"].emit("close", sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error2) {
              sock.error = 14;
              Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
            };
          }
        },
        poll(sock) {
          if (sock.type === 1 && sock.server) {
            return sock.pending.length ? 64 | 1 : 0;
          }
          var mask = 0;
          var dest = sock.type === 1 ? (
            // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport)
          ) : null;
          if (sock.recv_queue.length || !dest || // connection-less sockets are always ready to read
          dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
            mask |= 64 | 1;
          }
          if (!dest || // connection-less sockets are always ready to write
          dest && dest.socket.readyState === dest.socket.OPEN) {
            mask |= 4;
          }
          if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
            mask |= 16;
          }
          return mask;
        },
        ioctl(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[arg >> 2] = bytes;
              return 0;
            default:
              return 28;
          }
        },
        close(sock) {
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          var peers = Object.keys(sock.peers);
          for (var i3 = 0; i3 < peers.length; i3++) {
            var peer = sock.peers[peers[i3]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },
        bind(sock, addr2, port) {
          if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
            throw new FS.ErrnoError(28);
          }
          sock.saddr = addr2;
          sock.sport = port;
          if (sock.type === 2) {
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e.name === "ErrnoError"))
                throw e;
              if (e.errno !== 138)
                throw e;
            }
          }
        },
        connect(sock, addr2, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }
          if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
          throw new FS.ErrnoError(26);
        },
        listen(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
          if (sock.server) {
            throw new FS.ErrnoError(28);
          }
          var WebSocketServer = require("ws").Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host,
            port: sock.sport
            // TODO support backlog
          });
          Module["websocket"].emit("listen", sock.stream.fd);
          sock.server.on("connection", function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
              sock.pending.push(newsock);
              Module["websocket"].emit("connection", newsock.stream.fd);
            } else {
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module["websocket"].emit("connection", sock.stream.fd);
            }
          });
          sock.server.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
            sock.server = null;
          });
          sock.server.on("error", function(error2) {
            sock.error = 23;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
          });
        },
        accept(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },
        getname(sock, peer) {
          var addr2, port;
          if (peer) {
            if (sock.daddr === void 0 || sock.dport === void 0) {
              throw new FS.ErrnoError(53);
            }
            addr2 = sock.daddr;
            port = sock.dport;
          } else {
            addr2 = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr2, port };
        },
        sendmsg(sock, buffer, offset, length, addr2, port) {
          if (sock.type === 2) {
            if (addr2 === void 0 || port === void 0) {
              addr2 = sock.daddr;
              port = sock.dport;
            }
            if (addr2 === void 0 || port === void 0) {
              throw new FS.ErrnoError(17);
            }
          } else {
            addr2 = sock.daddr;
            port = sock.dport;
          }
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr2, port);
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(6);
            }
          }
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
          var data;
          data = buffer.slice(offset, offset + length);
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
          try {
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },
        recvmsg(sock, length) {
          if (sock.type === 1 && sock.server) {
            throw new FS.ErrnoError(53);
          }
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
              if (!dest) {
                throw new FS.ErrnoError(53);
              }
              if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                return null;
              }
              throw new FS.ErrnoError(6);
            }
            throw new FS.ErrnoError(6);
          }
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
          return res;
        }
      }
    };
    var getSocketFromFD = (fd) => {
      var socket = SOCKFS.getSocket(fd);
      if (!socket)
        throw new FS.ErrnoError(8);
      return socket;
    };
    var Sockets = {
      BUFFER_SIZE: 10240,
      MAX_BUFFER_SIZE: 10485760,
      nextFd: 1,
      fds: {},
      nextport: 1,
      maxport: 65535,
      peer: null,
      connections: {},
      portmap: {},
      localAddr: 4261412874,
      addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
    };
    var inetNtop4 = (addr2) => {
      return (addr2 & 255) + "." + (addr2 >> 8 & 255) + "." + (addr2 >> 16 & 255) + "." + (addr2 >> 24 & 255);
    };
    var inetNtop6 = (ints) => {
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i3 = 0;
      var parts2 = [
        ints[0] & 65535,
        ints[0] >> 16,
        ints[1] & 65535,
        ints[1] >> 16,
        ints[2] & 65535,
        ints[2] >> 16,
        ints[3] & 65535,
        ints[3] >> 16
      ];
      var hasipv4 = true;
      var v4part = "";
      for (i3 = 0; i3 < 5; i3++) {
        if (parts2[i3] !== 0) {
          hasipv4 = false;
          break;
        }
      }
      if (hasipv4) {
        v4part = inetNtop4(parts2[6] | parts2[7] << 16);
        if (parts2[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        if (parts2[5] === 0) {
          str = "::";
          if (v4part === "0.0.0.0")
            v4part = "";
          if (v4part === "0.0.0.1")
            v4part = "1";
          str += v4part;
          return str;
        }
      }
      for (word = 0; word < 8; word++) {
        if (parts2[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          if (parts2[word] === 0 && word >= zstart && word < zstart + longest) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0)
                str += ":";
            }
            continue;
          }
        }
        str += Number(_ntohs(parts2[word] & 65535)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    };
    var readSockaddr = (sa, salen) => {
      var family = HEAP16[sa >> 1];
      var port = _ntohs(HEAPU16[sa + 2 >> 1]);
      var addr2;
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr2 = HEAP32[sa + 4 >> 2];
          addr2 = inetNtop4(addr2);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr2 = [
            HEAP32[sa + 8 >> 2],
            HEAP32[sa + 12 >> 2],
            HEAP32[sa + 16 >> 2],
            HEAP32[sa + 20 >> 2]
          ];
          addr2 = inetNtop6(addr2);
          break;
        default:
          return { errno: 5 };
      }
      return { family, addr: addr2, port };
    };
    var inetPton4 = (str) => {
      var b4 = str.split(".");
      for (var i3 = 0; i3 < 4; i3++) {
        var tmp = Number(b4[i3]);
        if (isNaN(tmp))
          return null;
        b4[i3] = tmp;
      }
      return (b4[0] | b4[1] << 8 | b4[2] << 16 | b4[3] << 24) >>> 0;
    };
    var jstoi_q = (str) => parseInt(str);
    var inetPton6 = (str) => {
      var words;
      var w6, offset, z4, i3;
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
      var parts2 = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:");
      } else {
        str = str.replace("::", ":Z:");
      }
      if (str.indexOf(".") > 0) {
        str = str.replace(new RegExp("[.]", "g"), ":");
        words = str.split(":");
        words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
        words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
        words = words.slice(0, words.length - 2);
      } else {
        words = str.split(":");
      }
      offset = 0;
      z4 = 0;
      for (w6 = 0; w6 < words.length; w6++) {
        if (typeof words[w6] == "string") {
          if (words[w6] === "Z") {
            for (z4 = 0; z4 < 8 - words.length + 1; z4++) {
              parts2[w6 + z4] = 0;
            }
            offset = z4 - 1;
          } else {
            parts2[w6 + offset] = _htons(parseInt(words[w6], 16));
          }
        } else {
          parts2[w6 + offset] = words[w6];
        }
      }
      return [
        parts2[1] << 16 | parts2[0],
        parts2[3] << 16 | parts2[2],
        parts2[5] << 16 | parts2[4],
        parts2[7] << 16 | parts2[6]
      ];
    };
    var DNS = {
      address_map: {
        id: 1,
        addrs: {},
        names: {}
      },
      lookup_name(name2) {
        var res = inetPton4(name2);
        if (res !== null) {
          return name2;
        }
        res = inetPton6(name2);
        if (res !== null) {
          return name2;
        }
        var addr2;
        if (DNS.address_map.addrs[name2]) {
          addr2 = DNS.address_map.addrs[name2];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, "exceeded max address mappings of 65535");
          addr2 = "172.29." + (id & 255) + "." + (id & 65280);
          DNS.address_map.names[addr2] = name2;
          DNS.address_map.addrs[name2] = addr2;
        }
        return addr2;
      },
      lookup_addr(addr2) {
        if (DNS.address_map.names[addr2]) {
          return DNS.address_map.names[addr2];
        }
        return null;
      }
    };
    var getSocketAddress = (addrp, addrlen) => {
      var info2 = readSockaddr(addrp, addrlen);
      if (info2.errno)
        throw new FS.ErrnoError(info2.errno);
      info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;
      return info2;
    };
    function ___syscall_bind(fd, addr2, addrlen, d1, d22, d3) {
      try {
        var sock = getSocketFromFD(fd);
        var info2 = getSocketAddress(addr2, addrlen);
        sock.sock_ops.bind(sock, info2.addr, info2.port);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_bind.sig = "iippiii";
    function ___syscall_chdir(path2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.chdir(path2);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_chdir.sig = "ip";
    function ___syscall_chmod(path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.chmod(path2, mode);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_chmod.sig = "ipi";
    function ___syscall_connect(fd, addr2, addrlen, d1, d22, d3) {
      try {
        var sock = getSocketFromFD(fd);
        var info2 = getSocketAddress(addr2, addrlen);
        sock.sock_ops.connect(sock, info2.addr, info2.port);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_connect.sig = "iippiii";
    function ___syscall_dup(fd) {
      try {
        var old = SYSCALLS.getStreamFromFD(fd);
        return FS.dupStream(old).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_dup.sig = "ii";
    function ___syscall_dup3(fd, newfd, flags2) {
      try {
        var old = SYSCALLS.getStreamFromFD(fd);
        if (old.fd === newfd)
          return -28;
        if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS)
          return -8;
        var existing = FS.getStream(newfd);
        if (existing)
          FS.close(existing);
        return FS.dupStream(old, newfd).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_dup3.sig = "iiii";
    function ___syscall_faccessat(dirfd, path2, amode, flags2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (amode & ~7) {
          return -28;
        }
        var lookup3 = FS.lookupPath(path2, { follow: true });
        var node = lookup3.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_faccessat.sig = "iipii";
    var ___syscall_fadvise64 = (fd, offset, len, advice) => {
      return 0;
    };
    ___syscall_fadvise64.sig = "iijji";
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
    function ___syscall_fallocate(fd, mode, offset, len) {
      offset = bigintToI53Checked(offset);
      len = bigintToI53Checked(len);
      try {
        if (isNaN(offset))
          return 61;
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        FS.allocate(stream2, offset, len);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
      ;
    }
    ___syscall_fallocate.sig = "iiijj";
    function syscallGetVarargI() {
      var ret = HEAP32[+SYSCALLS.varargs >> 2];
      SYSCALLS.varargs += 4;
      return ret;
    }
    var syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = syscallGetVarargI();
            if (arg < 0) {
              return -28;
            }
            while (FS.streams[arg]) {
              arg++;
            }
            var newStream;
            newStream = FS.dupStream(stream2, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream2.flags;
          case 4: {
            var arg = syscallGetVarargI();
            stream2.flags |= arg;
            return 0;
          }
          case 12: {
            var arg = syscallGetVarargP();
            var offset = 0;
            HEAP16[arg + offset >> 1] = 2;
            return 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_fcntl64.sig = "iiip";
    function ___syscall_fdatasync(fd) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_fdatasync.sig = "ii";
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream2.path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_fstat64.sig = "iip";
    function ___syscall_ftruncate64(fd, length) {
      length = bigintToI53Checked(length);
      try {
        if (isNaN(length))
          return 61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
      ;
    }
    ___syscall_ftruncate64.sig = "iij";
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
    function ___syscall_getcwd(buf, size) {
      try {
        if (size === 0)
          return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size < cwdLengthInBytes)
          return -68;
        stringToUTF8(cwd, buf, size);
        return cwdLengthInBytes;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_getcwd.sig = "ipp";
    function ___syscall_getdents64(fd, dirp, count) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        stream2.getdents || (stream2.getdents = FS.readdir(stream2.path));
        var struct_size = 280;
        var pos = 0;
        var off = FS.llseek(stream2, 0, 1);
        var idx = Math.floor(off / struct_size);
        while (idx < stream2.getdents.length && pos + struct_size <= count) {
          var id;
          var type;
          var name2 = stream2.getdents[idx];
          if (name2 === ".") {
            id = stream2.node.id;
            type = 4;
          } else if (name2 === "..") {
            var lookup3 = FS.lookupPath(stream2.path, { parent: true });
            id = lookup3.node.id;
            type = 4;
          } else {
            var child = FS.lookupNode(stream2.node, name2);
            id = child.id;
            type = FS.isChrdev(child.mode) ? 2 : (
              // DT_CHR, character device.
              FS.isDir(child.mode) ? 4 : (
                // DT_DIR, directory.
                FS.isLink(child.mode) ? 10 : (
                  // DT_LNK, symbolic link.
                  8
                )
              )
            );
          }
          HEAP64[dirp + pos >> 3] = BigInt(id);
          HEAP64[dirp + pos + 8 >> 3] = BigInt((idx + 1) * struct_size);
          HEAP16[dirp + pos + 16 >> 1] = 280;
          HEAP8[dirp + pos + 18] = type;
          stringToUTF8(name2, dirp + pos + 19, 256);
          pos += struct_size;
          idx += 1;
        }
        FS.llseek(stream2, idx * struct_size, 0);
        return pos;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_getdents64.sig = "iipp";
    var writeSockaddr = (sa, family, addr2, port, addrlen) => {
      switch (family) {
        case 2:
          addr2 = inetPton4(addr2);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[addrlen >> 2] = 16;
          }
          HEAP16[sa >> 1] = family;
          HEAP32[sa + 4 >> 2] = addr2;
          HEAP16[sa + 2 >> 1] = _htons(port);
          break;
        case 10:
          addr2 = inetPton6(addr2);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[addrlen >> 2] = 28;
          }
          HEAP32[sa >> 2] = family;
          HEAP32[sa + 8 >> 2] = addr2[0];
          HEAP32[sa + 12 >> 2] = addr2[1];
          HEAP32[sa + 16 >> 2] = addr2[2];
          HEAP32[sa + 20 >> 2] = addr2[3];
          HEAP16[sa + 2 >> 1] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    };
    function ___syscall_getsockname(fd, addr2, addrlen, d1, d22, d3) {
      try {
        var sock = getSocketFromFD(fd);
        var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_getsockname.sig = "iippiii";
    function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
      try {
        var sock = getSocketFromFD(fd);
        if (level === 1) {
          if (optname === 4) {
            HEAP32[optval >> 2] = sock.error;
            HEAP32[optlen >> 2] = 4;
            sock.error = null;
            return 0;
          }
        }
        return -50;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_getsockopt.sig = "iiiippi";
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509: {
            if (!stream2.tty)
              return -59;
            return 0;
          }
          case 21505: {
            if (!stream2.tty)
              return -59;
            if (stream2.tty.ops.ioctl_tcgets) {
              var termios = stream2.tty.ops.ioctl_tcgets(stream2);
              var argp = syscallGetVarargP();
              HEAP32[argp >> 2] = termios.c_iflag || 0;
              HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
              HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
              HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
              for (var i3 = 0; i3 < 32; i3++) {
                HEAP8[argp + i3 + 17] = termios.c_cc[i3] || 0;
              }
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512: {
            if (!stream2.tty)
              return -59;
            return 0;
          }
          case 21506:
          case 21507:
          case 21508: {
            if (!stream2.tty)
              return -59;
            if (stream2.tty.ops.ioctl_tcsets) {
              var argp = syscallGetVarargP();
              var c_iflag = HEAP32[argp >> 2];
              var c_oflag = HEAP32[argp + 4 >> 2];
              var c_cflag = HEAP32[argp + 8 >> 2];
              var c_lflag = HEAP32[argp + 12 >> 2];
              var c_cc = [];
              for (var i3 = 0; i3 < 32; i3++) {
                c_cc.push(HEAP8[argp + i3 + 17]);
              }
              return stream2.tty.ops.ioctl_tcsets(stream2.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
            }
            return 0;
          }
          case 21519: {
            if (!stream2.tty)
              return -59;
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream2.tty)
              return -59;
            return -28;
          }
          case 21531: {
            var argp = syscallGetVarargP();
            return FS.ioctl(stream2, op, argp);
          }
          case 21523: {
            if (!stream2.tty)
              return -59;
            if (stream2.tty.ops && stream2.tty.ops.ioctl_tiocgwinsz) {
              var winsize = stream2.tty.ops.ioctl_tiocgwinsz(stream2.tty);
              var argp = syscallGetVarargP();
              HEAP16[argp >> 1] = winsize[0];
              HEAP16[argp + 2 >> 1] = winsize[1];
            }
            return 0;
          }
          case 21524: {
            if (!stream2.tty)
              return -59;
            return 0;
          }
          case 21515: {
            if (!stream2.tty)
              return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_ioctl.sig = "iiip";
    function ___syscall_lstat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.lstat, path2, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_lstat64.sig = "ipp";
    function ___syscall_mkdirat(dirfd, path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        path2 = PATH.normalize(path2);
        if (path2[path2.length - 1] === "/")
          path2 = path2.substr(0, path2.length - 1);
        FS.mkdir(path2, mode, 0);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_mkdirat.sig = "iipi";
    function ___syscall_newfstatat(dirfd, path2, buf, flags2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        var nofollow = flags2 & 256;
        var allowEmpty = flags2 & 4096;
        flags2 = flags2 & ~6400;
        path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_newfstatat.sig = "iippi";
    function ___syscall_openat(dirfd, path2, flags2, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        var mode = varargs ? syscallGetVarargI() : 0;
        return FS.open(path2, flags2, mode).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_openat.sig = "iipip";
    var PIPEFS = {
      BUCKET_BUFFER_SIZE: 8192,
      mount(mount) {
        return FS.createNode(null, "/", 16384 | 511, 0);
      },
      createPipe() {
        var pipe = {
          buckets: [],
          // refcnt 2 because pipe has a read end and a write end. We need to be
          // able to read from the read end after write end is closed.
          refcnt: 2
        };
        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });
        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
        rNode.pipe = pipe;
        wNode.pipe = pipe;
        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: 0,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;
        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: 1,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;
        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },
      stream_ops: {
        poll(stream2) {
          var pipe = stream2.node.pipe;
          if ((stream2.flags & 2097155) === 1) {
            return 256 | 4;
          }
          if (pipe.buckets.length > 0) {
            for (var i3 = 0; i3 < pipe.buckets.length; i3++) {
              var bucket = pipe.buckets[i3];
              if (bucket.offset - bucket.roffset > 0) {
                return 64 | 1;
              }
            }
          }
          return 0;
        },
        ioctl(stream2, request, varargs) {
          return 28;
        },
        fsync(stream2) {
          return 28;
        },
        read(stream2, buffer, offset, length, position) {
          var pipe = stream2.node.pipe;
          var currentLength = 0;
          for (var i3 = 0; i3 < pipe.buckets.length; i3++) {
            var bucket = pipe.buckets[i3];
            currentLength += bucket.offset - bucket.roffset;
          }
          var data = buffer.subarray(offset, offset + length);
          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            throw new FS.ErrnoError(6);
          }
          var toRead = Math.min(currentLength, length);
          var totalRead = toRead;
          var toRemove = 0;
          for (var i3 = 0; i3 < pipe.buckets.length; i3++) {
            var currBucket = pipe.buckets[i3];
            var bucketSize = currBucket.offset - currBucket.roffset;
            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }
          if (toRemove && toRemove == pipe.buckets.length) {
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }
          pipe.buckets.splice(0, toRemove);
          return totalRead;
        },
        write(stream2, buffer, offset, length, position) {
          var pipe = stream2.node.pipe;
          var data = buffer.subarray(offset, offset + length);
          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }
          var currBucket = null;
          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }
          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }
          var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
          for (var i3 = 0; i3 < numBuckets; i3++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }
          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }
          return dataLen;
        },
        close(stream2) {
          var pipe = stream2.node.pipe;
          pipe.refcnt--;
          if (pipe.refcnt === 0) {
            pipe.buckets = null;
          }
        }
      },
      nextname() {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return "pipe[" + PIPEFS.nextname.current++ + "]";
      }
    };
    function ___syscall_pipe(fdPtr) {
      try {
        if (fdPtr == 0) {
          throw new FS.ErrnoError(21);
        }
        var res = PIPEFS.createPipe();
        HEAP32[fdPtr >> 2] = res.readable_fd;
        HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_pipe.sig = "ip";
    function ___syscall_poll(fds, nfds, timeout) {
      try {
        var nonzero = 0;
        for (var i3 = 0; i3 < nfds; i3++) {
          var pollfd = fds + 8 * i3;
          var fd = HEAP32[pollfd >> 2];
          var events = HEAP16[pollfd + 4 >> 1];
          var mask = 32;
          var stream2 = FS.getStream(fd);
          if (stream2) {
            mask = SYSCALLS.DEFAULT_POLLMASK;
            if (stream2.stream_ops.poll) {
              mask = stream2.stream_ops.poll(stream2, -1);
            }
          }
          mask &= events | 8 | 16;
          if (mask)
            nonzero++;
          HEAP16[pollfd + 6 >> 1] = mask;
        }
        return nonzero;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_poll.sig = "ipii";
    function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path2);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_readlinkat.sig = "iippp";
    function ___syscall_recvfrom(fd, buf, len, flags2, addr2, addrlen) {
      try {
        var sock = getSocketFromFD(fd);
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg)
          return 0;
        if (addr2) {
          var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
        }
        HEAPU8.set(msg.buffer, buf);
        return msg.buffer.byteLength;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_recvfrom.sig = "iippipp";
    function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
      try {
        oldpath = SYSCALLS.getStr(oldpath);
        newpath = SYSCALLS.getStr(newpath);
        oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
        newpath = SYSCALLS.calculateAt(newdirfd, newpath);
        FS.rename(oldpath, newpath);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_renameat.sig = "iipip";
    function ___syscall_rmdir(path2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.rmdir(path2);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_rmdir.sig = "ip";
    function ___syscall_sendto(fd, message, length, flags2, addr2, addr_len) {
      try {
        var sock = getSocketFromFD(fd);
        if (!addr2) {
          return FS.write(sock.stream, HEAP8, message, length);
        }
        var dest = getSocketAddress(addr2, addr_len);
        return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_sendto.sig = "iippipp";
    function ___syscall_socket(domain, type, protocol) {
      try {
        var sock = SOCKFS.createSocket(domain, type, protocol);
        return sock.stream.fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_socket.sig = "iiiiiii";
    function ___syscall_stat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.stat, path2, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_stat64.sig = "ipp";
    function ___syscall_symlink(target, linkpath) {
      try {
        target = SYSCALLS.getStr(target);
        linkpath = SYSCALLS.getStr(linkpath);
        FS.symlink(target, linkpath);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_symlink.sig = "ipp";
    function ___syscall_truncate64(path2, length) {
      length = bigintToI53Checked(length);
      try {
        if (isNaN(length))
          return 61;
        path2 = SYSCALLS.getStr(path2);
        FS.truncate(path2, length);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
      ;
    }
    ___syscall_truncate64.sig = "ipj";
    function ___syscall_unlinkat(dirfd, path2, flags2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (flags2 === 0) {
          FS.unlink(path2);
        } else if (flags2 === 512) {
          FS.rmdir(path2);
        } else {
          abort("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
    }
    ___syscall_unlinkat.sig = "iipi";
    var ___table_base = new WebAssembly.Global({ "value": "i32", "mutable": false }, 1);
    var __abort_js = () => {
      abort("");
    };
    __abort_js.sig = "v";
    var ENV = {};
    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
    var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
    var dlSetError = (msg) => {
      var sp = stackSave();
      var cmsg = stringToUTF8OnStack(msg);
      ___dl_seterr(cmsg, 0);
      stackRestore(sp);
    };
    var dlopenInternal = (handle2, jsflags) => {
      var filename = UTF8ToString(handle2 + 36);
      var flags2 = HEAP32[handle2 + 4 >> 2];
      filename = PATH.normalize(filename);
      var searchpaths = [];
      var global2 = Boolean(flags2 & 256);
      var localScope2 = global2 ? null : {};
      var combinedFlags = {
        global: global2,
        nodelete: Boolean(flags2 & 4096),
        loadAsync: jsflags.loadAsync
      };
      if (jsflags.loadAsync) {
        return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
      }
      try {
        return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
      } catch (e) {
        dlSetError(`Could not load dynamic lib: ${filename}
${e}`);
        return 0;
      }
    };
    var __dlopen_js = (handle2) => {
      return dlopenInternal(handle2, { loadAsync: false });
    };
    __dlopen_js.sig = "pp";
    var __dlsym_js = (handle2, symbol, symbolIndex) => {
      symbol = UTF8ToString(symbol);
      var result;
      var newSymIndex;
      var lib = LDSO.loadedLibsByHandle[handle2];
      if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
        dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);
        return 0;
      }
      newSymIndex = Object.keys(lib.exports).indexOf(symbol);
      result = lib.exports[symbol];
      if (typeof result == "function") {
        var addr2 = getFunctionAddress(result);
        if (addr2) {
          result = addr2;
        } else {
          result = addFunction(result, result.sig);
          HEAPU32[symbolIndex >> 2] = newSymIndex;
        }
      }
      return result;
    };
    __dlsym_js.sig = "pppp";
    var nowIsMonotonic = 1;
    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
    __emscripten_get_now_is_monotonic.sig = "i";
    var __emscripten_runtime_keepalive_clear = () => {
      noExitRuntime = false;
      runtimeKeepaliveCounter = 0;
    };
    __emscripten_runtime_keepalive_clear.sig = "v";
    var __emscripten_system = (command) => {
      if (ENVIRONMENT_IS_NODE) {
        if (!command)
          return 1;
        var cmdstr = UTF8ToString(command);
        if (!cmdstr.length)
          return 0;
        var cp = require("child_process");
        var ret = cp.spawnSync(cmdstr, [], { shell: true, stdio: "inherit" });
        var _W_EXITCODE = (ret2, sig) => ret2 << 8 | sig;
        if (ret.status === null) {
          var signalToNumber = (sig) => {
            switch (sig) {
              case "SIGHUP":
                return 1;
              case "SIGQUIT":
                return 3;
              case "SIGFPE":
                return 8;
              case "SIGKILL":
                return 9;
              case "SIGALRM":
                return 14;
              case "SIGTERM":
                return 15;
              default:
                return 2;
            }
          };
          return _W_EXITCODE(0, signalToNumber(ret.signal));
        }
        return _W_EXITCODE(ret.status, 0);
      }
      if (!command)
        return 0;
      return -52;
    };
    __emscripten_system.sig = "ip";
    var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
    __emscripten_throw_longjmp.sig = "v";
    function __gmtime_js(time, tmPtr) {
      time = bigintToI53Checked(time);
      var date = new Date(time * 1e3);
      HEAP32[tmPtr >> 2] = date.getUTCSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      ;
    }
    __gmtime_js.sig = "vjp";
    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    };
    function __localtime_js(time, tmPtr) {
      time = bigintToI53Checked(time);
      var date = new Date(time * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
      var start2 = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start2.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
      ;
    }
    __localtime_js.sig = "vjp";
    function __mmap_js(len, prot, flags2, fd, offset, allocated, addr2) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream2, len, offset, prot, flags2);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr2 >> 2] = ptr;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
      ;
    }
    __mmap_js.sig = "ipiiijpp";
    function __munmap_js(addr2, len, prot, flags2, fd, offset) {
      offset = bigintToI53Checked(offset);
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr2, stream2, len, flags2, offset);
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return -e.errno;
      }
      ;
    }
    __munmap_js.sig = "ippiiij";
    var timers = {};
    var handleException = (e) => {
      if (e instanceof ExitStatus || e == "unwind") {
        return EXITSTATUS;
      }
      quit_(1, e);
    };
    var runtimeKeepaliveCounter = 0;
    var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
    var _proc_exit = (code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module["onExit"]?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
    _proc_exit.sig = "vi";
    var exitJS = (status, implicit) => {
      EXITSTATUS = status;
      _proc_exit(status);
    };
    var _exit = exitJS;
    _exit.sig = "vi";
    var maybeExit = () => {
      if (!keepRuntimeAlive()) {
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
      }
    };
    var callUserCallback = (func2) => {
      if (ABORT) {
        return;
      }
      try {
        func2();
        maybeExit();
      } catch (e) {
        handleException(e);
      }
    };
    var _emscripten_get_now = () => performance.now();
    _emscripten_get_now.sig = "d";
    var __setitimer_js = (which, timeout_ms) => {
      if (timers[which]) {
        clearTimeout(timers[which].id);
        delete timers[which];
      }
      if (!timeout_ms)
        return 0;
      var id = setTimeout(() => {
        delete timers[which];
        callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
      }, timeout_ms);
      timers[which] = { id, timeout_ms };
      return 0;
    };
    __setitimer_js.sig = "iid";
    var __tzset_js = (timezone, daylight, std_name, dst_name) => {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      var extractZone = (timezoneOffset) => {
        var sign = timezoneOffset >= 0 ? "-" : "+";
        var absOffset = Math.abs(timezoneOffset);
        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes = String(absOffset % 60).padStart(2, "0");
        return `UTC${sign}${hours}${minutes}`;
      };
      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    };
    __tzset_js.sig = "vpppp";
    var readEmAsmArgsArray = [];
    var readEmAsmArgs = (sigPtr, buf) => {
      readEmAsmArgsArray.length = 0;
      var ch;
      while (ch = HEAPU8[sigPtr++]) {
        var wide = ch != 105;
        wide &= ch != 112;
        buf += wide && buf % 8 ? 4 : 0;
        readEmAsmArgsArray.push(
          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
          ch == 112 ? HEAPU32[buf >> 2] : ch == 106 ? HEAP64[buf >> 3] : ch == 105 ? HEAP32[buf >> 2] : HEAPF64[buf >> 3]
        );
        buf += wide ? 8 : 4;
      }
      return readEmAsmArgsArray;
    };
    var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args2 = readEmAsmArgs(sigPtr, argbuf);
      return ASM_CONSTS[code](...args2);
    };
    var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };
    _emscripten_asm_const_int.sig = "ippp";
    var _emscripten_date_now = () => Date.now();
    _emscripten_date_now.sig = "d";
    var _emscripten_force_exit = (status) => {
      __emscripten_runtime_keepalive_clear();
      _exit(status);
    };
    _emscripten_force_exit.sig = "vi";
    var getHeapMax = () => (
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648
    );
    var growMemory = (size) => {
      var b4 = wasmMemory.buffer;
      var pages = (size - b4.byteLength + 65535) / 65536;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    };
    _emscripten_resize_heap.sig = "ip";
    var _emscripten_set_main_loop_timing = (mode, value) => {
      MainLoop.timingMode = mode;
      MainLoop.timingValue = value;
      if (!MainLoop.func) {
        return 1;
      }
      if (!MainLoop.running) {
        MainLoop.running = true;
      }
      if (mode == 0) {
        MainLoop.scheduler = function MainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, MainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
          setTimeout(MainLoop.runner, timeUntilNextTick);
        };
        MainLoop.method = "timeout";
      } else if (mode == 1) {
        MainLoop.scheduler = function MainLoop_scheduler_rAF() {
          MainLoop.requestAnimationFrame(MainLoop.runner);
        };
        MainLoop.method = "rAF";
      } else if (mode == 2) {
        if (typeof MainLoop.setImmediate == "undefined") {
          if (typeof setImmediate == "undefined") {
            var setImmediates = [];
            var emscriptenMainLoopMessageId = "setimmediate";
            var MainLoop_setImmediate_messageHandler = (event) => {
              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            };
            addEventListener("message", MainLoop_setImmediate_messageHandler, true);
            MainLoop.setImmediate = /** @type{function(function(): ?, ...?): number} */
            (func2) => {
              setImmediates.push(func2);
              if (ENVIRONMENT_IS_WORKER) {
                Module["setImmediates"] ?? (Module["setImmediates"] = []);
                Module["setImmediates"].push(func2);
                postMessage({ target: emscriptenMainLoopMessageId });
              } else
                postMessage(emscriptenMainLoopMessageId, "*");
            };
          } else {
            MainLoop.setImmediate = setImmediate;
          }
        }
        MainLoop.scheduler = function MainLoop_scheduler_setImmediate() {
          MainLoop.setImmediate(MainLoop.runner);
        };
        MainLoop.method = "immediate";
      }
      return 0;
    };
    _emscripten_set_main_loop_timing.sig = "iii";
    var MainLoop = {
      running: false,
      scheduler: null,
      method: "",
      currentlyRunningMainloop: 0,
      func: null,
      arg: 0,
      timingMode: 0,
      timingValue: 0,
      currentFrameNumber: 0,
      queue: [],
      preMainLoop: [],
      postMainLoop: [],
      pause() {
        MainLoop.scheduler = null;
        MainLoop.currentlyRunningMainloop++;
      },
      resume() {
        MainLoop.currentlyRunningMainloop++;
        var timingMode = MainLoop.timingMode;
        var timingValue = MainLoop.timingValue;
        var func2 = MainLoop.func;
        MainLoop.func = null;
        setMainLoop(func2, 0, false, MainLoop.arg, true);
        _emscripten_set_main_loop_timing(timingMode, timingValue);
        MainLoop.scheduler();
      },
      updateStatus() {
        if (Module["setStatus"]) {
          var message = Module["statusMessage"] || "Please wait...";
          var remaining = MainLoop.remainingBlockers ?? 0;
          var expected = MainLoop.expectedBlockers ?? 0;
          if (remaining) {
            if (remaining < expected) {
              Module["setStatus"](`{message} ({expected - remaining}/{expected})`);
            } else {
              Module["setStatus"](message);
            }
          } else {
            Module["setStatus"]("");
          }
        }
      },
      init() {
        Module["preMainLoop"] && MainLoop.preMainLoop.push(Module["preMainLoop"]);
        Module["postMainLoop"] && MainLoop.postMainLoop.push(Module["postMainLoop"]);
      },
      runIter(func2) {
        if (ABORT)
          return;
        for (var pre of MainLoop.preMainLoop) {
          if (pre() === false) {
            return;
          }
        }
        callUserCallback(func2);
        for (var post of MainLoop.postMainLoop) {
          post();
        }
      },
      nextRAF: 0,
      fakeRequestAnimationFrame(func2) {
        var now = Date.now();
        if (MainLoop.nextRAF === 0) {
          MainLoop.nextRAF = now + 1e3 / 60;
        } else {
          while (now + 2 >= MainLoop.nextRAF) {
            MainLoop.nextRAF += 1e3 / 60;
          }
        }
        var delay = Math.max(MainLoop.nextRAF - now, 0);
        setTimeout(func2, delay);
      },
      requestAnimationFrame(func2) {
        if (typeof requestAnimationFrame == "function") {
          requestAnimationFrame(func2);
          return;
        }
        var RAF = MainLoop.fakeRequestAnimationFrame;
        RAF(func2);
      }
    };
    var setMainLoop = (iterFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
      MainLoop.func = iterFunc;
      MainLoop.arg = arg;
      var thisMainLoopId = MainLoop.currentlyRunningMainloop;
      function checkIsRunning() {
        if (thisMainLoopId < MainLoop.currentlyRunningMainloop) {
          maybeExit();
          return false;
        }
        return true;
      }
      MainLoop.running = false;
      MainLoop.runner = function MainLoop_runner() {
        if (ABORT)
          return;
        if (MainLoop.queue.length > 0) {
          var start2 = Date.now();
          var blocker = MainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (MainLoop.remainingBlockers) {
            var remaining = MainLoop.remainingBlockers;
            var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
            if (blocker.counted) {
              MainLoop.remainingBlockers = next;
            } else {
              next = next + 0.5;
              MainLoop.remainingBlockers = (8 * remaining + next) / 9;
            }
          }
          MainLoop.updateStatus();
          if (!checkIsRunning())
            return;
          setTimeout(MainLoop.runner, 0);
          return;
        }
        if (!checkIsRunning())
          return;
        MainLoop.currentFrameNumber = MainLoop.currentFrameNumber + 1 | 0;
        if (MainLoop.timingMode == 1 && MainLoop.timingValue > 1 && MainLoop.currentFrameNumber % MainLoop.timingValue != 0) {
          MainLoop.scheduler();
          return;
        } else if (MainLoop.timingMode == 0) {
          MainLoop.tickStartTime = _emscripten_get_now();
        }
        MainLoop.runIter(iterFunc);
        if (!checkIsRunning())
          return;
        MainLoop.scheduler();
      };
      if (!noSetTiming) {
        if (fps && fps > 0) {
          _emscripten_set_main_loop_timing(0, 1e3 / fps);
        } else {
          _emscripten_set_main_loop_timing(1, 1);
        }
        MainLoop.scheduler();
      }
      if (simulateInfiniteLoop) {
        throw "unwind";
      }
    };
    var _emscripten_set_main_loop = (func2, fps, simulateInfiniteLoop) => {
      var iterFunc = getWasmTableEntry(func2);
      setMainLoop(iterFunc, fps, simulateInfiniteLoop);
    };
    _emscripten_set_main_loop.sig = "vpii";
    var getExecutableName = () => {
      return thisProgram || "./this.program";
    };
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = {
          "USER": "web_user",
          "LOGNAME": "web_user",
          "PATH": "/",
          "PWD": "/",
          "HOME": "/home/web_user",
          "LANG": lang,
          "_": getExecutableName()
        };
        for (var x4 in ENV) {
          if (ENV[x4] === void 0)
            delete env[x4];
          else
            env[x4] = ENV[x4];
        }
        var strings = [];
        for (var x4 in env) {
          strings.push(`${x4}=${env[x4]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
    var stringToAscii = (str, buffer) => {
      for (var i3 = 0; i3 < str.length; ++i3) {
        HEAP8[buffer++] = str.charCodeAt(i3);
      }
      HEAP8[buffer] = 0;
    };
    var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string, i3) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i3 * 4 >> 2] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
    _environ_get.sig = "ipp";
    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach((string) => bufSize += string.length + 1);
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    };
    _environ_sizes_get.sig = "ipp";
    function _fd_close(fd) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream2);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    _fd_close.sig = "ii";
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags2 = 0;
        {
          var stream2 = SYSCALLS.getStreamFromFD(fd);
          var type = stream2.tty ? 2 : FS.isDir(stream2.mode) ? 3 : FS.isLink(stream2.mode) ? 7 : 4;
        }
        HEAP8[pbuf] = type;
        HEAP16[pbuf + 2 >> 1] = flags2;
        HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
        HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    _fd_fdstat_get.sig = "iip";
    var doReadv = (stream2, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i3 = 0; i3 < iovcnt; i3++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream2, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_pread(fd, iov, iovcnt, offset, pnum) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream2, iov, iovcnt, offset);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
      ;
    }
    _fd_pread.sig = "iippjp";
    var doWritev = (stream2, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i3 = 0; i3 < iovcnt; i3++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream2, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len) {
          break;
        }
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_pwrite(fd, iov, iovcnt, offset, pnum) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream2, iov, iovcnt, offset);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
      ;
    }
    _fd_pwrite.sig = "iippjp";
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream2, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    _fd_read.sig = "iippp";
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream2, offset, whence);
        HEAP64[newOffset >> 3] = BigInt(stream2.position);
        if (stream2.getdents && offset === 0 && whence === 0)
          stream2.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
      ;
    }
    _fd_seek.sig = "iijip";
    function _fd_sync(fd) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        if (stream2.stream_ops?.fsync) {
          return stream2.stream_ops.fsync(stream2);
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    _fd_sync.sig = "ii";
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream2 = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream2, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    _fd_write.sig = "iippp";
    var _getaddrinfo = (node, service, hint, out2) => {
      var addrs = [];
      var canon = null;
      var addr2 = 0;
      var port = 0;
      var flags2 = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last2;
      function allocaddrinfo(family2, type2, proto2, canon2, addr3, port2) {
        var sa, salen, ai2;
        var errno;
        salen = family2 === 10 ? 28 : 16;
        addr3 = family2 === 10 ? inetNtop6(addr3) : inetNtop4(addr3);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family2, addr3, port2);
        assert(!errno);
        ai2 = _malloc(32);
        HEAP32[ai2 + 4 >> 2] = family2;
        HEAP32[ai2 + 8 >> 2] = type2;
        HEAP32[ai2 + 12 >> 2] = proto2;
        HEAPU32[ai2 + 24 >> 2] = canon2;
        HEAPU32[ai2 + 20 >> 2] = sa;
        if (family2 === 10) {
          HEAP32[ai2 + 16 >> 2] = 28;
        } else {
          HEAP32[ai2 + 16 >> 2] = 16;
        }
        HEAP32[ai2 + 28 >> 2] = 0;
        return ai2;
      }
      if (hint) {
        flags2 = HEAP32[hint >> 2];
        family = HEAP32[hint + 4 >> 2];
        type = HEAP32[hint + 8 >> 2];
        proto = HEAP32[hint + 12 >> 2];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
      if (!node && !service) {
        return -2;
      }
      if (flags2 & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
        return -1;
      }
      if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
        return -1;
      }
      if (flags2 & 32) {
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
        if (isNaN(port)) {
          if (flags2 & 1024) {
            return -2;
          }
          return -8;
        }
      }
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags2 & 1) === 0) {
          if (family === 2) {
            addr2 = _htonl(2130706433);
          } else {
            addr2 = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr2, port);
        HEAPU32[out2 >> 2] = ai;
        return 0;
      }
      node = UTF8ToString(node);
      addr2 = inetPton4(node);
      if (addr2 !== null) {
        if (family === 0 || family === 2) {
          family = 2;
        } else if (family === 10 && flags2 & 8) {
          addr2 = [0, 0, _htonl(65535), addr2];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr2 = inetPton6(node);
        if (addr2 !== null) {
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr2 != null) {
        ai = allocaddrinfo(family, type, proto, node, addr2, port);
        HEAPU32[out2 >> 2] = ai;
        return 0;
      }
      if (flags2 & 4) {
        return -2;
      }
      node = DNS.lookup_name(node);
      addr2 = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr2 = [0, 0, _htonl(65535), addr2];
      }
      ai = allocaddrinfo(family, type, proto, null, addr2, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    };
    _getaddrinfo.sig = "ipppp";
    var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags2) => {
      var info2 = readSockaddr(sa, salen);
      if (info2.errno) {
        return -6;
      }
      var port = info2.port;
      var addr2 = info2.addr;
      var overflowed = false;
      if (node && nodelen) {
        var lookup3;
        if (flags2 & 1 || !(lookup3 = DNS.lookup_addr(addr2))) {
          if (flags2 & 8) {
            return -2;
          }
        } else {
          addr2 = lookup3;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr2, node, nodelen);
        if (numBytesWrittenExclNull + 1 >= nodelen) {
          overflowed = true;
        }
      }
      if (serv && servlen) {
        port = "" + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
        if (numBytesWrittenExclNull + 1 >= servlen) {
          overflowed = true;
        }
      }
      if (overflowed) {
        return -12;
      }
      return 0;
    };
    _getnameinfo.sig = "ipipipii";
    var stringToNewUTF8 = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret)
        stringToUTF8(str, ret, size);
      return ret;
    };
    var getCFunc = (ident) => {
      var func2 = Module["_" + ident];
      return func2;
    };
    var writeArrayToMemory = (array, buffer) => {
      HEAP8.set(array, buffer);
    };
    var ccall = (ident, returnType, argTypes, args2, opts) => {
      var toC = {
        "string": (str) => {
          var ret2 = 0;
          if (str !== null && str !== void 0 && str !== 0) {
            ret2 = stringToUTF8OnStack(str);
          }
          return ret2;
        },
        "array": (arr) => {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        }
      };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func2 = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args2) {
        for (var i3 = 0; i3 < args2.length; i3++) {
          var converter = toC[argTypes[i3]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i3] = converter(args2[i3]);
          } else {
            cArgs[i3] = args2[i3];
          }
        }
      }
      var ret = func2(...cArgs);
      function onDone(ret2) {
        if (stack !== 0)
          stackRestore(stack);
        return convertReturnValue(ret2);
      }
      ret = onDone(ret);
      return ret;
    };
    var cwrap = (ident, returnType, argTypes, opts) => {
      var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args2) => ccall(ident, returnType, argTypes, args2, opts);
    };
    var FS_createPath = FS.createPath;
    var FS_unlink = (path2) => FS.unlink(path2);
    var FS_createLazyFile = FS.createLazyFile;
    var FS_createDevice = FS.createDevice;
    var setTempRet0 = (val) => __emscripten_tempret_set(val);
    var _setTempRet0 = setTempRet0;
    Module["_setTempRet0"] = _setTempRet0;
    var getTempRet0 = (val) => __emscripten_tempret_get();
    var _getTempRet0 = getTempRet0;
    Module["_getTempRet0"] = _getTempRet0;
    registerWasmPlugin();
    ;
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    Module["FS_createPath"] = FS.createPath;
    Module["FS_createDataFile"] = FS.createDataFile;
    Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
    Module["FS_unlink"] = FS.unlink;
    Module["FS_createLazyFile"] = FS.createLazyFile;
    Module["FS_createDevice"] = FS.createDevice;
    ;
    if (ENVIRONMENT_IS_NODE) {
      NODEFS.staticInit();
    }
    ;
    Module["requestAnimationFrame"] = MainLoop.requestAnimationFrame;
    Module["pauseMainLoop"] = MainLoop.pause;
    Module["resumeMainLoop"] = MainLoop.resume;
    MainLoop.init();
    ;
    var wasmImports = {
      /** @export */
      __assert_fail: ___assert_fail,
      /** @export */
      __call_sighandler: ___call_sighandler,
      /** @export */
      __heap_base: ___heap_base,
      /** @export */
      __indirect_function_table: wasmTable,
      /** @export */
      __memory_base: ___memory_base,
      /** @export */
      __stack_pointer: ___stack_pointer,
      /** @export */
      __syscall__newselect: ___syscall__newselect,
      /** @export */
      __syscall_bind: ___syscall_bind,
      /** @export */
      __syscall_chdir: ___syscall_chdir,
      /** @export */
      __syscall_chmod: ___syscall_chmod,
      /** @export */
      __syscall_connect: ___syscall_connect,
      /** @export */
      __syscall_dup: ___syscall_dup,
      /** @export */
      __syscall_dup3: ___syscall_dup3,
      /** @export */
      __syscall_faccessat: ___syscall_faccessat,
      /** @export */
      __syscall_fadvise64: ___syscall_fadvise64,
      /** @export */
      __syscall_fallocate: ___syscall_fallocate,
      /** @export */
      __syscall_fcntl64: ___syscall_fcntl64,
      /** @export */
      __syscall_fdatasync: ___syscall_fdatasync,
      /** @export */
      __syscall_fstat64: ___syscall_fstat64,
      /** @export */
      __syscall_ftruncate64: ___syscall_ftruncate64,
      /** @export */
      __syscall_getcwd: ___syscall_getcwd,
      /** @export */
      __syscall_getdents64: ___syscall_getdents64,
      /** @export */
      __syscall_getsockname: ___syscall_getsockname,
      /** @export */
      __syscall_getsockopt: ___syscall_getsockopt,
      /** @export */
      __syscall_ioctl: ___syscall_ioctl,
      /** @export */
      __syscall_lstat64: ___syscall_lstat64,
      /** @export */
      __syscall_mkdirat: ___syscall_mkdirat,
      /** @export */
      __syscall_newfstatat: ___syscall_newfstatat,
      /** @export */
      __syscall_openat: ___syscall_openat,
      /** @export */
      __syscall_pipe: ___syscall_pipe,
      /** @export */
      __syscall_poll: ___syscall_poll,
      /** @export */
      __syscall_readlinkat: ___syscall_readlinkat,
      /** @export */
      __syscall_recvfrom: ___syscall_recvfrom,
      /** @export */
      __syscall_renameat: ___syscall_renameat,
      /** @export */
      __syscall_rmdir: ___syscall_rmdir,
      /** @export */
      __syscall_sendto: ___syscall_sendto,
      /** @export */
      __syscall_socket: ___syscall_socket,
      /** @export */
      __syscall_stat64: ___syscall_stat64,
      /** @export */
      __syscall_symlink: ___syscall_symlink,
      /** @export */
      __syscall_truncate64: ___syscall_truncate64,
      /** @export */
      __syscall_unlinkat: ___syscall_unlinkat,
      /** @export */
      __table_base: ___table_base,
      /** @export */
      _abort_js: __abort_js,
      /** @export */
      _dlopen_js: __dlopen_js,
      /** @export */
      _dlsym_js: __dlsym_js,
      /** @export */
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      /** @export */
      _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
      /** @export */
      _emscripten_system: __emscripten_system,
      /** @export */
      _emscripten_throw_longjmp: __emscripten_throw_longjmp,
      /** @export */
      _gmtime_js: __gmtime_js,
      /** @export */
      _localtime_js: __localtime_js,
      /** @export */
      _mmap_js: __mmap_js,
      /** @export */
      _munmap_js: __munmap_js,
      /** @export */
      _setitimer_js: __setitimer_js,
      /** @export */
      _tzset_js: __tzset_js,
      /** @export */
      emscripten_asm_const_int: _emscripten_asm_const_int,
      /** @export */
      emscripten_date_now: _emscripten_date_now,
      /** @export */
      emscripten_force_exit: _emscripten_force_exit,
      /** @export */
      emscripten_get_now: _emscripten_get_now,
      /** @export */
      emscripten_resize_heap: _emscripten_resize_heap,
      /** @export */
      emscripten_set_main_loop: _emscripten_set_main_loop,
      /** @export */
      environ_get: _environ_get,
      /** @export */
      environ_sizes_get: _environ_sizes_get,
      /** @export */
      exit: _exit,
      /** @export */
      fd_close: _fd_close,
      /** @export */
      fd_fdstat_get: _fd_fdstat_get,
      /** @export */
      fd_pread: _fd_pread,
      /** @export */
      fd_pwrite: _fd_pwrite,
      /** @export */
      fd_read: _fd_read,
      /** @export */
      fd_seek: _fd_seek,
      /** @export */
      fd_sync: _fd_sync,
      /** @export */
      fd_write: _fd_write,
      /** @export */
      getTempRet0: _getTempRet0,
      /** @export */
      getaddrinfo: _getaddrinfo,
      /** @export */
      getnameinfo: _getnameinfo,
      /** @export */
      invoke_di,
      /** @export */
      invoke_i,
      /** @export */
      invoke_id,
      /** @export */
      invoke_ii,
      /** @export */
      invoke_iii,
      /** @export */
      invoke_iiii,
      /** @export */
      invoke_iiiii,
      /** @export */
      invoke_iiiiii,
      /** @export */
      invoke_iiiiiii,
      /** @export */
      invoke_iiiiiiii,
      /** @export */
      invoke_iiiiiiiii,
      /** @export */
      invoke_iiiiiiiiii,
      /** @export */
      invoke_iiiiiiiiiiiiiiiii,
      /** @export */
      invoke_iiiiiji,
      /** @export */
      invoke_iiiij,
      /** @export */
      invoke_iiiijii,
      /** @export */
      invoke_iiij,
      /** @export */
      invoke_iiji,
      /** @export */
      invoke_ij,
      /** @export */
      invoke_ijiiiii,
      /** @export */
      invoke_ijiiiiii,
      /** @export */
      invoke_ji,
      /** @export */
      invoke_jii,
      /** @export */
      invoke_jiiii,
      /** @export */
      invoke_jiiiii,
      /** @export */
      invoke_jiiiiiiii,
      /** @export */
      invoke_v,
      /** @export */
      invoke_vi,
      /** @export */
      invoke_vid,
      /** @export */
      invoke_vii,
      /** @export */
      invoke_viii,
      /** @export */
      invoke_viiii,
      /** @export */
      invoke_viiiii,
      /** @export */
      invoke_viiiiii,
      /** @export */
      invoke_viiiiiii,
      /** @export */
      invoke_viiiiiiii,
      /** @export */
      invoke_viiiiiiiii,
      /** @export */
      invoke_viiiiiiiiiiii,
      /** @export */
      invoke_viiij,
      /** @export */
      invoke_viij,
      /** @export */
      invoke_viiji,
      /** @export */
      invoke_viijii,
      /** @export */
      invoke_viijiiii,
      /** @export */
      invoke_vij,
      /** @export */
      invoke_viji,
      /** @export */
      invoke_vijiji,
      /** @export */
      invoke_vj,
      /** @export */
      invoke_vji,
      /** @export */
      is_web_env,
      /** @export */
      memory: wasmMemory,
      /** @export */
      proc_exit: _proc_exit,
      /** @export */
      setTempRet0: _setTempRet0
    };
    var wasmExports = createWasm();
    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
    var ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports["__wasm_apply_data_relocs"])();
    var _ScanKeywordLookup = Module["_ScanKeywordLookup"] = (a0, a1) => (_ScanKeywordLookup = Module["_ScanKeywordLookup"] = wasmExports["ScanKeywordLookup"])(a0, a1);
    var _pg_snprintf = Module["_pg_snprintf"] = (a0, a1, a2, a3) => (_pg_snprintf = Module["_pg_snprintf"] = wasmExports["pg_snprintf"])(a0, a1, a2, a3);
    var _strlen = Module["_strlen"] = (a0) => (_strlen = Module["_strlen"] = wasmExports["strlen"])(a0);
    var _memset = Module["_memset"] = (a0, a1, a2) => (_memset = Module["_memset"] = wasmExports["memset"])(a0, a1, a2);
    var _strchr = Module["_strchr"] = (a0, a1) => (_strchr = Module["_strchr"] = wasmExports["strchr"])(a0, a1);
    var _PQserverVersion = Module["_PQserverVersion"] = (a0) => (_PQserverVersion = Module["_PQserverVersion"] = wasmExports["PQserverVersion"])(a0);
    var _strstr = Module["_strstr"] = (a0, a1) => (_strstr = Module["_strstr"] = wasmExports["strstr"])(a0, a1);
    var _pg_fprintf = Module["_pg_fprintf"] = (a0, a1, a2) => (_pg_fprintf = Module["_pg_fprintf"] = wasmExports["pg_fprintf"])(a0, a1, a2);
    var _strspn = Module["_strspn"] = (a0, a1) => (_strspn = Module["_strspn"] = wasmExports["strspn"])(a0, a1);
    var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
    var _pg_strcasecmp = Module["_pg_strcasecmp"] = (a0, a1) => (_pg_strcasecmp = Module["_pg_strcasecmp"] = wasmExports["pg_strcasecmp"])(a0, a1);
    var _strcmp = Module["_strcmp"] = (a0, a1) => (_strcmp = Module["_strcmp"] = wasmExports["strcmp"])(a0, a1);
    var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
    var _pg_tolower = Module["_pg_tolower"] = (a0) => (_pg_tolower = Module["_pg_tolower"] = wasmExports["pg_tolower"])(a0);
    var _memchr = Module["_memchr"] = (a0, a1, a2) => (_memchr = Module["_memchr"] = wasmExports["memchr"])(a0, a1, a2);
    var _getenv = Module["_getenv"] = (a0) => (_getenv = Module["_getenv"] = wasmExports["getenv"])(a0);
    var _fileno = Module["_fileno"] = (a0) => (_fileno = Module["_fileno"] = wasmExports["fileno"])(a0);
    var _isatty = Module["_isatty"] = (a0) => (_isatty = Module["_isatty"] = wasmExports["isatty"])(a0);
    var _strdup = Module["_strdup"] = (a0) => (_strdup = Module["_strdup"] = wasmExports["strdup"])(a0);
    var ___errno_location = Module["___errno_location"] = () => (___errno_location = Module["___errno_location"] = wasmExports["__errno_location"])();
    var _fflush = Module["_fflush"] = (a0) => (_fflush = Module["_fflush"] = wasmExports["fflush"])(a0);
    var _pg_vsnprintf = Module["_pg_vsnprintf"] = (a0, a1, a2, a3) => (_pg_vsnprintf = Module["_pg_vsnprintf"] = wasmExports["pg_vsnprintf"])(a0, a1, a2, a3);
    var _pg_malloc_extended = Module["_pg_malloc_extended"] = (a0, a1) => (_pg_malloc_extended = Module["_pg_malloc_extended"] = wasmExports["pg_malloc_extended"])(a0, a1);
    var _errstart_cold = Module["_errstart_cold"] = (a0, a1) => (_errstart_cold = Module["_errstart_cold"] = wasmExports["errstart_cold"])(a0, a1);
    var _errmsg_internal = Module["_errmsg_internal"] = (a0, a1) => (_errmsg_internal = Module["_errmsg_internal"] = wasmExports["errmsg_internal"])(a0, a1);
    var _errfinish = Module["_errfinish"] = (a0, a1, a2) => (_errfinish = Module["_errfinish"] = wasmExports["errfinish"])(a0, a1, a2);
    var _puts = Module["_puts"] = (a0) => (_puts = Module["_puts"] = wasmExports["puts"])(a0);
    var _psprintf = Module["_psprintf"] = (a0, a1) => (_psprintf = Module["_psprintf"] = wasmExports["psprintf"])(a0, a1);
    var _pfree = Module["_pfree"] = (a0) => (_pfree = Module["_pfree"] = wasmExports["pfree"])(a0);
    var _initStringInfo = Module["_initStringInfo"] = (a0) => (_initStringInfo = Module["_initStringInfo"] = wasmExports["initStringInfo"])(a0);
    var _appendStringInfoChar = Module["_appendStringInfoChar"] = (a0, a1) => (_appendStringInfoChar = Module["_appendStringInfoChar"] = wasmExports["appendStringInfoChar"])(a0, a1);
    var _appendStringInfoString = Module["_appendStringInfoString"] = (a0, a1) => (_appendStringInfoString = Module["_appendStringInfoString"] = wasmExports["appendStringInfoString"])(a0, a1);
    var _escape_json = Module["_escape_json"] = (a0, a1) => (_escape_json = Module["_escape_json"] = wasmExports["escape_json"])(a0, a1);
    var _enlargeStringInfo = Module["_enlargeStringInfo"] = (a0, a1) => (_enlargeStringInfo = Module["_enlargeStringInfo"] = wasmExports["enlargeStringInfo"])(a0, a1);
    var _appendStringInfo = Module["_appendStringInfo"] = (a0, a1, a2) => (_appendStringInfo = Module["_appendStringInfo"] = wasmExports["appendStringInfo"])(a0, a1, a2);
    var _errmsg = Module["_errmsg"] = (a0, a1) => (_errmsg = Module["_errmsg"] = wasmExports["errmsg"])(a0, a1);
    var _errcode_for_file_access = Module["_errcode_for_file_access"] = () => (_errcode_for_file_access = Module["_errcode_for_file_access"] = wasmExports["errcode_for_file_access"])();
    var _palloc0 = Module["_palloc0"] = (a0) => (_palloc0 = Module["_palloc0"] = wasmExports["palloc0"])(a0);
    var _palloc = Module["_palloc"] = (a0) => (_palloc = Module["_palloc"] = wasmExports["palloc"])(a0);
    var _errcode = Module["_errcode"] = (a0) => (_errcode = Module["_errcode"] = wasmExports["errcode"])(a0);
    var _bbsink_forward_end_archive = Module["_bbsink_forward_end_archive"] = (a0) => (_bbsink_forward_end_archive = Module["_bbsink_forward_end_archive"] = wasmExports["bbsink_forward_end_archive"])(a0);
    var _memcpy = Module["_memcpy"] = (a0, a1, a2) => (_memcpy = Module["_memcpy"] = wasmExports["memcpy"])(a0, a1, a2);
    var _bbsink_forward_begin_manifest = Module["_bbsink_forward_begin_manifest"] = (a0) => (_bbsink_forward_begin_manifest = Module["_bbsink_forward_begin_manifest"] = wasmExports["bbsink_forward_begin_manifest"])(a0);
    var _bbsink_forward_end_manifest = Module["_bbsink_forward_end_manifest"] = (a0) => (_bbsink_forward_end_manifest = Module["_bbsink_forward_end_manifest"] = wasmExports["bbsink_forward_end_manifest"])(a0);
    var _bbsink_forward_end_backup = Module["_bbsink_forward_end_backup"] = (a0, a1, a2) => (_bbsink_forward_end_backup = Module["_bbsink_forward_end_backup"] = wasmExports["bbsink_forward_end_backup"])(a0, a1, a2);
    var _bbsink_forward_cleanup = Module["_bbsink_forward_cleanup"] = (a0) => (_bbsink_forward_cleanup = Module["_bbsink_forward_cleanup"] = wasmExports["bbsink_forward_cleanup"])(a0);
    var _StartTransactionCommand = Module["_StartTransactionCommand"] = () => (_StartTransactionCommand = Module["_StartTransactionCommand"] = wasmExports["StartTransactionCommand"])();
    var _GetUserId = Module["_GetUserId"] = () => (_GetUserId = Module["_GetUserId"] = wasmExports["GetUserId"])();
    var _has_privs_of_role = Module["_has_privs_of_role"] = (a0, a1) => (_has_privs_of_role = Module["_has_privs_of_role"] = wasmExports["has_privs_of_role"])(a0, a1);
    var _errdetail = Module["_errdetail"] = (a0, a1) => (_errdetail = Module["_errdetail"] = wasmExports["errdetail"])(a0, a1);
    var _CommitTransactionCommand = Module["_CommitTransactionCommand"] = () => (_CommitTransactionCommand = Module["_CommitTransactionCommand"] = wasmExports["CommitTransactionCommand"])();
    var _bbsink_forward_begin_archive = Module["_bbsink_forward_begin_archive"] = (a0, a1) => (_bbsink_forward_begin_archive = Module["_bbsink_forward_begin_archive"] = wasmExports["bbsink_forward_begin_archive"])(a0, a1);
    var _errhint = Module["_errhint"] = (a0, a1) => (_errhint = Module["_errhint"] = wasmExports["errhint"])(a0, a1);
    var _bbsink_forward_archive_contents = Module["_bbsink_forward_archive_contents"] = (a0, a1) => (_bbsink_forward_archive_contents = Module["_bbsink_forward_archive_contents"] = wasmExports["bbsink_forward_archive_contents"])(a0, a1);
    var _bbsink_forward_manifest_contents = Module["_bbsink_forward_manifest_contents"] = (a0, a1) => (_bbsink_forward_manifest_contents = Module["_bbsink_forward_manifest_contents"] = wasmExports["bbsink_forward_manifest_contents"])(a0, a1);
    var _fd_durable_rename = Module["_fd_durable_rename"] = (a0, a1, a2) => (_fd_durable_rename = Module["_fd_durable_rename"] = wasmExports["fd_durable_rename"])(a0, a1, a2);
    var _bbsink_forward_begin_backup = Module["_bbsink_forward_begin_backup"] = (a0) => (_bbsink_forward_begin_backup = Module["_bbsink_forward_begin_backup"] = wasmExports["bbsink_forward_begin_backup"])(a0);
    var _BaseBackupAddTarget = Module["_BaseBackupAddTarget"] = (a0, a1, a2) => (_BaseBackupAddTarget = Module["_BaseBackupAddTarget"] = wasmExports["BaseBackupAddTarget"])(a0, a1, a2);
    var _lappend = Module["_lappend"] = (a0, a1) => (_lappend = Module["_lappend"] = wasmExports["lappend"])(a0, a1);
    var _pstrdup = Module["_pstrdup"] = (a0) => (_pstrdup = Module["_pstrdup"] = wasmExports["pstrdup"])(a0);
    var _GetCurrentTimestamp = Module["_GetCurrentTimestamp"] = () => (_GetCurrentTimestamp = Module["_GetCurrentTimestamp"] = wasmExports["GetCurrentTimestamp"])();
    var _CreateDestReceiver = Module["_CreateDestReceiver"] = (a0) => (_CreateDestReceiver = Module["_CreateDestReceiver"] = wasmExports["CreateDestReceiver"])(a0);
    var _CreateTemplateTupleDesc = Module["_CreateTemplateTupleDesc"] = (a0) => (_CreateTemplateTupleDesc = Module["_CreateTemplateTupleDesc"] = wasmExports["CreateTemplateTupleDesc"])(a0);
    var _strtoul = Module["_strtoul"] = (a0, a1, a2) => (_strtoul = Module["_strtoul"] = wasmExports["strtoul"])(a0, a1, a2);
    var _cstring_to_text = Module["_cstring_to_text"] = (a0) => (_cstring_to_text = Module["_cstring_to_text"] = wasmExports["cstring_to_text"])(a0);
    var _Int64GetDatum = Module["_Int64GetDatum"] = (a0) => (_Int64GetDatum = Module["_Int64GetDatum"] = wasmExports["Int64GetDatum"])(a0);
    var _TimestampDifferenceMilliseconds = Module["_TimestampDifferenceMilliseconds"] = (a0, a1) => (_TimestampDifferenceMilliseconds = Module["_TimestampDifferenceMilliseconds"] = wasmExports["TimestampDifferenceMilliseconds"])(a0, a1);
    var ___wasm_setjmp_test = Module["___wasm_setjmp_test"] = (a0, a1) => (___wasm_setjmp_test = Module["___wasm_setjmp_test"] = wasmExports["__wasm_setjmp_test"])(a0, a1);
    var _defGetString = Module["_defGetString"] = (a0) => (_defGetString = Module["_defGetString"] = wasmExports["defGetString"])(a0);
    var _defGetBoolean = Module["_defGetBoolean"] = (a0) => (_defGetBoolean = Module["_defGetBoolean"] = wasmExports["defGetBoolean"])(a0);
    var _parse_bool = Module["_parse_bool"] = (a0, a1) => (_parse_bool = Module["_parse_bool"] = wasmExports["parse_bool"])(a0, a1);
    var ___wasm_setjmp = Module["___wasm_setjmp"] = (a0, a1, a2) => (___wasm_setjmp = Module["___wasm_setjmp"] = wasmExports["__wasm_setjmp"])(a0, a1, a2);
    var _pg_re_throw = Module["_pg_re_throw"] = () => (_pg_re_throw = Module["_pg_re_throw"] = wasmExports["pg_re_throw"])();
    var _emscripten_longjmp = Module["_emscripten_longjmp"] = (a0, a1) => (_emscripten_longjmp = Module["_emscripten_longjmp"] = wasmExports["emscripten_longjmp"])(a0, a1);
    var _ResourceOwnerCreate = Module["_ResourceOwnerCreate"] = (a0, a1) => (_ResourceOwnerCreate = Module["_ResourceOwnerCreate"] = wasmExports["ResourceOwnerCreate"])(a0, a1);
    var _RecoveryInProgress = Module["_RecoveryInProgress"] = () => (_RecoveryInProgress = Module["_RecoveryInProgress"] = wasmExports["RecoveryInProgress"])();
    var _makeStringInfo = Module["_makeStringInfo"] = () => (_makeStringInfo = Module["_makeStringInfo"] = wasmExports["makeStringInfo"])();
    var _before_shmem_exit = Module["_before_shmem_exit"] = (a0, a1) => (_before_shmem_exit = Module["_before_shmem_exit"] = wasmExports["before_shmem_exit"])(a0, a1);
    var _cancel_before_shmem_exit = Module["_cancel_before_shmem_exit"] = (a0, a1) => (_cancel_before_shmem_exit = Module["_cancel_before_shmem_exit"] = wasmExports["cancel_before_shmem_exit"])(a0, a1);
    var _AllocateDir = Module["_AllocateDir"] = (a0) => (_AllocateDir = Module["_AllocateDir"] = wasmExports["AllocateDir"])(a0);
    var _ReadDir = Module["_ReadDir"] = (a0, a1) => (_ReadDir = Module["_ReadDir"] = wasmExports["ReadDir"])(a0, a1);
    var _FreeDir = Module["_FreeDir"] = (a0) => (_FreeDir = Module["_FreeDir"] = wasmExports["FreeDir"])(a0);
    var _list_sort = Module["_list_sort"] = (a0, a1) => (_list_sort = Module["_list_sort"] = wasmExports["list_sort"])(a0, a1);
    var _sscanf = Module["_sscanf"] = (a0, a1, a2) => (_sscanf = Module["_sscanf"] = wasmExports["sscanf"])(a0, a1, a2);
    var _OpenTransientFile = Module["_OpenTransientFile"] = (a0, a1) => (_OpenTransientFile = Module["_OpenTransientFile"] = wasmExports["OpenTransientFile"])(a0, a1);
    var _fstat = Module["_fstat"] = (a0, a1) => (_fstat = Module["_fstat"] = wasmExports["fstat"])(a0, a1);
    var _CloseTransientFile = Module["_CloseTransientFile"] = (a0) => (_CloseTransientFile = Module["_CloseTransientFile"] = wasmExports["CloseTransientFile"])(a0);
    var _errstart = Module["_errstart"] = (a0, a1) => (_errstart = Module["_errstart"] = wasmExports["errstart"])(a0, a1);
    var _errmsg_plural = Module["_errmsg_plural"] = (a0, a1, a2, a3) => (_errmsg_plural = Module["_errmsg_plural"] = wasmExports["errmsg_plural"])(a0, a1, a2, a3);
    var _strncmp = Module["_strncmp"] = (a0, a1, a2) => (_strncmp = Module["_strncmp"] = wasmExports["strncmp"])(a0, a1, a2);
    var _ProcessInterrupts = Module["_ProcessInterrupts"] = () => (_ProcessInterrupts = Module["_ProcessInterrupts"] = wasmExports["ProcessInterrupts"])();
    var _memcmp = Module["_memcmp"] = (a0, a1, a2) => (_memcmp = Module["_memcmp"] = wasmExports["memcmp"])(a0, a1, a2);
    var _geteuid = Module["_geteuid"] = () => (_geteuid = Module["_geteuid"] = wasmExports["geteuid"])();
    var _time = Module["_time"] = (a0) => (_time = Module["_time"] = wasmExports["time"])(a0);
    var _atoi = Module["_atoi"] = (a0) => (_atoi = Module["_atoi"] = wasmExports["atoi"])(a0);
    var _pg_checksum_page = Module["_pg_checksum_page"] = (a0, a1) => (_pg_checksum_page = Module["_pg_checksum_page"] = wasmExports["pg_checksum_page"])(a0, a1);
    var _pgstat_progress_update_param = Module["_pgstat_progress_update_param"] = (a0, a1) => (_pgstat_progress_update_param = Module["_pgstat_progress_update_param"] = wasmExports["pgstat_progress_update_param"])(a0, a1);
    var _ResetLatch = Module["_ResetLatch"] = (a0) => (_ResetLatch = Module["_ResetLatch"] = wasmExports["ResetLatch"])(a0);
    var _WaitLatch = Module["_WaitLatch"] = (a0, a1, a2, a3) => (_WaitLatch = Module["_WaitLatch"] = wasmExports["WaitLatch"])(a0, a1, a2, a3);
    var _gettimeofday = Module["_gettimeofday"] = (a0, a1) => (_gettimeofday = Module["_gettimeofday"] = wasmExports["gettimeofday"])(a0, a1);
    var _raw_parser = Module["_raw_parser"] = (a0, a1) => (_raw_parser = Module["_raw_parser"] = wasmExports["raw_parser"])(a0, a1);
    var _errdetail_internal = Module["_errdetail_internal"] = (a0, a1) => (_errdetail_internal = Module["_errdetail_internal"] = wasmExports["errdetail_internal"])(a0, a1);
    var _list_make1_impl = Module["_list_make1_impl"] = (a0, a1) => (_list_make1_impl = Module["_list_make1_impl"] = wasmExports["list_make1_impl"])(a0, a1);
    var _MemoryContextAllocZeroAligned = Module["_MemoryContextAllocZeroAligned"] = (a0, a1) => (_MemoryContextAllocZeroAligned = Module["_MemoryContextAllocZeroAligned"] = wasmExports["MemoryContextAllocZeroAligned"])(a0, a1);
    var _pg_prng_double = Module["_pg_prng_double"] = (a0) => (_pg_prng_double = Module["_pg_prng_double"] = wasmExports["pg_prng_double"])(a0);
    var _sigaddset = Module["_sigaddset"] = (a0, a1) => (_sigaddset = Module["_sigaddset"] = wasmExports["sigaddset"])(a0, a1);
    var _die = Module["_die"] = (a0) => (_die = Module["_die"] = wasmExports["die"])(a0);
    var _check_stack_depth = Module["_check_stack_depth"] = () => (_check_stack_depth = Module["_check_stack_depth"] = wasmExports["check_stack_depth"])();
    var _pre_format_elog_string = Module["_pre_format_elog_string"] = (a0, a1) => (_pre_format_elog_string = Module["_pre_format_elog_string"] = wasmExports["pre_format_elog_string"])(a0, a1);
    var _format_elog_string = Module["_format_elog_string"] = (a0, a1) => (_format_elog_string = Module["_format_elog_string"] = wasmExports["format_elog_string"])(a0, a1);
    var _SplitIdentifierString = Module["_SplitIdentifierString"] = (a0, a1, a2) => (_SplitIdentifierString = Module["_SplitIdentifierString"] = wasmExports["SplitIdentifierString"])(a0, a1, a2);
    var _list_free = Module["_list_free"] = (a0) => (_list_free = Module["_list_free"] = wasmExports["list_free"])(a0);
    var _guc_malloc = Module["_guc_malloc"] = (a0, a1) => (_guc_malloc = Module["_guc_malloc"] = wasmExports["guc_malloc"])(a0, a1);
    var _SetConfigOption = Module["_SetConfigOption"] = (a0, a1, a2, a3) => (_SetConfigOption = Module["_SetConfigOption"] = wasmExports["SetConfigOption"])(a0, a1, a2, a3);
    var _pg_sprintf = Module["_pg_sprintf"] = (a0, a1, a2) => (_pg_sprintf = Module["_pg_sprintf"] = wasmExports["pg_sprintf"])(a0, a1, a2);
    var _strlcpy = Module["_strlcpy"] = (a0, a1, a2) => (_strlcpy = Module["_strlcpy"] = wasmExports["strlcpy"])(a0, a1, a2);
    var _fsync_pgdata = Module["_fsync_pgdata"] = (a0, a1) => (_fsync_pgdata = Module["_fsync_pgdata"] = wasmExports["fsync_pgdata"])(a0, a1);
    var _get_restricted_token = Module["_get_restricted_token"] = () => (_get_restricted_token = Module["_get_restricted_token"] = wasmExports["get_restricted_token"])();
    var _pg_malloc = Module["_pg_malloc"] = (a0) => (_pg_malloc = Module["_pg_malloc"] = wasmExports["pg_malloc"])(a0);
    var _pg_realloc = Module["_pg_realloc"] = (a0, a1) => (_pg_realloc = Module["_pg_realloc"] = wasmExports["pg_realloc"])(a0, a1);
    var _realloc = Module["_realloc"] = (a0, a1) => (_realloc = Module["_realloc"] = wasmExports["realloc"])(a0, a1);
    var _pg_strdup = Module["_pg_strdup"] = (a0) => (_pg_strdup = Module["_pg_strdup"] = wasmExports["pg_strdup"])(a0);
    var _simple_prompt = Module["_simple_prompt"] = (a0, a1) => (_simple_prompt = Module["_simple_prompt"] = wasmExports["simple_prompt"])(a0, a1);
    var _MemoryContextDelete = Module["_MemoryContextDelete"] = (a0) => (_MemoryContextDelete = Module["_MemoryContextDelete"] = wasmExports["MemoryContextDelete"])(a0);
    var _pg_printf = Module["_pg_printf"] = (a0, a1) => (_pg_printf = Module["_pg_printf"] = wasmExports["pg_printf"])(a0, a1);
    var _AllocSetContextCreateInternal = Module["_AllocSetContextCreateInternal"] = (a0, a1, a2, a3, a4) => (_AllocSetContextCreateInternal = Module["_AllocSetContextCreateInternal"] = wasmExports["AllocSetContextCreateInternal"])(a0, a1, a2, a3, a4);
    var _fopen = Module["_fopen"] = (a0, a1) => (_fopen = Module["_fopen"] = wasmExports["fopen"])(a0, a1);
    var _interactive_file = Module["_interactive_file"] = () => (_interactive_file = Module["_interactive_file"] = wasmExports["interactive_file"])();
    var _fclose = Module["_fclose"] = (a0) => (_fclose = Module["_fclose"] = wasmExports["fclose"])(a0);
    var _interactive_one = Module["_interactive_one"] = () => (_interactive_one = Module["_interactive_one"] = wasmExports["interactive_one"])();
    var _MemoryContextReset = Module["_MemoryContextReset"] = (a0) => (_MemoryContextReset = Module["_MemoryContextReset"] = wasmExports["MemoryContextReset"])(a0);
    var _resetStringInfo = Module["_resetStringInfo"] = (a0) => (_resetStringInfo = Module["_resetStringInfo"] = wasmExports["resetStringInfo"])(a0);
    var _getc = Module["_getc"] = (a0) => (_getc = Module["_getc"] = wasmExports["getc"])(a0);
    var _pq_getmsgint = Module["_pq_getmsgint"] = (a0, a1) => (_pq_getmsgint = Module["_pq_getmsgint"] = wasmExports["pq_getmsgint"])(a0, a1);
    var _pgstat_report_activity = Module["_pgstat_report_activity"] = (a0, a1) => (_pgstat_report_activity = Module["_pgstat_report_activity"] = wasmExports["pgstat_report_activity"])(a0, a1);
    var _access = Module["_access"] = (a0, a1) => (_access = Module["_access"] = wasmExports["access"])(a0, a1);
    var _pq_recvbuf_fill = Module["_pq_recvbuf_fill"] = (a0, a1) => (_pq_recvbuf_fill = Module["_pq_recvbuf_fill"] = wasmExports["pq_recvbuf_fill"])(a0, a1);
    var _unlink = Module["_unlink"] = (a0) => (_unlink = Module["_unlink"] = wasmExports["unlink"])(a0);
    var _calloc = Module["_calloc"] = (a0, a1) => (_calloc = Module["_calloc"] = wasmExports["calloc"])(a0, a1);
    var _EmitErrorReport = Module["_EmitErrorReport"] = () => (_EmitErrorReport = Module["_EmitErrorReport"] = wasmExports["EmitErrorReport"])();
    var _FlushErrorState = Module["_FlushErrorState"] = () => (_FlushErrorState = Module["_FlushErrorState"] = wasmExports["FlushErrorState"])();
    var _pg_repl_raf = Module["_pg_repl_raf"] = () => (_pg_repl_raf = Module["_pg_repl_raf"] = wasmExports["pg_repl_raf"])();
    var _pg_shutdown = Module["_pg_shutdown"] = () => (_pg_shutdown = Module["_pg_shutdown"] = wasmExports["pg_shutdown"])();
    var _errhidestmt = Module["_errhidestmt"] = (a0) => (_errhidestmt = Module["_errhidestmt"] = wasmExports["errhidestmt"])(a0);
    var _GetTransactionSnapshot = Module["_GetTransactionSnapshot"] = () => (_GetTransactionSnapshot = Module["_GetTransactionSnapshot"] = wasmExports["GetTransactionSnapshot"])();
    var _PushActiveSnapshot = Module["_PushActiveSnapshot"] = (a0) => (_PushActiveSnapshot = Module["_PushActiveSnapshot"] = wasmExports["PushActiveSnapshot"])(a0);
    var _PopActiveSnapshot = Module["_PopActiveSnapshot"] = () => (_PopActiveSnapshot = Module["_PopActiveSnapshot"] = wasmExports["PopActiveSnapshot"])();
    var _CommandCounterIncrement = Module["_CommandCounterIncrement"] = () => (_CommandCounterIncrement = Module["_CommandCounterIncrement"] = wasmExports["CommandCounterIncrement"])();
    var _MemoryContextSetParent = Module["_MemoryContextSetParent"] = (a0, a1) => (_MemoryContextSetParent = Module["_MemoryContextSetParent"] = wasmExports["MemoryContextSetParent"])(a0, a1);
    var _makeParamList = Module["_makeParamList"] = (a0) => (_makeParamList = Module["_makeParamList"] = wasmExports["makeParamList"])(a0);
    var _getTypeInputInfo = Module["_getTypeInputInfo"] = (a0, a1, a2) => (_getTypeInputInfo = Module["_getTypeInputInfo"] = wasmExports["getTypeInputInfo"])(a0, a1, a2);
    var _pnstrdup = Module["_pnstrdup"] = (a0, a1) => (_pnstrdup = Module["_pnstrdup"] = wasmExports["pnstrdup"])(a0, a1);
    var _interactive_write = Module["_interactive_write"] = (a0) => (_interactive_write = Module["_interactive_write"] = wasmExports["interactive_write"])(a0);
    var _interactive_read = Module["_interactive_read"] = () => (_interactive_read = Module["_interactive_read"] = wasmExports["interactive_read"])();
    var _appendStringInfoStringQuoted = Module["_appendStringInfoStringQuoted"] = (a0, a1, a2) => (_appendStringInfoStringQuoted = Module["_appendStringInfoStringQuoted"] = wasmExports["appendStringInfoStringQuoted"])(a0, a1, a2);
    var _set_errcontext_domain = Module["_set_errcontext_domain"] = (a0) => (_set_errcontext_domain = Module["_set_errcontext_domain"] = wasmExports["set_errcontext_domain"])(a0);
    var _errcontext_msg = Module["_errcontext_msg"] = (a0, a1) => (_errcontext_msg = Module["_errcontext_msg"] = wasmExports["errcontext_msg"])(a0, a1);
    var _SearchSysCache1 = Module["_SearchSysCache1"] = (a0, a1) => (_SearchSysCache1 = Module["_SearchSysCache1"] = wasmExports["SearchSysCache1"])(a0, a1);
    var _ReleaseSysCache = Module["_ReleaseSysCache"] = (a0) => (_ReleaseSysCache = Module["_ReleaseSysCache"] = wasmExports["ReleaseSysCache"])(a0);
    var _fmgr_info = Module["_fmgr_info"] = (a0, a1) => (_fmgr_info = Module["_fmgr_info"] = wasmExports["fmgr_info"])(a0, a1);
    var _object_aclcheck = Module["_object_aclcheck"] = (a0, a1, a2, a3) => (_object_aclcheck = Module["_object_aclcheck"] = wasmExports["object_aclcheck"])(a0, a1, a2, a3);
    var _get_namespace_name = Module["_get_namespace_name"] = (a0) => (_get_namespace_name = Module["_get_namespace_name"] = wasmExports["get_namespace_name"])(a0);
    var _aclcheck_error = Module["_aclcheck_error"] = (a0, a1, a2) => (_aclcheck_error = Module["_aclcheck_error"] = wasmExports["aclcheck_error"])(a0, a1, a2);
    var _appendBinaryStringInfo = Module["_appendBinaryStringInfo"] = (a0, a1, a2) => (_appendBinaryStringInfo = Module["_appendBinaryStringInfo"] = wasmExports["appendBinaryStringInfo"])(a0, a1, a2);
    var _getTypeOutputInfo = Module["_getTypeOutputInfo"] = (a0, a1, a2) => (_getTypeOutputInfo = Module["_getTypeOutputInfo"] = wasmExports["getTypeOutputInfo"])(a0, a1, a2);
    var _OidOutputFunctionCall = Module["_OidOutputFunctionCall"] = (a0, a1) => (_OidOutputFunctionCall = Module["_OidOutputFunctionCall"] = wasmExports["OidOutputFunctionCall"])(a0, a1);
    var _RegisterSnapshot = Module["_RegisterSnapshot"] = (a0) => (_RegisterSnapshot = Module["_RegisterSnapshot"] = wasmExports["RegisterSnapshot"])(a0);
    var _UnregisterSnapshot = Module["_UnregisterSnapshot"] = (a0) => (_UnregisterSnapshot = Module["_UnregisterSnapshot"] = wasmExports["UnregisterSnapshot"])(a0);
    var _GetActiveSnapshot = Module["_GetActiveSnapshot"] = () => (_GetActiveSnapshot = Module["_GetActiveSnapshot"] = wasmExports["GetActiveSnapshot"])();
    var _MemoryContextAlloc = Module["_MemoryContextAlloc"] = (a0, a1) => (_MemoryContextAlloc = Module["_MemoryContextAlloc"] = wasmExports["MemoryContextAlloc"])(a0, a1);
    var _SetTuplestoreDestReceiverParams = Module["_SetTuplestoreDestReceiverParams"] = (a0, a1, a2, a3, a4, a5) => (_SetTuplestoreDestReceiverParams = Module["_SetTuplestoreDestReceiverParams"] = wasmExports["SetTuplestoreDestReceiverParams"])(a0, a1, a2, a3, a4, a5);
    var _MemoryContextDeleteChildren = Module["_MemoryContextDeleteChildren"] = (a0) => (_MemoryContextDeleteChildren = Module["_MemoryContextDeleteChildren"] = wasmExports["MemoryContextDeleteChildren"])(a0);
    var _EnsurePortalSnapshotExists = Module["_EnsurePortalSnapshotExists"] = () => (_EnsurePortalSnapshotExists = Module["_EnsurePortalSnapshotExists"] = wasmExports["EnsurePortalSnapshotExists"])();
    var _MakeSingleTupleTableSlot = Module["_MakeSingleTupleTableSlot"] = (a0, a1) => (_MakeSingleTupleTableSlot = Module["_MakeSingleTupleTableSlot"] = wasmExports["MakeSingleTupleTableSlot"])(a0, a1);
    var _ExecDropSingleTupleTableSlot = Module["_ExecDropSingleTupleTableSlot"] = (a0) => (_ExecDropSingleTupleTableSlot = Module["_ExecDropSingleTupleTableSlot"] = wasmExports["ExecDropSingleTupleTableSlot"])(a0);
    var _GetCommandTagName = Module["_GetCommandTagName"] = (a0) => (_GetCommandTagName = Module["_GetCommandTagName"] = wasmExports["GetCommandTagName"])(a0);
    var _standard_ProcessUtility = Module["_standard_ProcessUtility"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_standard_ProcessUtility = Module["_standard_ProcessUtility"] = wasmExports["standard_ProcessUtility"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _copyObjectImpl = Module["_copyObjectImpl"] = (a0) => (_copyObjectImpl = Module["_copyObjectImpl"] = wasmExports["copyObjectImpl"])(a0);
    var _Async_Notify = Module["_Async_Notify"] = (a0, a1) => (_Async_Notify = Module["_Async_Notify"] = wasmExports["Async_Notify"])(a0, a1);
    var _superuser = Module["_superuser"] = () => (_superuser = Module["_superuser"] = wasmExports["superuser"])();
    var _list_concat = Module["_list_concat"] = (a0, a1) => (_list_concat = Module["_list_concat"] = wasmExports["list_concat"])(a0, a1);
    var _RangeVarGetRelidExtended = Module["_RangeVarGetRelidExtended"] = (a0, a1, a2, a3, a4) => (_RangeVarGetRelidExtended = Module["_RangeVarGetRelidExtended"] = wasmExports["RangeVarGetRelidExtended"])(a0, a1, a2, a3, a4);
    var _get_rel_relkind = Module["_get_rel_relkind"] = (a0) => (_get_rel_relkind = Module["_get_rel_relkind"] = wasmExports["get_rel_relkind"])(a0);
    var _CreateTupleDescCopy = Module["_CreateTupleDescCopy"] = (a0) => (_CreateTupleDescCopy = Module["_CreateTupleDescCopy"] = wasmExports["CreateTupleDescCopy"])(a0);
    var _bms_next_member = Module["_bms_next_member"] = (a0, a1) => (_bms_next_member = Module["_bms_next_member"] = wasmExports["bms_next_member"])(a0, a1);
    var _bms_add_member = Module["_bms_add_member"] = (a0, a1) => (_bms_add_member = Module["_bms_add_member"] = wasmExports["bms_add_member"])(a0, a1);
    var _bms_is_member = Module["_bms_is_member"] = (a0, a1) => (_bms_is_member = Module["_bms_is_member"] = wasmExports["bms_is_member"])(a0, a1);
    var _bms_del_member = Module["_bms_del_member"] = (a0, a1) => (_bms_del_member = Module["_bms_del_member"] = wasmExports["bms_del_member"])(a0, a1);
    var _bms_union = Module["_bms_union"] = (a0, a1) => (_bms_union = Module["_bms_union"] = wasmExports["bms_union"])(a0, a1);
    var _bms_overlap = Module["_bms_overlap"] = (a0, a1) => (_bms_overlap = Module["_bms_overlap"] = wasmExports["bms_overlap"])(a0, a1);
    var _table_open = Module["_table_open"] = (a0, a1) => (_table_open = Module["_table_open"] = wasmExports["table_open"])(a0, a1);
    var _ScanKeyInit = Module["_ScanKeyInit"] = (a0, a1, a2, a3, a4) => (_ScanKeyInit = Module["_ScanKeyInit"] = wasmExports["ScanKeyInit"])(a0, a1, a2, a3, a4);
    var _systable_beginscan = Module["_systable_beginscan"] = (a0, a1, a2, a3, a4, a5) => (_systable_beginscan = Module["_systable_beginscan"] = wasmExports["systable_beginscan"])(a0, a1, a2, a3, a4, a5);
    var _systable_getnext = Module["_systable_getnext"] = (a0) => (_systable_getnext = Module["_systable_getnext"] = wasmExports["systable_getnext"])(a0);
    var _systable_endscan = Module["_systable_endscan"] = (a0) => (_systable_endscan = Module["_systable_endscan"] = wasmExports["systable_endscan"])(a0);
    var _table_close = Module["_table_close"] = (a0, a1) => (_table_close = Module["_table_close"] = wasmExports["table_close"])(a0, a1);
    var _errdetail_relkind_not_supported = Module["_errdetail_relkind_not_supported"] = (a0) => (_errdetail_relkind_not_supported = Module["_errdetail_relkind_not_supported"] = wasmExports["errdetail_relkind_not_supported"])(a0);
    var _object_ownercheck = Module["_object_ownercheck"] = (a0, a1, a2) => (_object_ownercheck = Module["_object_ownercheck"] = wasmExports["object_ownercheck"])(a0, a1, a2);
    var _get_relkind_objtype = Module["_get_relkind_objtype"] = (a0) => (_get_relkind_objtype = Module["_get_relkind_objtype"] = wasmExports["get_relkind_objtype"])(a0);
    var _SearchSysCache2 = Module["_SearchSysCache2"] = (a0, a1, a2) => (_SearchSysCache2 = Module["_SearchSysCache2"] = wasmExports["SearchSysCache2"])(a0, a1, a2);
    var _get_rel_name = Module["_get_rel_name"] = (a0) => (_get_rel_name = Module["_get_rel_name"] = wasmExports["get_rel_name"])(a0);
    var _heap_form_tuple = Module["_heap_form_tuple"] = (a0, a1, a2) => (_heap_form_tuple = Module["_heap_form_tuple"] = wasmExports["heap_form_tuple"])(a0, a1, a2);
    var _heap_freetuple = Module["_heap_freetuple"] = (a0) => (_heap_freetuple = Module["_heap_freetuple"] = wasmExports["heap_freetuple"])(a0);
    var _exprType = Module["_exprType"] = (a0) => (_exprType = Module["_exprType"] = wasmExports["exprType"])(a0);
    var _format_type_be = Module["_format_type_be"] = (a0) => (_format_type_be = Module["_format_type_be"] = wasmExports["format_type_be"])(a0);
    var _exprTypmod = Module["_exprTypmod"] = (a0) => (_exprTypmod = Module["_exprTypmod"] = wasmExports["exprTypmod"])(a0);
    var _format_type_with_typemod = Module["_format_type_with_typemod"] = (a0, a1) => (_format_type_with_typemod = Module["_format_type_with_typemod"] = wasmExports["format_type_with_typemod"])(a0, a1);
    var _relation_open = Module["_relation_open"] = (a0, a1) => (_relation_open = Module["_relation_open"] = wasmExports["relation_open"])(a0, a1);
    var _relation_close = Module["_relation_close"] = (a0, a1) => (_relation_close = Module["_relation_close"] = wasmExports["relation_close"])(a0, a1);
    var _makeString = Module["_makeString"] = (a0) => (_makeString = Module["_makeString"] = wasmExports["makeString"])(a0);
    var _makeTargetEntry = Module["_makeTargetEntry"] = (a0, a1, a2, a3) => (_makeTargetEntry = Module["_makeTargetEntry"] = wasmExports["makeTargetEntry"])(a0, a1, a2, a3);
    var _makeVar = Module["_makeVar"] = (a0, a1, a2, a3, a4, a5) => (_makeVar = Module["_makeVar"] = wasmExports["makeVar"])(a0, a1, a2, a3, a4, a5);
    var _list_make2_impl = Module["_list_make2_impl"] = (a0, a1, a2) => (_list_make2_impl = Module["_list_make2_impl"] = wasmExports["list_make2_impl"])(a0, a1, a2);
    var _lappend_oid = Module["_lappend_oid"] = (a0, a1) => (_lappend_oid = Module["_lappend_oid"] = wasmExports["lappend_oid"])(a0, a1);
    var _lappend_int = Module["_lappend_int"] = (a0, a1) => (_lappend_int = Module["_lappend_int"] = wasmExports["lappend_int"])(a0, a1);
    var _SearchSysCacheExists = Module["_SearchSysCacheExists"] = (a0, a1, a2, a3, a4) => (_SearchSysCacheExists = Module["_SearchSysCacheExists"] = wasmExports["SearchSysCacheExists"])(a0, a1, a2, a3, a4);
    var _strip_implicit_coercions = Module["_strip_implicit_coercions"] = (a0) => (_strip_implicit_coercions = Module["_strip_implicit_coercions"] = wasmExports["strip_implicit_coercions"])(a0);
    var _stringToNode = Module["_stringToNode"] = (a0) => (_stringToNode = Module["_stringToNode"] = wasmExports["stringToNode"])(a0);
    var _coerce_to_target_type = Module["_coerce_to_target_type"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_coerce_to_target_type = Module["_coerce_to_target_type"] = wasmExports["coerce_to_target_type"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _try_relation_open = Module["_try_relation_open"] = (a0, a1) => (_try_relation_open = Module["_try_relation_open"] = wasmExports["try_relation_open"])(a0, a1);
    var _list_member_oid = Module["_list_member_oid"] = (a0, a1) => (_list_member_oid = Module["_list_member_oid"] = wasmExports["list_member_oid"])(a0, a1);
    var _list_delete_last = Module["_list_delete_last"] = (a0) => (_list_delete_last = Module["_list_delete_last"] = wasmExports["list_delete_last"])(a0);
    var _list_delete_cell = Module["_list_delete_cell"] = (a0, a1) => (_list_delete_cell = Module["_list_delete_cell"] = wasmExports["list_delete_cell"])(a0, a1);
    var _addRTEPermissionInfo = Module["_addRTEPermissionInfo"] = (a0, a1) => (_addRTEPermissionInfo = Module["_addRTEPermissionInfo"] = wasmExports["addRTEPermissionInfo"])(a0, a1);
    var _equal = Module["_equal"] = (a0, a1) => (_equal = Module["_equal"] = wasmExports["equal"])(a0, a1);
    var _repalloc = Module["_repalloc"] = (a0, a1) => (_repalloc = Module["_repalloc"] = wasmExports["repalloc"])(a0, a1);
    var _memmove = Module["_memmove"] = (a0, a1, a2) => (_memmove = Module["_memmove"] = wasmExports["memmove"])(a0, a1, a2);
    var _palloc_extended = Module["_palloc_extended"] = (a0, a1) => (_palloc_extended = Module["_palloc_extended"] = wasmExports["palloc_extended"])(a0, a1);
    var _pg_reg_getinitialstate = Module["_pg_reg_getinitialstate"] = (a0) => (_pg_reg_getinitialstate = Module["_pg_reg_getinitialstate"] = wasmExports["pg_reg_getinitialstate"])(a0);
    var _pg_reg_getfinalstate = Module["_pg_reg_getfinalstate"] = (a0) => (_pg_reg_getfinalstate = Module["_pg_reg_getfinalstate"] = wasmExports["pg_reg_getfinalstate"])(a0);
    var _pg_reg_getnumoutarcs = Module["_pg_reg_getnumoutarcs"] = (a0, a1) => (_pg_reg_getnumoutarcs = Module["_pg_reg_getnumoutarcs"] = wasmExports["pg_reg_getnumoutarcs"])(a0, a1);
    var _pg_reg_getoutarcs = Module["_pg_reg_getoutarcs"] = (a0, a1, a2, a3) => (_pg_reg_getoutarcs = Module["_pg_reg_getoutarcs"] = wasmExports["pg_reg_getoutarcs"])(a0, a1, a2, a3);
    var _pg_reg_getnumcolors = Module["_pg_reg_getnumcolors"] = (a0) => (_pg_reg_getnumcolors = Module["_pg_reg_getnumcolors"] = wasmExports["pg_reg_getnumcolors"])(a0);
    var _pg_reg_colorisbegin = Module["_pg_reg_colorisbegin"] = (a0, a1) => (_pg_reg_colorisbegin = Module["_pg_reg_colorisbegin"] = wasmExports["pg_reg_colorisbegin"])(a0, a1);
    var _pg_reg_colorisend = Module["_pg_reg_colorisend"] = (a0, a1) => (_pg_reg_colorisend = Module["_pg_reg_colorisend"] = wasmExports["pg_reg_colorisend"])(a0, a1);
    var _pg_reg_getnumcharacters = Module["_pg_reg_getnumcharacters"] = (a0, a1) => (_pg_reg_getnumcharacters = Module["_pg_reg_getnumcharacters"] = wasmExports["pg_reg_getnumcharacters"])(a0, a1);
    var _pg_reg_getcharacters = Module["_pg_reg_getcharacters"] = (a0, a1, a2, a3) => (_pg_reg_getcharacters = Module["_pg_reg_getcharacters"] = wasmExports["pg_reg_getcharacters"])(a0, a1, a2, a3);
    var _pg_regerror = Module["_pg_regerror"] = (a0, a1, a2, a3) => (_pg_regerror = Module["_pg_regerror"] = wasmExports["pg_regerror"])(a0, a1, a2, a3);
    var _strcpy = Module["_strcpy"] = (a0, a1) => (_strcpy = Module["_strcpy"] = wasmExports["strcpy"])(a0, a1);
    var _pg_regcomp = Module["_pg_regcomp"] = (a0, a1, a2, a3, a4) => (_pg_regcomp = Module["_pg_regcomp"] = wasmExports["pg_regcomp"])(a0, a1, a2, a3, a4);
    var _GetDatabaseEncoding = Module["_GetDatabaseEncoding"] = () => (_GetDatabaseEncoding = Module["_GetDatabaseEncoding"] = wasmExports["GetDatabaseEncoding"])();
    var _pg_qsort = Module["_pg_qsort"] = (a0, a1, a2, a3) => (_pg_qsort = Module["_pg_qsort"] = wasmExports["pg_qsort"])(a0, a1, a2, a3);
    var _isalnum = Module["_isalnum"] = (a0) => (_isalnum = Module["_isalnum"] = wasmExports["isalnum"])(a0);
    var _tolower = Module["_tolower"] = (a0) => (_tolower = Module["_tolower"] = wasmExports["tolower"])(a0);
    var _toupper = Module["_toupper"] = (a0) => (_toupper = Module["_toupper"] = wasmExports["toupper"])(a0);
    var _makeRangeVar = Module["_makeRangeVar"] = (a0, a1, a2) => (_makeRangeVar = Module["_makeRangeVar"] = wasmExports["makeRangeVar"])(a0, a1, a2);
    var _ferror = Module["_ferror"] = (a0) => (_ferror = Module["_ferror"] = wasmExports["ferror"])(a0);
    var _fread = Module["_fread"] = (a0, a1, a2, a3) => (_fread = Module["_fread"] = wasmExports["fread"])(a0, a1, a2, a3);
    var _clearerr = Module["_clearerr"] = (a0) => (_clearerr = Module["_clearerr"] = wasmExports["clearerr"])(a0);
    var _pqsignal = Module["_pqsignal"] = (a0, a1) => (_pqsignal = Module["_pqsignal"] = wasmExports["pqsignal"])(a0, a1);
    var _table_openrv = Module["_table_openrv"] = (a0, a1) => (_table_openrv = Module["_table_openrv"] = wasmExports["table_openrv"])(a0, a1);
    var _MemoryContextAllocZero = Module["_MemoryContextAllocZero"] = (a0, a1) => (_MemoryContextAllocZero = Module["_MemoryContextAllocZero"] = wasmExports["MemoryContextAllocZero"])(a0, a1);
    var _heap_getnext = Module["_heap_getnext"] = (a0, a1) => (_heap_getnext = Module["_heap_getnext"] = wasmExports["heap_getnext"])(a0, a1);
    var _list_free_deep = Module["_list_free_deep"] = (a0) => (_list_free_deep = Module["_list_free_deep"] = wasmExports["list_free_deep"])(a0);
    var _index_open = Module["_index_open"] = (a0, a1) => (_index_open = Module["_index_open"] = wasmExports["index_open"])(a0, a1);
    var _index_close = Module["_index_close"] = (a0, a1) => (_index_close = Module["_index_close"] = wasmExports["index_close"])(a0, a1);
    var _ExecReScan = Module["_ExecReScan"] = (a0) => (_ExecReScan = Module["_ExecReScan"] = wasmExports["ExecReScan"])(a0);
    var _InstrEndLoop = Module["_InstrEndLoop"] = (a0) => (_InstrEndLoop = Module["_InstrEndLoop"] = wasmExports["InstrEndLoop"])(a0);
    var _bms_free = Module["_bms_free"] = (a0) => (_bms_free = Module["_bms_free"] = wasmExports["bms_free"])(a0);
    var _text_to_cstring = Module["_text_to_cstring"] = (a0) => (_text_to_cstring = Module["_text_to_cstring"] = wasmExports["text_to_cstring"])(a0);
    var _slot_getsomeattrs_int = Module["_slot_getsomeattrs_int"] = (a0, a1) => (_slot_getsomeattrs_int = Module["_slot_getsomeattrs_int"] = wasmExports["slot_getsomeattrs_int"])(a0, a1);
    var _CreateExecutorState = Module["_CreateExecutorState"] = () => (_CreateExecutorState = Module["_CreateExecutorState"] = wasmExports["CreateExecutorState"])();
    var _FreeExecutorState = Module["_FreeExecutorState"] = (a0) => (_FreeExecutorState = Module["_FreeExecutorState"] = wasmExports["FreeExecutorState"])(a0);
    var _FreeExprContext = Module["_FreeExprContext"] = (a0, a1) => (_FreeExprContext = Module["_FreeExprContext"] = wasmExports["FreeExprContext"])(a0, a1);
    var _CreateExprContext = Module["_CreateExprContext"] = (a0) => (_CreateExprContext = Module["_CreateExprContext"] = wasmExports["CreateExprContext"])(a0);
    var _MakePerTupleExprContext = Module["_MakePerTupleExprContext"] = (a0) => (_MakePerTupleExprContext = Module["_MakePerTupleExprContext"] = wasmExports["MakePerTupleExprContext"])(a0);
    var _list_member_int = Module["_list_member_int"] = (a0, a1) => (_list_member_int = Module["_list_member_int"] = wasmExports["list_member_int"])(a0, a1);
    var _ExecOpenScanRelation = Module["_ExecOpenScanRelation"] = (a0, a1, a2) => (_ExecOpenScanRelation = Module["_ExecOpenScanRelation"] = wasmExports["ExecOpenScanRelation"])(a0, a1, a2);
    var _ExecInitRangeTable = Module["_ExecInitRangeTable"] = (a0, a1, a2) => (_ExecInitRangeTable = Module["_ExecInitRangeTable"] = wasmExports["ExecInitRangeTable"])(a0, a1, a2);
    var _pg_mbstrlen_with_len = Module["_pg_mbstrlen_with_len"] = (a0, a1) => (_pg_mbstrlen_with_len = Module["_pg_mbstrlen_with_len"] = wasmExports["pg_mbstrlen_with_len"])(a0, a1);
    var _errposition = Module["_errposition"] = (a0) => (_errposition = Module["_errposition"] = wasmExports["errposition"])(a0);
    var _lookup_rowtype_tupdesc = Module["_lookup_rowtype_tupdesc"] = (a0, a1) => (_lookup_rowtype_tupdesc = Module["_lookup_rowtype_tupdesc"] = wasmExports["lookup_rowtype_tupdesc"])(a0, a1);
    var _DecrTupleDescRefCount = Module["_DecrTupleDescRefCount"] = (a0) => (_DecrTupleDescRefCount = Module["_DecrTupleDescRefCount"] = wasmExports["DecrTupleDescRefCount"])(a0);
    var _getmissingattr = Module["_getmissingattr"] = (a0, a1, a2) => (_getmissingattr = Module["_getmissingattr"] = wasmExports["getmissingattr"])(a0, a1, a2);
    var _nocachegetattr = Module["_nocachegetattr"] = (a0, a1, a2) => (_nocachegetattr = Module["_nocachegetattr"] = wasmExports["nocachegetattr"])(a0, a1, a2);
    var _ExecGetReturningSlot = Module["_ExecGetReturningSlot"] = (a0, a1) => (_ExecGetReturningSlot = Module["_ExecGetReturningSlot"] = wasmExports["ExecGetReturningSlot"])(a0, a1);
    var _build_attrmap_by_name_if_req = Module["_build_attrmap_by_name_if_req"] = (a0, a1, a2) => (_build_attrmap_by_name_if_req = Module["_build_attrmap_by_name_if_req"] = wasmExports["build_attrmap_by_name_if_req"])(a0, a1, a2);
    var _ExecGetResultRelCheckAsUser = Module["_ExecGetResultRelCheckAsUser"] = (a0, a1) => (_ExecGetResultRelCheckAsUser = Module["_ExecGetResultRelCheckAsUser"] = wasmExports["ExecGetResultRelCheckAsUser"])(a0, a1);
    var _add_size = Module["_add_size"] = (a0, a1) => (_add_size = Module["_add_size"] = wasmExports["add_size"])(a0, a1);
    var _shm_toc_allocate = Module["_shm_toc_allocate"] = (a0, a1) => (_shm_toc_allocate = Module["_shm_toc_allocate"] = wasmExports["shm_toc_allocate"])(a0, a1);
    var _shm_toc_insert = Module["_shm_toc_insert"] = (a0, a1, a2) => (_shm_toc_insert = Module["_shm_toc_insert"] = wasmExports["shm_toc_insert"])(a0, a1, a2);
    var _shm_toc_lookup = Module["_shm_toc_lookup"] = (a0, a1, a2) => (_shm_toc_lookup = Module["_shm_toc_lookup"] = wasmExports["shm_toc_lookup"])(a0, a1, a2);
    var _ExecInitExpr = Module["_ExecInitExpr"] = (a0, a1) => (_ExecInitExpr = Module["_ExecInitExpr"] = wasmExports["ExecInitExpr"])(a0, a1);
    var _ItemPointerCompare = Module["_ItemPointerCompare"] = (a0, a1) => (_ItemPointerCompare = Module["_ItemPointerCompare"] = wasmExports["ItemPointerCompare"])(a0, a1);
    var _bms_add_members = Module["_bms_add_members"] = (a0, a1) => (_bms_add_members = Module["_bms_add_members"] = wasmExports["bms_add_members"])(a0, a1);
    var _bms_num_members = Module["_bms_num_members"] = (a0) => (_bms_num_members = Module["_bms_num_members"] = wasmExports["bms_num_members"])(a0);
    var _tuplesort_end = Module["_tuplesort_end"] = (a0) => (_tuplesort_end = Module["_tuplesort_end"] = wasmExports["tuplesort_end"])(a0);
    var _ExecInitExprList = Module["_ExecInitExprList"] = (a0, a1) => (_ExecInitExprList = Module["_ExecInitExprList"] = wasmExports["ExecInitExprList"])(a0, a1);
    var _get_typlenbyval = Module["_get_typlenbyval"] = (a0, a1, a2) => (_get_typlenbyval = Module["_get_typlenbyval"] = wasmExports["get_typlenbyval"])(a0, a1, a2);
    var _SysCacheGetAttr = Module["_SysCacheGetAttr"] = (a0, a1, a2, a3) => (_SysCacheGetAttr = Module["_SysCacheGetAttr"] = wasmExports["SysCacheGetAttr"])(a0, a1, a2, a3);
    var _ExecForceStoreHeapTuple = Module["_ExecForceStoreHeapTuple"] = (a0, a1, a2) => (_ExecForceStoreHeapTuple = Module["_ExecForceStoreHeapTuple"] = wasmExports["ExecForceStoreHeapTuple"])(a0, a1, a2);
    var _tuplesort_performsort = Module["_tuplesort_performsort"] = (a0) => (_tuplesort_performsort = Module["_tuplesort_performsort"] = wasmExports["tuplesort_performsort"])(a0);
    var _tuplesort_begin_heap = Module["_tuplesort_begin_heap"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_tuplesort_begin_heap = Module["_tuplesort_begin_heap"] = wasmExports["tuplesort_begin_heap"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _ExecStoreVirtualTuple = Module["_ExecStoreVirtualTuple"] = (a0) => (_ExecStoreVirtualTuple = Module["_ExecStoreVirtualTuple"] = wasmExports["ExecStoreVirtualTuple"])(a0);
    var _MemoryContextMemAllocated = Module["_MemoryContextMemAllocated"] = (a0, a1) => (_MemoryContextMemAllocated = Module["_MemoryContextMemAllocated"] = wasmExports["MemoryContextMemAllocated"])(a0, a1);
    var _tuplesort_gettupleslot = Module["_tuplesort_gettupleslot"] = (a0, a1, a2, a3, a4) => (_tuplesort_gettupleslot = Module["_tuplesort_gettupleslot"] = wasmExports["tuplesort_gettupleslot"])(a0, a1, a2, a3, a4);
    var _tuplesort_puttupleslot = Module["_tuplesort_puttupleslot"] = (a0, a1) => (_tuplesort_puttupleslot = Module["_tuplesort_puttupleslot"] = wasmExports["tuplesort_puttupleslot"])(a0, a1);
    var _datumCopy = Module["_datumCopy"] = (a0, a1, a2) => (_datumCopy = Module["_datumCopy"] = wasmExports["datumCopy"])(a0, a1, a2);
    var _ExecStoreAllNullTuple = Module["_ExecStoreAllNullTuple"] = (a0) => (_ExecStoreAllNullTuple = Module["_ExecStoreAllNullTuple"] = wasmExports["ExecStoreAllNullTuple"])(a0);
    var _FunctionCall2Coll = Module["_FunctionCall2Coll"] = (a0, a1, a2, a3) => (_FunctionCall2Coll = Module["_FunctionCall2Coll"] = wasmExports["FunctionCall2Coll"])(a0, a1, a2, a3);
    var _MakeExpandedObjectReadOnlyInternal = Module["_MakeExpandedObjectReadOnlyInternal"] = (a0) => (_MakeExpandedObjectReadOnlyInternal = Module["_MakeExpandedObjectReadOnlyInternal"] = wasmExports["MakeExpandedObjectReadOnlyInternal"])(a0);
    var _ReleaseBuffer = Module["_ReleaseBuffer"] = (a0) => (_ReleaseBuffer = Module["_ReleaseBuffer"] = wasmExports["ReleaseBuffer"])(a0);
    var _s_init_lock_sema = Module["_s_init_lock_sema"] = (a0, a1) => (_s_init_lock_sema = Module["_s_init_lock_sema"] = wasmExports["s_init_lock_sema"])(a0, a1);
    var _ConditionVariableInit = Module["_ConditionVariableInit"] = (a0) => (_ConditionVariableInit = Module["_ConditionVariableInit"] = wasmExports["ConditionVariableInit"])(a0);
    var _tas_sema = Module["_tas_sema"] = (a0) => (_tas_sema = Module["_tas_sema"] = wasmExports["tas_sema"])(a0);
    var _s_lock = Module["_s_lock"] = (a0, a1, a2, a3) => (_s_lock = Module["_s_lock"] = wasmExports["s_lock"])(a0, a1, a2, a3);
    var _s_unlock_sema = Module["_s_unlock_sema"] = (a0) => (_s_unlock_sema = Module["_s_unlock_sema"] = wasmExports["s_unlock_sema"])(a0);
    var _ConditionVariableSleep = Module["_ConditionVariableSleep"] = (a0, a1) => (_ConditionVariableSleep = Module["_ConditionVariableSleep"] = wasmExports["ConditionVariableSleep"])(a0, a1);
    var _ConditionVariableCancelSleep = Module["_ConditionVariableCancelSleep"] = () => (_ConditionVariableCancelSleep = Module["_ConditionVariableCancelSleep"] = wasmExports["ConditionVariableCancelSleep"])();
    var _visibilitymap_get_status = Module["_visibilitymap_get_status"] = (a0, a1, a2) => (_visibilitymap_get_status = Module["_visibilitymap_get_status"] = wasmExports["visibilitymap_get_status"])(a0, a1, a2);
    var _PrefetchBuffer = Module["_PrefetchBuffer"] = (a0, a1, a2, a3) => (_PrefetchBuffer = Module["_PrefetchBuffer"] = wasmExports["PrefetchBuffer"])(a0, a1, a2, a3);
    var _ExecFindJunkAttributeInTlist = Module["_ExecFindJunkAttributeInTlist"] = (a0, a1) => (_ExecFindJunkAttributeInTlist = Module["_ExecFindJunkAttributeInTlist"] = wasmExports["ExecFindJunkAttributeInTlist"])(a0, a1);
    var _get_call_expr_argtype = Module["_get_call_expr_argtype"] = (a0, a1) => (_get_call_expr_argtype = Module["_get_call_expr_argtype"] = wasmExports["get_call_expr_argtype"])(a0, a1);
    var _get_typcollation = Module["_get_typcollation"] = (a0) => (_get_typcollation = Module["_get_typcollation"] = wasmExports["get_typcollation"])(a0);
    var _MemoryContextSetIdentifier = Module["_MemoryContextSetIdentifier"] = (a0, a1) => (_MemoryContextSetIdentifier = Module["_MemoryContextSetIdentifier"] = wasmExports["MemoryContextSetIdentifier"])(a0, a1);
    var _get_call_result_type = Module["_get_call_result_type"] = (a0, a1, a2) => (_get_call_result_type = Module["_get_call_result_type"] = wasmExports["get_call_result_type"])(a0, a1, a2);
    var _SysCacheGetAttrNotNull = Module["_SysCacheGetAttrNotNull"] = (a0, a1, a2) => (_SysCacheGetAttrNotNull = Module["_SysCacheGetAttrNotNull"] = wasmExports["SysCacheGetAttrNotNull"])(a0, a1, a2);
    var _BlessTupleDesc = Module["_BlessTupleDesc"] = (a0) => (_BlessTupleDesc = Module["_BlessTupleDesc"] = wasmExports["BlessTupleDesc"])(a0);
    var _type_is_rowtype = Module["_type_is_rowtype"] = (a0) => (_type_is_rowtype = Module["_type_is_rowtype"] = wasmExports["type_is_rowtype"])(a0);
    var _GetCurrentSubTransactionId = Module["_GetCurrentSubTransactionId"] = () => (_GetCurrentSubTransactionId = Module["_GetCurrentSubTransactionId"] = wasmExports["GetCurrentSubTransactionId"])();
    var _tuplestore_begin_heap = Module["_tuplestore_begin_heap"] = (a0, a1, a2) => (_tuplestore_begin_heap = Module["_tuplestore_begin_heap"] = wasmExports["tuplestore_begin_heap"])(a0, a1, a2);
    var _geterrposition = Module["_geterrposition"] = () => (_geterrposition = Module["_geterrposition"] = wasmExports["geterrposition"])();
    var _internalerrposition = Module["_internalerrposition"] = (a0) => (_internalerrposition = Module["_internalerrposition"] = wasmExports["internalerrposition"])(a0);
    var _internalerrquery = Module["_internalerrquery"] = (a0) => (_internalerrquery = Module["_internalerrquery"] = wasmExports["internalerrquery"])(a0);
    var _tuplestore_end = Module["_tuplestore_end"] = (a0) => (_tuplestore_end = Module["_tuplestore_end"] = wasmExports["tuplestore_end"])(a0);
    var _get_typtype = Module["_get_typtype"] = (a0) => (_get_typtype = Module["_get_typtype"] = wasmExports["get_typtype"])(a0);
    var _InstrAlloc = Module["_InstrAlloc"] = (a0, a1, a2) => (_InstrAlloc = Module["_InstrAlloc"] = wasmExports["InstrAlloc"])(a0, a1, a2);
    var _table_parallelscan_estimate = Module["_table_parallelscan_estimate"] = (a0, a1) => (_table_parallelscan_estimate = Module["_table_parallelscan_estimate"] = wasmExports["table_parallelscan_estimate"])(a0, a1);
    var _table_parallelscan_initialize = Module["_table_parallelscan_initialize"] = (a0, a1, a2) => (_table_parallelscan_initialize = Module["_table_parallelscan_initialize"] = wasmExports["table_parallelscan_initialize"])(a0, a1, a2);
    var _table_beginscan_parallel = Module["_table_beginscan_parallel"] = (a0, a1) => (_table_beginscan_parallel = Module["_table_beginscan_parallel"] = wasmExports["table_beginscan_parallel"])(a0, a1);
    var _tuplestore_putvalues = Module["_tuplestore_putvalues"] = (a0, a1, a2, a3) => (_tuplestore_putvalues = Module["_tuplestore_putvalues"] = wasmExports["tuplestore_putvalues"])(a0, a1, a2, a3);
    var _pull_varattnos = Module["_pull_varattnos"] = (a0, a1, a2) => (_pull_varattnos = Module["_pull_varattnos"] = wasmExports["pull_varattnos"])(a0, a1, a2);
    var _ExecPrepareExpr = Module["_ExecPrepareExpr"] = (a0, a1) => (_ExecPrepareExpr = Module["_ExecPrepareExpr"] = wasmExports["ExecPrepareExpr"])(a0, a1);
    var _hash_search = Module["_hash_search"] = (a0, a1, a2, a3) => (_hash_search = Module["_hash_search"] = wasmExports["hash_search"])(a0, a1, a2, a3);
    var _hash_create = Module["_hash_create"] = (a0, a1, a2, a3) => (_hash_create = Module["_hash_create"] = wasmExports["hash_create"])(a0, a1, a2, a3);
    var _pg_detoast_datum = Module["_pg_detoast_datum"] = (a0) => (_pg_detoast_datum = Module["_pg_detoast_datum"] = wasmExports["pg_detoast_datum"])(a0);
    var _TransactionIdIsCurrentTransactionId = Module["_TransactionIdIsCurrentTransactionId"] = (a0) => (_TransactionIdIsCurrentTransactionId = Module["_TransactionIdIsCurrentTransactionId"] = wasmExports["TransactionIdIsCurrentTransactionId"])(a0);
    var _execute_attr_map_slot = Module["_execute_attr_map_slot"] = (a0, a1, a2) => (_execute_attr_map_slot = Module["_execute_attr_map_slot"] = wasmExports["execute_attr_map_slot"])(a0, a1, a2);
    var _MemoryContextAllocExtended = Module["_MemoryContextAllocExtended"] = (a0, a1, a2) => (_MemoryContextAllocExtended = Module["_MemoryContextAllocExtended"] = wasmExports["MemoryContextAllocExtended"])(a0, a1, a2);
    var _bms_nonempty_difference = Module["_bms_nonempty_difference"] = (a0, a1) => (_bms_nonempty_difference = Module["_bms_nonempty_difference"] = wasmExports["bms_nonempty_difference"])(a0, a1);
    var _FunctionCall1Coll = Module["_FunctionCall1Coll"] = (a0, a1, a2) => (_FunctionCall1Coll = Module["_FunctionCall1Coll"] = wasmExports["FunctionCall1Coll"])(a0, a1, a2);
    var _fmgr_info_cxt = Module["_fmgr_info_cxt"] = (a0, a1, a2) => (_fmgr_info_cxt = Module["_fmgr_info_cxt"] = wasmExports["fmgr_info_cxt"])(a0, a1, a2);
    var _tuplesort_reset = Module["_tuplesort_reset"] = (a0) => (_tuplesort_reset = Module["_tuplesort_reset"] = wasmExports["tuplesort_reset"])(a0);
    var _deconstruct_array_builtin = Module["_deconstruct_array_builtin"] = (a0, a1, a2, a3, a4) => (_deconstruct_array_builtin = Module["_deconstruct_array_builtin"] = wasmExports["deconstruct_array_builtin"])(a0, a1, a2, a3, a4);
    var _pairingheap_remove_first = Module["_pairingheap_remove_first"] = (a0) => (_pairingheap_remove_first = Module["_pairingheap_remove_first"] = wasmExports["pairingheap_remove_first"])(a0);
    var _get_typlenbyvalalign = Module["_get_typlenbyvalalign"] = (a0, a1, a2, a3) => (_get_typlenbyvalalign = Module["_get_typlenbyvalalign"] = wasmExports["get_typlenbyvalalign"])(a0, a1, a2, a3);
    var _deconstruct_array = Module["_deconstruct_array"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_deconstruct_array = Module["_deconstruct_array"] = wasmExports["deconstruct_array"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _pairingheap_allocate = Module["_pairingheap_allocate"] = (a0, a1) => (_pairingheap_allocate = Module["_pairingheap_allocate"] = wasmExports["pairingheap_allocate"])(a0, a1);
    var _pairingheap_first = Module["_pairingheap_first"] = (a0) => (_pairingheap_first = Module["_pairingheap_first"] = wasmExports["pairingheap_first"])(a0);
    var _pairingheap_add = Module["_pairingheap_add"] = (a0, a1) => (_pairingheap_add = Module["_pairingheap_add"] = wasmExports["pairingheap_add"])(a0, a1);
    var _convert_tuples_by_position = Module["_convert_tuples_by_position"] = (a0, a1, a2) => (_convert_tuples_by_position = Module["_convert_tuples_by_position"] = wasmExports["convert_tuples_by_position"])(a0, a1, a2);
    var _detoast_external_attr = Module["_detoast_external_attr"] = (a0) => (_detoast_external_attr = Module["_detoast_external_attr"] = wasmExports["detoast_external_attr"])(a0);
    var _LaunchParallelWorkers = Module["_LaunchParallelWorkers"] = (a0) => (_LaunchParallelWorkers = Module["_LaunchParallelWorkers"] = wasmExports["LaunchParallelWorkers"])(a0);
    var _TupleDescInitEntry = Module["_TupleDescInitEntry"] = (a0, a1, a2, a3, a4, a5) => (_TupleDescInitEntry = Module["_TupleDescInitEntry"] = wasmExports["TupleDescInitEntry"])(a0, a1, a2, a3, a4, a5);
    var _TupleDescInitEntryCollation = Module["_TupleDescInitEntryCollation"] = (a0, a1, a2) => (_TupleDescInitEntryCollation = Module["_TupleDescInitEntryCollation"] = wasmExports["TupleDescInitEntryCollation"])(a0, a1, a2);
    var _pg_prng_uint32 = Module["_pg_prng_uint32"] = (a0) => (_pg_prng_uint32 = Module["_pg_prng_uint32"] = wasmExports["pg_prng_uint32"])(a0);
    var _DirectFunctionCall1Coll = Module["_DirectFunctionCall1Coll"] = (a0, a1, a2) => (_DirectFunctionCall1Coll = Module["_DirectFunctionCall1Coll"] = wasmExports["DirectFunctionCall1Coll"])(a0, a1, a2);
    var _get_attstatsslot = Module["_get_attstatsslot"] = (a0, a1, a2, a3, a4) => (_get_attstatsslot = Module["_get_attstatsslot"] = wasmExports["get_attstatsslot"])(a0, a1, a2, a3, a4);
    var _free_attstatsslot = Module["_free_attstatsslot"] = (a0) => (_free_attstatsslot = Module["_free_attstatsslot"] = wasmExports["free_attstatsslot"])(a0);
    var _LWLockAcquire = Module["_LWLockAcquire"] = (a0, a1) => (_LWLockAcquire = Module["_LWLockAcquire"] = wasmExports["LWLockAcquire"])(a0, a1);
    var _LWLockRelease = Module["_LWLockRelease"] = (a0) => (_LWLockRelease = Module["_LWLockRelease"] = wasmExports["LWLockRelease"])(a0);
    var _LWLockInitialize = Module["_LWLockInitialize"] = (a0, a1) => (_LWLockInitialize = Module["_LWLockInitialize"] = wasmExports["LWLockInitialize"])(a0, a1);
    var _SPI_connect = Module["_SPI_connect"] = () => (_SPI_connect = Module["_SPI_connect"] = wasmExports["SPI_connect"])();
    var _SPI_connect_ext = Module["_SPI_connect_ext"] = (a0) => (_SPI_connect_ext = Module["_SPI_connect_ext"] = wasmExports["SPI_connect_ext"])(a0);
    var _SPI_finish = Module["_SPI_finish"] = () => (_SPI_finish = Module["_SPI_finish"] = wasmExports["SPI_finish"])();
    var _SPI_commit = Module["_SPI_commit"] = () => (_SPI_commit = Module["_SPI_commit"] = wasmExports["SPI_commit"])();
    var _CopyErrorData = Module["_CopyErrorData"] = () => (_CopyErrorData = Module["_CopyErrorData"] = wasmExports["CopyErrorData"])();
    var _ReThrowError = Module["_ReThrowError"] = (a0) => (_ReThrowError = Module["_ReThrowError"] = wasmExports["ReThrowError"])(a0);
    var _SPI_commit_and_chain = Module["_SPI_commit_and_chain"] = () => (_SPI_commit_and_chain = Module["_SPI_commit_and_chain"] = wasmExports["SPI_commit_and_chain"])();
    var _SPI_rollback = Module["_SPI_rollback"] = () => (_SPI_rollback = Module["_SPI_rollback"] = wasmExports["SPI_rollback"])();
    var _SPI_rollback_and_chain = Module["_SPI_rollback_and_chain"] = () => (_SPI_rollback_and_chain = Module["_SPI_rollback_and_chain"] = wasmExports["SPI_rollback_and_chain"])();
    var _SPI_execute = Module["_SPI_execute"] = (a0, a1, a2) => (_SPI_execute = Module["_SPI_execute"] = wasmExports["SPI_execute"])(a0, a1, a2);
    var _SPI_freetuptable = Module["_SPI_freetuptable"] = (a0) => (_SPI_freetuptable = Module["_SPI_freetuptable"] = wasmExports["SPI_freetuptable"])(a0);
    var _ReleaseCachedPlan = Module["_ReleaseCachedPlan"] = (a0, a1) => (_ReleaseCachedPlan = Module["_ReleaseCachedPlan"] = wasmExports["ReleaseCachedPlan"])(a0, a1);
    var _SPI_exec = Module["_SPI_exec"] = (a0, a1) => (_SPI_exec = Module["_SPI_exec"] = wasmExports["SPI_exec"])(a0, a1);
    var _SPI_execute_extended = Module["_SPI_execute_extended"] = (a0, a1) => (_SPI_execute_extended = Module["_SPI_execute_extended"] = wasmExports["SPI_execute_extended"])(a0, a1);
    var _SPI_execp = Module["_SPI_execp"] = (a0, a1, a2, a3) => (_SPI_execp = Module["_SPI_execp"] = wasmExports["SPI_execp"])(a0, a1, a2, a3);
    var _SPI_execute_plan_extended = Module["_SPI_execute_plan_extended"] = (a0, a1) => (_SPI_execute_plan_extended = Module["_SPI_execute_plan_extended"] = wasmExports["SPI_execute_plan_extended"])(a0, a1);
    var _SPI_execute_plan_with_paramlist = Module["_SPI_execute_plan_with_paramlist"] = (a0, a1, a2, a3) => (_SPI_execute_plan_with_paramlist = Module["_SPI_execute_plan_with_paramlist"] = wasmExports["SPI_execute_plan_with_paramlist"])(a0, a1, a2, a3);
    var _SPI_prepare = Module["_SPI_prepare"] = (a0, a1, a2) => (_SPI_prepare = Module["_SPI_prepare"] = wasmExports["SPI_prepare"])(a0, a1, a2);
    var _SPI_prepare_extended = Module["_SPI_prepare_extended"] = (a0, a1) => (_SPI_prepare_extended = Module["_SPI_prepare_extended"] = wasmExports["SPI_prepare_extended"])(a0, a1);
    var _SPI_keepplan = Module["_SPI_keepplan"] = (a0) => (_SPI_keepplan = Module["_SPI_keepplan"] = wasmExports["SPI_keepplan"])(a0);
    var _SPI_freeplan = Module["_SPI_freeplan"] = (a0) => (_SPI_freeplan = Module["_SPI_freeplan"] = wasmExports["SPI_freeplan"])(a0);
    var _SPI_copytuple = Module["_SPI_copytuple"] = (a0) => (_SPI_copytuple = Module["_SPI_copytuple"] = wasmExports["SPI_copytuple"])(a0);
    var _SPI_returntuple = Module["_SPI_returntuple"] = (a0, a1) => (_SPI_returntuple = Module["_SPI_returntuple"] = wasmExports["SPI_returntuple"])(a0, a1);
    var _heap_deform_tuple = Module["_heap_deform_tuple"] = (a0, a1, a2, a3) => (_heap_deform_tuple = Module["_heap_deform_tuple"] = wasmExports["heap_deform_tuple"])(a0, a1, a2, a3);
    var _SPI_fnumber = Module["_SPI_fnumber"] = (a0, a1) => (_SPI_fnumber = Module["_SPI_fnumber"] = wasmExports["SPI_fnumber"])(a0, a1);
    var _SPI_fname = Module["_SPI_fname"] = (a0, a1) => (_SPI_fname = Module["_SPI_fname"] = wasmExports["SPI_fname"])(a0, a1);
    var _SPI_getvalue = Module["_SPI_getvalue"] = (a0, a1, a2) => (_SPI_getvalue = Module["_SPI_getvalue"] = wasmExports["SPI_getvalue"])(a0, a1, a2);
    var _SPI_getbinval = Module["_SPI_getbinval"] = (a0, a1, a2, a3) => (_SPI_getbinval = Module["_SPI_getbinval"] = wasmExports["SPI_getbinval"])(a0, a1, a2, a3);
    var _SPI_gettype = Module["_SPI_gettype"] = (a0, a1) => (_SPI_gettype = Module["_SPI_gettype"] = wasmExports["SPI_gettype"])(a0, a1);
    var _SPI_gettypeid = Module["_SPI_gettypeid"] = (a0, a1) => (_SPI_gettypeid = Module["_SPI_gettypeid"] = wasmExports["SPI_gettypeid"])(a0, a1);
    var _SPI_getrelname = Module["_SPI_getrelname"] = (a0) => (_SPI_getrelname = Module["_SPI_getrelname"] = wasmExports["SPI_getrelname"])(a0);
    var _SPI_palloc = Module["_SPI_palloc"] = (a0) => (_SPI_palloc = Module["_SPI_palloc"] = wasmExports["SPI_palloc"])(a0);
    var _SPI_datumTransfer = Module["_SPI_datumTransfer"] = (a0, a1, a2) => (_SPI_datumTransfer = Module["_SPI_datumTransfer"] = wasmExports["SPI_datumTransfer"])(a0, a1, a2);
    var _datumTransfer = Module["_datumTransfer"] = (a0, a1, a2) => (_datumTransfer = Module["_datumTransfer"] = wasmExports["datumTransfer"])(a0, a1, a2);
    var _MemoryContextStrdup = Module["_MemoryContextStrdup"] = (a0, a1) => (_MemoryContextStrdup = Module["_MemoryContextStrdup"] = wasmExports["MemoryContextStrdup"])(a0, a1);
    var _SPI_cursor_open_with_paramlist = Module["_SPI_cursor_open_with_paramlist"] = (a0, a1, a2, a3) => (_SPI_cursor_open_with_paramlist = Module["_SPI_cursor_open_with_paramlist"] = wasmExports["SPI_cursor_open_with_paramlist"])(a0, a1, a2, a3);
    var _SPI_cursor_parse_open = Module["_SPI_cursor_parse_open"] = (a0, a1, a2) => (_SPI_cursor_parse_open = Module["_SPI_cursor_parse_open"] = wasmExports["SPI_cursor_parse_open"])(a0, a1, a2);
    var _SPI_cursor_find = Module["_SPI_cursor_find"] = (a0) => (_SPI_cursor_find = Module["_SPI_cursor_find"] = wasmExports["SPI_cursor_find"])(a0);
    var _SPI_cursor_fetch = Module["_SPI_cursor_fetch"] = (a0, a1, a2) => (_SPI_cursor_fetch = Module["_SPI_cursor_fetch"] = wasmExports["SPI_cursor_fetch"])(a0, a1, a2);
    var _SPI_scroll_cursor_fetch = Module["_SPI_scroll_cursor_fetch"] = (a0, a1, a2) => (_SPI_scroll_cursor_fetch = Module["_SPI_scroll_cursor_fetch"] = wasmExports["SPI_scroll_cursor_fetch"])(a0, a1, a2);
    var _SPI_scroll_cursor_move = Module["_SPI_scroll_cursor_move"] = (a0, a1, a2) => (_SPI_scroll_cursor_move = Module["_SPI_scroll_cursor_move"] = wasmExports["SPI_scroll_cursor_move"])(a0, a1, a2);
    var _SPI_cursor_close = Module["_SPI_cursor_close"] = (a0) => (_SPI_cursor_close = Module["_SPI_cursor_close"] = wasmExports["SPI_cursor_close"])(a0);
    var _SPI_result_code_string = Module["_SPI_result_code_string"] = (a0) => (_SPI_result_code_string = Module["_SPI_result_code_string"] = wasmExports["SPI_result_code_string"])(a0);
    var _SPI_plan_get_plan_sources = Module["_SPI_plan_get_plan_sources"] = (a0) => (_SPI_plan_get_plan_sources = Module["_SPI_plan_get_plan_sources"] = wasmExports["SPI_plan_get_plan_sources"])(a0);
    var _SPI_plan_get_cached_plan = Module["_SPI_plan_get_cached_plan"] = (a0) => (_SPI_plan_get_cached_plan = Module["_SPI_plan_get_cached_plan"] = wasmExports["SPI_plan_get_cached_plan"])(a0);
    var _SPI_register_trigger_data = Module["_SPI_register_trigger_data"] = (a0) => (_SPI_register_trigger_data = Module["_SPI_register_trigger_data"] = wasmExports["SPI_register_trigger_data"])(a0);
    var _tuplestore_tuple_count = Module["_tuplestore_tuple_count"] = (a0) => (_tuplestore_tuple_count = Module["_tuplestore_tuple_count"] = wasmExports["tuplestore_tuple_count"])(a0);
    var _exprLocation = Module["_exprLocation"] = (a0) => (_exprLocation = Module["_exprLocation"] = wasmExports["exprLocation"])(a0);
    var _tuplestore_puttuple = Module["_tuplestore_puttuple"] = (a0, a1) => (_tuplestore_puttuple = Module["_tuplestore_puttuple"] = wasmExports["tuplestore_puttuple"])(a0, a1);
    var _pg_class_aclcheck = Module["_pg_class_aclcheck"] = (a0, a1, a2) => (_pg_class_aclcheck = Module["_pg_class_aclcheck"] = wasmExports["pg_class_aclcheck"])(a0, a1, a2);
    var _RelationGetIndexList = Module["_RelationGetIndexList"] = (a0) => (_RelationGetIndexList = Module["_RelationGetIndexList"] = wasmExports["RelationGetIndexList"])(a0);
    var _get_partition_ancestors = Module["_get_partition_ancestors"] = (a0) => (_get_partition_ancestors = Module["_get_partition_ancestors"] = wasmExports["get_partition_ancestors"])(a0);
    var _ExecInitExprWithParams = Module["_ExecInitExprWithParams"] = (a0, a1) => (_ExecInitExprWithParams = Module["_ExecInitExprWithParams"] = wasmExports["ExecInitExprWithParams"])(a0, a1);
    var _AddWaitEventToSet = Module["_AddWaitEventToSet"] = (a0, a1, a2, a3, a4) => (_AddWaitEventToSet = Module["_AddWaitEventToSet"] = wasmExports["AddWaitEventToSet"])(a0, a1, a2, a3, a4);
    var _GetNumRegisteredWaitEvents = Module["_GetNumRegisteredWaitEvents"] = (a0) => (_GetNumRegisteredWaitEvents = Module["_GetNumRegisteredWaitEvents"] = wasmExports["GetNumRegisteredWaitEvents"])(a0);
    var _BuildIndexInfo = Module["_BuildIndexInfo"] = (a0) => (_BuildIndexInfo = Module["_BuildIndexInfo"] = wasmExports["BuildIndexInfo"])(a0);
    var _ItemPointerEquals = Module["_ItemPointerEquals"] = (a0, a1) => (_ItemPointerEquals = Module["_ItemPointerEquals"] = wasmExports["ItemPointerEquals"])(a0, a1);
    var _TransactionIdPrecedes = Module["_TransactionIdPrecedes"] = (a0, a1) => (_TransactionIdPrecedes = Module["_TransactionIdPrecedes"] = wasmExports["TransactionIdPrecedes"])(a0, a1);
    var _bsearch = Module["_bsearch"] = (a0, a1, a2, a3, a4) => (_bsearch = Module["_bsearch"] = wasmExports["bsearch"])(a0, a1, a2, a3, a4);
    var _pg_detoast_datum_copy = Module["_pg_detoast_datum_copy"] = (a0) => (_pg_detoast_datum_copy = Module["_pg_detoast_datum_copy"] = wasmExports["pg_detoast_datum_copy"])(a0);
    var _HeapTupleHeaderGetDatum = Module["_HeapTupleHeaderGetDatum"] = (a0) => (_HeapTupleHeaderGetDatum = Module["_HeapTupleHeaderGetDatum"] = wasmExports["HeapTupleHeaderGetDatum"])(a0);
    var _construct_md_array = Module["_construct_md_array"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_construct_md_array = Module["_construct_md_array"] = wasmExports["construct_md_array"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _ArrayGetNItems = Module["_ArrayGetNItems"] = (a0, a1) => (_ArrayGetNItems = Module["_ArrayGetNItems"] = wasmExports["ArrayGetNItems"])(a0, a1);
    var _construct_empty_array = Module["_construct_empty_array"] = (a0) => (_construct_empty_array = Module["_construct_empty_array"] = wasmExports["construct_empty_array"])(a0);
    var _DatumGetEOHP = Module["_DatumGetEOHP"] = (a0) => (_DatumGetEOHP = Module["_DatumGetEOHP"] = wasmExports["DatumGetEOHP"])(a0);
    var _expanded_record_fetch_tupdesc = Module["_expanded_record_fetch_tupdesc"] = (a0) => (_expanded_record_fetch_tupdesc = Module["_expanded_record_fetch_tupdesc"] = wasmExports["expanded_record_fetch_tupdesc"])(a0);
    var _expanded_record_fetch_field = Module["_expanded_record_fetch_field"] = (a0, a1, a2) => (_expanded_record_fetch_field = Module["_expanded_record_fetch_field"] = wasmExports["expanded_record_fetch_field"])(a0, a1, a2);
    var _lookup_type_cache = Module["_lookup_type_cache"] = (a0, a1) => (_lookup_type_cache = Module["_lookup_type_cache"] = wasmExports["lookup_type_cache"])(a0, a1);
    var _execute_attr_map_tuple = Module["_execute_attr_map_tuple"] = (a0, a1) => (_execute_attr_map_tuple = Module["_execute_attr_map_tuple"] = wasmExports["execute_attr_map_tuple"])(a0, a1);
    var _cstring_to_text_with_len = Module["_cstring_to_text_with_len"] = (a0, a1) => (_cstring_to_text_with_len = Module["_cstring_to_text_with_len"] = wasmExports["cstring_to_text_with_len"])(a0, a1);
    var _pg_detoast_datum_packed = Module["_pg_detoast_datum_packed"] = (a0) => (_pg_detoast_datum_packed = Module["_pg_detoast_datum_packed"] = wasmExports["pg_detoast_datum_packed"])(a0);
    var _lookup_rowtype_tupdesc_domain = Module["_lookup_rowtype_tupdesc_domain"] = (a0, a1, a2) => (_lookup_rowtype_tupdesc_domain = Module["_lookup_rowtype_tupdesc_domain"] = wasmExports["lookup_rowtype_tupdesc_domain"])(a0, a1, a2);
    var _MemoryContextGetParent = Module["_MemoryContextGetParent"] = (a0) => (_MemoryContextGetParent = Module["_MemoryContextGetParent"] = wasmExports["MemoryContextGetParent"])(a0);
    var _DeleteExpandedObject = Module["_DeleteExpandedObject"] = (a0) => (_DeleteExpandedObject = Module["_DeleteExpandedObject"] = wasmExports["DeleteExpandedObject"])(a0);
    var _get_opfamily_member = Module["_get_opfamily_member"] = (a0, a1, a2, a3) => (_get_opfamily_member = Module["_get_opfamily_member"] = wasmExports["get_opfamily_member"])(a0, a1, a2, a3);
    var _GetCurrentCommandId = Module["_GetCurrentCommandId"] = (a0) => (_GetCurrentCommandId = Module["_GetCurrentCommandId"] = wasmExports["GetCurrentCommandId"])(a0);
    var _clock_gettime = Module["_clock_gettime"] = (a0, a1) => (_clock_gettime = Module["_clock_gettime"] = wasmExports["clock_gettime"])(a0, a1);
    var _BufferUsageAccumDiff = Module["_BufferUsageAccumDiff"] = (a0, a1, a2) => (_BufferUsageAccumDiff = Module["_BufferUsageAccumDiff"] = wasmExports["BufferUsageAccumDiff"])(a0, a1, a2);
    var _WalUsageAccumDiff = Module["_WalUsageAccumDiff"] = (a0, a1, a2) => (_WalUsageAccumDiff = Module["_WalUsageAccumDiff"] = wasmExports["WalUsageAccumDiff"])(a0, a1, a2);
    var _InstrUpdateTupleCount = Module["_InstrUpdateTupleCount"] = (a0, a1) => (_InstrUpdateTupleCount = Module["_InstrUpdateTupleCount"] = wasmExports["InstrUpdateTupleCount"])(a0, a1);
    var _ExprEvalPushStep = Module["_ExprEvalPushStep"] = (a0, a1) => (_ExprEvalPushStep = Module["_ExprEvalPushStep"] = wasmExports["ExprEvalPushStep"])(a0, a1);
    var _get_element_type = Module["_get_element_type"] = (a0) => (_get_element_type = Module["_get_element_type"] = wasmExports["get_element_type"])(a0);
    var _EOH_get_flat_size = Module["_EOH_get_flat_size"] = (a0) => (_EOH_get_flat_size = Module["_EOH_get_flat_size"] = wasmExports["EOH_get_flat_size"])(a0);
    var _EOH_flatten_into = Module["_EOH_flatten_into"] = (a0, a1, a2) => (_EOH_flatten_into = Module["_EOH_flatten_into"] = wasmExports["EOH_flatten_into"])(a0, a1, a2);
    var _ExecStoreHeapTuple = Module["_ExecStoreHeapTuple"] = (a0, a1, a2) => (_ExecStoreHeapTuple = Module["_ExecStoreHeapTuple"] = wasmExports["ExecStoreHeapTuple"])(a0, a1, a2);
    var _MakeTupleTableSlot = Module["_MakeTupleTableSlot"] = (a0, a1) => (_MakeTupleTableSlot = Module["_MakeTupleTableSlot"] = wasmExports["MakeTupleTableSlot"])(a0, a1);
    var _ExecFetchSlotHeapTuple = Module["_ExecFetchSlotHeapTuple"] = (a0, a1, a2) => (_ExecFetchSlotHeapTuple = Module["_ExecFetchSlotHeapTuple"] = wasmExports["ExecFetchSlotHeapTuple"])(a0, a1, a2);
    var _TupleDescGetAttInMetadata = Module["_TupleDescGetAttInMetadata"] = (a0) => (_TupleDescGetAttInMetadata = Module["_TupleDescGetAttInMetadata"] = wasmExports["TupleDescGetAttInMetadata"])(a0);
    var _BuildTupleFromCStrings = Module["_BuildTupleFromCStrings"] = (a0, a1) => (_BuildTupleFromCStrings = Module["_BuildTupleFromCStrings"] = wasmExports["BuildTupleFromCStrings"])(a0, a1);
    var _InputFunctionCall = Module["_InputFunctionCall"] = (a0, a1, a2, a3) => (_InputFunctionCall = Module["_InputFunctionCall"] = wasmExports["InputFunctionCall"])(a0, a1, a2, a3);
    var _standard_ExecutorStart = Module["_standard_ExecutorStart"] = (a0, a1) => (_standard_ExecutorStart = Module["_standard_ExecutorStart"] = wasmExports["standard_ExecutorStart"])(a0, a1);
    var _get_rel_namespace = Module["_get_rel_namespace"] = (a0) => (_get_rel_namespace = Module["_get_rel_namespace"] = wasmExports["get_rel_namespace"])(a0);
    var _standard_ExecutorRun = Module["_standard_ExecutorRun"] = (a0, a1, a2, a3) => (_standard_ExecutorRun = Module["_standard_ExecutorRun"] = wasmExports["standard_ExecutorRun"])(a0, a1, a2, a3);
    var _EnterParallelMode = Module["_EnterParallelMode"] = () => (_EnterParallelMode = Module["_EnterParallelMode"] = wasmExports["EnterParallelMode"])();
    var _ExitParallelMode = Module["_ExitParallelMode"] = () => (_ExitParallelMode = Module["_ExitParallelMode"] = wasmExports["ExitParallelMode"])();
    var _standard_ExecutorFinish = Module["_standard_ExecutorFinish"] = (a0) => (_standard_ExecutorFinish = Module["_standard_ExecutorFinish"] = wasmExports["standard_ExecutorFinish"])(a0);
    var _standard_ExecutorEnd = Module["_standard_ExecutorEnd"] = (a0) => (_standard_ExecutorEnd = Module["_standard_ExecutorEnd"] = wasmExports["standard_ExecutorEnd"])(a0);
    var _CreateParallelContext = Module["_CreateParallelContext"] = (a0, a1, a2) => (_CreateParallelContext = Module["_CreateParallelContext"] = wasmExports["CreateParallelContext"])(a0, a1, a2);
    var _InitializeParallelDSM = Module["_InitializeParallelDSM"] = (a0) => (_InitializeParallelDSM = Module["_InitializeParallelDSM"] = wasmExports["InitializeParallelDSM"])(a0);
    var _WaitForParallelWorkersToFinish = Module["_WaitForParallelWorkersToFinish"] = (a0) => (_WaitForParallelWorkersToFinish = Module["_WaitForParallelWorkersToFinish"] = wasmExports["WaitForParallelWorkersToFinish"])(a0);
    var _DestroyParallelContext = Module["_DestroyParallelContext"] = (a0) => (_DestroyParallelContext = Module["_DestroyParallelContext"] = wasmExports["DestroyParallelContext"])(a0);
    var _index_deform_tuple = Module["_index_deform_tuple"] = (a0, a1, a2, a3) => (_index_deform_tuple = Module["_index_deform_tuple"] = wasmExports["index_deform_tuple"])(a0, a1, a2, a3);
    var _ExecAsyncResponse = Module["_ExecAsyncResponse"] = (a0) => (_ExecAsyncResponse = Module["_ExecAsyncResponse"] = wasmExports["ExecAsyncResponse"])(a0);
    var _ExecAsyncRequestDone = Module["_ExecAsyncRequestDone"] = (a0, a1) => (_ExecAsyncRequestDone = Module["_ExecAsyncRequestDone"] = wasmExports["ExecAsyncRequestDone"])(a0, a1);
    var _ExecAsyncRequestPending = Module["_ExecAsyncRequestPending"] = (a0) => (_ExecAsyncRequestPending = Module["_ExecAsyncRequestPending"] = wasmExports["ExecAsyncRequestPending"])(a0);
    var _format_procedure = Module["_format_procedure"] = (a0) => (_format_procedure = Module["_format_procedure"] = wasmExports["format_procedure"])(a0);
    var _stat = Module["_stat"] = (a0, a1) => (_stat = Module["_stat"] = wasmExports["stat"])(a0, a1);
    var _bloom_create = Module["_bloom_create"] = (a0, a1, a2) => (_bloom_create = Module["_bloom_create"] = wasmExports["bloom_create"])(a0, a1, a2);
    var _bloom_free = Module["_bloom_free"] = (a0) => (_bloom_free = Module["_bloom_free"] = wasmExports["bloom_free"])(a0);
    var _bloom_add_element = Module["_bloom_add_element"] = (a0, a1, a2) => (_bloom_add_element = Module["_bloom_add_element"] = wasmExports["bloom_add_element"])(a0, a1, a2);
    var _hash_bytes_extended = Module["_hash_bytes_extended"] = (a0, a1, a2) => (_hash_bytes_extended = Module["_hash_bytes_extended"] = wasmExports["hash_bytes_extended"])(a0, a1, a2);
    var _bloom_lacks_element = Module["_bloom_lacks_element"] = (a0, a1, a2) => (_bloom_lacks_element = Module["_bloom_lacks_element"] = wasmExports["bloom_lacks_element"])(a0, a1, a2);
    var _bloom_prop_bits_set = Module["_bloom_prop_bits_set"] = (a0) => (_bloom_prop_bits_set = Module["_bloom_prop_bits_set"] = wasmExports["bloom_prop_bits_set"])(a0);
    var _pg_popcount = Module["_pg_popcount"] = (a0, a1) => (_pg_popcount = Module["_pg_popcount"] = wasmExports["pg_popcount"])(a0, a1);
    var _log = Module["_log"] = (a0) => (_log = Module["_log"] = wasmExports["log"])(a0);
    var _bms_make_singleton = Module["_bms_make_singleton"] = (a0) => (_bms_make_singleton = Module["_bms_make_singleton"] = wasmExports["bms_make_singleton"])(a0);
    var _pairingheap_free = Module["_pairingheap_free"] = (a0) => (_pairingheap_free = Module["_pairingheap_free"] = wasmExports["pairingheap_free"])(a0);
    var _estimate_expression_value = Module["_estimate_expression_value"] = (a0, a1) => (_estimate_expression_value = Module["_estimate_expression_value"] = wasmExports["estimate_expression_value"])(a0, a1);
    var _clamp_row_est = Module["_clamp_row_est"] = (a0) => (_clamp_row_est = Module["_clamp_row_est"] = wasmExports["clamp_row_est"])(a0);
    var _hash_bytes = Module["_hash_bytes"] = (a0, a1) => (_hash_bytes = Module["_hash_bytes"] = wasmExports["hash_bytes"])(a0, a1);
    var _MarkBufferDirty = Module["_MarkBufferDirty"] = (a0) => (_MarkBufferDirty = Module["_MarkBufferDirty"] = wasmExports["MarkBufferDirty"])(a0);
    var _UnlockReleaseBuffer = Module["_UnlockReleaseBuffer"] = (a0) => (_UnlockReleaseBuffer = Module["_UnlockReleaseBuffer"] = wasmExports["UnlockReleaseBuffer"])(a0);
    var _PageAddItemExtended = Module["_PageAddItemExtended"] = (a0, a1, a2, a3, a4) => (_PageAddItemExtended = Module["_PageAddItemExtended"] = wasmExports["PageAddItemExtended"])(a0, a1, a2, a3, a4);
    var _BufferGetBlockNumber = Module["_BufferGetBlockNumber"] = (a0) => (_BufferGetBlockNumber = Module["_BufferGetBlockNumber"] = wasmExports["BufferGetBlockNumber"])(a0);
    var _PageIndexMultiDelete = Module["_PageIndexMultiDelete"] = (a0, a1, a2) => (_PageIndexMultiDelete = Module["_PageIndexMultiDelete"] = wasmExports["PageIndexMultiDelete"])(a0, a1, a2);
    var __hash_ovflblkno_to_bitno = Module["__hash_ovflblkno_to_bitno"] = (a0, a1) => (__hash_ovflblkno_to_bitno = Module["__hash_ovflblkno_to_bitno"] = wasmExports["_hash_ovflblkno_to_bitno"])(a0, a1);
    var _LockBuffer = Module["_LockBuffer"] = (a0, a1) => (_LockBuffer = Module["_LockBuffer"] = wasmExports["LockBuffer"])(a0, a1);
    var __hash_relbuf = Module["__hash_relbuf"] = (a0, a1) => (__hash_relbuf = Module["__hash_relbuf"] = wasmExports["_hash_relbuf"])(a0, a1);
    var __hash_getbuf = Module["__hash_getbuf"] = (a0, a1, a2, a3) => (__hash_getbuf = Module["__hash_getbuf"] = wasmExports["_hash_getbuf"])(a0, a1, a2, a3);
    var _XLogBeginInsert = Module["_XLogBeginInsert"] = () => (_XLogBeginInsert = Module["_XLogBeginInsert"] = wasmExports["XLogBeginInsert"])();
    var _XLogRegisterData = Module["_XLogRegisterData"] = (a0, a1) => (_XLogRegisterData = Module["_XLogRegisterData"] = wasmExports["XLogRegisterData"])(a0, a1);
    var _XLogInsert = Module["_XLogInsert"] = (a0, a1) => (_XLogInsert = Module["_XLogInsert"] = wasmExports["XLogInsert"])(a0, a1);
    var __hash_getbuf_with_strategy = Module["__hash_getbuf_with_strategy"] = (a0, a1, a2, a3, a4) => (__hash_getbuf_with_strategy = Module["__hash_getbuf_with_strategy"] = wasmExports["_hash_getbuf_with_strategy"])(a0, a1, a2, a3, a4);
    var _SearchSysCacheList = Module["_SearchSysCacheList"] = (a0, a1, a2, a3, a4) => (_SearchSysCacheList = Module["_SearchSysCacheList"] = wasmExports["SearchSysCacheList"])(a0, a1, a2, a3, a4);
    var _check_amoptsproc_signature = Module["_check_amoptsproc_signature"] = (a0) => (_check_amoptsproc_signature = Module["_check_amoptsproc_signature"] = wasmExports["check_amoptsproc_signature"])(a0);
    var _format_operator = Module["_format_operator"] = (a0) => (_format_operator = Module["_format_operator"] = wasmExports["format_operator"])(a0);
    var _check_amop_signature = Module["_check_amop_signature"] = (a0, a1, a2, a3) => (_check_amop_signature = Module["_check_amop_signature"] = wasmExports["check_amop_signature"])(a0, a1, a2, a3);
    var _identify_opfamily_groups = Module["_identify_opfamily_groups"] = (a0, a1) => (_identify_opfamily_groups = Module["_identify_opfamily_groups"] = wasmExports["identify_opfamily_groups"])(a0, a1);
    var _ReleaseCatCacheList = Module["_ReleaseCatCacheList"] = (a0) => (_ReleaseCatCacheList = Module["_ReleaseCatCacheList"] = wasmExports["ReleaseCatCacheList"])(a0);
    var __hash_get_indextuple_hashkey = Module["__hash_get_indextuple_hashkey"] = (a0) => (__hash_get_indextuple_hashkey = Module["__hash_get_indextuple_hashkey"] = wasmExports["_hash_get_indextuple_hashkey"])(a0);
    var _PageGetFreeSpace = Module["_PageGetFreeSpace"] = (a0) => (_PageGetFreeSpace = Module["_PageGetFreeSpace"] = wasmExports["PageGetFreeSpace"])(a0);
    var _ReadBuffer = Module["_ReadBuffer"] = (a0, a1) => (_ReadBuffer = Module["_ReadBuffer"] = wasmExports["ReadBuffer"])(a0, a1);
    var _ReadBufferExtended = Module["_ReadBufferExtended"] = (a0, a1, a2, a3, a4) => (_ReadBufferExtended = Module["_ReadBufferExtended"] = wasmExports["ReadBufferExtended"])(a0, a1, a2, a3, a4);
    var _PageInit = Module["_PageInit"] = (a0, a1, a2) => (_PageInit = Module["_PageInit"] = wasmExports["PageInit"])(a0, a1, a2);
    var _RelationGetNumberOfBlocksInFork = Module["_RelationGetNumberOfBlocksInFork"] = (a0, a1) => (_RelationGetNumberOfBlocksInFork = Module["_RelationGetNumberOfBlocksInFork"] = wasmExports["RelationGetNumberOfBlocksInFork"])(a0, a1);
    var _ExtendBufferedRel = Module["_ExtendBufferedRel"] = (a0, a1, a2, a3) => (_ExtendBufferedRel = Module["_ExtendBufferedRel"] = wasmExports["ExtendBufferedRel"])(a0, a1, a2, a3);
    var _index_getprocid = Module["_index_getprocid"] = (a0, a1, a2) => (_index_getprocid = Module["_index_getprocid"] = wasmExports["index_getprocid"])(a0, a1, a2);
    var _smgropen = Module["_smgropen"] = (a0, a1) => (_smgropen = Module["_smgropen"] = wasmExports["smgropen"])(a0, a1);
    var _smgrsetowner = Module["_smgrsetowner"] = (a0, a1) => (_smgrsetowner = Module["_smgrsetowner"] = wasmExports["smgrsetowner"])(a0, a1);
    var _hash_destroy = Module["_hash_destroy"] = (a0) => (_hash_destroy = Module["_hash_destroy"] = wasmExports["hash_destroy"])(a0);
    var _index_form_tuple = Module["_index_form_tuple"] = (a0, a1, a2) => (_index_form_tuple = Module["_index_form_tuple"] = wasmExports["index_form_tuple"])(a0, a1, a2);
    var _LockBufferForCleanup = Module["_LockBufferForCleanup"] = (a0) => (_LockBufferForCleanup = Module["_LockBufferForCleanup"] = wasmExports["LockBufferForCleanup"])(a0);
    var _RelationGetIndexScan = Module["_RelationGetIndexScan"] = (a0, a1, a2) => (_RelationGetIndexScan = Module["_RelationGetIndexScan"] = wasmExports["RelationGetIndexScan"])(a0, a1, a2);
    var _tbm_add_tuples = Module["_tbm_add_tuples"] = (a0, a1, a2, a3) => (_tbm_add_tuples = Module["_tbm_add_tuples"] = wasmExports["tbm_add_tuples"])(a0, a1, a2, a3);
    var _vacuum_delay_point = Module["_vacuum_delay_point"] = () => (_vacuum_delay_point = Module["_vacuum_delay_point"] = wasmExports["vacuum_delay_point"])();
    var _index_getprocinfo = Module["_index_getprocinfo"] = (a0, a1, a2) => (_index_getprocinfo = Module["_index_getprocinfo"] = wasmExports["index_getprocinfo"])(a0, a1, a2);
    var _build_reloptions = Module["_build_reloptions"] = (a0, a1, a2, a3, a4, a5) => (_build_reloptions = Module["_build_reloptions"] = wasmExports["build_reloptions"])(a0, a1, a2, a3, a4, a5);
    var _TestForOldSnapshot_impl = Module["_TestForOldSnapshot_impl"] = (a0, a1) => (_TestForOldSnapshot_impl = Module["_TestForOldSnapshot_impl"] = wasmExports["TestForOldSnapshot_impl"])(a0, a1);
    var _pgstat_assoc_relation = Module["_pgstat_assoc_relation"] = (a0) => (_pgstat_assoc_relation = Module["_pgstat_assoc_relation"] = wasmExports["pgstat_assoc_relation"])(a0);
    var _visibilitymap_clear = Module["_visibilitymap_clear"] = (a0, a1, a2, a3) => (_visibilitymap_clear = Module["_visibilitymap_clear"] = wasmExports["visibilitymap_clear"])(a0, a1, a2, a3);
    var _visibilitymap_pin = Module["_visibilitymap_pin"] = (a0, a1, a2) => (_visibilitymap_pin = Module["_visibilitymap_pin"] = wasmExports["visibilitymap_pin"])(a0, a1, a2);
    var _smgrexists = Module["_smgrexists"] = (a0, a1) => (_smgrexists = Module["_smgrexists"] = wasmExports["smgrexists"])(a0, a1);
    var _visibilitymap_prepare_truncate = Module["_visibilitymap_prepare_truncate"] = (a0, a1) => (_visibilitymap_prepare_truncate = Module["_visibilitymap_prepare_truncate"] = wasmExports["visibilitymap_prepare_truncate"])(a0, a1);
    var _log_newpage_buffer = Module["_log_newpage_buffer"] = (a0, a1) => (_log_newpage_buffer = Module["_log_newpage_buffer"] = wasmExports["log_newpage_buffer"])(a0, a1);
    var _HeapTupleSatisfiesVisibility = Module["_HeapTupleSatisfiesVisibility"] = (a0, a1, a2) => (_HeapTupleSatisfiesVisibility = Module["_HeapTupleSatisfiesVisibility"] = wasmExports["HeapTupleSatisfiesVisibility"])(a0, a1, a2);
    var _HeapTupleGetUpdateXid = Module["_HeapTupleGetUpdateXid"] = (a0) => (_HeapTupleGetUpdateXid = Module["_HeapTupleGetUpdateXid"] = wasmExports["HeapTupleGetUpdateXid"])(a0);
    var _HeapTupleSatisfiesVacuum = Module["_HeapTupleSatisfiesVacuum"] = (a0, a1, a2) => (_HeapTupleSatisfiesVacuum = Module["_HeapTupleSatisfiesVacuum"] = wasmExports["HeapTupleSatisfiesVacuum"])(a0, a1, a2);
    var _GetOldestNonRemovableTransactionId = Module["_GetOldestNonRemovableTransactionId"] = (a0) => (_GetOldestNonRemovableTransactionId = Module["_GetOldestNonRemovableTransactionId"] = wasmExports["GetOldestNonRemovableTransactionId"])(a0);
    var _PageGetHeapFreeSpace = Module["_PageGetHeapFreeSpace"] = (a0) => (_PageGetHeapFreeSpace = Module["_PageGetHeapFreeSpace"] = wasmExports["PageGetHeapFreeSpace"])(a0);
    var _vac_estimate_reltuples = Module["_vac_estimate_reltuples"] = (a0, a1, a2, a3) => (_vac_estimate_reltuples = Module["_vac_estimate_reltuples"] = wasmExports["vac_estimate_reltuples"])(a0, a1, a2, a3);
    var _GetRecordedFreeSpace = Module["_GetRecordedFreeSpace"] = (a0, a1) => (_GetRecordedFreeSpace = Module["_GetRecordedFreeSpace"] = wasmExports["GetRecordedFreeSpace"])(a0, a1);
    var _heap_tuple_needs_eventual_freeze = Module["_heap_tuple_needs_eventual_freeze"] = (a0) => (_heap_tuple_needs_eventual_freeze = Module["_heap_tuple_needs_eventual_freeze"] = wasmExports["heap_tuple_needs_eventual_freeze"])(a0);
    var _hash_seq_init = Module["_hash_seq_init"] = (a0, a1) => (_hash_seq_init = Module["_hash_seq_init"] = wasmExports["hash_seq_init"])(a0, a1);
    var _hash_seq_search = Module["_hash_seq_search"] = (a0) => (_hash_seq_search = Module["_hash_seq_search"] = wasmExports["hash_seq_search"])(a0);
    var _ftruncate = Module["_ftruncate"] = (a0, a1) => (_ftruncate = Module["_ftruncate"] = wasmExports["ftruncate"])(a0, a1);
    var _pwrite = Module["_pwrite"] = (a0, a1, a2, a3) => (_pwrite = Module["_pwrite"] = wasmExports["pwrite"])(a0, a1, a2, a3);
    var _fd_fsync_fname = Module["_fd_fsync_fname"] = (a0, a1) => (_fd_fsync_fname = Module["_fd_fsync_fname"] = wasmExports["fd_fsync_fname"])(a0, a1);
    var _GetMultiXactIdMembers = Module["_GetMultiXactIdMembers"] = (a0, a1, a2, a3) => (_GetMultiXactIdMembers = Module["_GetMultiXactIdMembers"] = wasmExports["GetMultiXactIdMembers"])(a0, a1, a2, a3);
    var _GetAccessStrategy = Module["_GetAccessStrategy"] = (a0) => (_GetAccessStrategy = Module["_GetAccessStrategy"] = wasmExports["GetAccessStrategy"])(a0);
    var _FreeAccessStrategy = Module["_FreeAccessStrategy"] = (a0) => (_FreeAccessStrategy = Module["_FreeAccessStrategy"] = wasmExports["FreeAccessStrategy"])(a0);
    var _HeapTupleSatisfiesUpdate = Module["_HeapTupleSatisfiesUpdate"] = (a0, a1, a2) => (_HeapTupleSatisfiesUpdate = Module["_HeapTupleSatisfiesUpdate"] = wasmExports["HeapTupleSatisfiesUpdate"])(a0, a1, a2);
    var _TransactionIdDidCommit = Module["_TransactionIdDidCommit"] = (a0) => (_TransactionIdDidCommit = Module["_TransactionIdDidCommit"] = wasmExports["TransactionIdDidCommit"])(a0);
    var _TransactionIdIsInProgress = Module["_TransactionIdIsInProgress"] = (a0) => (_TransactionIdIsInProgress = Module["_TransactionIdIsInProgress"] = wasmExports["TransactionIdIsInProgress"])(a0);
    var _datumIsEqual = Module["_datumIsEqual"] = (a0, a1, a2, a3) => (_datumIsEqual = Module["_datumIsEqual"] = wasmExports["datumIsEqual"])(a0, a1, a2, a3);
    var _MultiXactIdPrecedes = Module["_MultiXactIdPrecedes"] = (a0, a1) => (_MultiXactIdPrecedes = Module["_MultiXactIdPrecedes"] = wasmExports["MultiXactIdPrecedes"])(a0, a1);
    var _XLogRecGetBlockTagExtended = Module["_XLogRecGetBlockTagExtended"] = (a0, a1, a2, a3, a4, a5) => (_XLogRecGetBlockTagExtended = Module["_XLogRecGetBlockTagExtended"] = wasmExports["XLogRecGetBlockTagExtended"])(a0, a1, a2, a3, a4, a5);
    var _ConditionalLockBuffer = Module["_ConditionalLockBuffer"] = (a0) => (_ConditionalLockBuffer = Module["_ConditionalLockBuffer"] = wasmExports["ConditionalLockBuffer"])(a0);
    var _toast_open_indexes = Module["_toast_open_indexes"] = (a0, a1, a2, a3) => (_toast_open_indexes = Module["_toast_open_indexes"] = wasmExports["toast_open_indexes"])(a0, a1, a2, a3);
    var _init_toast_snapshot = Module["_init_toast_snapshot"] = (a0) => (_init_toast_snapshot = Module["_init_toast_snapshot"] = wasmExports["init_toast_snapshot"])(a0);
    var _systable_beginscan_ordered = Module["_systable_beginscan_ordered"] = (a0, a1, a2, a3, a4) => (_systable_beginscan_ordered = Module["_systable_beginscan_ordered"] = wasmExports["systable_beginscan_ordered"])(a0, a1, a2, a3, a4);
    var _systable_getnext_ordered = Module["_systable_getnext_ordered"] = (a0, a1) => (_systable_getnext_ordered = Module["_systable_getnext_ordered"] = wasmExports["systable_getnext_ordered"])(a0, a1);
    var _systable_endscan_ordered = Module["_systable_endscan_ordered"] = (a0) => (_systable_endscan_ordered = Module["_systable_endscan_ordered"] = wasmExports["systable_endscan_ordered"])(a0);
    var _toast_close_indexes = Module["_toast_close_indexes"] = (a0, a1, a2) => (_toast_close_indexes = Module["_toast_close_indexes"] = wasmExports["toast_close_indexes"])(a0, a1, a2);
    var _GenerationContextCreate = Module["_GenerationContextCreate"] = (a0, a1, a2, a3, a4) => (_GenerationContextCreate = Module["_GenerationContextCreate"] = wasmExports["GenerationContextCreate"])(a0, a1, a2, a3, a4);
    var _LockRelationForExtension = Module["_LockRelationForExtension"] = (a0, a1) => (_LockRelationForExtension = Module["_LockRelationForExtension"] = wasmExports["LockRelationForExtension"])(a0, a1);
    var _UnlockRelationForExtension = Module["_UnlockRelationForExtension"] = (a0, a1) => (_UnlockRelationForExtension = Module["_UnlockRelationForExtension"] = wasmExports["UnlockRelationForExtension"])(a0, a1);
    var _RecordFreeIndexPage = Module["_RecordFreeIndexPage"] = (a0, a1) => (_RecordFreeIndexPage = Module["_RecordFreeIndexPage"] = wasmExports["RecordFreeIndexPage"])(a0, a1);
    var _IndexFreeSpaceMapVacuum = Module["_IndexFreeSpaceMapVacuum"] = (a0) => (_IndexFreeSpaceMapVacuum = Module["_IndexFreeSpaceMapVacuum"] = wasmExports["IndexFreeSpaceMapVacuum"])(a0);
    var _gistcheckpage = Module["_gistcheckpage"] = (a0, a1) => (_gistcheckpage = Module["_gistcheckpage"] = wasmExports["gistcheckpage"])(a0, a1);
    var _nocache_index_getattr = Module["_nocache_index_getattr"] = (a0, a1, a2) => (_nocache_index_getattr = Module["_nocache_index_getattr"] = wasmExports["nocache_index_getattr"])(a0, a1, a2);
    var _GetFreeIndexPage = Module["_GetFreeIndexPage"] = (a0) => (_GetFreeIndexPage = Module["_GetFreeIndexPage"] = wasmExports["GetFreeIndexPage"])(a0);
    var _check_amproc_signature = Module["_check_amproc_signature"] = (a0, a1, a2, a3, a4, a5) => (_check_amproc_signature = Module["_check_amproc_signature"] = wasmExports["check_amproc_signature"])(a0, a1, a2, a3, a4, a5);
    var _DirectFunctionCall2Coll = Module["_DirectFunctionCall2Coll"] = (a0, a1, a2, a3) => (_DirectFunctionCall2Coll = Module["_DirectFunctionCall2Coll"] = wasmExports["DirectFunctionCall2Coll"])(a0, a1, a2, a3);
    var _float_overflow_error = Module["_float_overflow_error"] = () => (_float_overflow_error = Module["_float_overflow_error"] = wasmExports["float_overflow_error"])();
    var _float_underflow_error = Module["_float_underflow_error"] = () => (_float_underflow_error = Module["_float_underflow_error"] = wasmExports["float_underflow_error"])();
    var _DirectFunctionCall5Coll = Module["_DirectFunctionCall5Coll"] = (a0, a1, a2, a3, a4, a5, a6) => (_DirectFunctionCall5Coll = Module["_DirectFunctionCall5Coll"] = wasmExports["DirectFunctionCall5Coll"])(a0, a1, a2, a3, a4, a5, a6);
    var _Float8GetDatum = Module["_Float8GetDatum"] = (a0) => (_Float8GetDatum = Module["_Float8GetDatum"] = wasmExports["Float8GetDatum"])(a0);
    var _fmgr_info_copy = Module["_fmgr_info_copy"] = (a0, a1, a2) => (_fmgr_info_copy = Module["_fmgr_info_copy"] = wasmExports["fmgr_info_copy"])(a0, a1, a2);
    var _PageIndexTupleOverwrite = Module["_PageIndexTupleOverwrite"] = (a0, a1, a2, a3) => (_PageIndexTupleOverwrite = Module["_PageIndexTupleOverwrite"] = wasmExports["PageIndexTupleOverwrite"])(a0, a1, a2, a3);
    var _log_newpage_range = Module["_log_newpage_range"] = (a0, a1, a2, a3, a4) => (_log_newpage_range = Module["_log_newpage_range"] = wasmExports["log_newpage_range"])(a0, a1, a2, a3, a4);
    var _pow = Module["_pow"] = (a0, a1) => (_pow = Module["_pow"] = wasmExports["pow"])(a0, a1);
    var _CreateTupleDescCopyConstr = Module["_CreateTupleDescCopyConstr"] = (a0) => (_CreateTupleDescCopyConstr = Module["_CreateTupleDescCopyConstr"] = wasmExports["CreateTupleDescCopyConstr"])(a0);
    var _PageGetExactFreeSpace = Module["_PageGetExactFreeSpace"] = (a0) => (_PageGetExactFreeSpace = Module["_PageGetExactFreeSpace"] = wasmExports["PageGetExactFreeSpace"])(a0);
    var _brin_build_desc = Module["_brin_build_desc"] = (a0) => (_brin_build_desc = Module["_brin_build_desc"] = wasmExports["brin_build_desc"])(a0);
    var _brin_deform_tuple = Module["_brin_deform_tuple"] = (a0, a1, a2) => (_brin_deform_tuple = Module["_brin_deform_tuple"] = wasmExports["brin_deform_tuple"])(a0, a1, a2);
    var _IndexGetRelation = Module["_IndexGetRelation"] = (a0, a1) => (_IndexGetRelation = Module["_IndexGetRelation"] = wasmExports["IndexGetRelation"])(a0, a1);
    var _FunctionCall4Coll = Module["_FunctionCall4Coll"] = (a0, a1, a2, a3, a4, a5) => (_FunctionCall4Coll = Module["_FunctionCall4Coll"] = wasmExports["FunctionCall4Coll"])(a0, a1, a2, a3, a4, a5);
    var _brin_free_desc = Module["_brin_free_desc"] = (a0) => (_brin_free_desc = Module["_brin_free_desc"] = wasmExports["brin_free_desc"])(a0);
    var _GetUserIdAndSecContext = Module["_GetUserIdAndSecContext"] = (a0, a1) => (_GetUserIdAndSecContext = Module["_GetUserIdAndSecContext"] = wasmExports["GetUserIdAndSecContext"])(a0, a1);
    var _SetUserIdAndSecContext = Module["_SetUserIdAndSecContext"] = (a0, a1) => (_SetUserIdAndSecContext = Module["_SetUserIdAndSecContext"] = wasmExports["SetUserIdAndSecContext"])(a0, a1);
    var _NewGUCNestLevel = Module["_NewGUCNestLevel"] = () => (_NewGUCNestLevel = Module["_NewGUCNestLevel"] = wasmExports["NewGUCNestLevel"])();
    var _AtEOXact_GUC = Module["_AtEOXact_GUC"] = (a0, a1) => (_AtEOXact_GUC = Module["_AtEOXact_GUC"] = wasmExports["AtEOXact_GUC"])(a0, a1);
    var _get_fn_opclass_options = Module["_get_fn_opclass_options"] = (a0) => (_get_fn_opclass_options = Module["_get_fn_opclass_options"] = wasmExports["get_fn_opclass_options"])(a0);
    var _init_local_reloptions = Module["_init_local_reloptions"] = (a0, a1) => (_init_local_reloptions = Module["_init_local_reloptions"] = wasmExports["init_local_reloptions"])(a0, a1);
    var _numeric_sub = Module["_numeric_sub"] = (a0) => (_numeric_sub = Module["_numeric_sub"] = wasmExports["numeric_sub"])(a0);
    var _qsort_arg = Module["_qsort_arg"] = (a0, a1, a2, a3, a4) => (_qsort_arg = Module["_qsort_arg"] = wasmExports["qsort_arg"])(a0, a1, a2, a3, a4);
    var _add_local_int_reloption = Module["_add_local_int_reloption"] = (a0, a1, a2, a3, a4, a5, a6) => (_add_local_int_reloption = Module["_add_local_int_reloption"] = wasmExports["add_local_int_reloption"])(a0, a1, a2, a3, a4, a5, a6);
    var _OutputFunctionCall = Module["_OutputFunctionCall"] = (a0, a1) => (_OutputFunctionCall = Module["_OutputFunctionCall"] = wasmExports["OutputFunctionCall"])(a0, a1);
    var _accumArrayResult = Module["_accumArrayResult"] = (a0, a1, a2, a3, a4) => (_accumArrayResult = Module["_accumArrayResult"] = wasmExports["accumArrayResult"])(a0, a1, a2, a3, a4);
    var _makeArrayResult = Module["_makeArrayResult"] = (a0, a1) => (_makeArrayResult = Module["_makeArrayResult"] = wasmExports["makeArrayResult"])(a0, a1);
    var _hash_get_num_entries = Module["_hash_get_num_entries"] = (a0) => (_hash_get_num_entries = Module["_hash_get_num_entries"] = wasmExports["hash_get_num_entries"])(a0);
    var _RestoreBlockImage = Module["_RestoreBlockImage"] = (a0, a1, a2) => (_RestoreBlockImage = Module["_RestoreBlockImage"] = wasmExports["RestoreBlockImage"])(a0, a1, a2);
    var _wal_segment_open = Module["_wal_segment_open"] = (a0, a1, a2) => (_wal_segment_open = Module["_wal_segment_open"] = wasmExports["wal_segment_open"])(a0, a1, a2);
    var _wal_segment_close = Module["_wal_segment_close"] = (a0) => (_wal_segment_close = Module["_wal_segment_close"] = wasmExports["wal_segment_close"])(a0);
    var _close = Module["_close"] = (a0) => (_close = Module["_close"] = wasmExports["close"])(a0);
    var _GetFlushRecPtr = Module["_GetFlushRecPtr"] = (a0) => (_GetFlushRecPtr = Module["_GetFlushRecPtr"] = wasmExports["GetFlushRecPtr"])(a0);
    var _GetXLogReplayRecPtr = Module["_GetXLogReplayRecPtr"] = (a0) => (_GetXLogReplayRecPtr = Module["_GetXLogReplayRecPtr"] = wasmExports["GetXLogReplayRecPtr"])(a0);
    var _pg_usleep = Module["_pg_usleep"] = (a0) => (_pg_usleep = Module["_pg_usleep"] = wasmExports["pg_usleep"])(a0);
    var _read_local_xlog_page_no_wait = Module["_read_local_xlog_page_no_wait"] = (a0, a1, a2, a3, a4) => (_read_local_xlog_page_no_wait = Module["_read_local_xlog_page_no_wait"] = wasmExports["read_local_xlog_page_no_wait"])(a0, a1, a2, a3, a4);
    var _dsm_create = Module["_dsm_create"] = (a0, a1) => (_dsm_create = Module["_dsm_create"] = wasmExports["dsm_create"])(a0, a1);
    var _dsm_segment_address = Module["_dsm_segment_address"] = (a0) => (_dsm_segment_address = Module["_dsm_segment_address"] = wasmExports["dsm_segment_address"])(a0);
    var _WaitForBackgroundWorkerShutdown = Module["_WaitForBackgroundWorkerShutdown"] = (a0) => (_WaitForBackgroundWorkerShutdown = Module["_WaitForBackgroundWorkerShutdown"] = wasmExports["WaitForBackgroundWorkerShutdown"])(a0);
    var _dsm_segment_handle = Module["_dsm_segment_handle"] = (a0) => (_dsm_segment_handle = Module["_dsm_segment_handle"] = wasmExports["dsm_segment_handle"])(a0);
    var _RegisterDynamicBackgroundWorker = Module["_RegisterDynamicBackgroundWorker"] = (a0, a1) => (_RegisterDynamicBackgroundWorker = Module["_RegisterDynamicBackgroundWorker"] = wasmExports["RegisterDynamicBackgroundWorker"])(a0, a1);
    var _WaitForParallelWorkersToAttach = Module["_WaitForParallelWorkersToAttach"] = (a0) => (_WaitForParallelWorkersToAttach = Module["_WaitForParallelWorkersToAttach"] = wasmExports["WaitForParallelWorkersToAttach"])(a0);
    var _dsm_detach = Module["_dsm_detach"] = (a0) => (_dsm_detach = Module["_dsm_detach"] = wasmExports["dsm_detach"])(a0);
    var _BackgroundWorkerUnblockSignals = Module["_BackgroundWorkerUnblockSignals"] = () => (_BackgroundWorkerUnblockSignals = Module["_BackgroundWorkerUnblockSignals"] = wasmExports["BackgroundWorkerUnblockSignals"])();
    var _dsm_attach = Module["_dsm_attach"] = (a0) => (_dsm_attach = Module["_dsm_attach"] = wasmExports["dsm_attach"])(a0);
    var _BackgroundWorkerInitializeConnectionByOid = Module["_BackgroundWorkerInitializeConnectionByOid"] = (a0, a1, a2) => (_BackgroundWorkerInitializeConnectionByOid = Module["_BackgroundWorkerInitializeConnectionByOid"] = wasmExports["BackgroundWorkerInitializeConnectionByOid"])(a0, a1, a2);
    var _GenericXLogStart = Module["_GenericXLogStart"] = (a0) => (_GenericXLogStart = Module["_GenericXLogStart"] = wasmExports["GenericXLogStart"])(a0);
    var _GenericXLogRegisterBuffer = Module["_GenericXLogRegisterBuffer"] = (a0, a1, a2) => (_GenericXLogRegisterBuffer = Module["_GenericXLogRegisterBuffer"] = wasmExports["GenericXLogRegisterBuffer"])(a0, a1, a2);
    var _GenericXLogFinish = Module["_GenericXLogFinish"] = (a0) => (_GenericXLogFinish = Module["_GenericXLogFinish"] = wasmExports["GenericXLogFinish"])(a0);
    var _GenericXLogAbort = Module["_GenericXLogAbort"] = (a0) => (_GenericXLogAbort = Module["_GenericXLogAbort"] = wasmExports["GenericXLogAbort"])(a0);
    var _ShmemInitStruct = Module["_ShmemInitStruct"] = (a0, a1, a2) => (_ShmemInitStruct = Module["_ShmemInitStruct"] = wasmExports["ShmemInitStruct"])(a0, a1, a2);
    var _init_MultiFuncCall = Module["_init_MultiFuncCall"] = (a0) => (_init_MultiFuncCall = Module["_init_MultiFuncCall"] = wasmExports["init_MultiFuncCall"])(a0);
    var _per_MultiFuncCall = Module["_per_MultiFuncCall"] = (a0) => (_per_MultiFuncCall = Module["_per_MultiFuncCall"] = wasmExports["per_MultiFuncCall"])(a0);
    var _end_MultiFuncCall = Module["_end_MultiFuncCall"] = (a0, a1) => (_end_MultiFuncCall = Module["_end_MultiFuncCall"] = wasmExports["end_MultiFuncCall"])(a0, a1);
    var _read = Module["_read"] = (a0, a1, a2) => (_read = Module["_read"] = wasmExports["read"])(a0, a1, a2);
    var _superuser_arg = Module["_superuser_arg"] = (a0) => (_superuser_arg = Module["_superuser_arg"] = wasmExports["superuser_arg"])(a0);
    var _XLogReaderAllocate = Module["_XLogReaderAllocate"] = (a0, a1, a2, a3) => (_XLogReaderAllocate = Module["_XLogReaderAllocate"] = wasmExports["XLogReaderAllocate"])(a0, a1, a2, a3);
    var _XLogReadRecord = Module["_XLogReadRecord"] = (a0, a1) => (_XLogReadRecord = Module["_XLogReadRecord"] = wasmExports["XLogReadRecord"])(a0, a1);
    var _XLogReaderFree = Module["_XLogReaderFree"] = (a0) => (_XLogReaderFree = Module["_XLogReaderFree"] = wasmExports["XLogReaderFree"])(a0);
    var _write = Module["_write"] = (a0, a1, a2) => (_write = Module["_write"] = wasmExports["write"])(a0, a1, a2);
    var _ReadMultiXactIdRange = Module["_ReadMultiXactIdRange"] = (a0, a1) => (_ReadMultiXactIdRange = Module["_ReadMultiXactIdRange"] = wasmExports["ReadMultiXactIdRange"])(a0, a1);
    var _MultiXactIdPrecedesOrEquals = Module["_MultiXactIdPrecedesOrEquals"] = (a0, a1) => (_MultiXactIdPrecedesOrEquals = Module["_MultiXactIdPrecedesOrEquals"] = wasmExports["MultiXactIdPrecedesOrEquals"])(a0, a1);
    var _numeric_in = Module["_numeric_in"] = (a0) => (_numeric_in = Module["_numeric_in"] = wasmExports["numeric_in"])(a0);
    var _DirectFunctionCall3Coll = Module["_DirectFunctionCall3Coll"] = (a0, a1, a2, a3, a4) => (_DirectFunctionCall3Coll = Module["_DirectFunctionCall3Coll"] = wasmExports["DirectFunctionCall3Coll"])(a0, a1, a2, a3, a4);
    var _AllocateFile = Module["_AllocateFile"] = (a0, a1) => (_AllocateFile = Module["_AllocateFile"] = wasmExports["AllocateFile"])(a0, a1);
    var _FreeFile = Module["_FreeFile"] = (a0) => (_FreeFile = Module["_FreeFile"] = wasmExports["FreeFile"])(a0);
    var _InitMaterializedSRF = Module["_InitMaterializedSRF"] = (a0, a1) => (_InitMaterializedSRF = Module["_InitMaterializedSRF"] = wasmExports["InitMaterializedSRF"])(a0, a1);
    var _XLogRecStoreStats = Module["_XLogRecStoreStats"] = (a0, a1) => (_XLogRecStoreStats = Module["_XLogRecStoreStats"] = wasmExports["XLogRecStoreStats"])(a0, a1);
    var _XLogFindNextRecord = Module["_XLogFindNextRecord"] = (a0, a1) => (_XLogFindNextRecord = Module["_XLogFindNextRecord"] = wasmExports["XLogFindNextRecord"])(a0, a1);
    var _fgets = Module["_fgets"] = (a0, a1, a2) => (_fgets = Module["_fgets"] = wasmExports["fgets"])(a0, a1, a2);
    var _getpid = Module["_getpid"] = () => (_getpid = Module["_getpid"] = wasmExports["getpid"])();
    var _lseek = Module["_lseek"] = (a0, a1, a2) => (_lseek = Module["_lseek"] = wasmExports["lseek"])(a0, a1, a2);
    var _strtol = Module["_strtol"] = (a0, a1, a2) => (_strtol = Module["_strtol"] = wasmExports["strtol"])(a0, a1, a2);
    var _wait_result_to_str = Module["_wait_result_to_str"] = (a0) => (_wait_result_to_str = Module["_wait_result_to_str"] = wasmExports["wait_result_to_str"])(a0);
    var _replace_percent_placeholders = Module["_replace_percent_placeholders"] = (a0, a1, a2, a3) => (_replace_percent_placeholders = Module["_replace_percent_placeholders"] = wasmExports["replace_percent_placeholders"])(a0, a1, a2, a3);
    var _RmgrNotFound = Module["_RmgrNotFound"] = (a0) => (_RmgrNotFound = Module["_RmgrNotFound"] = wasmExports["RmgrNotFound"])(a0);
    var _GetCurrentTransactionNestLevel = Module["_GetCurrentTransactionNestLevel"] = () => (_GetCurrentTransactionNestLevel = Module["_GetCurrentTransactionNestLevel"] = wasmExports["GetCurrentTransactionNestLevel"])();
    var _ResourceOwnerDelete = Module["_ResourceOwnerDelete"] = (a0) => (_ResourceOwnerDelete = Module["_ResourceOwnerDelete"] = wasmExports["ResourceOwnerDelete"])(a0);
    var _AtEOSubXact_Files = Module["_AtEOSubXact_Files"] = (a0, a1, a2) => (_AtEOSubXact_Files = Module["_AtEOSubXact_Files"] = wasmExports["AtEOSubXact_Files"])(a0, a1, a2);
    var _RegisterXactCallback = Module["_RegisterXactCallback"] = (a0, a1) => (_RegisterXactCallback = Module["_RegisterXactCallback"] = wasmExports["RegisterXactCallback"])(a0, a1);
    var _RegisterSubXactCallback = Module["_RegisterSubXactCallback"] = (a0, a1) => (_RegisterSubXactCallback = Module["_RegisterSubXactCallback"] = wasmExports["RegisterSubXactCallback"])(a0, a1);
    var _BeginInternalSubTransaction = Module["_BeginInternalSubTransaction"] = (a0) => (_BeginInternalSubTransaction = Module["_BeginInternalSubTransaction"] = wasmExports["BeginInternalSubTransaction"])(a0);
    var _ReleaseCurrentSubTransaction = Module["_ReleaseCurrentSubTransaction"] = () => (_ReleaseCurrentSubTransaction = Module["_ReleaseCurrentSubTransaction"] = wasmExports["ReleaseCurrentSubTransaction"])();
    var _RollbackAndReleaseCurrentSubTransaction = Module["_RollbackAndReleaseCurrentSubTransaction"] = () => (_RollbackAndReleaseCurrentSubTransaction = Module["_RollbackAndReleaseCurrentSubTransaction"] = wasmExports["RollbackAndReleaseCurrentSubTransaction"])();
    var _timestamptz_in = Module["_timestamptz_in"] = (a0) => (_timestamptz_in = Module["_timestamptz_in"] = wasmExports["timestamptz_in"])(a0);
    var _timestamptz_to_str = Module["_timestamptz_to_str"] = (a0) => (_timestamptz_to_str = Module["_timestamptz_to_str"] = wasmExports["timestamptz_to_str"])(a0);
    var _fscanf = Module["_fscanf"] = (a0, a1, a2) => (_fscanf = Module["_fscanf"] = wasmExports["fscanf"])(a0, a1, a2);
    var _ParseDateTime = Module["_ParseDateTime"] = (a0, a1, a2, a3, a4, a5, a6) => (_ParseDateTime = Module["_ParseDateTime"] = wasmExports["ParseDateTime"])(a0, a1, a2, a3, a4, a5, a6);
    var _DecodeDateTime = Module["_DecodeDateTime"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_DecodeDateTime = Module["_DecodeDateTime"] = wasmExports["DecodeDateTime"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _ReleaseExternalFD = Module["_ReleaseExternalFD"] = () => (_ReleaseExternalFD = Module["_ReleaseExternalFD"] = wasmExports["ReleaseExternalFD"])();
    var _pg_strong_random = Module["_pg_strong_random"] = (a0, a1) => (_pg_strong_random = Module["_pg_strong_random"] = wasmExports["pg_strong_random"])(a0, a1);
    var _XLogRecGetBlockRefInfo = Module["_XLogRecGetBlockRefInfo"] = (a0, a1, a2, a3, a4) => (_XLogRecGetBlockRefInfo = Module["_XLogRecGetBlockRefInfo"] = wasmExports["XLogRecGetBlockRefInfo"])(a0, a1, a2, a3, a4);
    var _strncpy = Module["_strncpy"] = (a0, a1, a2) => (_strncpy = Module["_strncpy"] = wasmExports["strncpy"])(a0, a1, a2);
    var _heap_modify_tuple_by_cols = Module["_heap_modify_tuple_by_cols"] = (a0, a1, a2, a3, a4, a5) => (_heap_modify_tuple_by_cols = Module["_heap_modify_tuple_by_cols"] = wasmExports["heap_modify_tuple_by_cols"])(a0, a1, a2, a3, a4, a5);
    var _free_attrmap = Module["_free_attrmap"] = (a0) => (_free_attrmap = Module["_free_attrmap"] = wasmExports["free_attrmap"])(a0);
    var _add_reloption_kind = Module["_add_reloption_kind"] = () => (_add_reloption_kind = Module["_add_reloption_kind"] = wasmExports["add_reloption_kind"])();
    var _register_reloptions_validator = Module["_register_reloptions_validator"] = (a0, a1) => (_register_reloptions_validator = Module["_register_reloptions_validator"] = wasmExports["register_reloptions_validator"])(a0, a1);
    var _add_int_reloption = Module["_add_int_reloption"] = (a0, a1, a2, a3, a4, a5, a6) => (_add_int_reloption = Module["_add_int_reloption"] = wasmExports["add_int_reloption"])(a0, a1, a2, a3, a4, a5, a6);
    var _untransformRelOptions = Module["_untransformRelOptions"] = (a0) => (_untransformRelOptions = Module["_untransformRelOptions"] = wasmExports["untransformRelOptions"])(a0);
    var _makeDefElem = Module["_makeDefElem"] = (a0, a1, a2) => (_makeDefElem = Module["_makeDefElem"] = wasmExports["makeDefElem"])(a0, a1, a2);
    var _parse_int = Module["_parse_int"] = (a0, a1, a2, a3) => (_parse_int = Module["_parse_int"] = wasmExports["parse_int"])(a0, a1, a2, a3);
    var _parse_real = Module["_parse_real"] = (a0, a1, a2, a3) => (_parse_real = Module["_parse_real"] = wasmExports["parse_real"])(a0, a1, a2, a3);
    var _typenameTypeIdAndMod = Module["_typenameTypeIdAndMod"] = (a0, a1, a2, a3) => (_typenameTypeIdAndMod = Module["_typenameTypeIdAndMod"] = wasmExports["typenameTypeIdAndMod"])(a0, a1, a2, a3);
    var _pg_ltoa = Module["_pg_ltoa"] = (a0, a1) => (_pg_ltoa = Module["_pg_ltoa"] = wasmExports["pg_ltoa"])(a0, a1);
    var _RelationIdGetRelation = Module["_RelationIdGetRelation"] = (a0) => (_RelationIdGetRelation = Module["_RelationIdGetRelation"] = wasmExports["RelationIdGetRelation"])(a0);
    var _relation_openrv = Module["_relation_openrv"] = (a0, a1) => (_relation_openrv = Module["_relation_openrv"] = wasmExports["relation_openrv"])(a0, a1);
    var _RelationClose = Module["_RelationClose"] = (a0) => (_RelationClose = Module["_RelationClose"] = wasmExports["RelationClose"])(a0);
    var _varstr_cmp = Module["_varstr_cmp"] = (a0, a1, a2, a3, a4) => (_varstr_cmp = Module["_varstr_cmp"] = wasmExports["varstr_cmp"])(a0, a1, a2, a3, a4);
    var _pg_prng_uint64_range = Module["_pg_prng_uint64_range"] = (a0, a1, a2) => (_pg_prng_uint64_range = Module["_pg_prng_uint64_range"] = wasmExports["pg_prng_uint64_range"])(a0, a1, a2);
    var _ginPostingListDecode = Module["_ginPostingListDecode"] = (a0, a1) => (_ginPostingListDecode = Module["_ginPostingListDecode"] = wasmExports["ginPostingListDecode"])(a0, a1);
    var _LockPage = Module["_LockPage"] = (a0, a1, a2) => (_LockPage = Module["_LockPage"] = wasmExports["LockPage"])(a0, a1, a2);
    var _UnlockPage = Module["_UnlockPage"] = (a0, a1, a2) => (_UnlockPage = Module["_UnlockPage"] = wasmExports["UnlockPage"])(a0, a1, a2);
    var __bt_search = Module["__bt_search"] = (a0, a1, a2, a3, a4, a5) => (__bt_search = Module["__bt_search"] = wasmExports["_bt_search"])(a0, a1, a2, a3, a4, a5);
    var __bt_compare = Module["__bt_compare"] = (a0, a1, a2, a3) => (__bt_compare = Module["__bt_compare"] = wasmExports["_bt_compare"])(a0, a1, a2, a3);
    var __bt_relbuf = Module["__bt_relbuf"] = (a0, a1) => (__bt_relbuf = Module["__bt_relbuf"] = wasmExports["_bt_relbuf"])(a0, a1);
    var __bt_binsrch_insert = Module["__bt_binsrch_insert"] = (a0, a1) => (__bt_binsrch_insert = Module["__bt_binsrch_insert"] = wasmExports["_bt_binsrch_insert"])(a0, a1);
    var __bt_metaversion = Module["__bt_metaversion"] = (a0, a1, a2) => (__bt_metaversion = Module["__bt_metaversion"] = wasmExports["_bt_metaversion"])(a0, a1, a2);
    var __bt_freestack = Module["__bt_freestack"] = (a0) => (__bt_freestack = Module["__bt_freestack"] = wasmExports["_bt_freestack"])(a0);
    var _btboolcmp = Module["_btboolcmp"] = (a0) => (_btboolcmp = Module["_btboolcmp"] = wasmExports["btboolcmp"])(a0);
    var _btint2cmp = Module["_btint2cmp"] = (a0) => (_btint2cmp = Module["_btint2cmp"] = wasmExports["btint2cmp"])(a0);
    var _btint4cmp = Module["_btint4cmp"] = (a0) => (_btint4cmp = Module["_btint4cmp"] = wasmExports["btint4cmp"])(a0);
    var _btint8cmp = Module["_btint8cmp"] = (a0) => (_btint8cmp = Module["_btint8cmp"] = wasmExports["btint8cmp"])(a0);
    var _btoidcmp = Module["_btoidcmp"] = (a0) => (_btoidcmp = Module["_btoidcmp"] = wasmExports["btoidcmp"])(a0);
    var _btcharcmp = Module["_btcharcmp"] = (a0) => (_btcharcmp = Module["_btcharcmp"] = wasmExports["btcharcmp"])(a0);
    var __bt_checkpage = Module["__bt_checkpage"] = (a0, a1) => (__bt_checkpage = Module["__bt_checkpage"] = wasmExports["_bt_checkpage"])(a0, a1);
    var __bt_mkscankey = Module["__bt_mkscankey"] = (a0, a1) => (__bt_mkscankey = Module["__bt_mkscankey"] = wasmExports["_bt_mkscankey"])(a0, a1);
    var __bt_form_posting = Module["__bt_form_posting"] = (a0, a1, a2) => (__bt_form_posting = Module["__bt_form_posting"] = wasmExports["_bt_form_posting"])(a0, a1, a2);
    var __bt_allequalimage = Module["__bt_allequalimage"] = (a0, a1) => (__bt_allequalimage = Module["__bt_allequalimage"] = wasmExports["_bt_allequalimage"])(a0, a1);
    var _ConditionVariableSignal = Module["_ConditionVariableSignal"] = (a0) => (_ConditionVariableSignal = Module["_ConditionVariableSignal"] = wasmExports["ConditionVariableSignal"])(a0);
    var _tuplesort_estimate_shared = Module["_tuplesort_estimate_shared"] = (a0) => (_tuplesort_estimate_shared = Module["_tuplesort_estimate_shared"] = wasmExports["tuplesort_estimate_shared"])(a0);
    var _tuplesort_initialize_shared = Module["_tuplesort_initialize_shared"] = (a0, a1, a2) => (_tuplesort_initialize_shared = Module["_tuplesort_initialize_shared"] = wasmExports["tuplesort_initialize_shared"])(a0, a1, a2);
    var _tuplesort_attach_shared = Module["_tuplesort_attach_shared"] = (a0, a1) => (_tuplesort_attach_shared = Module["_tuplesort_attach_shared"] = wasmExports["tuplesort_attach_shared"])(a0, a1);
    var __bt_check_natts = Module["__bt_check_natts"] = (a0, a1, a2, a3) => (__bt_check_natts = Module["__bt_check_natts"] = wasmExports["_bt_check_natts"])(a0, a1, a2, a3);
    var _smgrread = Module["_smgrread"] = (a0, a1, a2, a3) => (_smgrread = Module["_smgrread"] = wasmExports["smgrread"])(a0, a1, a2, a3);
    var _smgrtruncate = Module["_smgrtruncate"] = (a0, a1, a2, a3) => (_smgrtruncate = Module["_smgrtruncate"] = wasmExports["smgrtruncate"])(a0, a1, a2, a3);
    var _ShmemInitHash = Module["_ShmemInitHash"] = (a0, a1, a2, a3, a4) => (_ShmemInitHash = Module["_ShmemInitHash"] = wasmExports["ShmemInitHash"])(a0, a1, a2, a3, a4);
    var _hash_estimate_size = Module["_hash_estimate_size"] = (a0, a1) => (_hash_estimate_size = Module["_hash_estimate_size"] = wasmExports["hash_estimate_size"])(a0, a1);
    var _on_shmem_exit = Module["_on_shmem_exit"] = (a0, a1) => (_on_shmem_exit = Module["_on_shmem_exit"] = wasmExports["on_shmem_exit"])(a0, a1);
    var _LWLockRegisterTranche = Module["_LWLockRegisterTranche"] = (a0, a1) => (_LWLockRegisterTranche = Module["_LWLockRegisterTranche"] = wasmExports["LWLockRegisterTranche"])(a0, a1);
    var _GetNamedLWLockTranche = Module["_GetNamedLWLockTranche"] = (a0) => (_GetNamedLWLockTranche = Module["_GetNamedLWLockTranche"] = wasmExports["GetNamedLWLockTranche"])(a0);
    var _LWLockNewTrancheId = Module["_LWLockNewTrancheId"] = () => (_LWLockNewTrancheId = Module["_LWLockNewTrancheId"] = wasmExports["LWLockNewTrancheId"])();
    var _RequestNamedLWLockTranche = Module["_RequestNamedLWLockTranche"] = (a0, a1) => (_RequestNamedLWLockTranche = Module["_RequestNamedLWLockTranche"] = wasmExports["RequestNamedLWLockTranche"])(a0, a1);
    var _RequestAddinShmemSpace = Module["_RequestAddinShmemSpace"] = (a0) => (_RequestAddinShmemSpace = Module["_RequestAddinShmemSpace"] = wasmExports["RequestAddinShmemSpace"])(a0);
    var _BackendXidGetPid = Module["_BackendXidGetPid"] = (a0) => (_BackendXidGetPid = Module["_BackendXidGetPid"] = wasmExports["BackendXidGetPid"])(a0);
    var _fcntl = Module["_fcntl"] = (a0, a1, a2) => (_fcntl = Module["_fcntl"] = wasmExports["fcntl"])(a0, a1, a2);
    var _poll = Module["_poll"] = (a0, a1, a2) => (_poll = Module["_poll"] = wasmExports["poll"])(a0, a1, a2);
    var _WaitLatchOrSocket = Module["_WaitLatchOrSocket"] = (a0, a1, a2, a3, a4) => (_WaitLatchOrSocket = Module["_WaitLatchOrSocket"] = wasmExports["WaitLatchOrSocket"])(a0, a1, a2, a3, a4);
    var _procsignal_sigusr1_handler = Module["_procsignal_sigusr1_handler"] = (a0) => (_procsignal_sigusr1_handler = Module["_procsignal_sigusr1_handler"] = wasmExports["procsignal_sigusr1_handler"])(a0);
    var _have_free_buffer = Module["_have_free_buffer"] = () => (_have_free_buffer = Module["_have_free_buffer"] = wasmExports["have_free_buffer"])();
    var _LockBufHdr = Module["_LockBufHdr"] = (a0) => (_LockBufHdr = Module["_LockBufHdr"] = wasmExports["LockBufHdr"])(a0);
    var _copy_file = Module["_copy_file"] = (a0, a1) => (_copy_file = Module["_copy_file"] = wasmExports["copy_file"])(a0, a1);
    var _wasm_OpenPipeStream = Module["_wasm_OpenPipeStream"] = (a0, a1) => (_wasm_OpenPipeStream = Module["_wasm_OpenPipeStream"] = wasmExports["wasm_OpenPipeStream"])(a0, a1);
    var _fiprintf = Module["_fiprintf"] = (a0, a1, a2) => (_fiprintf = Module["_fiprintf"] = wasmExports["fiprintf"])(a0, a1, a2);
    var _fsync_fname_ext = Module["_fsync_fname_ext"] = (a0, a1, a2, a3) => (_fsync_fname_ext = Module["_fsync_fname_ext"] = wasmExports["fsync_fname_ext"])(a0, a1, a2, a3);
    var _rename = Module["_rename"] = (a0, a1) => (_rename = Module["_rename"] = wasmExports["rename"])(a0, a1);
    var _dup = Module["_dup"] = (a0) => (_dup = Module["_dup"] = wasmExports["dup"])(a0);
    var _open = Module["_open"] = (a0, a1, a2) => (_open = Module["_open"] = wasmExports["open"])(a0, a1, a2);
    var _AcquireExternalFD = Module["_AcquireExternalFD"] = () => (_AcquireExternalFD = Module["_AcquireExternalFD"] = wasmExports["AcquireExternalFD"])();
    var _pclose = Module["_pclose"] = (a0) => (_pclose = Module["_pclose"] = wasmExports["pclose"])(a0);
    var _ClosePipeStream = Module["_ClosePipeStream"] = (a0) => (_ClosePipeStream = Module["_ClosePipeStream"] = wasmExports["ClosePipeStream"])(a0);
    var _get_tsearch_config_filename = Module["_get_tsearch_config_filename"] = (a0, a1) => (_get_tsearch_config_filename = Module["_get_tsearch_config_filename"] = wasmExports["get_tsearch_config_filename"])(a0, a1);
    var _lowerstr = Module["_lowerstr"] = (a0) => (_lowerstr = Module["_lowerstr"] = wasmExports["lowerstr"])(a0);
    var _readstoplist = Module["_readstoplist"] = (a0, a1, a2) => (_readstoplist = Module["_readstoplist"] = wasmExports["readstoplist"])(a0, a1, a2);
    var _lowerstr_with_len = Module["_lowerstr_with_len"] = (a0, a1) => (_lowerstr_with_len = Module["_lowerstr_with_len"] = wasmExports["lowerstr_with_len"])(a0, a1);
    var _searchstoplist = Module["_searchstoplist"] = (a0, a1) => (_searchstoplist = Module["_searchstoplist"] = wasmExports["searchstoplist"])(a0, a1);
    var _tsearch_readline_begin = Module["_tsearch_readline_begin"] = (a0, a1) => (_tsearch_readline_begin = Module["_tsearch_readline_begin"] = wasmExports["tsearch_readline_begin"])(a0, a1);
    var _tsearch_readline = Module["_tsearch_readline"] = (a0) => (_tsearch_readline = Module["_tsearch_readline"] = wasmExports["tsearch_readline"])(a0);
    var _pg_mblen = Module["_pg_mblen"] = (a0) => (_pg_mblen = Module["_pg_mblen"] = wasmExports["pg_mblen"])(a0);
    var _t_isspace = Module["_t_isspace"] = (a0) => (_t_isspace = Module["_t_isspace"] = wasmExports["t_isspace"])(a0);
    var _tsearch_readline_end = Module["_tsearch_readline_end"] = (a0) => (_tsearch_readline_end = Module["_tsearch_readline_end"] = wasmExports["tsearch_readline_end"])(a0);
    var _pg_mb2wchar_with_len = Module["_pg_mb2wchar_with_len"] = (a0, a1, a2) => (_pg_mb2wchar_with_len = Module["_pg_mb2wchar_with_len"] = wasmExports["pg_mb2wchar_with_len"])(a0, a1, a2);
    var _t_isdigit = Module["_t_isdigit"] = (a0) => (_t_isdigit = Module["_t_isdigit"] = wasmExports["t_isdigit"])(a0);
    var _strcat = Module["_strcat"] = (a0, a1) => (_strcat = Module["_strcat"] = wasmExports["strcat"])(a0, a1);
    var _lookup_ts_dictionary_cache = Module["_lookup_ts_dictionary_cache"] = (a0) => (_lookup_ts_dictionary_cache = Module["_lookup_ts_dictionary_cache"] = wasmExports["lookup_ts_dictionary_cache"])(a0);
    var _construct_array_builtin = Module["_construct_array_builtin"] = (a0, a1, a2) => (_construct_array_builtin = Module["_construct_array_builtin"] = wasmExports["construct_array_builtin"])(a0, a1, a2);
    var _t_isalnum = Module["_t_isalnum"] = (a0) => (_t_isalnum = Module["_t_isalnum"] = wasmExports["t_isalnum"])(a0);
    var _pg_any_to_server = Module["_pg_any_to_server"] = (a0, a1, a2) => (_pg_any_to_server = Module["_pg_any_to_server"] = wasmExports["pg_any_to_server"])(a0, a1, a2);
    var _pg_database_encoding_max_length = Module["_pg_database_encoding_max_length"] = () => (_pg_database_encoding_max_length = Module["_pg_database_encoding_max_length"] = wasmExports["pg_database_encoding_max_length"])();
    var _isxdigit = Module["_isxdigit"] = (a0) => (_isxdigit = Module["_isxdigit"] = wasmExports["isxdigit"])(a0);
    var _pg_strtoint32 = Module["_pg_strtoint32"] = (a0) => (_pg_strtoint32 = Module["_pg_strtoint32"] = wasmExports["pg_strtoint32"])(a0);
    var _textToQualifiedNameList = Module["_textToQualifiedNameList"] = (a0) => (_textToQualifiedNameList = Module["_textToQualifiedNameList"] = wasmExports["textToQualifiedNameList"])(a0);
    var _DirectFunctionCall4Coll = Module["_DirectFunctionCall4Coll"] = (a0, a1, a2, a3, a4, a5) => (_DirectFunctionCall4Coll = Module["_DirectFunctionCall4Coll"] = wasmExports["DirectFunctionCall4Coll"])(a0, a1, a2, a3, a4, a5);
    var _get_restriction_variable = Module["_get_restriction_variable"] = (a0, a1, a2, a3, a4, a5) => (_get_restriction_variable = Module["_get_restriction_variable"] = wasmExports["get_restriction_variable"])(a0, a1, a2, a3, a4, a5);
    var _GetForeignDataWrapper = Module["_GetForeignDataWrapper"] = (a0) => (_GetForeignDataWrapper = Module["_GetForeignDataWrapper"] = wasmExports["GetForeignDataWrapper"])(a0);
    var _GetSysCacheOid = Module["_GetSysCacheOid"] = (a0, a1, a2, a3, a4, a5) => (_GetSysCacheOid = Module["_GetSysCacheOid"] = wasmExports["GetSysCacheOid"])(a0, a1, a2, a3, a4, a5);
    var _GetForeignServer = Module["_GetForeignServer"] = (a0) => (_GetForeignServer = Module["_GetForeignServer"] = wasmExports["GetForeignServer"])(a0);
    var _GetForeignServerExtended = Module["_GetForeignServerExtended"] = (a0, a1) => (_GetForeignServerExtended = Module["_GetForeignServerExtended"] = wasmExports["GetForeignServerExtended"])(a0, a1);
    var _GetForeignServerByName = Module["_GetForeignServerByName"] = (a0, a1) => (_GetForeignServerByName = Module["_GetForeignServerByName"] = wasmExports["GetForeignServerByName"])(a0, a1);
    var _GetUserMapping = Module["_GetUserMapping"] = (a0, a1) => (_GetUserMapping = Module["_GetUserMapping"] = wasmExports["GetUserMapping"])(a0, a1);
    var _GetUserNameFromId = Module["_GetUserNameFromId"] = (a0, a1) => (_GetUserNameFromId = Module["_GetUserNameFromId"] = wasmExports["GetUserNameFromId"])(a0, a1);
    var _GetForeignTable = Module["_GetForeignTable"] = (a0) => (_GetForeignTable = Module["_GetForeignTable"] = wasmExports["GetForeignTable"])(a0);
    var _GetForeignColumnOptions = Module["_GetForeignColumnOptions"] = (a0, a1) => (_GetForeignColumnOptions = Module["_GetForeignColumnOptions"] = wasmExports["GetForeignColumnOptions"])(a0, a1);
    var _initClosestMatch = Module["_initClosestMatch"] = (a0, a1, a2) => (_initClosestMatch = Module["_initClosestMatch"] = wasmExports["initClosestMatch"])(a0, a1, a2);
    var _updateClosestMatch = Module["_updateClosestMatch"] = (a0, a1) => (_updateClosestMatch = Module["_updateClosestMatch"] = wasmExports["updateClosestMatch"])(a0, a1);
    var _getClosestMatch = Module["_getClosestMatch"] = (a0) => (_getClosestMatch = Module["_getClosestMatch"] = wasmExports["getClosestMatch"])(a0);
    var _GetExistingLocalJoinPath = Module["_GetExistingLocalJoinPath"] = (a0) => (_GetExistingLocalJoinPath = Module["_GetExistingLocalJoinPath"] = wasmExports["GetExistingLocalJoinPath"])(a0);
    var _find_base_rel = Module["_find_base_rel"] = (a0, a1) => (_find_base_rel = Module["_find_base_rel"] = wasmExports["find_base_rel"])(a0, a1);
    var _bms_equal = Module["_bms_equal"] = (a0, a1) => (_bms_equal = Module["_bms_equal"] = wasmExports["bms_equal"])(a0, a1);
    var _list_copy = Module["_list_copy"] = (a0) => (_list_copy = Module["_list_copy"] = wasmExports["list_copy"])(a0);
    var _list_make3_impl = Module["_list_make3_impl"] = (a0, a1, a2, a3) => (_list_make3_impl = Module["_list_make3_impl"] = wasmExports["list_make3_impl"])(a0, a1, a2, a3);
    var _parser_errposition = Module["_parser_errposition"] = (a0, a1) => (_parser_errposition = Module["_parser_errposition"] = wasmExports["parser_errposition"])(a0, a1);
    var _get_fn_expr_argtype = Module["_get_fn_expr_argtype"] = (a0, a1) => (_get_fn_expr_argtype = Module["_get_fn_expr_argtype"] = wasmExports["get_fn_expr_argtype"])(a0, a1);
    var _fwrite = Module["_fwrite"] = (a0, a1, a2, a3) => (_fwrite = Module["_fwrite"] = wasmExports["fwrite"])(a0, a1, a2, a3);
    var _fputc = Module["_fputc"] = (a0, a1) => (_fputc = Module["_fputc"] = wasmExports["fputc"])(a0, a1);
    var _MemoryContextAllocHuge = Module["_MemoryContextAllocHuge"] = (a0, a1) => (_MemoryContextAllocHuge = Module["_MemoryContextAllocHuge"] = wasmExports["MemoryContextAllocHuge"])(a0, a1);
    var _hash_seq_term = Module["_hash_seq_term"] = (a0) => (_hash_seq_term = Module["_hash_seq_term"] = wasmExports["hash_seq_term"])(a0);
    var _PinPortal = Module["_PinPortal"] = (a0) => (_PinPortal = Module["_PinPortal"] = wasmExports["PinPortal"])(a0);
    var _UnpinPortal = Module["_UnpinPortal"] = (a0) => (_UnpinPortal = Module["_UnpinPortal"] = wasmExports["UnpinPortal"])(a0);
    var _strnlen = Module["_strnlen"] = (a0, a1) => (_strnlen = Module["_strnlen"] = wasmExports["strnlen"])(a0, a1);
    var _pchomp = Module["_pchomp"] = (a0) => (_pchomp = Module["_pchomp"] = wasmExports["pchomp"])(a0);
    var _dlsym = Module["_dlsym"] = (a0, a1) => (_dlsym = Module["_dlsym"] = wasmExports["dlsym"])(a0, a1);
    var _dlopen = Module["_dlopen"] = (a0, a1) => (_dlopen = Module["_dlopen"] = wasmExports["dlopen"])(a0, a1);
    var _dlerror = Module["_dlerror"] = () => (_dlerror = Module["_dlerror"] = wasmExports["dlerror"])();
    var _dlclose = Module["_dlclose"] = (a0) => (_dlclose = Module["_dlclose"] = wasmExports["dlclose"])(a0);
    var _find_rendezvous_variable = Module["_find_rendezvous_variable"] = (a0) => (_find_rendezvous_variable = Module["_find_rendezvous_variable"] = wasmExports["find_rendezvous_variable"])(a0);
    var _canonicalize_path = Module["_canonicalize_path"] = (a0) => (_canonicalize_path = Module["_canonicalize_path"] = wasmExports["canonicalize_path"])(a0);
    var _CallerFInfoFunctionCall2 = Module["_CallerFInfoFunctionCall2"] = (a0, a1, a2, a3, a4) => (_CallerFInfoFunctionCall2 = Module["_CallerFInfoFunctionCall2"] = wasmExports["CallerFInfoFunctionCall2"])(a0, a1, a2, a3, a4);
    var _FunctionCall0Coll = Module["_FunctionCall0Coll"] = (a0, a1) => (_FunctionCall0Coll = Module["_FunctionCall0Coll"] = wasmExports["FunctionCall0Coll"])(a0, a1);
    var _get_fn_expr_rettype = Module["_get_fn_expr_rettype"] = (a0) => (_get_fn_expr_rettype = Module["_get_fn_expr_rettype"] = wasmExports["get_fn_expr_rettype"])(a0);
    var _get_base_element_type = Module["_get_base_element_type"] = (a0) => (_get_base_element_type = Module["_get_base_element_type"] = wasmExports["get_base_element_type"])(a0);
    var _has_fn_opclass_options = Module["_has_fn_opclass_options"] = (a0) => (_has_fn_opclass_options = Module["_has_fn_opclass_options"] = wasmExports["has_fn_opclass_options"])(a0);
    var _CheckFunctionValidatorAccess = Module["_CheckFunctionValidatorAccess"] = (a0, a1) => (_CheckFunctionValidatorAccess = Module["_CheckFunctionValidatorAccess"] = wasmExports["CheckFunctionValidatorAccess"])(a0, a1);
    var _resolve_polymorphic_argtypes = Module["_resolve_polymorphic_argtypes"] = (a0, a1, a2, a3) => (_resolve_polymorphic_argtypes = Module["_resolve_polymorphic_argtypes"] = wasmExports["resolve_polymorphic_argtypes"])(a0, a1, a2, a3);
    var _get_func_arg_info = Module["_get_func_arg_info"] = (a0, a1, a2, a3) => (_get_func_arg_info = Module["_get_func_arg_info"] = wasmExports["get_func_arg_info"])(a0, a1, a2, a3);
    var _makeRangeVarFromNameList = Module["_makeRangeVarFromNameList"] = (a0) => (_makeRangeVarFromNameList = Module["_makeRangeVarFromNameList"] = wasmExports["makeRangeVarFromNameList"])(a0);
    var _pg_hmac_free = Module["_pg_hmac_free"] = (a0) => (_pg_hmac_free = Module["_pg_hmac_free"] = wasmExports["pg_hmac_free"])(a0);
    var _ResourceOwnerReleaseAllPlanCacheRefs = Module["_ResourceOwnerReleaseAllPlanCacheRefs"] = (a0) => (_ResourceOwnerReleaseAllPlanCacheRefs = Module["_ResourceOwnerReleaseAllPlanCacheRefs"] = wasmExports["ResourceOwnerReleaseAllPlanCacheRefs"])(a0);
    var _RegisterResourceReleaseCallback = Module["_RegisterResourceReleaseCallback"] = (a0, a1) => (_RegisterResourceReleaseCallback = Module["_RegisterResourceReleaseCallback"] = wasmExports["RegisterResourceReleaseCallback"])(a0, a1);
    var _namein = Module["_namein"] = (a0) => (_namein = Module["_namein"] = wasmExports["namein"])(a0);
    var _tidin = Module["_tidin"] = (a0) => (_tidin = Module["_tidin"] = wasmExports["tidin"])(a0);
    var _tidout = Module["_tidout"] = (a0) => (_tidout = Module["_tidout"] = wasmExports["tidout"])(a0);
    var _texteq = Module["_texteq"] = (a0) => (_texteq = Module["_texteq"] = wasmExports["texteq"])(a0);
    var _btfloat4cmp = Module["_btfloat4cmp"] = (a0) => (_btfloat4cmp = Module["_btfloat4cmp"] = wasmExports["btfloat4cmp"])(a0);
    var _btfloat8cmp = Module["_btfloat8cmp"] = (a0) => (_btfloat8cmp = Module["_btfloat8cmp"] = wasmExports["btfloat8cmp"])(a0);
    var _btnamecmp = Module["_btnamecmp"] = (a0) => (_btnamecmp = Module["_btnamecmp"] = wasmExports["btnamecmp"])(a0);
    var _bttextcmp = Module["_bttextcmp"] = (a0) => (_bttextcmp = Module["_bttextcmp"] = wasmExports["bttextcmp"])(a0);
    var _cash_cmp = Module["_cash_cmp"] = (a0) => (_cash_cmp = Module["_cash_cmp"] = wasmExports["cash_cmp"])(a0);
    var _text_lt = Module["_text_lt"] = (a0) => (_text_lt = Module["_text_lt"] = wasmExports["text_lt"])(a0);
    var _text_le = Module["_text_le"] = (a0) => (_text_le = Module["_text_le"] = wasmExports["text_le"])(a0);
    var _text_gt = Module["_text_gt"] = (a0) => (_text_gt = Module["_text_gt"] = wasmExports["text_gt"])(a0);
    var _text_ge = Module["_text_ge"] = (a0) => (_text_ge = Module["_text_ge"] = wasmExports["text_ge"])(a0);
    var _current_query = Module["_current_query"] = (a0) => (_current_query = Module["_current_query"] = wasmExports["current_query"])(a0);
    var _macaddr_eq = Module["_macaddr_eq"] = (a0) => (_macaddr_eq = Module["_macaddr_eq"] = wasmExports["macaddr_eq"])(a0);
    var _macaddr_lt = Module["_macaddr_lt"] = (a0) => (_macaddr_lt = Module["_macaddr_lt"] = wasmExports["macaddr_lt"])(a0);
    var _macaddr_le = Module["_macaddr_le"] = (a0) => (_macaddr_le = Module["_macaddr_le"] = wasmExports["macaddr_le"])(a0);
    var _macaddr_gt = Module["_macaddr_gt"] = (a0) => (_macaddr_gt = Module["_macaddr_gt"] = wasmExports["macaddr_gt"])(a0);
    var _macaddr_ge = Module["_macaddr_ge"] = (a0) => (_macaddr_ge = Module["_macaddr_ge"] = wasmExports["macaddr_ge"])(a0);
    var _macaddr_cmp = Module["_macaddr_cmp"] = (a0) => (_macaddr_cmp = Module["_macaddr_cmp"] = wasmExports["macaddr_cmp"])(a0);
    var _inet_in = Module["_inet_in"] = (a0) => (_inet_in = Module["_inet_in"] = wasmExports["inet_in"])(a0);
    var _network_cmp = Module["_network_cmp"] = (a0) => (_network_cmp = Module["_network_cmp"] = wasmExports["network_cmp"])(a0);
    var _be_lo_unlink = Module["_be_lo_unlink"] = (a0) => (_be_lo_unlink = Module["_be_lo_unlink"] = wasmExports["be_lo_unlink"])(a0);
    var _bpchareq = Module["_bpchareq"] = (a0) => (_bpchareq = Module["_bpchareq"] = wasmExports["bpchareq"])(a0);
    var _bpcharlt = Module["_bpcharlt"] = (a0) => (_bpcharlt = Module["_bpcharlt"] = wasmExports["bpcharlt"])(a0);
    var _bpcharle = Module["_bpcharle"] = (a0) => (_bpcharle = Module["_bpcharle"] = wasmExports["bpcharle"])(a0);
    var _bpchargt = Module["_bpchargt"] = (a0) => (_bpchargt = Module["_bpchargt"] = wasmExports["bpchargt"])(a0);
    var _bpcharge = Module["_bpcharge"] = (a0) => (_bpcharge = Module["_bpcharge"] = wasmExports["bpcharge"])(a0);
    var _bpcharcmp = Module["_bpcharcmp"] = (a0) => (_bpcharcmp = Module["_bpcharcmp"] = wasmExports["bpcharcmp"])(a0);
    var _date_eq = Module["_date_eq"] = (a0) => (_date_eq = Module["_date_eq"] = wasmExports["date_eq"])(a0);
    var _date_lt = Module["_date_lt"] = (a0) => (_date_lt = Module["_date_lt"] = wasmExports["date_lt"])(a0);
    var _date_le = Module["_date_le"] = (a0) => (_date_le = Module["_date_le"] = wasmExports["date_le"])(a0);
    var _date_gt = Module["_date_gt"] = (a0) => (_date_gt = Module["_date_gt"] = wasmExports["date_gt"])(a0);
    var _date_ge = Module["_date_ge"] = (a0) => (_date_ge = Module["_date_ge"] = wasmExports["date_ge"])(a0);
    var _date_cmp = Module["_date_cmp"] = (a0) => (_date_cmp = Module["_date_cmp"] = wasmExports["date_cmp"])(a0);
    var _time_lt = Module["_time_lt"] = (a0) => (_time_lt = Module["_time_lt"] = wasmExports["time_lt"])(a0);
    var _time_le = Module["_time_le"] = (a0) => (_time_le = Module["_time_le"] = wasmExports["time_le"])(a0);
    var _time_gt = Module["_time_gt"] = (a0) => (_time_gt = Module["_time_gt"] = wasmExports["time_gt"])(a0);
    var _time_ge = Module["_time_ge"] = (a0) => (_time_ge = Module["_time_ge"] = wasmExports["time_ge"])(a0);
    var _time_cmp = Module["_time_cmp"] = (a0) => (_time_cmp = Module["_time_cmp"] = wasmExports["time_cmp"])(a0);
    var _date_mi = Module["_date_mi"] = (a0) => (_date_mi = Module["_date_mi"] = wasmExports["date_mi"])(a0);
    var _time_eq = Module["_time_eq"] = (a0) => (_time_eq = Module["_time_eq"] = wasmExports["time_eq"])(a0);
    var _timestamp_eq = Module["_timestamp_eq"] = (a0) => (_timestamp_eq = Module["_timestamp_eq"] = wasmExports["timestamp_eq"])(a0);
    var _timestamp_lt = Module["_timestamp_lt"] = (a0) => (_timestamp_lt = Module["_timestamp_lt"] = wasmExports["timestamp_lt"])(a0);
    var _timestamp_le = Module["_timestamp_le"] = (a0) => (_timestamp_le = Module["_timestamp_le"] = wasmExports["timestamp_le"])(a0);
    var _timestamp_ge = Module["_timestamp_ge"] = (a0) => (_timestamp_ge = Module["_timestamp_ge"] = wasmExports["timestamp_ge"])(a0);
    var _timestamp_gt = Module["_timestamp_gt"] = (a0) => (_timestamp_gt = Module["_timestamp_gt"] = wasmExports["timestamp_gt"])(a0);
    var _interval_eq = Module["_interval_eq"] = (a0) => (_interval_eq = Module["_interval_eq"] = wasmExports["interval_eq"])(a0);
    var _interval_lt = Module["_interval_lt"] = (a0) => (_interval_lt = Module["_interval_lt"] = wasmExports["interval_lt"])(a0);
    var _interval_le = Module["_interval_le"] = (a0) => (_interval_le = Module["_interval_le"] = wasmExports["interval_le"])(a0);
    var _interval_ge = Module["_interval_ge"] = (a0) => (_interval_ge = Module["_interval_ge"] = wasmExports["interval_ge"])(a0);
    var _interval_gt = Module["_interval_gt"] = (a0) => (_interval_gt = Module["_interval_gt"] = wasmExports["interval_gt"])(a0);
    var _interval_um = Module["_interval_um"] = (a0) => (_interval_um = Module["_interval_um"] = wasmExports["interval_um"])(a0);
    var _interval_mi = Module["_interval_mi"] = (a0) => (_interval_mi = Module["_interval_mi"] = wasmExports["interval_mi"])(a0);
    var _timestamp_mi = Module["_timestamp_mi"] = (a0) => (_timestamp_mi = Module["_timestamp_mi"] = wasmExports["timestamp_mi"])(a0);
    var _quote_ident = Module["_quote_ident"] = (a0) => (_quote_ident = Module["_quote_ident"] = wasmExports["quote_ident"])(a0);
    var _timestamp_in = Module["_timestamp_in"] = (a0) => (_timestamp_in = Module["_timestamp_in"] = wasmExports["timestamp_in"])(a0);
    var _timestamp_cmp = Module["_timestamp_cmp"] = (a0) => (_timestamp_cmp = Module["_timestamp_cmp"] = wasmExports["timestamp_cmp"])(a0);
    var _interval_cmp = Module["_interval_cmp"] = (a0) => (_interval_cmp = Module["_interval_cmp"] = wasmExports["interval_cmp"])(a0);
    var _timetz_cmp = Module["_timetz_cmp"] = (a0) => (_timetz_cmp = Module["_timetz_cmp"] = wasmExports["timetz_cmp"])(a0);
    var _bit_in = Module["_bit_in"] = (a0) => (_bit_in = Module["_bit_in"] = wasmExports["bit_in"])(a0);
    var _varbit_in = Module["_varbit_in"] = (a0) => (_varbit_in = Module["_varbit_in"] = wasmExports["varbit_in"])(a0);
    var _biteq = Module["_biteq"] = (a0) => (_biteq = Module["_biteq"] = wasmExports["biteq"])(a0);
    var _bitge = Module["_bitge"] = (a0) => (_bitge = Module["_bitge"] = wasmExports["bitge"])(a0);
    var _bitgt = Module["_bitgt"] = (a0) => (_bitgt = Module["_bitgt"] = wasmExports["bitgt"])(a0);
    var _bitle = Module["_bitle"] = (a0) => (_bitle = Module["_bitle"] = wasmExports["bitle"])(a0);
    var _bitlt = Module["_bitlt"] = (a0) => (_bitlt = Module["_bitlt"] = wasmExports["bitlt"])(a0);
    var _bitcmp = Module["_bitcmp"] = (a0) => (_bitcmp = Module["_bitcmp"] = wasmExports["bitcmp"])(a0);
    var _time_mi_time = Module["_time_mi_time"] = (a0) => (_time_mi_time = Module["_time_mi_time"] = wasmExports["time_mi_time"])(a0);
    var _numeric_eq = Module["_numeric_eq"] = (a0) => (_numeric_eq = Module["_numeric_eq"] = wasmExports["numeric_eq"])(a0);
    var _numeric_gt = Module["_numeric_gt"] = (a0) => (_numeric_gt = Module["_numeric_gt"] = wasmExports["numeric_gt"])(a0);
    var _numeric_ge = Module["_numeric_ge"] = (a0) => (_numeric_ge = Module["_numeric_ge"] = wasmExports["numeric_ge"])(a0);
    var _numeric_lt = Module["_numeric_lt"] = (a0) => (_numeric_lt = Module["_numeric_lt"] = wasmExports["numeric_lt"])(a0);
    var _numeric_le = Module["_numeric_le"] = (a0) => (_numeric_le = Module["_numeric_le"] = wasmExports["numeric_le"])(a0);
    var _numeric_div = Module["_numeric_div"] = (a0) => (_numeric_div = Module["_numeric_div"] = wasmExports["numeric_div"])(a0);
    var _numeric_float4 = Module["_numeric_float4"] = (a0) => (_numeric_float4 = Module["_numeric_float4"] = wasmExports["numeric_float4"])(a0);
    var _numeric_cmp = Module["_numeric_cmp"] = (a0) => (_numeric_cmp = Module["_numeric_cmp"] = wasmExports["numeric_cmp"])(a0);
    var _byteaeq = Module["_byteaeq"] = (a0) => (_byteaeq = Module["_byteaeq"] = wasmExports["byteaeq"])(a0);
    var _bytealt = Module["_bytealt"] = (a0) => (_bytealt = Module["_bytealt"] = wasmExports["bytealt"])(a0);
    var _byteale = Module["_byteale"] = (a0) => (_byteale = Module["_byteale"] = wasmExports["byteale"])(a0);
    var _byteagt = Module["_byteagt"] = (a0) => (_byteagt = Module["_byteagt"] = wasmExports["byteagt"])(a0);
    var _byteage = Module["_byteage"] = (a0) => (_byteage = Module["_byteage"] = wasmExports["byteage"])(a0);
    var _byteacmp = Module["_byteacmp"] = (a0) => (_byteacmp = Module["_byteacmp"] = wasmExports["byteacmp"])(a0);
    var _to_hex32 = Module["_to_hex32"] = (a0) => (_to_hex32 = Module["_to_hex32"] = wasmExports["to_hex32"])(a0);
    var _uuid_in = Module["_uuid_in"] = (a0) => (_uuid_in = Module["_uuid_in"] = wasmExports["uuid_in"])(a0);
    var _uuid_out = Module["_uuid_out"] = (a0) => (_uuid_out = Module["_uuid_out"] = wasmExports["uuid_out"])(a0);
    var _uuid_cmp = Module["_uuid_cmp"] = (a0) => (_uuid_cmp = Module["_uuid_cmp"] = wasmExports["uuid_cmp"])(a0);
    var _pg_lsn_in = Module["_pg_lsn_in"] = (a0) => (_pg_lsn_in = Module["_pg_lsn_in"] = wasmExports["pg_lsn_in"])(a0);
    var _gen_random_uuid = Module["_gen_random_uuid"] = (a0) => (_gen_random_uuid = Module["_gen_random_uuid"] = wasmExports["gen_random_uuid"])(a0);
    var _enum_lt = Module["_enum_lt"] = (a0) => (_enum_lt = Module["_enum_lt"] = wasmExports["enum_lt"])(a0);
    var _enum_gt = Module["_enum_gt"] = (a0) => (_enum_gt = Module["_enum_gt"] = wasmExports["enum_gt"])(a0);
    var _enum_le = Module["_enum_le"] = (a0) => (_enum_le = Module["_enum_le"] = wasmExports["enum_le"])(a0);
    var _enum_ge = Module["_enum_ge"] = (a0) => (_enum_ge = Module["_enum_ge"] = wasmExports["enum_ge"])(a0);
    var _enum_cmp = Module["_enum_cmp"] = (a0) => (_enum_cmp = Module["_enum_cmp"] = wasmExports["enum_cmp"])(a0);
    var _arraycontsel = Module["_arraycontsel"] = (a0) => (_arraycontsel = Module["_arraycontsel"] = wasmExports["arraycontsel"])(a0);
    var _arraycontjoinsel = Module["_arraycontjoinsel"] = (a0) => (_arraycontjoinsel = Module["_arraycontjoinsel"] = wasmExports["arraycontjoinsel"])(a0);
    var _macaddr8_eq = Module["_macaddr8_eq"] = (a0) => (_macaddr8_eq = Module["_macaddr8_eq"] = wasmExports["macaddr8_eq"])(a0);
    var _macaddr8_lt = Module["_macaddr8_lt"] = (a0) => (_macaddr8_lt = Module["_macaddr8_lt"] = wasmExports["macaddr8_lt"])(a0);
    var _macaddr8_le = Module["_macaddr8_le"] = (a0) => (_macaddr8_le = Module["_macaddr8_le"] = wasmExports["macaddr8_le"])(a0);
    var _macaddr8_gt = Module["_macaddr8_gt"] = (a0) => (_macaddr8_gt = Module["_macaddr8_gt"] = wasmExports["macaddr8_gt"])(a0);
    var _macaddr8_ge = Module["_macaddr8_ge"] = (a0) => (_macaddr8_ge = Module["_macaddr8_ge"] = wasmExports["macaddr8_ge"])(a0);
    var _macaddr8_cmp = Module["_macaddr8_cmp"] = (a0) => (_macaddr8_cmp = Module["_macaddr8_cmp"] = wasmExports["macaddr8_cmp"])(a0);
    var _local2local = Module["_local2local"] = (a0, a1, a2, a3, a4, a5, a6) => (_local2local = Module["_local2local"] = wasmExports["local2local"])(a0, a1, a2, a3, a4, a5, a6);
    var _report_invalid_encoding = Module["_report_invalid_encoding"] = (a0, a1, a2) => (_report_invalid_encoding = Module["_report_invalid_encoding"] = wasmExports["report_invalid_encoding"])(a0, a1, a2);
    var _report_untranslatable_char = Module["_report_untranslatable_char"] = (a0, a1, a2, a3) => (_report_untranslatable_char = Module["_report_untranslatable_char"] = wasmExports["report_untranslatable_char"])(a0, a1, a2, a3);
    var _latin2mic = Module["_latin2mic"] = (a0, a1, a2, a3, a4, a5) => (_latin2mic = Module["_latin2mic"] = wasmExports["latin2mic"])(a0, a1, a2, a3, a4, a5);
    var _mic2latin = Module["_mic2latin"] = (a0, a1, a2, a3, a4, a5) => (_mic2latin = Module["_mic2latin"] = wasmExports["mic2latin"])(a0, a1, a2, a3, a4, a5);
    var _latin2mic_with_table = Module["_latin2mic_with_table"] = (a0, a1, a2, a3, a4, a5, a6) => (_latin2mic_with_table = Module["_latin2mic_with_table"] = wasmExports["latin2mic_with_table"])(a0, a1, a2, a3, a4, a5, a6);
    var _mic2latin_with_table = Module["_mic2latin_with_table"] = (a0, a1, a2, a3, a4, a5, a6) => (_mic2latin_with_table = Module["_mic2latin_with_table"] = wasmExports["mic2latin_with_table"])(a0, a1, a2, a3, a4, a5, a6);
    var _pg_utf_mblen = Module["_pg_utf_mblen"] = (a0) => (_pg_utf_mblen = Module["_pg_utf_mblen"] = wasmExports["pg_utf_mblen"])(a0);
    var _pg_encoding_verifymbchar = Module["_pg_encoding_verifymbchar"] = (a0, a1, a2) => (_pg_encoding_verifymbchar = Module["_pg_encoding_verifymbchar"] = wasmExports["pg_encoding_verifymbchar"])(a0, a1, a2);
    var _GetDatabaseEncodingName = Module["_GetDatabaseEncodingName"] = () => (_GetDatabaseEncodingName = Module["_GetDatabaseEncodingName"] = wasmExports["GetDatabaseEncodingName"])();
    var _pg_do_encoding_conversion = Module["_pg_do_encoding_conversion"] = (a0, a1, a2, a3) => (_pg_do_encoding_conversion = Module["_pg_do_encoding_conversion"] = wasmExports["pg_do_encoding_conversion"])(a0, a1, a2, a3);
    var _pg_encoding_to_char_private = Module["_pg_encoding_to_char_private"] = (a0) => (_pg_encoding_to_char_private = Module["_pg_encoding_to_char_private"] = wasmExports["pg_encoding_to_char_private"])(a0);
    var _pg_char_to_encoding_private = Module["_pg_char_to_encoding_private"] = (a0) => (_pg_char_to_encoding_private = Module["_pg_char_to_encoding_private"] = wasmExports["pg_char_to_encoding_private"])(a0);
    var _pg_encoding_max_length = Module["_pg_encoding_max_length"] = (a0) => (_pg_encoding_max_length = Module["_pg_encoding_max_length"] = wasmExports["pg_encoding_max_length"])(a0);
    var _pg_server_to_any = Module["_pg_server_to_any"] = (a0, a1, a2) => (_pg_server_to_any = Module["_pg_server_to_any"] = wasmExports["pg_server_to_any"])(a0, a1, a2);
    var _pg_wchar2mb_with_len = Module["_pg_wchar2mb_with_len"] = (a0, a1, a2) => (_pg_wchar2mb_with_len = Module["_pg_wchar2mb_with_len"] = wasmExports["pg_wchar2mb_with_len"])(a0, a1, a2);
    var _pg_encoding_mblen = Module["_pg_encoding_mblen"] = (a0, a1) => (_pg_encoding_mblen = Module["_pg_encoding_mblen"] = wasmExports["pg_encoding_mblen"])(a0, a1);
    var _check_encoding_conversion_args = Module["_check_encoding_conversion_args"] = (a0, a1, a2, a3, a4) => (_check_encoding_conversion_args = Module["_check_encoding_conversion_args"] = wasmExports["check_encoding_conversion_args"])(a0, a1, a2, a3, a4);
    var _set_config_option = Module["_set_config_option"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_set_config_option = Module["_set_config_option"] = wasmExports["set_config_option"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _quote_identifier = Module["_quote_identifier"] = (a0) => (_quote_identifier = Module["_quote_identifier"] = wasmExports["quote_identifier"])(a0);
    var _list_delete = Module["_list_delete"] = (a0, a1) => (_list_delete = Module["_list_delete"] = wasmExports["list_delete"])(a0, a1);
    var _feof = Module["_feof"] = (a0) => (_feof = Module["_feof"] = wasmExports["feof"])(a0);
    var _BlockSampler_Init = Module["_BlockSampler_Init"] = (a0, a1, a2, a3) => (_BlockSampler_Init = Module["_BlockSampler_Init"] = wasmExports["BlockSampler_Init"])(a0, a1, a2, a3);
    var _pg_prng_seed = Module["_pg_prng_seed"] = (a0, a1) => (_pg_prng_seed = Module["_pg_prng_seed"] = wasmExports["pg_prng_seed"])(a0, a1);
    var _sampler_random_init_state = Module["_sampler_random_init_state"] = (a0, a1) => (_sampler_random_init_state = Module["_sampler_random_init_state"] = wasmExports["sampler_random_init_state"])(a0, a1);
    var _BlockSampler_HasMore = Module["_BlockSampler_HasMore"] = (a0) => (_BlockSampler_HasMore = Module["_BlockSampler_HasMore"] = wasmExports["BlockSampler_HasMore"])(a0);
    var _BlockSampler_Next = Module["_BlockSampler_Next"] = (a0) => (_BlockSampler_Next = Module["_BlockSampler_Next"] = wasmExports["BlockSampler_Next"])(a0);
    var _sampler_random_fract = Module["_sampler_random_fract"] = (a0) => (_sampler_random_fract = Module["_sampler_random_fract"] = wasmExports["sampler_random_fract"])(a0);
    var _reservoir_init_selection_state = Module["_reservoir_init_selection_state"] = (a0, a1) => (_reservoir_init_selection_state = Module["_reservoir_init_selection_state"] = wasmExports["reservoir_init_selection_state"])(a0, a1);
    var _reservoir_get_next_S = Module["_reservoir_get_next_S"] = (a0, a1, a2) => (_reservoir_get_next_S = Module["_reservoir_get_next_S"] = wasmExports["reservoir_get_next_S"])(a0, a1, a2);
    var _GetConfigOption = Module["_GetConfigOption"] = (a0, a1, a2) => (_GetConfigOption = Module["_GetConfigOption"] = wasmExports["GetConfigOption"])(a0, a1, a2);
    var _ProcessConfigFile = Module["_ProcessConfigFile"] = (a0) => (_ProcessConfigFile = Module["_ProcessConfigFile"] = wasmExports["ProcessConfigFile"])(a0);
    var _strtod = Module["_strtod"] = (a0, a1) => (_strtod = Module["_strtod"] = wasmExports["strtod"])(a0, a1);
    var _truncate_identifier = Module["_truncate_identifier"] = (a0, a1, a2) => (_truncate_identifier = Module["_truncate_identifier"] = wasmExports["truncate_identifier"])(a0, a1, a2);
    var _DefineCustomBoolVariable = Module["_DefineCustomBoolVariable"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_DefineCustomBoolVariable = Module["_DefineCustomBoolVariable"] = wasmExports["DefineCustomBoolVariable"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _DefineCustomIntVariable = Module["_DefineCustomIntVariable"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => (_DefineCustomIntVariable = Module["_DefineCustomIntVariable"] = wasmExports["DefineCustomIntVariable"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    var _DefineCustomRealVariable = Module["_DefineCustomRealVariable"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => (_DefineCustomRealVariable = Module["_DefineCustomRealVariable"] = wasmExports["DefineCustomRealVariable"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    var _DefineCustomStringVariable = Module["_DefineCustomStringVariable"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_DefineCustomStringVariable = Module["_DefineCustomStringVariable"] = wasmExports["DefineCustomStringVariable"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _DefineCustomEnumVariable = Module["_DefineCustomEnumVariable"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => (_DefineCustomEnumVariable = Module["_DefineCustomEnumVariable"] = wasmExports["DefineCustomEnumVariable"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    var _MarkGUCPrefixReserved = Module["_MarkGUCPrefixReserved"] = (a0) => (_MarkGUCPrefixReserved = Module["_MarkGUCPrefixReserved"] = wasmExports["MarkGUCPrefixReserved"])(a0);
    var _strcspn = Module["_strcspn"] = (a0, a1) => (_strcspn = Module["_strcspn"] = wasmExports["strcspn"])(a0, a1);
    var _CacheRegisterSyscacheCallback = Module["_CacheRegisterSyscacheCallback"] = (a0, a1, a2) => (_CacheRegisterSyscacheCallback = Module["_CacheRegisterSyscacheCallback"] = wasmExports["CacheRegisterSyscacheCallback"])(a0, a1, a2);
    var _TransferExpandedObject = Module["_TransferExpandedObject"] = (a0, a1) => (_TransferExpandedObject = Module["_TransferExpandedObject"] = wasmExports["TransferExpandedObject"])(a0, a1);
    var _errsave_start = Module["_errsave_start"] = (a0, a1) => (_errsave_start = Module["_errsave_start"] = wasmExports["errsave_start"])(a0, a1);
    var _errsave_finish = Module["_errsave_finish"] = (a0, a1, a2, a3) => (_errsave_finish = Module["_errsave_finish"] = wasmExports["errsave_finish"])(a0, a1, a2, a3);
    var _pq_getmsgtext = Module["_pq_getmsgtext"] = (a0, a1, a2) => (_pq_getmsgtext = Module["_pq_getmsgtext"] = wasmExports["pq_getmsgtext"])(a0, a1, a2);
    var _pq_begintypsend = Module["_pq_begintypsend"] = (a0) => (_pq_begintypsend = Module["_pq_begintypsend"] = wasmExports["pq_begintypsend"])(a0);
    var _pq_sendtext = Module["_pq_sendtext"] = (a0, a1, a2) => (_pq_sendtext = Module["_pq_sendtext"] = wasmExports["pq_sendtext"])(a0, a1, a2);
    var _pq_endtypsend = Module["_pq_endtypsend"] = (a0) => (_pq_endtypsend = Module["_pq_endtypsend"] = wasmExports["pq_endtypsend"])(a0);
    var _downcase_truncate_identifier = Module["_downcase_truncate_identifier"] = (a0, a1, a2) => (_downcase_truncate_identifier = Module["_downcase_truncate_identifier"] = wasmExports["downcase_truncate_identifier"])(a0, a1, a2);
    var _int64_to_numeric = Module["_int64_to_numeric"] = (a0) => (_int64_to_numeric = Module["_int64_to_numeric"] = wasmExports["int64_to_numeric"])(a0);
    var _ArrayGetIntegerTypmods = Module["_ArrayGetIntegerTypmods"] = (a0, a1) => (_ArrayGetIntegerTypmods = Module["_ArrayGetIntegerTypmods"] = wasmExports["ArrayGetIntegerTypmods"])(a0, a1);
    var _text_to_cstring_buffer = Module["_text_to_cstring_buffer"] = (a0, a1, a2) => (_text_to_cstring_buffer = Module["_text_to_cstring_buffer"] = wasmExports["text_to_cstring_buffer"])(a0, a1, a2);
    var _array_contains_nulls = Module["_array_contains_nulls"] = (a0) => (_array_contains_nulls = Module["_array_contains_nulls"] = wasmExports["array_contains_nulls"])(a0);
    var _JsonbValueToJsonb = Module["_JsonbValueToJsonb"] = (a0) => (_JsonbValueToJsonb = Module["_JsonbValueToJsonb"] = wasmExports["JsonbValueToJsonb"])(a0);
    var _pushJsonbValue = Module["_pushJsonbValue"] = (a0, a1, a2) => (_pushJsonbValue = Module["_pushJsonbValue"] = wasmExports["pushJsonbValue"])(a0, a1, a2);
    var _float4in_internal = Module["_float4in_internal"] = (a0, a1, a2, a3, a4) => (_float4in_internal = Module["_float4in_internal"] = wasmExports["float4in_internal"])(a0, a1, a2, a3, a4);
    var _strtof = Module["_strtof"] = (a0, a1) => (_strtof = Module["_strtof"] = wasmExports["strtof"])(a0, a1);
    var _float_to_shortest_decimal_buf = Module["_float_to_shortest_decimal_buf"] = (a0, a1) => (_float_to_shortest_decimal_buf = Module["_float_to_shortest_decimal_buf"] = wasmExports["float_to_shortest_decimal_buf"])(a0, a1);
    var _pq_getmsgfloat4 = Module["_pq_getmsgfloat4"] = (a0) => (_pq_getmsgfloat4 = Module["_pq_getmsgfloat4"] = wasmExports["pq_getmsgfloat4"])(a0);
    var _pq_sendfloat4 = Module["_pq_sendfloat4"] = (a0, a1) => (_pq_sendfloat4 = Module["_pq_sendfloat4"] = wasmExports["pq_sendfloat4"])(a0, a1);
    var _float8in_internal = Module["_float8in_internal"] = (a0, a1, a2, a3, a4) => (_float8in_internal = Module["_float8in_internal"] = wasmExports["float8in_internal"])(a0, a1, a2, a3, a4);
    var _float8out_internal = Module["_float8out_internal"] = (a0) => (_float8out_internal = Module["_float8out_internal"] = wasmExports["float8out_internal"])(a0);
    var _pq_getmsgfloat8 = Module["_pq_getmsgfloat8"] = (a0) => (_pq_getmsgfloat8 = Module["_pq_getmsgfloat8"] = wasmExports["pq_getmsgfloat8"])(a0);
    var _pq_sendfloat8 = Module["_pq_sendfloat8"] = (a0, a1) => (_pq_sendfloat8 = Module["_pq_sendfloat8"] = wasmExports["pq_sendfloat8"])(a0, a1);
    var _log10 = Module["_log10"] = (a0) => (_log10 = Module["_log10"] = wasmExports["log10"])(a0);
    var _acos = Module["_acos"] = (a0) => (_acos = Module["_acos"] = wasmExports["acos"])(a0);
    var _asin = Module["_asin"] = (a0) => (_asin = Module["_asin"] = wasmExports["asin"])(a0);
    var _cos = Module["_cos"] = (a0) => (_cos = Module["_cos"] = wasmExports["cos"])(a0);
    var _sin = Module["_sin"] = (a0) => (_sin = Module["_sin"] = wasmExports["sin"])(a0);
    var _fmod = Module["_fmod"] = (a0, a1) => (_fmod = Module["_fmod"] = wasmExports["fmod"])(a0, a1);
    var _pg_prng_seed_check = Module["_pg_prng_seed_check"] = (a0) => (_pg_prng_seed_check = Module["_pg_prng_seed_check"] = wasmExports["pg_prng_seed_check"])(a0);
    var _construct_array = Module["_construct_array"] = (a0, a1, a2, a3, a4, a5) => (_construct_array = Module["_construct_array"] = wasmExports["construct_array"])(a0, a1, a2, a3, a4, a5);
    var _quote_literal_cstr = Module["_quote_literal_cstr"] = (a0) => (_quote_literal_cstr = Module["_quote_literal_cstr"] = wasmExports["quote_literal_cstr"])(a0);
    var _pg_inet_net_ntop = Module["_pg_inet_net_ntop"] = (a0, a1, a2, a3, a4) => (_pg_inet_net_ntop = Module["_pg_inet_net_ntop"] = wasmExports["pg_inet_net_ntop"])(a0, a1, a2, a3, a4);
    var _convert_network_to_scalar = Module["_convert_network_to_scalar"] = (a0, a1, a2) => (_convert_network_to_scalar = Module["_convert_network_to_scalar"] = wasmExports["convert_network_to_scalar"])(a0, a1, a2);
    var _pg_getnameinfo_all = Module["_pg_getnameinfo_all"] = (a0, a1, a2, a3, a4, a5, a6) => (_pg_getnameinfo_all = Module["_pg_getnameinfo_all"] = wasmExports["pg_getnameinfo_all"])(a0, a1, a2, a3, a4, a5, a6);
    var _appendStringInfoSpaces = Module["_appendStringInfoSpaces"] = (a0, a1) => (_appendStringInfoSpaces = Module["_appendStringInfoSpaces"] = wasmExports["appendStringInfoSpaces"])(a0, a1);
    var _format_type_extended = Module["_format_type_extended"] = (a0, a1, a2) => (_format_type_extended = Module["_format_type_extended"] = wasmExports["format_type_extended"])(a0, a1, a2);
    var _get_namespace_name_or_temp = Module["_get_namespace_name_or_temp"] = (a0) => (_get_namespace_name_or_temp = Module["_get_namespace_name_or_temp"] = wasmExports["get_namespace_name_or_temp"])(a0);
    var _quote_qualified_identifier = Module["_quote_qualified_identifier"] = (a0, a1) => (_quote_qualified_identifier = Module["_quote_qualified_identifier"] = wasmExports["quote_qualified_identifier"])(a0, a1);
    var _make_expanded_record_from_typeid = Module["_make_expanded_record_from_typeid"] = (a0, a1, a2) => (_make_expanded_record_from_typeid = Module["_make_expanded_record_from_typeid"] = wasmExports["make_expanded_record_from_typeid"])(a0, a1, a2);
    var _make_expanded_record_from_tupdesc = Module["_make_expanded_record_from_tupdesc"] = (a0, a1) => (_make_expanded_record_from_tupdesc = Module["_make_expanded_record_from_tupdesc"] = wasmExports["make_expanded_record_from_tupdesc"])(a0, a1);
    var _make_expanded_record_from_exprecord = Module["_make_expanded_record_from_exprecord"] = (a0, a1) => (_make_expanded_record_from_exprecord = Module["_make_expanded_record_from_exprecord"] = wasmExports["make_expanded_record_from_exprecord"])(a0, a1);
    var _expanded_record_set_tuple = Module["_expanded_record_set_tuple"] = (a0, a1, a2, a3) => (_expanded_record_set_tuple = Module["_expanded_record_set_tuple"] = wasmExports["expanded_record_set_tuple"])(a0, a1, a2, a3);
    var _domain_check = Module["_domain_check"] = (a0, a1, a2, a3, a4) => (_domain_check = Module["_domain_check"] = wasmExports["domain_check"])(a0, a1, a2, a3, a4);
    var _expanded_record_get_tuple = Module["_expanded_record_get_tuple"] = (a0) => (_expanded_record_get_tuple = Module["_expanded_record_get_tuple"] = wasmExports["expanded_record_get_tuple"])(a0);
    var _deconstruct_expanded_record = Module["_deconstruct_expanded_record"] = (a0) => (_deconstruct_expanded_record = Module["_deconstruct_expanded_record"] = wasmExports["deconstruct_expanded_record"])(a0);
    var _expanded_record_lookup_field = Module["_expanded_record_lookup_field"] = (a0, a1, a2) => (_expanded_record_lookup_field = Module["_expanded_record_lookup_field"] = wasmExports["expanded_record_lookup_field"])(a0, a1, a2);
    var _expanded_record_set_field_internal = Module["_expanded_record_set_field_internal"] = (a0, a1, a2, a3, a4, a5) => (_expanded_record_set_field_internal = Module["_expanded_record_set_field_internal"] = wasmExports["expanded_record_set_field_internal"])(a0, a1, a2, a3, a4, a5);
    var _expanded_record_set_fields = Module["_expanded_record_set_fields"] = (a0, a1, a2, a3) => (_expanded_record_set_fields = Module["_expanded_record_set_fields"] = wasmExports["expanded_record_set_fields"])(a0, a1, a2, a3);
    var _err_generic_string = Module["_err_generic_string"] = (a0, a1) => (_err_generic_string = Module["_err_generic_string"] = wasmExports["err_generic_string"])(a0, a1);
    var _forkname_to_number = Module["_forkname_to_number"] = (a0) => (_forkname_to_number = Module["_forkname_to_number"] = wasmExports["forkname_to_number"])(a0);
    var _RelidByRelfilenumber = Module["_RelidByRelfilenumber"] = (a0, a1) => (_RelidByRelfilenumber = Module["_RelidByRelfilenumber"] = wasmExports["RelidByRelfilenumber"])(a0, a1);
    var _pg_xml_init = Module["_pg_xml_init"] = (a0) => (_pg_xml_init = Module["_pg_xml_init"] = wasmExports["pg_xml_init"])(a0);
    var _xmlInitParser = Module["_xmlInitParser"] = () => (_xmlInitParser = Module["_xmlInitParser"] = wasmExports["xmlInitParser"])();
    var _xml_ereport = Module["_xml_ereport"] = (a0, a1, a2, a3) => (_xml_ereport = Module["_xml_ereport"] = wasmExports["xml_ereport"])(a0, a1, a2, a3);
    var _pg_xml_done = Module["_pg_xml_done"] = (a0, a1) => (_pg_xml_done = Module["_pg_xml_done"] = wasmExports["pg_xml_done"])(a0, a1);
    var _xmlXPathNewContext = Module["_xmlXPathNewContext"] = (a0) => (_xmlXPathNewContext = Module["_xmlXPathNewContext"] = wasmExports["xmlXPathNewContext"])(a0);
    var _xmlXPathFreeContext = Module["_xmlXPathFreeContext"] = (a0) => (_xmlXPathFreeContext = Module["_xmlXPathFreeContext"] = wasmExports["xmlXPathFreeContext"])(a0);
    var _xmlFreeDoc = Module["_xmlFreeDoc"] = (a0) => (_xmlFreeDoc = Module["_xmlFreeDoc"] = wasmExports["xmlFreeDoc"])(a0);
    var _xmlXPathCompile = Module["_xmlXPathCompile"] = (a0) => (_xmlXPathCompile = Module["_xmlXPathCompile"] = wasmExports["xmlXPathCompile"])(a0);
    var _xmlXPathCompiledEval = Module["_xmlXPathCompiledEval"] = (a0, a1) => (_xmlXPathCompiledEval = Module["_xmlXPathCompiledEval"] = wasmExports["xmlXPathCompiledEval"])(a0, a1);
    var _xmlXPathFreeCompExpr = Module["_xmlXPathFreeCompExpr"] = (a0) => (_xmlXPathFreeCompExpr = Module["_xmlXPathFreeCompExpr"] = wasmExports["xmlXPathFreeCompExpr"])(a0);
    var _xmlStrdup = Module["_xmlStrdup"] = (a0) => (_xmlStrdup = Module["_xmlStrdup"] = wasmExports["xmlStrdup"])(a0);
    var _initArrayResult = Module["_initArrayResult"] = (a0, a1, a2) => (_initArrayResult = Module["_initArrayResult"] = wasmExports["initArrayResult"])(a0, a1, a2);
    var _xmlXPathCastNodeToString = Module["_xmlXPathCastNodeToString"] = (a0) => (_xmlXPathCastNodeToString = Module["_xmlXPathCastNodeToString"] = wasmExports["xmlXPathCastNodeToString"])(a0);
    var _str_tolower = Module["_str_tolower"] = (a0, a1, a2) => (_str_tolower = Module["_str_tolower"] = wasmExports["str_tolower"])(a0, a1, a2);
    var _GetSysCacheHashValue = Module["_GetSysCacheHashValue"] = (a0, a1, a2, a3, a4) => (_GetSysCacheHashValue = Module["_GetSysCacheHashValue"] = wasmExports["GetSysCacheHashValue"])(a0, a1, a2, a3, a4);
    var ___multi3 = Module["___multi3"] = (a0, a1, a2, a3, a4) => (___multi3 = Module["___multi3"] = wasmExports["__multi3"])(a0, a1, a2, a3, a4);
    var _expand_array = Module["_expand_array"] = (a0, a1, a2) => (_expand_array = Module["_expand_array"] = wasmExports["expand_array"])(a0, a1, a2);
    var _generic_restriction_selectivity = Module["_generic_restriction_selectivity"] = (a0, a1, a2, a3, a4, a5) => (_generic_restriction_selectivity = Module["_generic_restriction_selectivity"] = wasmExports["generic_restriction_selectivity"])(a0, a1, a2, a3, a4, a5);
    var _bms_membership = Module["_bms_membership"] = (a0) => (_bms_membership = Module["_bms_membership"] = wasmExports["bms_membership"])(a0);
    var _find_join_rel = Module["_find_join_rel"] = (a0, a1) => (_find_join_rel = Module["_find_join_rel"] = wasmExports["find_join_rel"])(a0, a1);
    var _bms_is_subset = Module["_bms_is_subset"] = (a0, a1) => (_bms_is_subset = Module["_bms_is_subset"] = wasmExports["bms_is_subset"])(a0, a1);
    var _estimate_num_groups = Module["_estimate_num_groups"] = (a0, a1, a2, a3, a4) => (_estimate_num_groups = Module["_estimate_num_groups"] = wasmExports["estimate_num_groups"])(a0, a1, a2, a3, a4);
    var _pull_var_clause = Module["_pull_var_clause"] = (a0, a1) => (_pull_var_clause = Module["_pull_var_clause"] = wasmExports["pull_var_clause"])(a0, a1);
    var _genericcostestimate = Module["_genericcostestimate"] = (a0, a1, a2, a3) => (_genericcostestimate = Module["_genericcostestimate"] = wasmExports["genericcostestimate"])(a0, a1, a2, a3);
    var _clauselist_selectivity = Module["_clauselist_selectivity"] = (a0, a1, a2, a3, a4) => (_clauselist_selectivity = Module["_clauselist_selectivity"] = wasmExports["clauselist_selectivity"])(a0, a1, a2, a3, a4);
    var _get_tablespace_page_costs = Module["_get_tablespace_page_costs"] = (a0, a1, a2) => (_get_tablespace_page_costs = Module["_get_tablespace_page_costs"] = wasmExports["get_tablespace_page_costs"])(a0, a1, a2);
    var _numeric_float8_no_overflow = Module["_numeric_float8_no_overflow"] = (a0) => (_numeric_float8_no_overflow = Module["_numeric_float8_no_overflow"] = wasmExports["numeric_float8_no_overflow"])(a0);
    var _array_create_iterator = Module["_array_create_iterator"] = (a0, a1, a2) => (_array_create_iterator = Module["_array_create_iterator"] = wasmExports["array_create_iterator"])(a0, a1, a2);
    var _array_iterate = Module["_array_iterate"] = (a0, a1, a2) => (_array_iterate = Module["_array_iterate"] = wasmExports["array_iterate"])(a0, a1, a2);
    var _transformExpr = Module["_transformExpr"] = (a0, a1, a2) => (_transformExpr = Module["_transformExpr"] = wasmExports["transformExpr"])(a0, a1, a2);
    var _numeric_is_nan = Module["_numeric_is_nan"] = (a0) => (_numeric_is_nan = Module["_numeric_is_nan"] = wasmExports["numeric_is_nan"])(a0);
    var _get_attname = Module["_get_attname"] = (a0, a1, a2) => (_get_attname = Module["_get_attname"] = wasmExports["get_attname"])(a0, a1, a2);
    var _pg_get_indexdef_columns_extended = Module["_pg_get_indexdef_columns_extended"] = (a0, a1) => (_pg_get_indexdef_columns_extended = Module["_pg_get_indexdef_columns_extended"] = wasmExports["pg_get_indexdef_columns_extended"])(a0, a1);
    var _RelationIsVisible = Module["_RelationIsVisible"] = (a0) => (_RelationIsVisible = Module["_RelationIsVisible"] = wasmExports["RelationIsVisible"])(a0);
    var _exprIsLengthCoercion = Module["_exprIsLengthCoercion"] = (a0, a1) => (_exprIsLengthCoercion = Module["_exprIsLengthCoercion"] = wasmExports["exprIsLengthCoercion"])(a0, a1);
    var _get_sortgroupref_tle = Module["_get_sortgroupref_tle"] = (a0, a1) => (_get_sortgroupref_tle = Module["_get_sortgroupref_tle"] = wasmExports["get_sortgroupref_tle"])(a0, a1);
    var _strrchr = Module["_strrchr"] = (a0, a1) => (_strrchr = Module["_strrchr"] = wasmExports["strrchr"])(a0, a1);
    var _get_rel_relispartition = Module["_get_rel_relispartition"] = (a0) => (_get_rel_relispartition = Module["_get_rel_relispartition"] = wasmExports["get_rel_relispartition"])(a0);
    var _scanner_isspace = Module["_scanner_isspace"] = (a0) => (_scanner_isspace = Module["_scanner_isspace"] = wasmExports["scanner_isspace"])(a0);
    var _varstr_levenshtein = Module["_varstr_levenshtein"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_varstr_levenshtein = Module["_varstr_levenshtein"] = wasmExports["varstr_levenshtein"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _varstr_levenshtein_less_equal = Module["_varstr_levenshtein_less_equal"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_varstr_levenshtein_less_equal = Module["_varstr_levenshtein_less_equal"] = wasmExports["varstr_levenshtein_less_equal"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _utf8_to_unicode = Module["_utf8_to_unicode"] = (a0) => (_utf8_to_unicode = Module["_utf8_to_unicode"] = wasmExports["utf8_to_unicode"])(a0);
    var _unpack_sql_state = Module["_unpack_sql_state"] = (a0) => (_unpack_sql_state = Module["_unpack_sql_state"] = wasmExports["unpack_sql_state"])(a0);
    var _get_role_oid = Module["_get_role_oid"] = (a0, a1) => (_get_role_oid = Module["_get_role_oid"] = wasmExports["get_role_oid"])(a0, a1);
    var _NameListToString = Module["_NameListToString"] = (a0) => (_NameListToString = Module["_NameListToString"] = wasmExports["NameListToString"])(a0);
    var _get_collation_oid = Module["_get_collation_oid"] = (a0, a1) => (_get_collation_oid = Module["_get_collation_oid"] = wasmExports["get_collation_oid"])(a0, a1);
    var _path_is_prefix_of_path = Module["_path_is_prefix_of_path"] = (a0, a1) => (_path_is_prefix_of_path = Module["_path_is_prefix_of_path"] = wasmExports["path_is_prefix_of_path"])(a0, a1);
    var _path_is_relative_and_below_cwd = Module["_path_is_relative_and_below_cwd"] = (a0) => (_path_is_relative_and_below_cwd = Module["_path_is_relative_and_below_cwd"] = wasmExports["path_is_relative_and_below_cwd"])(a0);
    var _setenv = Module["_setenv"] = (a0, a1, a2) => (_setenv = Module["_setenv"] = wasmExports["setenv"])(a0, a1, a2);
    var _pg_get_encoding_from_locale = Module["_pg_get_encoding_from_locale"] = (a0, a1) => (_pg_get_encoding_from_locale = Module["_pg_get_encoding_from_locale"] = wasmExports["pg_get_encoding_from_locale"])(a0, a1);
    var _localtime = Module["_localtime"] = (a0) => (_localtime = Module["_localtime"] = wasmExports["localtime"])(a0);
    var _strftime = Module["_strftime"] = (a0, a1, a2, a3) => (_strftime = Module["_strftime"] = wasmExports["strftime"])(a0, a1, a2, a3);
    var _get_extension_oid = Module["_get_extension_oid"] = (a0, a1) => (_get_extension_oid = Module["_get_extension_oid"] = wasmExports["get_extension_oid"])(a0, a1);
    var _IsValidJsonNumber = Module["_IsValidJsonNumber"] = (a0, a1) => (_IsValidJsonNumber = Module["_IsValidJsonNumber"] = wasmExports["IsValidJsonNumber"])(a0, a1);
    var _strlcat = Module["_strlcat"] = (a0, a1, a2) => (_strlcat = Module["_strlcat"] = wasmExports["strlcat"])(a0, a1, a2);
    var _pg_bindtextdomain = Module["_pg_bindtextdomain"] = (a0) => (_pg_bindtextdomain = Module["_pg_bindtextdomain"] = wasmExports["pg_bindtextdomain"])(a0);
    var _CacheRegisterRelcacheCallback = Module["_CacheRegisterRelcacheCallback"] = (a0, a1) => (_CacheRegisterRelcacheCallback = Module["_CacheRegisterRelcacheCallback"] = wasmExports["CacheRegisterRelcacheCallback"])(a0, a1);
    var _CachedPlanAllowsSimpleValidityCheck = Module["_CachedPlanAllowsSimpleValidityCheck"] = (a0, a1, a2) => (_CachedPlanAllowsSimpleValidityCheck = Module["_CachedPlanAllowsSimpleValidityCheck"] = wasmExports["CachedPlanAllowsSimpleValidityCheck"])(a0, a1, a2);
    var _CachedPlanIsSimplyValid = Module["_CachedPlanIsSimplyValid"] = (a0, a1, a2) => (_CachedPlanIsSimplyValid = Module["_CachedPlanIsSimplyValid"] = wasmExports["CachedPlanIsSimplyValid"])(a0, a1, a2);
    var _GetCachedExpression = Module["_GetCachedExpression"] = (a0) => (_GetCachedExpression = Module["_GetCachedExpression"] = wasmExports["GetCachedExpression"])(a0);
    var _FreeCachedExpression = Module["_FreeCachedExpression"] = (a0) => (_FreeCachedExpression = Module["_FreeCachedExpression"] = wasmExports["FreeCachedExpression"])(a0);
    var _SearchSysCacheAttName = Module["_SearchSysCacheAttName"] = (a0, a1) => (_SearchSysCacheAttName = Module["_SearchSysCacheAttName"] = wasmExports["SearchSysCacheAttName"])(a0, a1);
    var _get_func_namespace = Module["_get_func_namespace"] = (a0) => (_get_func_namespace = Module["_get_func_namespace"] = wasmExports["get_func_namespace"])(a0);
    var _get_rel_type_id = Module["_get_rel_type_id"] = (a0) => (_get_rel_type_id = Module["_get_rel_type_id"] = wasmExports["get_rel_type_id"])(a0);
    var _get_typsubscript = Module["_get_typsubscript"] = (a0, a1) => (_get_typsubscript = Module["_get_typsubscript"] = wasmExports["get_typsubscript"])(a0, a1);
    var _is_publishable_relation = Module["_is_publishable_relation"] = (a0) => (_is_publishable_relation = Module["_is_publishable_relation"] = wasmExports["is_publishable_relation"])(a0);
    var _GetRelationPublications = Module["_GetRelationPublications"] = (a0) => (_GetRelationPublications = Module["_GetRelationPublications"] = wasmExports["GetRelationPublications"])(a0);
    var _GetSchemaPublications = Module["_GetSchemaPublications"] = (a0) => (_GetSchemaPublications = Module["_GetSchemaPublications"] = wasmExports["GetSchemaPublications"])(a0);
    var _in_error_recursion_trouble = Module["_in_error_recursion_trouble"] = () => (_in_error_recursion_trouble = Module["_in_error_recursion_trouble"] = wasmExports["in_error_recursion_trouble"])();
    var _getinternalerrposition = Module["_getinternalerrposition"] = () => (_getinternalerrposition = Module["_getinternalerrposition"] = wasmExports["getinternalerrposition"])();
    var _FreeErrorData = Module["_FreeErrorData"] = (a0) => (_FreeErrorData = Module["_FreeErrorData"] = wasmExports["FreeErrorData"])(a0);
    var _GetErrorContextStack = Module["_GetErrorContextStack"] = () => (_GetErrorContextStack = Module["_GetErrorContextStack"] = wasmExports["GetErrorContextStack"])();
    var _scanner_init = Module["_scanner_init"] = (a0, a1, a2, a3) => (_scanner_init = Module["_scanner_init"] = wasmExports["scanner_init"])(a0, a1, a2, a3);
    var _scanner_finish = Module["_scanner_finish"] = (a0) => (_scanner_finish = Module["_scanner_finish"] = wasmExports["scanner_finish"])(a0);
    var _core_yylex = Module["_core_yylex"] = (a0, a1, a2) => (_core_yylex = Module["_core_yylex"] = wasmExports["core_yylex"])(a0, a1, a2);
    var _LookupTypeName = Module["_LookupTypeName"] = (a0, a1, a2, a3) => (_LookupTypeName = Module["_LookupTypeName"] = wasmExports["LookupTypeName"])(a0, a1, a2, a3);
    var _typeStringToTypeName = Module["_typeStringToTypeName"] = (a0, a1) => (_typeStringToTypeName = Module["_typeStringToTypeName"] = wasmExports["typeStringToTypeName"])(a0, a1);
    var _makeTypeNameFromNameList = Module["_makeTypeNameFromNameList"] = (a0) => (_makeTypeNameFromNameList = Module["_makeTypeNameFromNameList"] = wasmExports["makeTypeNameFromNameList"])(a0);
    var _makeBoolean = Module["_makeBoolean"] = (a0) => (_makeBoolean = Module["_makeBoolean"] = wasmExports["makeBoolean"])(a0);
    var _makeInteger = Module["_makeInteger"] = (a0) => (_makeInteger = Module["_makeInteger"] = wasmExports["makeInteger"])(a0);
    var _makeTypeName = Module["_makeTypeName"] = (a0) => (_makeTypeName = Module["_makeTypeName"] = wasmExports["makeTypeName"])(a0);
    var _list_make4_impl = Module["_list_make4_impl"] = (a0, a1, a2, a3, a4) => (_list_make4_impl = Module["_list_make4_impl"] = wasmExports["list_make4_impl"])(a0, a1, a2, a3, a4);
    var _list_member = Module["_list_member"] = (a0, a1) => (_list_member = Module["_list_member"] = wasmExports["list_member"])(a0, a1);
    var _SignalHandlerForConfigReload = Module["_SignalHandlerForConfigReload"] = (a0) => (_SignalHandlerForConfigReload = Module["_SignalHandlerForConfigReload"] = wasmExports["SignalHandlerForConfigReload"])(a0);
    var _SignalHandlerForShutdownRequest = Module["_SignalHandlerForShutdownRequest"] = (a0) => (_SignalHandlerForShutdownRequest = Module["_SignalHandlerForShutdownRequest"] = wasmExports["SignalHandlerForShutdownRequest"])(a0);
    var _send = Module["_send"] = (a0, a1, a2, a3) => (_send = Module["_send"] = wasmExports["send"])(a0, a1, a2, a3);
    var _gai_strerror = Module["_gai_strerror"] = (a0) => (_gai_strerror = Module["_gai_strerror"] = wasmExports["gai_strerror"])(a0);
    var _RegisterBackgroundWorker = Module["_RegisterBackgroundWorker"] = (a0) => (_RegisterBackgroundWorker = Module["_RegisterBackgroundWorker"] = wasmExports["RegisterBackgroundWorker"])(a0);
    var _WaitForBackgroundWorkerStartup = Module["_WaitForBackgroundWorkerStartup"] = (a0, a1) => (_WaitForBackgroundWorkerStartup = Module["_WaitForBackgroundWorkerStartup"] = wasmExports["WaitForBackgroundWorkerStartup"])(a0, a1);
    var _pg_initdb = Module["_pg_initdb"] = () => (_pg_initdb = Module["_pg_initdb"] = wasmExports["pg_initdb"])();
    var _pg_initdb_main = Module["_pg_initdb_main"] = () => (_pg_initdb_main = Module["_pg_initdb_main"] = wasmExports["pg_initdb_main"])();
    var ___cxa_throw = Module["___cxa_throw"] = (a0, a1, a2) => (___cxa_throw = Module["___cxa_throw"] = wasmExports["__cxa_throw"])(a0, a1, a2);
    var _main_repl = Module["_main_repl"] = () => (_main_repl = Module["_main_repl"] = wasmExports["main_repl"])();
    var _main = Module["_main"] = (a0, a1) => (_main = Module["_main"] = wasmExports["__main_argc_argv"])(a0, a1);
    var _list_make5_impl = Module["_list_make5_impl"] = (a0, a1, a2, a3, a4, a5) => (_list_make5_impl = Module["_list_make5_impl"] = wasmExports["list_make5_impl"])(a0, a1, a2, a3, a4, a5);
    var _lappend_xid = Module["_lappend_xid"] = (a0, a1) => (_lappend_xid = Module["_lappend_xid"] = wasmExports["lappend_xid"])(a0, a1);
    var _list_member_ptr = Module["_list_member_ptr"] = (a0, a1) => (_list_member_ptr = Module["_list_member_ptr"] = wasmExports["list_member_ptr"])(a0, a1);
    var _list_member_xid = Module["_list_member_xid"] = (a0, a1) => (_list_member_xid = Module["_list_member_xid"] = wasmExports["list_member_xid"])(a0, a1);
    var _list_append_unique_ptr = Module["_list_append_unique_ptr"] = (a0, a1) => (_list_append_unique_ptr = Module["_list_append_unique_ptr"] = wasmExports["list_append_unique_ptr"])(a0, a1);
    var _CleanQuerytext = Module["_CleanQuerytext"] = (a0, a1, a2) => (_CleanQuerytext = Module["_CleanQuerytext"] = wasmExports["CleanQuerytext"])(a0, a1, a2);
    var _EnableQueryId = Module["_EnableQueryId"] = () => (_EnableQueryId = Module["_EnableQueryId"] = wasmExports["EnableQueryId"])();
    var _make_orclause = Module["_make_orclause"] = (a0) => (_make_orclause = Module["_make_orclause"] = wasmExports["make_orclause"])(a0);
    var _join_clause_is_movable_to = Module["_join_clause_is_movable_to"] = (a0, a1) => (_join_clause_is_movable_to = Module["_join_clause_is_movable_to"] = wasmExports["join_clause_is_movable_to"])(a0, a1);
    var _make_restrictinfo = Module["_make_restrictinfo"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_make_restrictinfo = Module["_make_restrictinfo"] = wasmExports["make_restrictinfo"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _get_plan_rowmark = Module["_get_plan_rowmark"] = (a0, a1) => (_get_plan_rowmark = Module["_get_plan_rowmark"] = wasmExports["get_plan_rowmark"])(a0, a1);
    var _add_row_identity_var = Module["_add_row_identity_var"] = (a0, a1, a2, a3) => (_add_row_identity_var = Module["_add_row_identity_var"] = wasmExports["add_row_identity_var"])(a0, a1, a2, a3);
    var _get_rel_all_updated_cols = Module["_get_rel_all_updated_cols"] = (a0, a1) => (_get_rel_all_updated_cols = Module["_get_rel_all_updated_cols"] = wasmExports["get_rel_all_updated_cols"])(a0, a1);
    var _get_baserel_parampathinfo = Module["_get_baserel_parampathinfo"] = (a0, a1, a2) => (_get_baserel_parampathinfo = Module["_get_baserel_parampathinfo"] = wasmExports["get_baserel_parampathinfo"])(a0, a1, a2);
    var _tlist_member = Module["_tlist_member"] = (a0, a1) => (_tlist_member = Module["_tlist_member"] = wasmExports["tlist_member"])(a0, a1);
    var _add_to_flat_tlist = Module["_add_to_flat_tlist"] = (a0, a1) => (_add_to_flat_tlist = Module["_add_to_flat_tlist"] = wasmExports["add_to_flat_tlist"])(a0, a1);
    var _get_sortgrouplist_exprs = Module["_get_sortgrouplist_exprs"] = (a0, a1) => (_get_sortgrouplist_exprs = Module["_get_sortgrouplist_exprs"] = wasmExports["get_sortgrouplist_exprs"])(a0, a1);
    var _get_sortgroupref_clause_noerr = Module["_get_sortgroupref_clause_noerr"] = (a0, a1) => (_get_sortgroupref_clause_noerr = Module["_get_sortgroupref_clause_noerr"] = wasmExports["get_sortgroupref_clause_noerr"])(a0, a1);
    var _grouping_is_sortable = Module["_grouping_is_sortable"] = (a0) => (_grouping_is_sortable = Module["_grouping_is_sortable"] = wasmExports["grouping_is_sortable"])(a0);
    var _copy_pathtarget = Module["_copy_pathtarget"] = (a0) => (_copy_pathtarget = Module["_copy_pathtarget"] = wasmExports["copy_pathtarget"])(a0);
    var _add_new_columns_to_pathtarget = Module["_add_new_columns_to_pathtarget"] = (a0, a1) => (_add_new_columns_to_pathtarget = Module["_add_new_columns_to_pathtarget"] = wasmExports["add_new_columns_to_pathtarget"])(a0, a1);
    var _get_translated_update_targetlist = Module["_get_translated_update_targetlist"] = (a0, a1, a2, a3) => (_get_translated_update_targetlist = Module["_get_translated_update_targetlist"] = wasmExports["get_translated_update_targetlist"])(a0, a1, a2, a3);
    var _contain_mutable_functions = Module["_contain_mutable_functions"] = (a0) => (_contain_mutable_functions = Module["_contain_mutable_functions"] = wasmExports["contain_mutable_functions"])(a0);
    var _cost_qual_eval = Module["_cost_qual_eval"] = (a0, a1, a2) => (_cost_qual_eval = Module["_cost_qual_eval"] = wasmExports["cost_qual_eval"])(a0, a1, a2);
    var _add_path = Module["_add_path"] = (a0, a1) => (_add_path = Module["_add_path"] = wasmExports["add_path"])(a0, a1);
    var _pathkeys_contained_in = Module["_pathkeys_contained_in"] = (a0, a1) => (_pathkeys_contained_in = Module["_pathkeys_contained_in"] = wasmExports["pathkeys_contained_in"])(a0, a1);
    var _cost_sort = Module["_cost_sort"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_cost_sort = Module["_cost_sort"] = wasmExports["cost_sort"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _create_foreignscan_path = Module["_create_foreignscan_path"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_create_foreignscan_path = Module["_create_foreignscan_path"] = wasmExports["create_foreignscan_path"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _create_foreign_join_path = Module["_create_foreign_join_path"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_create_foreign_join_path = Module["_create_foreign_join_path"] = wasmExports["create_foreign_join_path"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _create_foreign_upper_path = Module["_create_foreign_upper_path"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_create_foreign_upper_path = Module["_create_foreign_upper_path"] = wasmExports["create_foreign_upper_path"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _create_projection_path = Module["_create_projection_path"] = (a0, a1, a2, a3) => (_create_projection_path = Module["_create_projection_path"] = wasmExports["create_projection_path"])(a0, a1, a2, a3);
    var _create_sort_path = Module["_create_sort_path"] = (a0, a1, a2, a3, a4) => (_create_sort_path = Module["_create_sort_path"] = wasmExports["create_sort_path"])(a0, a1, a2, a3, a4);
    var _adjust_limit_rows_costs = Module["_adjust_limit_rows_costs"] = (a0, a1, a2, a3, a4) => (_adjust_limit_rows_costs = Module["_adjust_limit_rows_costs"] = wasmExports["adjust_limit_rows_costs"])(a0, a1, a2, a3, a4);
    var _extract_actual_clauses = Module["_extract_actual_clauses"] = (a0, a1) => (_extract_actual_clauses = Module["_extract_actual_clauses"] = wasmExports["extract_actual_clauses"])(a0, a1);
    var _get_agg_clause_costs = Module["_get_agg_clause_costs"] = (a0, a1, a2) => (_get_agg_clause_costs = Module["_get_agg_clause_costs"] = wasmExports["get_agg_clause_costs"])(a0, a1, a2);
    var _update_mergeclause_eclasses = Module["_update_mergeclause_eclasses"] = (a0, a1) => (_update_mergeclause_eclasses = Module["_update_mergeclause_eclasses"] = wasmExports["update_mergeclause_eclasses"])(a0, a1);
    var _set_baserel_size_estimates = Module["_set_baserel_size_estimates"] = (a0, a1) => (_set_baserel_size_estimates = Module["_set_baserel_size_estimates"] = wasmExports["set_baserel_size_estimates"])(a0, a1);
    var _make_canonical_pathkey = Module["_make_canonical_pathkey"] = (a0, a1, a2, a3, a4) => (_make_canonical_pathkey = Module["_make_canonical_pathkey"] = wasmExports["make_canonical_pathkey"])(a0, a1, a2, a3, a4);
    var _eclass_useful_for_merging = Module["_eclass_useful_for_merging"] = (a0, a1, a2) => (_eclass_useful_for_merging = Module["_eclass_useful_for_merging"] = wasmExports["eclass_useful_for_merging"])(a0, a1, a2);
    var _generate_implied_equalities_for_column = Module["_generate_implied_equalities_for_column"] = (a0, a1, a2, a3, a4) => (_generate_implied_equalities_for_column = Module["_generate_implied_equalities_for_column"] = wasmExports["generate_implied_equalities_for_column"])(a0, a1, a2, a3, a4);
    var _standard_planner = Module["_standard_planner"] = (a0, a1, a2, a3) => (_standard_planner = Module["_standard_planner"] = wasmExports["standard_planner"])(a0, a1, a2, a3);
    var _plan_create_index_workers = Module["_plan_create_index_workers"] = (a0, a1) => (_plan_create_index_workers = Module["_plan_create_index_workers"] = wasmExports["plan_create_index_workers"])(a0, a1);
    var _change_plan_targetlist = Module["_change_plan_targetlist"] = (a0, a1, a2) => (_change_plan_targetlist = Module["_change_plan_targetlist"] = wasmExports["change_plan_targetlist"])(a0, a1, a2);
    var _make_foreignscan = Module["_make_foreignscan"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_make_foreignscan = Module["_make_foreignscan"] = wasmExports["make_foreignscan"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _BeginCopyFrom = Module["_BeginCopyFrom"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_BeginCopyFrom = Module["_BeginCopyFrom"] = wasmExports["BeginCopyFrom"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _EndCopyFrom = Module["_EndCopyFrom"] = (a0) => (_EndCopyFrom = Module["_EndCopyFrom"] = wasmExports["EndCopyFrom"])(a0);
    var _ProcessCopyOptions = Module["_ProcessCopyOptions"] = (a0, a1, a2, a3) => (_ProcessCopyOptions = Module["_ProcessCopyOptions"] = wasmExports["ProcessCopyOptions"])(a0, a1, a2, a3);
    var _NextCopyFrom = Module["_NextCopyFrom"] = (a0, a1, a2, a3) => (_NextCopyFrom = Module["_NextCopyFrom"] = wasmExports["NextCopyFrom"])(a0, a1, a2, a3);
    var _defGetStreamingMode = Module["_defGetStreamingMode"] = (a0) => (_defGetStreamingMode = Module["_defGetStreamingMode"] = wasmExports["defGetStreamingMode"])(a0);
    var _plain_crypt_verify = Module["_plain_crypt_verify"] = (a0, a1, a2, a3) => (_plain_crypt_verify = Module["_plain_crypt_verify"] = wasmExports["plain_crypt_verify"])(a0, a1, a2, a3);
    var _getExtensionOfObject = Module["_getExtensionOfObject"] = (a0, a1) => (_getExtensionOfObject = Module["_getExtensionOfObject"] = wasmExports["getExtensionOfObject"])(a0, a1);
    var _nextval = Module["_nextval"] = (a0) => (_nextval = Module["_nextval"] = wasmExports["nextval"])(a0);
    var _CopyFromErrorCallback = Module["_CopyFromErrorCallback"] = (a0) => (_CopyFromErrorCallback = Module["_CopyFromErrorCallback"] = wasmExports["CopyFromErrorCallback"])(a0);
    var _GetTopMostAncestorInPublication = Module["_GetTopMostAncestorInPublication"] = (a0, a1, a2) => (_GetTopMostAncestorInPublication = Module["_GetTopMostAncestorInPublication"] = wasmExports["GetTopMostAncestorInPublication"])(a0, a1, a2);
    var _pub_collist_to_bitmapset = Module["_pub_collist_to_bitmapset"] = (a0, a1, a2) => (_pub_collist_to_bitmapset = Module["_pub_collist_to_bitmapset"] = wasmExports["pub_collist_to_bitmapset"])(a0, a1, a2);
    var _ExplainBeginOutput = Module["_ExplainBeginOutput"] = (a0) => (_ExplainBeginOutput = Module["_ExplainBeginOutput"] = wasmExports["ExplainBeginOutput"])(a0);
    var _NewExplainState = Module["_NewExplainState"] = () => (_NewExplainState = Module["_NewExplainState"] = wasmExports["NewExplainState"])();
    var _ExplainEndOutput = Module["_ExplainEndOutput"] = (a0) => (_ExplainEndOutput = Module["_ExplainEndOutput"] = wasmExports["ExplainEndOutput"])(a0);
    var _ExplainPrintPlan = Module["_ExplainPrintPlan"] = (a0, a1) => (_ExplainPrintPlan = Module["_ExplainPrintPlan"] = wasmExports["ExplainPrintPlan"])(a0, a1);
    var _ExplainPrintTriggers = Module["_ExplainPrintTriggers"] = (a0, a1) => (_ExplainPrintTriggers = Module["_ExplainPrintTriggers"] = wasmExports["ExplainPrintTriggers"])(a0, a1);
    var _ExplainPrintJITSummary = Module["_ExplainPrintJITSummary"] = (a0, a1) => (_ExplainPrintJITSummary = Module["_ExplainPrintJITSummary"] = wasmExports["ExplainPrintJITSummary"])(a0, a1);
    var _ExplainPropertyInteger = Module["_ExplainPropertyInteger"] = (a0, a1, a2, a3) => (_ExplainPropertyInteger = Module["_ExplainPropertyInteger"] = wasmExports["ExplainPropertyInteger"])(a0, a1, a2, a3);
    var _ExplainQueryText = Module["_ExplainQueryText"] = (a0, a1) => (_ExplainQueryText = Module["_ExplainQueryText"] = wasmExports["ExplainQueryText"])(a0, a1);
    var _ExplainPropertyText = Module["_ExplainPropertyText"] = (a0, a1, a2) => (_ExplainPropertyText = Module["_ExplainPropertyText"] = wasmExports["ExplainPropertyText"])(a0, a1, a2);
    var _ExplainQueryParameters = Module["_ExplainQueryParameters"] = (a0, a1, a2) => (_ExplainQueryParameters = Module["_ExplainQueryParameters"] = wasmExports["ExplainQueryParameters"])(a0, a1, a2);
    var _pg_is_ascii = Module["_pg_is_ascii"] = (a0) => (_pg_is_ascii = Module["_pg_is_ascii"] = wasmExports["pg_is_ascii"])(a0);
    var _pg_md5_encrypt = Module["_pg_md5_encrypt"] = (a0, a1, a2, a3, a4) => (_pg_md5_encrypt = Module["_pg_md5_encrypt"] = wasmExports["pg_md5_encrypt"])(a0, a1, a2, a3, a4);
    var _explicit_bzero = Module["_explicit_bzero"] = (a0, a1) => (_explicit_bzero = Module["_explicit_bzero"] = wasmExports["explicit_bzero"])(a0, a1);
    var _pg_strip_crlf = Module["_pg_strip_crlf"] = (a0) => (_pg_strip_crlf = Module["_pg_strip_crlf"] = wasmExports["pg_strip_crlf"])(a0);
    var _recv = Module["_recv"] = (a0, a1, a2, a3) => (_recv = Module["_recv"] = wasmExports["recv"])(a0, a1, a2, a3);
    var _pg_getaddrinfo_all = Module["_pg_getaddrinfo_all"] = (a0, a1, a2, a3) => (_pg_getaddrinfo_all = Module["_pg_getaddrinfo_all"] = wasmExports["pg_getaddrinfo_all"])(a0, a1, a2, a3);
    var _pg_freeaddrinfo_all = Module["_pg_freeaddrinfo_all"] = (a0, a1) => (_pg_freeaddrinfo_all = Module["_pg_freeaddrinfo_all"] = wasmExports["pg_freeaddrinfo_all"])(a0, a1);
    var _sigemptyset = Module["_sigemptyset"] = (a0) => (_sigemptyset = Module["_sigemptyset"] = wasmExports["sigemptyset"])(a0);
    var _getpeereid = Module["_getpeereid"] = (a0, a1, a2) => (_getpeereid = Module["_getpeereid"] = wasmExports["getpeereid"])(a0, a1, a2);
    var _socket = Module["_socket"] = (a0, a1, a2) => (_socket = Module["_socket"] = wasmExports["socket"])(a0, a1, a2);
    var _connect = Module["_connect"] = (a0, a1, a2) => (_connect = Module["_connect"] = wasmExports["connect"])(a0, a1, a2);
    var _setsockopt = Module["_setsockopt"] = (a0, a1, a2, a3, a4) => (_setsockopt = Module["_setsockopt"] = wasmExports["setsockopt"])(a0, a1, a2, a3, a4);
    var _getsockname = Module["_getsockname"] = (a0, a1, a2) => (_getsockname = Module["_getsockname"] = wasmExports["getsockname"])(a0, a1, a2);
    var _getsockopt = Module["_getsockopt"] = (a0, a1, a2, a3, a4) => (_getsockopt = Module["_getsockopt"] = wasmExports["getsockopt"])(a0, a1, a2, a3, a4);
    var _pg_b64_enc_len = Module["_pg_b64_enc_len"] = (a0) => (_pg_b64_enc_len = Module["_pg_b64_enc_len"] = wasmExports["pg_b64_enc_len"])(a0);
    var _pg_b64_encode = Module["_pg_b64_encode"] = (a0, a1, a2, a3) => (_pg_b64_encode = Module["_pg_b64_encode"] = wasmExports["pg_b64_encode"])(a0, a1, a2, a3);
    var _pg_b64_dec_len = Module["_pg_b64_dec_len"] = (a0) => (_pg_b64_dec_len = Module["_pg_b64_dec_len"] = wasmExports["pg_b64_dec_len"])(a0);
    var _pg_b64_decode = Module["_pg_b64_decode"] = (a0, a1, a2, a3) => (_pg_b64_decode = Module["_pg_b64_decode"] = wasmExports["pg_b64_decode"])(a0, a1, a2, a3);
    var _pg_hmac_create = Module["_pg_hmac_create"] = (a0) => (_pg_hmac_create = Module["_pg_hmac_create"] = wasmExports["pg_hmac_create"])(a0);
    var _pg_hmac_init = Module["_pg_hmac_init"] = (a0, a1, a2) => (_pg_hmac_init = Module["_pg_hmac_init"] = wasmExports["pg_hmac_init"])(a0, a1, a2);
    var _pg_hmac_update = Module["_pg_hmac_update"] = (a0, a1, a2) => (_pg_hmac_update = Module["_pg_hmac_update"] = wasmExports["pg_hmac_update"])(a0, a1, a2);
    var _pg_hmac_final = Module["_pg_hmac_final"] = (a0, a1, a2) => (_pg_hmac_final = Module["_pg_hmac_final"] = wasmExports["pg_hmac_final"])(a0, a1, a2);
    var _pg_hmac_error = Module["_pg_hmac_error"] = (a0) => (_pg_hmac_error = Module["_pg_hmac_error"] = wasmExports["pg_hmac_error"])(a0);
    var _scram_H = Module["_scram_H"] = (a0, a1, a2, a3, a4) => (_scram_H = Module["_scram_H"] = wasmExports["scram_H"])(a0, a1, a2, a3, a4);
    var _pg_saslprep = Module["_pg_saslprep"] = (a0, a1) => (_pg_saslprep = Module["_pg_saslprep"] = wasmExports["pg_saslprep"])(a0, a1);
    var _scram_build_secret = Module["_scram_build_secret"] = (a0, a1, a2, a3, a4, a5, a6) => (_scram_build_secret = Module["_scram_build_secret"] = wasmExports["scram_build_secret"])(a0, a1, a2, a3, a4, a5, a6);
    var _scram_SaltedPassword = Module["_scram_SaltedPassword"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_scram_SaltedPassword = Module["_scram_SaltedPassword"] = wasmExports["scram_SaltedPassword"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _scram_ServerKey = Module["_scram_ServerKey"] = (a0, a1, a2, a3, a4) => (_scram_ServerKey = Module["_scram_ServerKey"] = wasmExports["scram_ServerKey"])(a0, a1, a2, a3, a4);
    var _logicalrep_write_begin = Module["_logicalrep_write_begin"] = (a0, a1) => (_logicalrep_write_begin = Module["_logicalrep_write_begin"] = wasmExports["logicalrep_write_begin"])(a0, a1);
    var _logicalrep_write_commit = Module["_logicalrep_write_commit"] = (a0, a1, a2) => (_logicalrep_write_commit = Module["_logicalrep_write_commit"] = wasmExports["logicalrep_write_commit"])(a0, a1, a2);
    var _logicalrep_write_begin_prepare = Module["_logicalrep_write_begin_prepare"] = (a0, a1) => (_logicalrep_write_begin_prepare = Module["_logicalrep_write_begin_prepare"] = wasmExports["logicalrep_write_begin_prepare"])(a0, a1);
    var _logicalrep_write_prepare = Module["_logicalrep_write_prepare"] = (a0, a1, a2) => (_logicalrep_write_prepare = Module["_logicalrep_write_prepare"] = wasmExports["logicalrep_write_prepare"])(a0, a1, a2);
    var _logicalrep_write_commit_prepared = Module["_logicalrep_write_commit_prepared"] = (a0, a1, a2) => (_logicalrep_write_commit_prepared = Module["_logicalrep_write_commit_prepared"] = wasmExports["logicalrep_write_commit_prepared"])(a0, a1, a2);
    var _logicalrep_write_rollback_prepared = Module["_logicalrep_write_rollback_prepared"] = (a0, a1, a2, a3) => (_logicalrep_write_rollback_prepared = Module["_logicalrep_write_rollback_prepared"] = wasmExports["logicalrep_write_rollback_prepared"])(a0, a1, a2, a3);
    var _logicalrep_write_stream_prepare = Module["_logicalrep_write_stream_prepare"] = (a0, a1, a2) => (_logicalrep_write_stream_prepare = Module["_logicalrep_write_stream_prepare"] = wasmExports["logicalrep_write_stream_prepare"])(a0, a1, a2);
    var _logicalrep_write_origin = Module["_logicalrep_write_origin"] = (a0, a1, a2) => (_logicalrep_write_origin = Module["_logicalrep_write_origin"] = wasmExports["logicalrep_write_origin"])(a0, a1, a2);
    var _logicalrep_write_insert = Module["_logicalrep_write_insert"] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_insert = Module["_logicalrep_write_insert"] = wasmExports["logicalrep_write_insert"])(a0, a1, a2, a3, a4, a5);
    var _logicalrep_write_update = Module["_logicalrep_write_update"] = (a0, a1, a2, a3, a4, a5, a6) => (_logicalrep_write_update = Module["_logicalrep_write_update"] = wasmExports["logicalrep_write_update"])(a0, a1, a2, a3, a4, a5, a6);
    var _logicalrep_write_delete = Module["_logicalrep_write_delete"] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_delete = Module["_logicalrep_write_delete"] = wasmExports["logicalrep_write_delete"])(a0, a1, a2, a3, a4, a5);
    var _logicalrep_write_truncate = Module["_logicalrep_write_truncate"] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_truncate = Module["_logicalrep_write_truncate"] = wasmExports["logicalrep_write_truncate"])(a0, a1, a2, a3, a4, a5);
    var _logicalrep_write_message = Module["_logicalrep_write_message"] = (a0, a1, a2, a3, a4, a5, a6) => (_logicalrep_write_message = Module["_logicalrep_write_message"] = wasmExports["logicalrep_write_message"])(a0, a1, a2, a3, a4, a5, a6);
    var _logicalrep_write_rel = Module["_logicalrep_write_rel"] = (a0, a1, a2, a3) => (_logicalrep_write_rel = Module["_logicalrep_write_rel"] = wasmExports["logicalrep_write_rel"])(a0, a1, a2, a3);
    var _logicalrep_write_typ = Module["_logicalrep_write_typ"] = (a0, a1, a2) => (_logicalrep_write_typ = Module["_logicalrep_write_typ"] = wasmExports["logicalrep_write_typ"])(a0, a1, a2);
    var _logicalrep_write_stream_start = Module["_logicalrep_write_stream_start"] = (a0, a1, a2) => (_logicalrep_write_stream_start = Module["_logicalrep_write_stream_start"] = wasmExports["logicalrep_write_stream_start"])(a0, a1, a2);
    var _logicalrep_write_stream_stop = Module["_logicalrep_write_stream_stop"] = (a0) => (_logicalrep_write_stream_stop = Module["_logicalrep_write_stream_stop"] = wasmExports["logicalrep_write_stream_stop"])(a0);
    var _logicalrep_write_stream_commit = Module["_logicalrep_write_stream_commit"] = (a0, a1, a2) => (_logicalrep_write_stream_commit = Module["_logicalrep_write_stream_commit"] = wasmExports["logicalrep_write_stream_commit"])(a0, a1, a2);
    var _logicalrep_write_stream_abort = Module["_logicalrep_write_stream_abort"] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_stream_abort = Module["_logicalrep_write_stream_abort"] = wasmExports["logicalrep_write_stream_abort"])(a0, a1, a2, a3, a4, a5);
    var _OutputPluginPrepareWrite = Module["_OutputPluginPrepareWrite"] = (a0, a1) => (_OutputPluginPrepareWrite = Module["_OutputPluginPrepareWrite"] = wasmExports["OutputPluginPrepareWrite"])(a0, a1);
    var _OutputPluginWrite = Module["_OutputPluginWrite"] = (a0, a1) => (_OutputPluginWrite = Module["_OutputPluginWrite"] = wasmExports["OutputPluginWrite"])(a0, a1);
    var _OutputPluginUpdateProgress = Module["_OutputPluginUpdateProgress"] = (a0, a1) => (_OutputPluginUpdateProgress = Module["_OutputPluginUpdateProgress"] = wasmExports["OutputPluginUpdateProgress"])(a0, a1);
    var _replorigin_by_oid = Module["_replorigin_by_oid"] = (a0, a1, a2) => (_replorigin_by_oid = Module["_replorigin_by_oid"] = wasmExports["replorigin_by_oid"])(a0, a1, a2);
    var _ProcessWalRcvInterrupts = Module["_ProcessWalRcvInterrupts"] = () => (_ProcessWalRcvInterrupts = Module["_ProcessWalRcvInterrupts"] = wasmExports["ProcessWalRcvInterrupts"])();
    var _PQconnectStartParams = Module["_PQconnectStartParams"] = (a0, a1, a2) => (_PQconnectStartParams = Module["_PQconnectStartParams"] = wasmExports["PQconnectStartParams"])(a0, a1, a2);
    var _PQstatus = Module["_PQstatus"] = (a0) => (_PQstatus = Module["_PQstatus"] = wasmExports["PQstatus"])(a0);
    var _PQsocket = Module["_PQsocket"] = (a0) => (_PQsocket = Module["_PQsocket"] = wasmExports["PQsocket"])(a0);
    var _PQconnectPoll = Module["_PQconnectPoll"] = (a0) => (_PQconnectPoll = Module["_PQconnectPoll"] = wasmExports["PQconnectPoll"])(a0);
    var _PQconnectionUsedPassword = Module["_PQconnectionUsedPassword"] = (a0) => (_PQconnectionUsedPassword = Module["_PQconnectionUsedPassword"] = wasmExports["PQconnectionUsedPassword"])(a0);
    var _PQfinish = Module["_PQfinish"] = (a0) => (_PQfinish = Module["_PQfinish"] = wasmExports["PQfinish"])(a0);
    var _PQresultStatus = Module["_PQresultStatus"] = (a0) => (_PQresultStatus = Module["_PQresultStatus"] = wasmExports["PQresultStatus"])(a0);
    var _PQclear = Module["_PQclear"] = (a0) => (_PQclear = Module["_PQclear"] = wasmExports["PQclear"])(a0);
    var _PQerrorMessage = Module["_PQerrorMessage"] = (a0) => (_PQerrorMessage = Module["_PQerrorMessage"] = wasmExports["PQerrorMessage"])(a0);
    var _PQnfields = Module["_PQnfields"] = (a0) => (_PQnfields = Module["_PQnfields"] = wasmExports["PQnfields"])(a0);
    var _PQntuples = Module["_PQntuples"] = (a0) => (_PQntuples = Module["_PQntuples"] = wasmExports["PQntuples"])(a0);
    var _PQgetvalue = Module["_PQgetvalue"] = (a0, a1, a2) => (_PQgetvalue = Module["_PQgetvalue"] = wasmExports["PQgetvalue"])(a0, a1, a2);
    var _PQconsumeInput = Module["_PQconsumeInput"] = (a0) => (_PQconsumeInput = Module["_PQconsumeInput"] = wasmExports["PQconsumeInput"])(a0);
    var _PQgetisnull = Module["_PQgetisnull"] = (a0, a1, a2) => (_PQgetisnull = Module["_PQgetisnull"] = wasmExports["PQgetisnull"])(a0, a1, a2);
    var _PQresultErrorField = Module["_PQresultErrorField"] = (a0, a1) => (_PQresultErrorField = Module["_PQresultErrorField"] = wasmExports["PQresultErrorField"])(a0, a1);
    var _PQsendQuery = Module["_PQsendQuery"] = (a0, a1) => (_PQsendQuery = Module["_PQsendQuery"] = wasmExports["PQsendQuery"])(a0, a1);
    var _PQisBusy = Module["_PQisBusy"] = (a0) => (_PQisBusy = Module["_PQisBusy"] = wasmExports["PQisBusy"])(a0);
    var _PQgetResult = Module["_PQgetResult"] = (a0) => (_PQgetResult = Module["_PQgetResult"] = wasmExports["PQgetResult"])(a0);
    var _RelnameGetRelid = Module["_RelnameGetRelid"] = (a0) => (_RelnameGetRelid = Module["_RelnameGetRelid"] = wasmExports["RelnameGetRelid"])(a0);
    var _GetPublicationByName = Module["_GetPublicationByName"] = (a0, a1) => (_GetPublicationByName = Module["_GetPublicationByName"] = wasmExports["GetPublicationByName"])(a0, a1);
    var _function_parse_error_transpose = Module["_function_parse_error_transpose"] = (a0) => (_function_parse_error_transpose = Module["_function_parse_error_transpose"] = wasmExports["function_parse_error_transpose"])(a0);
    var _fputs = Module["_fputs"] = (a0, a1) => (_fputs = Module["_fputs"] = wasmExports["fputs"])(a0, a1);
    var _popen = Module["_popen"] = (a0, a1) => (_popen = Module["_popen"] = wasmExports["popen"])(a0, a1);
    var _float_to_shortest_decimal_bufn = Module["_float_to_shortest_decimal_bufn"] = (a0, a1) => (_float_to_shortest_decimal_bufn = Module["_float_to_shortest_decimal_bufn"] = wasmExports["float_to_shortest_decimal_bufn"])(a0, a1);
    var _pg_prng_uint64 = Module["_pg_prng_uint64"] = (a0) => (_pg_prng_uint64 = Module["_pg_prng_uint64"] = wasmExports["pg_prng_uint64"])(a0);
    var _scram_ClientKey = Module["_scram_ClientKey"] = (a0, a1, a2, a3, a4) => (_scram_ClientKey = Module["_scram_ClientKey"] = wasmExports["scram_ClientKey"])(a0, a1, a2, a3, a4);
    var _pg_encoding_dsplen = Module["_pg_encoding_dsplen"] = (a0, a1) => (_pg_encoding_dsplen = Module["_pg_encoding_dsplen"] = wasmExports["pg_encoding_dsplen"])(a0, a1);
    var _getcwd = Module["_getcwd"] = (a0, a1) => (_getcwd = Module["_getcwd"] = wasmExports["getcwd"])(a0, a1);
    var _pg_get_user_home_dir = Module["_pg_get_user_home_dir"] = (a0, a1, a2) => (_pg_get_user_home_dir = Module["_pg_get_user_home_dir"] = wasmExports["pg_get_user_home_dir"])(a0, a1, a2);
    var _nanosleep = Module["_nanosleep"] = (a0, a1) => (_nanosleep = Module["_nanosleep"] = wasmExports["nanosleep"])(a0, a1);
    var _snprintf = Module["_snprintf"] = (a0, a1, a2, a3) => (_snprintf = Module["_snprintf"] = wasmExports["snprintf"])(a0, a1, a2, a3);
    var _pg_strerror_r = Module["_pg_strerror_r"] = (a0, a1, a2) => (_pg_strerror_r = Module["_pg_strerror_r"] = wasmExports["pg_strerror_r"])(a0, a1, a2);
    var _pthread_mutex_lock = Module["_pthread_mutex_lock"] = (a0) => (_pthread_mutex_lock = Module["_pthread_mutex_lock"] = wasmExports["pthread_mutex_lock"])(a0);
    var _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = (a0) => (_pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = wasmExports["pthread_mutex_unlock"])(a0);
    var _strncat = Module["_strncat"] = (a0, a1, a2) => (_strncat = Module["_strncat"] = wasmExports["strncat"])(a0, a1, a2);
    var _PQexec = Module["_PQexec"] = (a0, a1) => (_PQexec = Module["_PQexec"] = wasmExports["PQexec"])(a0, a1);
    var _PQsetSingleRowMode = Module["_PQsetSingleRowMode"] = (a0) => (_PQsetSingleRowMode = Module["_PQsetSingleRowMode"] = wasmExports["PQsetSingleRowMode"])(a0);
    var _PQcmdStatus = Module["_PQcmdStatus"] = (a0) => (_PQcmdStatus = Module["_PQcmdStatus"] = wasmExports["PQcmdStatus"])(a0);
    var _pthread_sigmask = Module["_pthread_sigmask"] = (a0, a1, a2) => (_pthread_sigmask = Module["_pthread_sigmask"] = wasmExports["pthread_sigmask"])(a0, a1, a2);
    var _sigismember = Module["_sigismember"] = (a0, a1) => (_sigismember = Module["_sigismember"] = wasmExports["sigismember"])(a0, a1);
    var _sigpending = Module["_sigpending"] = (a0) => (_sigpending = Module["_sigpending"] = wasmExports["sigpending"])(a0);
    var _sigwait = Module["_sigwait"] = (a0, a1) => (_sigwait = Module["_sigwait"] = wasmExports["sigwait"])(a0, a1);
    var _isolat1ToUTF8 = Module["_isolat1ToUTF8"] = (a0, a1, a2, a3) => (_isolat1ToUTF8 = Module["_isolat1ToUTF8"] = wasmExports["isolat1ToUTF8"])(a0, a1, a2, a3);
    var _UTF8Toisolat1 = Module["_UTF8Toisolat1"] = (a0, a1, a2, a3) => (_UTF8Toisolat1 = Module["_UTF8Toisolat1"] = wasmExports["UTF8Toisolat1"])(a0, a1, a2, a3);
    var _vfprintf = Module["_vfprintf"] = (a0, a1, a2) => (_vfprintf = Module["_vfprintf"] = wasmExports["vfprintf"])(a0, a1, a2);
    var _vsnprintf = Module["_vsnprintf"] = (a0, a1, a2, a3) => (_vsnprintf = Module["_vsnprintf"] = wasmExports["vsnprintf"])(a0, a1, a2, a3);
    var _xmlParserValidityWarning = Module["_xmlParserValidityWarning"] = (a0, a1, a2) => (_xmlParserValidityWarning = Module["_xmlParserValidityWarning"] = wasmExports["xmlParserValidityWarning"])(a0, a1, a2);
    var _xmlParserValidityError = Module["_xmlParserValidityError"] = (a0, a1, a2) => (_xmlParserValidityError = Module["_xmlParserValidityError"] = wasmExports["xmlParserValidityError"])(a0, a1, a2);
    var _xmlParserError = Module["_xmlParserError"] = (a0, a1, a2) => (_xmlParserError = Module["_xmlParserError"] = wasmExports["xmlParserError"])(a0, a1, a2);
    var _xmlParserWarning = Module["_xmlParserWarning"] = (a0, a1, a2) => (_xmlParserWarning = Module["_xmlParserWarning"] = wasmExports["xmlParserWarning"])(a0, a1, a2);
    var _fprintf = Module["_fprintf"] = (a0, a1, a2) => (_fprintf = Module["_fprintf"] = wasmExports["fprintf"])(a0, a1, a2);
    var ___xmlParserInputBufferCreateFilename = Module["___xmlParserInputBufferCreateFilename"] = (a0, a1) => (___xmlParserInputBufferCreateFilename = Module["___xmlParserInputBufferCreateFilename"] = wasmExports["__xmlParserInputBufferCreateFilename"])(a0, a1);
    var ___xmlOutputBufferCreateFilename = Module["___xmlOutputBufferCreateFilename"] = (a0, a1, a2) => (___xmlOutputBufferCreateFilename = Module["___xmlOutputBufferCreateFilename"] = wasmExports["__xmlOutputBufferCreateFilename"])(a0, a1, a2);
    var _xmlSAX2InternalSubset = Module["_xmlSAX2InternalSubset"] = (a0, a1, a2, a3) => (_xmlSAX2InternalSubset = Module["_xmlSAX2InternalSubset"] = wasmExports["xmlSAX2InternalSubset"])(a0, a1, a2, a3);
    var _xmlSAX2IsStandalone = Module["_xmlSAX2IsStandalone"] = (a0) => (_xmlSAX2IsStandalone = Module["_xmlSAX2IsStandalone"] = wasmExports["xmlSAX2IsStandalone"])(a0);
    var _xmlSAX2HasInternalSubset = Module["_xmlSAX2HasInternalSubset"] = (a0) => (_xmlSAX2HasInternalSubset = Module["_xmlSAX2HasInternalSubset"] = wasmExports["xmlSAX2HasInternalSubset"])(a0);
    var _xmlSAX2HasExternalSubset = Module["_xmlSAX2HasExternalSubset"] = (a0) => (_xmlSAX2HasExternalSubset = Module["_xmlSAX2HasExternalSubset"] = wasmExports["xmlSAX2HasExternalSubset"])(a0);
    var _xmlSAX2ResolveEntity = Module["_xmlSAX2ResolveEntity"] = (a0, a1, a2) => (_xmlSAX2ResolveEntity = Module["_xmlSAX2ResolveEntity"] = wasmExports["xmlSAX2ResolveEntity"])(a0, a1, a2);
    var _xmlSAX2GetEntity = Module["_xmlSAX2GetEntity"] = (a0, a1) => (_xmlSAX2GetEntity = Module["_xmlSAX2GetEntity"] = wasmExports["xmlSAX2GetEntity"])(a0, a1);
    var _xmlSAX2EntityDecl = Module["_xmlSAX2EntityDecl"] = (a0, a1, a2, a3, a4, a5) => (_xmlSAX2EntityDecl = Module["_xmlSAX2EntityDecl"] = wasmExports["xmlSAX2EntityDecl"])(a0, a1, a2, a3, a4, a5);
    var _xmlSAX2NotationDecl = Module["_xmlSAX2NotationDecl"] = (a0, a1, a2, a3) => (_xmlSAX2NotationDecl = Module["_xmlSAX2NotationDecl"] = wasmExports["xmlSAX2NotationDecl"])(a0, a1, a2, a3);
    var _xmlSAX2AttributeDecl = Module["_xmlSAX2AttributeDecl"] = (a0, a1, a2, a3, a4, a5, a6) => (_xmlSAX2AttributeDecl = Module["_xmlSAX2AttributeDecl"] = wasmExports["xmlSAX2AttributeDecl"])(a0, a1, a2, a3, a4, a5, a6);
    var _xmlSAX2ElementDecl = Module["_xmlSAX2ElementDecl"] = (a0, a1, a2, a3) => (_xmlSAX2ElementDecl = Module["_xmlSAX2ElementDecl"] = wasmExports["xmlSAX2ElementDecl"])(a0, a1, a2, a3);
    var _xmlSAX2UnparsedEntityDecl = Module["_xmlSAX2UnparsedEntityDecl"] = (a0, a1, a2, a3, a4) => (_xmlSAX2UnparsedEntityDecl = Module["_xmlSAX2UnparsedEntityDecl"] = wasmExports["xmlSAX2UnparsedEntityDecl"])(a0, a1, a2, a3, a4);
    var _xmlSAX2SetDocumentLocator = Module["_xmlSAX2SetDocumentLocator"] = (a0, a1) => (_xmlSAX2SetDocumentLocator = Module["_xmlSAX2SetDocumentLocator"] = wasmExports["xmlSAX2SetDocumentLocator"])(a0, a1);
    var _xmlSAX2StartDocument = Module["_xmlSAX2StartDocument"] = (a0) => (_xmlSAX2StartDocument = Module["_xmlSAX2StartDocument"] = wasmExports["xmlSAX2StartDocument"])(a0);
    var _xmlSAX2EndDocument = Module["_xmlSAX2EndDocument"] = (a0) => (_xmlSAX2EndDocument = Module["_xmlSAX2EndDocument"] = wasmExports["xmlSAX2EndDocument"])(a0);
    var _xmlSAX2StartElement = Module["_xmlSAX2StartElement"] = (a0, a1, a2) => (_xmlSAX2StartElement = Module["_xmlSAX2StartElement"] = wasmExports["xmlSAX2StartElement"])(a0, a1, a2);
    var _xmlSAX2EndElement = Module["_xmlSAX2EndElement"] = (a0, a1) => (_xmlSAX2EndElement = Module["_xmlSAX2EndElement"] = wasmExports["xmlSAX2EndElement"])(a0, a1);
    var _xmlSAX2Reference = Module["_xmlSAX2Reference"] = (a0, a1) => (_xmlSAX2Reference = Module["_xmlSAX2Reference"] = wasmExports["xmlSAX2Reference"])(a0, a1);
    var _xmlSAX2Characters = Module["_xmlSAX2Characters"] = (a0, a1, a2) => (_xmlSAX2Characters = Module["_xmlSAX2Characters"] = wasmExports["xmlSAX2Characters"])(a0, a1, a2);
    var _xmlSAX2ProcessingInstruction = Module["_xmlSAX2ProcessingInstruction"] = (a0, a1, a2) => (_xmlSAX2ProcessingInstruction = Module["_xmlSAX2ProcessingInstruction"] = wasmExports["xmlSAX2ProcessingInstruction"])(a0, a1, a2);
    var _xmlSAX2Comment = Module["_xmlSAX2Comment"] = (a0, a1) => (_xmlSAX2Comment = Module["_xmlSAX2Comment"] = wasmExports["xmlSAX2Comment"])(a0, a1);
    var _xmlSAX2GetParameterEntity = Module["_xmlSAX2GetParameterEntity"] = (a0, a1) => (_xmlSAX2GetParameterEntity = Module["_xmlSAX2GetParameterEntity"] = wasmExports["xmlSAX2GetParameterEntity"])(a0, a1);
    var _xmlSAX2CDataBlock = Module["_xmlSAX2CDataBlock"] = (a0, a1, a2) => (_xmlSAX2CDataBlock = Module["_xmlSAX2CDataBlock"] = wasmExports["xmlSAX2CDataBlock"])(a0, a1, a2);
    var _xmlSAX2ExternalSubset = Module["_xmlSAX2ExternalSubset"] = (a0, a1, a2, a3) => (_xmlSAX2ExternalSubset = Module["_xmlSAX2ExternalSubset"] = wasmExports["xmlSAX2ExternalSubset"])(a0, a1, a2, a3);
    var _xmlSAX2GetPublicId = Module["_xmlSAX2GetPublicId"] = (a0) => (_xmlSAX2GetPublicId = Module["_xmlSAX2GetPublicId"] = wasmExports["xmlSAX2GetPublicId"])(a0);
    var _xmlSAX2GetSystemId = Module["_xmlSAX2GetSystemId"] = (a0) => (_xmlSAX2GetSystemId = Module["_xmlSAX2GetSystemId"] = wasmExports["xmlSAX2GetSystemId"])(a0);
    var _xmlSAX2GetLineNumber = Module["_xmlSAX2GetLineNumber"] = (a0) => (_xmlSAX2GetLineNumber = Module["_xmlSAX2GetLineNumber"] = wasmExports["xmlSAX2GetLineNumber"])(a0);
    var _xmlSAX2GetColumnNumber = Module["_xmlSAX2GetColumnNumber"] = (a0) => (_xmlSAX2GetColumnNumber = Module["_xmlSAX2GetColumnNumber"] = wasmExports["xmlSAX2GetColumnNumber"])(a0);
    var _xmlSAX2IgnorableWhitespace = Module["_xmlSAX2IgnorableWhitespace"] = (a0, a1, a2) => (_xmlSAX2IgnorableWhitespace = Module["_xmlSAX2IgnorableWhitespace"] = wasmExports["xmlSAX2IgnorableWhitespace"])(a0, a1, a2);
    var _xmlHashDefaultDeallocator = Module["_xmlHashDefaultDeallocator"] = (a0, a1) => (_xmlHashDefaultDeallocator = Module["_xmlHashDefaultDeallocator"] = wasmExports["xmlHashDefaultDeallocator"])(a0, a1);
    var _iconv_open = Module["_iconv_open"] = (a0, a1) => (_iconv_open = Module["_iconv_open"] = wasmExports["iconv_open"])(a0, a1);
    var _iconv_close = Module["_iconv_close"] = (a0) => (_iconv_close = Module["_iconv_close"] = wasmExports["iconv_close"])(a0);
    var _iconv = Module["_iconv"] = (a0, a1, a2, a3, a4) => (_iconv = Module["_iconv"] = wasmExports["iconv"])(a0, a1, a2, a3, a4);
    var _UTF8ToHtml = Module["_UTF8ToHtml"] = (a0, a1, a2, a3) => (_UTF8ToHtml = Module["_UTF8ToHtml"] = wasmExports["UTF8ToHtml"])(a0, a1, a2, a3);
    var _xmlReadMemory = Module["_xmlReadMemory"] = (a0, a1, a2, a3, a4) => (_xmlReadMemory = Module["_xmlReadMemory"] = wasmExports["xmlReadMemory"])(a0, a1, a2, a3, a4);
    var _xmlSAX2StartElementNs = Module["_xmlSAX2StartElementNs"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_xmlSAX2StartElementNs = Module["_xmlSAX2StartElementNs"] = wasmExports["xmlSAX2StartElementNs"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _xmlSAX2EndElementNs = Module["_xmlSAX2EndElementNs"] = (a0, a1, a2, a3) => (_xmlSAX2EndElementNs = Module["_xmlSAX2EndElementNs"] = wasmExports["xmlSAX2EndElementNs"])(a0, a1, a2, a3);
    var ___cxa_atexit = Module["___cxa_atexit"] = (a0, a1, a2) => (___cxa_atexit = Module["___cxa_atexit"] = wasmExports["__cxa_atexit"])(a0, a1, a2);
    var _xmlDocGetRootElement = Module["_xmlDocGetRootElement"] = (a0) => (_xmlDocGetRootElement = Module["_xmlDocGetRootElement"] = wasmExports["xmlDocGetRootElement"])(a0);
    var _xmlFileMatch = Module["_xmlFileMatch"] = (a0) => (_xmlFileMatch = Module["_xmlFileMatch"] = wasmExports["xmlFileMatch"])(a0);
    var _xmlFileOpen = Module["_xmlFileOpen"] = (a0) => (_xmlFileOpen = Module["_xmlFileOpen"] = wasmExports["xmlFileOpen"])(a0);
    var _xmlFileRead = Module["_xmlFileRead"] = (a0, a1, a2) => (_xmlFileRead = Module["_xmlFileRead"] = wasmExports["xmlFileRead"])(a0, a1, a2);
    var _xmlFileClose = Module["_xmlFileClose"] = (a0) => (_xmlFileClose = Module["_xmlFileClose"] = wasmExports["xmlFileClose"])(a0);
    var _gzread = Module["_gzread"] = (a0, a1, a2) => (_gzread = Module["_gzread"] = wasmExports["gzread"])(a0, a1, a2);
    var _gzclose = Module["_gzclose"] = (a0) => (_gzclose = Module["_gzclose"] = wasmExports["gzclose"])(a0);
    var _gzdirect = Module["_gzdirect"] = (a0) => (_gzdirect = Module["_gzdirect"] = wasmExports["gzdirect"])(a0);
    var _gzdopen = Module["_gzdopen"] = (a0, a1) => (_gzdopen = Module["_gzdopen"] = wasmExports["gzdopen"])(a0, a1);
    var _gzopen = Module["_gzopen"] = (a0, a1) => (_gzopen = Module["_gzopen"] = wasmExports["gzopen"])(a0, a1);
    var _gzwrite = Module["_gzwrite"] = (a0, a1, a2) => (_gzwrite = Module["_gzwrite"] = wasmExports["gzwrite"])(a0, a1, a2);
    var _xmlUCSIsCatNd = Module["_xmlUCSIsCatNd"] = (a0) => (_xmlUCSIsCatNd = Module["_xmlUCSIsCatNd"] = wasmExports["xmlUCSIsCatNd"])(a0);
    var _xmlUCSIsCatP = Module["_xmlUCSIsCatP"] = (a0) => (_xmlUCSIsCatP = Module["_xmlUCSIsCatP"] = wasmExports["xmlUCSIsCatP"])(a0);
    var _xmlUCSIsCatZ = Module["_xmlUCSIsCatZ"] = (a0) => (_xmlUCSIsCatZ = Module["_xmlUCSIsCatZ"] = wasmExports["xmlUCSIsCatZ"])(a0);
    var _xmlUCSIsCatC = Module["_xmlUCSIsCatC"] = (a0) => (_xmlUCSIsCatC = Module["_xmlUCSIsCatC"] = wasmExports["xmlUCSIsCatC"])(a0);
    var _xmlUCSIsCatL = Module["_xmlUCSIsCatL"] = (a0) => (_xmlUCSIsCatL = Module["_xmlUCSIsCatL"] = wasmExports["xmlUCSIsCatL"])(a0);
    var _xmlUCSIsCatLu = Module["_xmlUCSIsCatLu"] = (a0) => (_xmlUCSIsCatLu = Module["_xmlUCSIsCatLu"] = wasmExports["xmlUCSIsCatLu"])(a0);
    var _xmlUCSIsCatLl = Module["_xmlUCSIsCatLl"] = (a0) => (_xmlUCSIsCatLl = Module["_xmlUCSIsCatLl"] = wasmExports["xmlUCSIsCatLl"])(a0);
    var _xmlUCSIsCatLt = Module["_xmlUCSIsCatLt"] = (a0) => (_xmlUCSIsCatLt = Module["_xmlUCSIsCatLt"] = wasmExports["xmlUCSIsCatLt"])(a0);
    var _xmlUCSIsCatLm = Module["_xmlUCSIsCatLm"] = (a0) => (_xmlUCSIsCatLm = Module["_xmlUCSIsCatLm"] = wasmExports["xmlUCSIsCatLm"])(a0);
    var _xmlUCSIsCatLo = Module["_xmlUCSIsCatLo"] = (a0) => (_xmlUCSIsCatLo = Module["_xmlUCSIsCatLo"] = wasmExports["xmlUCSIsCatLo"])(a0);
    var _xmlUCSIsCatM = Module["_xmlUCSIsCatM"] = (a0) => (_xmlUCSIsCatM = Module["_xmlUCSIsCatM"] = wasmExports["xmlUCSIsCatM"])(a0);
    var _xmlUCSIsCatMn = Module["_xmlUCSIsCatMn"] = (a0) => (_xmlUCSIsCatMn = Module["_xmlUCSIsCatMn"] = wasmExports["xmlUCSIsCatMn"])(a0);
    var _xmlUCSIsCatMc = Module["_xmlUCSIsCatMc"] = (a0) => (_xmlUCSIsCatMc = Module["_xmlUCSIsCatMc"] = wasmExports["xmlUCSIsCatMc"])(a0);
    var _xmlUCSIsCatMe = Module["_xmlUCSIsCatMe"] = (a0) => (_xmlUCSIsCatMe = Module["_xmlUCSIsCatMe"] = wasmExports["xmlUCSIsCatMe"])(a0);
    var _xmlUCSIsCatN = Module["_xmlUCSIsCatN"] = (a0) => (_xmlUCSIsCatN = Module["_xmlUCSIsCatN"] = wasmExports["xmlUCSIsCatN"])(a0);
    var _xmlUCSIsCatNl = Module["_xmlUCSIsCatNl"] = (a0) => (_xmlUCSIsCatNl = Module["_xmlUCSIsCatNl"] = wasmExports["xmlUCSIsCatNl"])(a0);
    var _xmlUCSIsCatNo = Module["_xmlUCSIsCatNo"] = (a0) => (_xmlUCSIsCatNo = Module["_xmlUCSIsCatNo"] = wasmExports["xmlUCSIsCatNo"])(a0);
    var _xmlUCSIsCatPc = Module["_xmlUCSIsCatPc"] = (a0) => (_xmlUCSIsCatPc = Module["_xmlUCSIsCatPc"] = wasmExports["xmlUCSIsCatPc"])(a0);
    var _xmlUCSIsCatPd = Module["_xmlUCSIsCatPd"] = (a0) => (_xmlUCSIsCatPd = Module["_xmlUCSIsCatPd"] = wasmExports["xmlUCSIsCatPd"])(a0);
    var _xmlUCSIsCatPs = Module["_xmlUCSIsCatPs"] = (a0) => (_xmlUCSIsCatPs = Module["_xmlUCSIsCatPs"] = wasmExports["xmlUCSIsCatPs"])(a0);
    var _xmlUCSIsCatPe = Module["_xmlUCSIsCatPe"] = (a0) => (_xmlUCSIsCatPe = Module["_xmlUCSIsCatPe"] = wasmExports["xmlUCSIsCatPe"])(a0);
    var _xmlUCSIsCatPi = Module["_xmlUCSIsCatPi"] = (a0) => (_xmlUCSIsCatPi = Module["_xmlUCSIsCatPi"] = wasmExports["xmlUCSIsCatPi"])(a0);
    var _xmlUCSIsCatPf = Module["_xmlUCSIsCatPf"] = (a0) => (_xmlUCSIsCatPf = Module["_xmlUCSIsCatPf"] = wasmExports["xmlUCSIsCatPf"])(a0);
    var _xmlUCSIsCatPo = Module["_xmlUCSIsCatPo"] = (a0) => (_xmlUCSIsCatPo = Module["_xmlUCSIsCatPo"] = wasmExports["xmlUCSIsCatPo"])(a0);
    var _xmlUCSIsCatZs = Module["_xmlUCSIsCatZs"] = (a0) => (_xmlUCSIsCatZs = Module["_xmlUCSIsCatZs"] = wasmExports["xmlUCSIsCatZs"])(a0);
    var _xmlUCSIsCatZl = Module["_xmlUCSIsCatZl"] = (a0) => (_xmlUCSIsCatZl = Module["_xmlUCSIsCatZl"] = wasmExports["xmlUCSIsCatZl"])(a0);
    var _xmlUCSIsCatZp = Module["_xmlUCSIsCatZp"] = (a0) => (_xmlUCSIsCatZp = Module["_xmlUCSIsCatZp"] = wasmExports["xmlUCSIsCatZp"])(a0);
    var _xmlUCSIsCatS = Module["_xmlUCSIsCatS"] = (a0) => (_xmlUCSIsCatS = Module["_xmlUCSIsCatS"] = wasmExports["xmlUCSIsCatS"])(a0);
    var _xmlUCSIsCatSm = Module["_xmlUCSIsCatSm"] = (a0) => (_xmlUCSIsCatSm = Module["_xmlUCSIsCatSm"] = wasmExports["xmlUCSIsCatSm"])(a0);
    var _xmlUCSIsCatSc = Module["_xmlUCSIsCatSc"] = (a0) => (_xmlUCSIsCatSc = Module["_xmlUCSIsCatSc"] = wasmExports["xmlUCSIsCatSc"])(a0);
    var _xmlUCSIsCatSk = Module["_xmlUCSIsCatSk"] = (a0) => (_xmlUCSIsCatSk = Module["_xmlUCSIsCatSk"] = wasmExports["xmlUCSIsCatSk"])(a0);
    var _xmlUCSIsCatSo = Module["_xmlUCSIsCatSo"] = (a0) => (_xmlUCSIsCatSo = Module["_xmlUCSIsCatSo"] = wasmExports["xmlUCSIsCatSo"])(a0);
    var _xmlUCSIsCatCc = Module["_xmlUCSIsCatCc"] = (a0) => (_xmlUCSIsCatCc = Module["_xmlUCSIsCatCc"] = wasmExports["xmlUCSIsCatCc"])(a0);
    var _xmlUCSIsCatCf = Module["_xmlUCSIsCatCf"] = (a0) => (_xmlUCSIsCatCf = Module["_xmlUCSIsCatCf"] = wasmExports["xmlUCSIsCatCf"])(a0);
    var _xmlUCSIsCatCo = Module["_xmlUCSIsCatCo"] = (a0) => (_xmlUCSIsCatCo = Module["_xmlUCSIsCatCo"] = wasmExports["xmlUCSIsCatCo"])(a0);
    var _xmlUCSIsAegeanNumbers = Module["_xmlUCSIsAegeanNumbers"] = (a0) => (_xmlUCSIsAegeanNumbers = Module["_xmlUCSIsAegeanNumbers"] = wasmExports["xmlUCSIsAegeanNumbers"])(a0);
    var _xmlUCSIsAlphabeticPresentationForms = Module["_xmlUCSIsAlphabeticPresentationForms"] = (a0) => (_xmlUCSIsAlphabeticPresentationForms = Module["_xmlUCSIsAlphabeticPresentationForms"] = wasmExports["xmlUCSIsAlphabeticPresentationForms"])(a0);
    var _xmlUCSIsArabic = Module["_xmlUCSIsArabic"] = (a0) => (_xmlUCSIsArabic = Module["_xmlUCSIsArabic"] = wasmExports["xmlUCSIsArabic"])(a0);
    var _xmlUCSIsArabicPresentationFormsA = Module["_xmlUCSIsArabicPresentationFormsA"] = (a0) => (_xmlUCSIsArabicPresentationFormsA = Module["_xmlUCSIsArabicPresentationFormsA"] = wasmExports["xmlUCSIsArabicPresentationFormsA"])(a0);
    var _xmlUCSIsArabicPresentationFormsB = Module["_xmlUCSIsArabicPresentationFormsB"] = (a0) => (_xmlUCSIsArabicPresentationFormsB = Module["_xmlUCSIsArabicPresentationFormsB"] = wasmExports["xmlUCSIsArabicPresentationFormsB"])(a0);
    var _xmlUCSIsArmenian = Module["_xmlUCSIsArmenian"] = (a0) => (_xmlUCSIsArmenian = Module["_xmlUCSIsArmenian"] = wasmExports["xmlUCSIsArmenian"])(a0);
    var _xmlUCSIsArrows = Module["_xmlUCSIsArrows"] = (a0) => (_xmlUCSIsArrows = Module["_xmlUCSIsArrows"] = wasmExports["xmlUCSIsArrows"])(a0);
    var _xmlUCSIsBasicLatin = Module["_xmlUCSIsBasicLatin"] = (a0) => (_xmlUCSIsBasicLatin = Module["_xmlUCSIsBasicLatin"] = wasmExports["xmlUCSIsBasicLatin"])(a0);
    var _xmlUCSIsBengali = Module["_xmlUCSIsBengali"] = (a0) => (_xmlUCSIsBengali = Module["_xmlUCSIsBengali"] = wasmExports["xmlUCSIsBengali"])(a0);
    var _xmlUCSIsBlockElements = Module["_xmlUCSIsBlockElements"] = (a0) => (_xmlUCSIsBlockElements = Module["_xmlUCSIsBlockElements"] = wasmExports["xmlUCSIsBlockElements"])(a0);
    var _xmlUCSIsBopomofo = Module["_xmlUCSIsBopomofo"] = (a0) => (_xmlUCSIsBopomofo = Module["_xmlUCSIsBopomofo"] = wasmExports["xmlUCSIsBopomofo"])(a0);
    var _xmlUCSIsBopomofoExtended = Module["_xmlUCSIsBopomofoExtended"] = (a0) => (_xmlUCSIsBopomofoExtended = Module["_xmlUCSIsBopomofoExtended"] = wasmExports["xmlUCSIsBopomofoExtended"])(a0);
    var _xmlUCSIsBoxDrawing = Module["_xmlUCSIsBoxDrawing"] = (a0) => (_xmlUCSIsBoxDrawing = Module["_xmlUCSIsBoxDrawing"] = wasmExports["xmlUCSIsBoxDrawing"])(a0);
    var _xmlUCSIsBraillePatterns = Module["_xmlUCSIsBraillePatterns"] = (a0) => (_xmlUCSIsBraillePatterns = Module["_xmlUCSIsBraillePatterns"] = wasmExports["xmlUCSIsBraillePatterns"])(a0);
    var _xmlUCSIsBuhid = Module["_xmlUCSIsBuhid"] = (a0) => (_xmlUCSIsBuhid = Module["_xmlUCSIsBuhid"] = wasmExports["xmlUCSIsBuhid"])(a0);
    var _xmlUCSIsByzantineMusicalSymbols = Module["_xmlUCSIsByzantineMusicalSymbols"] = (a0) => (_xmlUCSIsByzantineMusicalSymbols = Module["_xmlUCSIsByzantineMusicalSymbols"] = wasmExports["xmlUCSIsByzantineMusicalSymbols"])(a0);
    var _xmlUCSIsCJKCompatibility = Module["_xmlUCSIsCJKCompatibility"] = (a0) => (_xmlUCSIsCJKCompatibility = Module["_xmlUCSIsCJKCompatibility"] = wasmExports["xmlUCSIsCJKCompatibility"])(a0);
    var _xmlUCSIsCJKCompatibilityForms = Module["_xmlUCSIsCJKCompatibilityForms"] = (a0) => (_xmlUCSIsCJKCompatibilityForms = Module["_xmlUCSIsCJKCompatibilityForms"] = wasmExports["xmlUCSIsCJKCompatibilityForms"])(a0);
    var _xmlUCSIsCJKCompatibilityIdeographs = Module["_xmlUCSIsCJKCompatibilityIdeographs"] = (a0) => (_xmlUCSIsCJKCompatibilityIdeographs = Module["_xmlUCSIsCJKCompatibilityIdeographs"] = wasmExports["xmlUCSIsCJKCompatibilityIdeographs"])(a0);
    var _xmlUCSIsCJKCompatibilityIdeographsSupplement = Module["_xmlUCSIsCJKCompatibilityIdeographsSupplement"] = (a0) => (_xmlUCSIsCJKCompatibilityIdeographsSupplement = Module["_xmlUCSIsCJKCompatibilityIdeographsSupplement"] = wasmExports["xmlUCSIsCJKCompatibilityIdeographsSupplement"])(a0);
    var _xmlUCSIsCJKRadicalsSupplement = Module["_xmlUCSIsCJKRadicalsSupplement"] = (a0) => (_xmlUCSIsCJKRadicalsSupplement = Module["_xmlUCSIsCJKRadicalsSupplement"] = wasmExports["xmlUCSIsCJKRadicalsSupplement"])(a0);
    var _xmlUCSIsCJKSymbolsandPunctuation = Module["_xmlUCSIsCJKSymbolsandPunctuation"] = (a0) => (_xmlUCSIsCJKSymbolsandPunctuation = Module["_xmlUCSIsCJKSymbolsandPunctuation"] = wasmExports["xmlUCSIsCJKSymbolsandPunctuation"])(a0);
    var _xmlUCSIsCJKUnifiedIdeographs = Module["_xmlUCSIsCJKUnifiedIdeographs"] = (a0) => (_xmlUCSIsCJKUnifiedIdeographs = Module["_xmlUCSIsCJKUnifiedIdeographs"] = wasmExports["xmlUCSIsCJKUnifiedIdeographs"])(a0);
    var _xmlUCSIsCJKUnifiedIdeographsExtensionA = Module["_xmlUCSIsCJKUnifiedIdeographsExtensionA"] = (a0) => (_xmlUCSIsCJKUnifiedIdeographsExtensionA = Module["_xmlUCSIsCJKUnifiedIdeographsExtensionA"] = wasmExports["xmlUCSIsCJKUnifiedIdeographsExtensionA"])(a0);
    var _xmlUCSIsCJKUnifiedIdeographsExtensionB = Module["_xmlUCSIsCJKUnifiedIdeographsExtensionB"] = (a0) => (_xmlUCSIsCJKUnifiedIdeographsExtensionB = Module["_xmlUCSIsCJKUnifiedIdeographsExtensionB"] = wasmExports["xmlUCSIsCJKUnifiedIdeographsExtensionB"])(a0);
    var _xmlUCSIsCherokee = Module["_xmlUCSIsCherokee"] = (a0) => (_xmlUCSIsCherokee = Module["_xmlUCSIsCherokee"] = wasmExports["xmlUCSIsCherokee"])(a0);
    var _xmlUCSIsCombiningDiacriticalMarks = Module["_xmlUCSIsCombiningDiacriticalMarks"] = (a0) => (_xmlUCSIsCombiningDiacriticalMarks = Module["_xmlUCSIsCombiningDiacriticalMarks"] = wasmExports["xmlUCSIsCombiningDiacriticalMarks"])(a0);
    var _xmlUCSIsCombiningDiacriticalMarksforSymbols = Module["_xmlUCSIsCombiningDiacriticalMarksforSymbols"] = (a0) => (_xmlUCSIsCombiningDiacriticalMarksforSymbols = Module["_xmlUCSIsCombiningDiacriticalMarksforSymbols"] = wasmExports["xmlUCSIsCombiningDiacriticalMarksforSymbols"])(a0);
    var _xmlUCSIsCombiningHalfMarks = Module["_xmlUCSIsCombiningHalfMarks"] = (a0) => (_xmlUCSIsCombiningHalfMarks = Module["_xmlUCSIsCombiningHalfMarks"] = wasmExports["xmlUCSIsCombiningHalfMarks"])(a0);
    var _xmlUCSIsCombiningMarksforSymbols = Module["_xmlUCSIsCombiningMarksforSymbols"] = (a0) => (_xmlUCSIsCombiningMarksforSymbols = Module["_xmlUCSIsCombiningMarksforSymbols"] = wasmExports["xmlUCSIsCombiningMarksforSymbols"])(a0);
    var _xmlUCSIsControlPictures = Module["_xmlUCSIsControlPictures"] = (a0) => (_xmlUCSIsControlPictures = Module["_xmlUCSIsControlPictures"] = wasmExports["xmlUCSIsControlPictures"])(a0);
    var _xmlUCSIsCurrencySymbols = Module["_xmlUCSIsCurrencySymbols"] = (a0) => (_xmlUCSIsCurrencySymbols = Module["_xmlUCSIsCurrencySymbols"] = wasmExports["xmlUCSIsCurrencySymbols"])(a0);
    var _xmlUCSIsCypriotSyllabary = Module["_xmlUCSIsCypriotSyllabary"] = (a0) => (_xmlUCSIsCypriotSyllabary = Module["_xmlUCSIsCypriotSyllabary"] = wasmExports["xmlUCSIsCypriotSyllabary"])(a0);
    var _xmlUCSIsCyrillic = Module["_xmlUCSIsCyrillic"] = (a0) => (_xmlUCSIsCyrillic = Module["_xmlUCSIsCyrillic"] = wasmExports["xmlUCSIsCyrillic"])(a0);
    var _xmlUCSIsCyrillicSupplement = Module["_xmlUCSIsCyrillicSupplement"] = (a0) => (_xmlUCSIsCyrillicSupplement = Module["_xmlUCSIsCyrillicSupplement"] = wasmExports["xmlUCSIsCyrillicSupplement"])(a0);
    var _xmlUCSIsDeseret = Module["_xmlUCSIsDeseret"] = (a0) => (_xmlUCSIsDeseret = Module["_xmlUCSIsDeseret"] = wasmExports["xmlUCSIsDeseret"])(a0);
    var _xmlUCSIsDevanagari = Module["_xmlUCSIsDevanagari"] = (a0) => (_xmlUCSIsDevanagari = Module["_xmlUCSIsDevanagari"] = wasmExports["xmlUCSIsDevanagari"])(a0);
    var _xmlUCSIsDingbats = Module["_xmlUCSIsDingbats"] = (a0) => (_xmlUCSIsDingbats = Module["_xmlUCSIsDingbats"] = wasmExports["xmlUCSIsDingbats"])(a0);
    var _xmlUCSIsEnclosedAlphanumerics = Module["_xmlUCSIsEnclosedAlphanumerics"] = (a0) => (_xmlUCSIsEnclosedAlphanumerics = Module["_xmlUCSIsEnclosedAlphanumerics"] = wasmExports["xmlUCSIsEnclosedAlphanumerics"])(a0);
    var _xmlUCSIsEnclosedCJKLettersandMonths = Module["_xmlUCSIsEnclosedCJKLettersandMonths"] = (a0) => (_xmlUCSIsEnclosedCJKLettersandMonths = Module["_xmlUCSIsEnclosedCJKLettersandMonths"] = wasmExports["xmlUCSIsEnclosedCJKLettersandMonths"])(a0);
    var _xmlUCSIsEthiopic = Module["_xmlUCSIsEthiopic"] = (a0) => (_xmlUCSIsEthiopic = Module["_xmlUCSIsEthiopic"] = wasmExports["xmlUCSIsEthiopic"])(a0);
    var _xmlUCSIsGeneralPunctuation = Module["_xmlUCSIsGeneralPunctuation"] = (a0) => (_xmlUCSIsGeneralPunctuation = Module["_xmlUCSIsGeneralPunctuation"] = wasmExports["xmlUCSIsGeneralPunctuation"])(a0);
    var _xmlUCSIsGeometricShapes = Module["_xmlUCSIsGeometricShapes"] = (a0) => (_xmlUCSIsGeometricShapes = Module["_xmlUCSIsGeometricShapes"] = wasmExports["xmlUCSIsGeometricShapes"])(a0);
    var _xmlUCSIsGeorgian = Module["_xmlUCSIsGeorgian"] = (a0) => (_xmlUCSIsGeorgian = Module["_xmlUCSIsGeorgian"] = wasmExports["xmlUCSIsGeorgian"])(a0);
    var _xmlUCSIsGothic = Module["_xmlUCSIsGothic"] = (a0) => (_xmlUCSIsGothic = Module["_xmlUCSIsGothic"] = wasmExports["xmlUCSIsGothic"])(a0);
    var _xmlUCSIsGreek = Module["_xmlUCSIsGreek"] = (a0) => (_xmlUCSIsGreek = Module["_xmlUCSIsGreek"] = wasmExports["xmlUCSIsGreek"])(a0);
    var _xmlUCSIsGreekExtended = Module["_xmlUCSIsGreekExtended"] = (a0) => (_xmlUCSIsGreekExtended = Module["_xmlUCSIsGreekExtended"] = wasmExports["xmlUCSIsGreekExtended"])(a0);
    var _xmlUCSIsGreekandCoptic = Module["_xmlUCSIsGreekandCoptic"] = (a0) => (_xmlUCSIsGreekandCoptic = Module["_xmlUCSIsGreekandCoptic"] = wasmExports["xmlUCSIsGreekandCoptic"])(a0);
    var _xmlUCSIsGujarati = Module["_xmlUCSIsGujarati"] = (a0) => (_xmlUCSIsGujarati = Module["_xmlUCSIsGujarati"] = wasmExports["xmlUCSIsGujarati"])(a0);
    var _xmlUCSIsGurmukhi = Module["_xmlUCSIsGurmukhi"] = (a0) => (_xmlUCSIsGurmukhi = Module["_xmlUCSIsGurmukhi"] = wasmExports["xmlUCSIsGurmukhi"])(a0);
    var _xmlUCSIsHalfwidthandFullwidthForms = Module["_xmlUCSIsHalfwidthandFullwidthForms"] = (a0) => (_xmlUCSIsHalfwidthandFullwidthForms = Module["_xmlUCSIsHalfwidthandFullwidthForms"] = wasmExports["xmlUCSIsHalfwidthandFullwidthForms"])(a0);
    var _xmlUCSIsHangulCompatibilityJamo = Module["_xmlUCSIsHangulCompatibilityJamo"] = (a0) => (_xmlUCSIsHangulCompatibilityJamo = Module["_xmlUCSIsHangulCompatibilityJamo"] = wasmExports["xmlUCSIsHangulCompatibilityJamo"])(a0);
    var _xmlUCSIsHangulJamo = Module["_xmlUCSIsHangulJamo"] = (a0) => (_xmlUCSIsHangulJamo = Module["_xmlUCSIsHangulJamo"] = wasmExports["xmlUCSIsHangulJamo"])(a0);
    var _xmlUCSIsHangulSyllables = Module["_xmlUCSIsHangulSyllables"] = (a0) => (_xmlUCSIsHangulSyllables = Module["_xmlUCSIsHangulSyllables"] = wasmExports["xmlUCSIsHangulSyllables"])(a0);
    var _xmlUCSIsHanunoo = Module["_xmlUCSIsHanunoo"] = (a0) => (_xmlUCSIsHanunoo = Module["_xmlUCSIsHanunoo"] = wasmExports["xmlUCSIsHanunoo"])(a0);
    var _xmlUCSIsHebrew = Module["_xmlUCSIsHebrew"] = (a0) => (_xmlUCSIsHebrew = Module["_xmlUCSIsHebrew"] = wasmExports["xmlUCSIsHebrew"])(a0);
    var _xmlUCSIsHighPrivateUseSurrogates = Module["_xmlUCSIsHighPrivateUseSurrogates"] = (a0) => (_xmlUCSIsHighPrivateUseSurrogates = Module["_xmlUCSIsHighPrivateUseSurrogates"] = wasmExports["xmlUCSIsHighPrivateUseSurrogates"])(a0);
    var _xmlUCSIsHighSurrogates = Module["_xmlUCSIsHighSurrogates"] = (a0) => (_xmlUCSIsHighSurrogates = Module["_xmlUCSIsHighSurrogates"] = wasmExports["xmlUCSIsHighSurrogates"])(a0);
    var _xmlUCSIsHiragana = Module["_xmlUCSIsHiragana"] = (a0) => (_xmlUCSIsHiragana = Module["_xmlUCSIsHiragana"] = wasmExports["xmlUCSIsHiragana"])(a0);
    var _xmlUCSIsIPAExtensions = Module["_xmlUCSIsIPAExtensions"] = (a0) => (_xmlUCSIsIPAExtensions = Module["_xmlUCSIsIPAExtensions"] = wasmExports["xmlUCSIsIPAExtensions"])(a0);
    var _xmlUCSIsIdeographicDescriptionCharacters = Module["_xmlUCSIsIdeographicDescriptionCharacters"] = (a0) => (_xmlUCSIsIdeographicDescriptionCharacters = Module["_xmlUCSIsIdeographicDescriptionCharacters"] = wasmExports["xmlUCSIsIdeographicDescriptionCharacters"])(a0);
    var _xmlUCSIsKanbun = Module["_xmlUCSIsKanbun"] = (a0) => (_xmlUCSIsKanbun = Module["_xmlUCSIsKanbun"] = wasmExports["xmlUCSIsKanbun"])(a0);
    var _xmlUCSIsKangxiRadicals = Module["_xmlUCSIsKangxiRadicals"] = (a0) => (_xmlUCSIsKangxiRadicals = Module["_xmlUCSIsKangxiRadicals"] = wasmExports["xmlUCSIsKangxiRadicals"])(a0);
    var _xmlUCSIsKannada = Module["_xmlUCSIsKannada"] = (a0) => (_xmlUCSIsKannada = Module["_xmlUCSIsKannada"] = wasmExports["xmlUCSIsKannada"])(a0);
    var _xmlUCSIsKatakana = Module["_xmlUCSIsKatakana"] = (a0) => (_xmlUCSIsKatakana = Module["_xmlUCSIsKatakana"] = wasmExports["xmlUCSIsKatakana"])(a0);
    var _xmlUCSIsKatakanaPhoneticExtensions = Module["_xmlUCSIsKatakanaPhoneticExtensions"] = (a0) => (_xmlUCSIsKatakanaPhoneticExtensions = Module["_xmlUCSIsKatakanaPhoneticExtensions"] = wasmExports["xmlUCSIsKatakanaPhoneticExtensions"])(a0);
    var _xmlUCSIsKhmer = Module["_xmlUCSIsKhmer"] = (a0) => (_xmlUCSIsKhmer = Module["_xmlUCSIsKhmer"] = wasmExports["xmlUCSIsKhmer"])(a0);
    var _xmlUCSIsKhmerSymbols = Module["_xmlUCSIsKhmerSymbols"] = (a0) => (_xmlUCSIsKhmerSymbols = Module["_xmlUCSIsKhmerSymbols"] = wasmExports["xmlUCSIsKhmerSymbols"])(a0);
    var _xmlUCSIsLao = Module["_xmlUCSIsLao"] = (a0) => (_xmlUCSIsLao = Module["_xmlUCSIsLao"] = wasmExports["xmlUCSIsLao"])(a0);
    var _xmlUCSIsLatin1Supplement = Module["_xmlUCSIsLatin1Supplement"] = (a0) => (_xmlUCSIsLatin1Supplement = Module["_xmlUCSIsLatin1Supplement"] = wasmExports["xmlUCSIsLatin1Supplement"])(a0);
    var _xmlUCSIsLatinExtendedA = Module["_xmlUCSIsLatinExtendedA"] = (a0) => (_xmlUCSIsLatinExtendedA = Module["_xmlUCSIsLatinExtendedA"] = wasmExports["xmlUCSIsLatinExtendedA"])(a0);
    var _xmlUCSIsLatinExtendedB = Module["_xmlUCSIsLatinExtendedB"] = (a0) => (_xmlUCSIsLatinExtendedB = Module["_xmlUCSIsLatinExtendedB"] = wasmExports["xmlUCSIsLatinExtendedB"])(a0);
    var _xmlUCSIsLatinExtendedAdditional = Module["_xmlUCSIsLatinExtendedAdditional"] = (a0) => (_xmlUCSIsLatinExtendedAdditional = Module["_xmlUCSIsLatinExtendedAdditional"] = wasmExports["xmlUCSIsLatinExtendedAdditional"])(a0);
    var _xmlUCSIsLetterlikeSymbols = Module["_xmlUCSIsLetterlikeSymbols"] = (a0) => (_xmlUCSIsLetterlikeSymbols = Module["_xmlUCSIsLetterlikeSymbols"] = wasmExports["xmlUCSIsLetterlikeSymbols"])(a0);
    var _xmlUCSIsLimbu = Module["_xmlUCSIsLimbu"] = (a0) => (_xmlUCSIsLimbu = Module["_xmlUCSIsLimbu"] = wasmExports["xmlUCSIsLimbu"])(a0);
    var _xmlUCSIsLinearBIdeograms = Module["_xmlUCSIsLinearBIdeograms"] = (a0) => (_xmlUCSIsLinearBIdeograms = Module["_xmlUCSIsLinearBIdeograms"] = wasmExports["xmlUCSIsLinearBIdeograms"])(a0);
    var _xmlUCSIsLinearBSyllabary = Module["_xmlUCSIsLinearBSyllabary"] = (a0) => (_xmlUCSIsLinearBSyllabary = Module["_xmlUCSIsLinearBSyllabary"] = wasmExports["xmlUCSIsLinearBSyllabary"])(a0);
    var _xmlUCSIsLowSurrogates = Module["_xmlUCSIsLowSurrogates"] = (a0) => (_xmlUCSIsLowSurrogates = Module["_xmlUCSIsLowSurrogates"] = wasmExports["xmlUCSIsLowSurrogates"])(a0);
    var _xmlUCSIsMalayalam = Module["_xmlUCSIsMalayalam"] = (a0) => (_xmlUCSIsMalayalam = Module["_xmlUCSIsMalayalam"] = wasmExports["xmlUCSIsMalayalam"])(a0);
    var _xmlUCSIsMathematicalAlphanumericSymbols = Module["_xmlUCSIsMathematicalAlphanumericSymbols"] = (a0) => (_xmlUCSIsMathematicalAlphanumericSymbols = Module["_xmlUCSIsMathematicalAlphanumericSymbols"] = wasmExports["xmlUCSIsMathematicalAlphanumericSymbols"])(a0);
    var _xmlUCSIsMathematicalOperators = Module["_xmlUCSIsMathematicalOperators"] = (a0) => (_xmlUCSIsMathematicalOperators = Module["_xmlUCSIsMathematicalOperators"] = wasmExports["xmlUCSIsMathematicalOperators"])(a0);
    var _xmlUCSIsMiscellaneousMathematicalSymbolsA = Module["_xmlUCSIsMiscellaneousMathematicalSymbolsA"] = (a0) => (_xmlUCSIsMiscellaneousMathematicalSymbolsA = Module["_xmlUCSIsMiscellaneousMathematicalSymbolsA"] = wasmExports["xmlUCSIsMiscellaneousMathematicalSymbolsA"])(a0);
    var _xmlUCSIsMiscellaneousMathematicalSymbolsB = Module["_xmlUCSIsMiscellaneousMathematicalSymbolsB"] = (a0) => (_xmlUCSIsMiscellaneousMathematicalSymbolsB = Module["_xmlUCSIsMiscellaneousMathematicalSymbolsB"] = wasmExports["xmlUCSIsMiscellaneousMathematicalSymbolsB"])(a0);
    var _xmlUCSIsMiscellaneousSymbols = Module["_xmlUCSIsMiscellaneousSymbols"] = (a0) => (_xmlUCSIsMiscellaneousSymbols = Module["_xmlUCSIsMiscellaneousSymbols"] = wasmExports["xmlUCSIsMiscellaneousSymbols"])(a0);
    var _xmlUCSIsMiscellaneousSymbolsandArrows = Module["_xmlUCSIsMiscellaneousSymbolsandArrows"] = (a0) => (_xmlUCSIsMiscellaneousSymbolsandArrows = Module["_xmlUCSIsMiscellaneousSymbolsandArrows"] = wasmExports["xmlUCSIsMiscellaneousSymbolsandArrows"])(a0);
    var _xmlUCSIsMiscellaneousTechnical = Module["_xmlUCSIsMiscellaneousTechnical"] = (a0) => (_xmlUCSIsMiscellaneousTechnical = Module["_xmlUCSIsMiscellaneousTechnical"] = wasmExports["xmlUCSIsMiscellaneousTechnical"])(a0);
    var _xmlUCSIsMongolian = Module["_xmlUCSIsMongolian"] = (a0) => (_xmlUCSIsMongolian = Module["_xmlUCSIsMongolian"] = wasmExports["xmlUCSIsMongolian"])(a0);
    var _xmlUCSIsMusicalSymbols = Module["_xmlUCSIsMusicalSymbols"] = (a0) => (_xmlUCSIsMusicalSymbols = Module["_xmlUCSIsMusicalSymbols"] = wasmExports["xmlUCSIsMusicalSymbols"])(a0);
    var _xmlUCSIsMyanmar = Module["_xmlUCSIsMyanmar"] = (a0) => (_xmlUCSIsMyanmar = Module["_xmlUCSIsMyanmar"] = wasmExports["xmlUCSIsMyanmar"])(a0);
    var _xmlUCSIsNumberForms = Module["_xmlUCSIsNumberForms"] = (a0) => (_xmlUCSIsNumberForms = Module["_xmlUCSIsNumberForms"] = wasmExports["xmlUCSIsNumberForms"])(a0);
    var _xmlUCSIsOgham = Module["_xmlUCSIsOgham"] = (a0) => (_xmlUCSIsOgham = Module["_xmlUCSIsOgham"] = wasmExports["xmlUCSIsOgham"])(a0);
    var _xmlUCSIsOldItalic = Module["_xmlUCSIsOldItalic"] = (a0) => (_xmlUCSIsOldItalic = Module["_xmlUCSIsOldItalic"] = wasmExports["xmlUCSIsOldItalic"])(a0);
    var _xmlUCSIsOpticalCharacterRecognition = Module["_xmlUCSIsOpticalCharacterRecognition"] = (a0) => (_xmlUCSIsOpticalCharacterRecognition = Module["_xmlUCSIsOpticalCharacterRecognition"] = wasmExports["xmlUCSIsOpticalCharacterRecognition"])(a0);
    var _xmlUCSIsOriya = Module["_xmlUCSIsOriya"] = (a0) => (_xmlUCSIsOriya = Module["_xmlUCSIsOriya"] = wasmExports["xmlUCSIsOriya"])(a0);
    var _xmlUCSIsOsmanya = Module["_xmlUCSIsOsmanya"] = (a0) => (_xmlUCSIsOsmanya = Module["_xmlUCSIsOsmanya"] = wasmExports["xmlUCSIsOsmanya"])(a0);
    var _xmlUCSIsPhoneticExtensions = Module["_xmlUCSIsPhoneticExtensions"] = (a0) => (_xmlUCSIsPhoneticExtensions = Module["_xmlUCSIsPhoneticExtensions"] = wasmExports["xmlUCSIsPhoneticExtensions"])(a0);
    var _xmlUCSIsPrivateUse = Module["_xmlUCSIsPrivateUse"] = (a0) => (_xmlUCSIsPrivateUse = Module["_xmlUCSIsPrivateUse"] = wasmExports["xmlUCSIsPrivateUse"])(a0);
    var _xmlUCSIsPrivateUseArea = Module["_xmlUCSIsPrivateUseArea"] = (a0) => (_xmlUCSIsPrivateUseArea = Module["_xmlUCSIsPrivateUseArea"] = wasmExports["xmlUCSIsPrivateUseArea"])(a0);
    var _xmlUCSIsRunic = Module["_xmlUCSIsRunic"] = (a0) => (_xmlUCSIsRunic = Module["_xmlUCSIsRunic"] = wasmExports["xmlUCSIsRunic"])(a0);
    var _xmlUCSIsShavian = Module["_xmlUCSIsShavian"] = (a0) => (_xmlUCSIsShavian = Module["_xmlUCSIsShavian"] = wasmExports["xmlUCSIsShavian"])(a0);
    var _xmlUCSIsSinhala = Module["_xmlUCSIsSinhala"] = (a0) => (_xmlUCSIsSinhala = Module["_xmlUCSIsSinhala"] = wasmExports["xmlUCSIsSinhala"])(a0);
    var _xmlUCSIsSmallFormVariants = Module["_xmlUCSIsSmallFormVariants"] = (a0) => (_xmlUCSIsSmallFormVariants = Module["_xmlUCSIsSmallFormVariants"] = wasmExports["xmlUCSIsSmallFormVariants"])(a0);
    var _xmlUCSIsSpacingModifierLetters = Module["_xmlUCSIsSpacingModifierLetters"] = (a0) => (_xmlUCSIsSpacingModifierLetters = Module["_xmlUCSIsSpacingModifierLetters"] = wasmExports["xmlUCSIsSpacingModifierLetters"])(a0);
    var _xmlUCSIsSpecials = Module["_xmlUCSIsSpecials"] = (a0) => (_xmlUCSIsSpecials = Module["_xmlUCSIsSpecials"] = wasmExports["xmlUCSIsSpecials"])(a0);
    var _xmlUCSIsSuperscriptsandSubscripts = Module["_xmlUCSIsSuperscriptsandSubscripts"] = (a0) => (_xmlUCSIsSuperscriptsandSubscripts = Module["_xmlUCSIsSuperscriptsandSubscripts"] = wasmExports["xmlUCSIsSuperscriptsandSubscripts"])(a0);
    var _xmlUCSIsSupplementalArrowsA = Module["_xmlUCSIsSupplementalArrowsA"] = (a0) => (_xmlUCSIsSupplementalArrowsA = Module["_xmlUCSIsSupplementalArrowsA"] = wasmExports["xmlUCSIsSupplementalArrowsA"])(a0);
    var _xmlUCSIsSupplementalArrowsB = Module["_xmlUCSIsSupplementalArrowsB"] = (a0) => (_xmlUCSIsSupplementalArrowsB = Module["_xmlUCSIsSupplementalArrowsB"] = wasmExports["xmlUCSIsSupplementalArrowsB"])(a0);
    var _xmlUCSIsSupplementalMathematicalOperators = Module["_xmlUCSIsSupplementalMathematicalOperators"] = (a0) => (_xmlUCSIsSupplementalMathematicalOperators = Module["_xmlUCSIsSupplementalMathematicalOperators"] = wasmExports["xmlUCSIsSupplementalMathematicalOperators"])(a0);
    var _xmlUCSIsSupplementaryPrivateUseAreaA = Module["_xmlUCSIsSupplementaryPrivateUseAreaA"] = (a0) => (_xmlUCSIsSupplementaryPrivateUseAreaA = Module["_xmlUCSIsSupplementaryPrivateUseAreaA"] = wasmExports["xmlUCSIsSupplementaryPrivateUseAreaA"])(a0);
    var _xmlUCSIsSupplementaryPrivateUseAreaB = Module["_xmlUCSIsSupplementaryPrivateUseAreaB"] = (a0) => (_xmlUCSIsSupplementaryPrivateUseAreaB = Module["_xmlUCSIsSupplementaryPrivateUseAreaB"] = wasmExports["xmlUCSIsSupplementaryPrivateUseAreaB"])(a0);
    var _xmlUCSIsSyriac = Module["_xmlUCSIsSyriac"] = (a0) => (_xmlUCSIsSyriac = Module["_xmlUCSIsSyriac"] = wasmExports["xmlUCSIsSyriac"])(a0);
    var _xmlUCSIsTagalog = Module["_xmlUCSIsTagalog"] = (a0) => (_xmlUCSIsTagalog = Module["_xmlUCSIsTagalog"] = wasmExports["xmlUCSIsTagalog"])(a0);
    var _xmlUCSIsTagbanwa = Module["_xmlUCSIsTagbanwa"] = (a0) => (_xmlUCSIsTagbanwa = Module["_xmlUCSIsTagbanwa"] = wasmExports["xmlUCSIsTagbanwa"])(a0);
    var _xmlUCSIsTags = Module["_xmlUCSIsTags"] = (a0) => (_xmlUCSIsTags = Module["_xmlUCSIsTags"] = wasmExports["xmlUCSIsTags"])(a0);
    var _xmlUCSIsTaiLe = Module["_xmlUCSIsTaiLe"] = (a0) => (_xmlUCSIsTaiLe = Module["_xmlUCSIsTaiLe"] = wasmExports["xmlUCSIsTaiLe"])(a0);
    var _xmlUCSIsTaiXuanJingSymbols = Module["_xmlUCSIsTaiXuanJingSymbols"] = (a0) => (_xmlUCSIsTaiXuanJingSymbols = Module["_xmlUCSIsTaiXuanJingSymbols"] = wasmExports["xmlUCSIsTaiXuanJingSymbols"])(a0);
    var _xmlUCSIsTamil = Module["_xmlUCSIsTamil"] = (a0) => (_xmlUCSIsTamil = Module["_xmlUCSIsTamil"] = wasmExports["xmlUCSIsTamil"])(a0);
    var _xmlUCSIsTelugu = Module["_xmlUCSIsTelugu"] = (a0) => (_xmlUCSIsTelugu = Module["_xmlUCSIsTelugu"] = wasmExports["xmlUCSIsTelugu"])(a0);
    var _xmlUCSIsThaana = Module["_xmlUCSIsThaana"] = (a0) => (_xmlUCSIsThaana = Module["_xmlUCSIsThaana"] = wasmExports["xmlUCSIsThaana"])(a0);
    var _xmlUCSIsThai = Module["_xmlUCSIsThai"] = (a0) => (_xmlUCSIsThai = Module["_xmlUCSIsThai"] = wasmExports["xmlUCSIsThai"])(a0);
    var _xmlUCSIsTibetan = Module["_xmlUCSIsTibetan"] = (a0) => (_xmlUCSIsTibetan = Module["_xmlUCSIsTibetan"] = wasmExports["xmlUCSIsTibetan"])(a0);
    var _xmlUCSIsUgaritic = Module["_xmlUCSIsUgaritic"] = (a0) => (_xmlUCSIsUgaritic = Module["_xmlUCSIsUgaritic"] = wasmExports["xmlUCSIsUgaritic"])(a0);
    var _xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module["_xmlUCSIsUnifiedCanadianAboriginalSyllabics"] = (a0) => (_xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module["_xmlUCSIsUnifiedCanadianAboriginalSyllabics"] = wasmExports["xmlUCSIsUnifiedCanadianAboriginalSyllabics"])(a0);
    var _xmlUCSIsVariationSelectors = Module["_xmlUCSIsVariationSelectors"] = (a0) => (_xmlUCSIsVariationSelectors = Module["_xmlUCSIsVariationSelectors"] = wasmExports["xmlUCSIsVariationSelectors"])(a0);
    var _xmlUCSIsVariationSelectorsSupplement = Module["_xmlUCSIsVariationSelectorsSupplement"] = (a0) => (_xmlUCSIsVariationSelectorsSupplement = Module["_xmlUCSIsVariationSelectorsSupplement"] = wasmExports["xmlUCSIsVariationSelectorsSupplement"])(a0);
    var _xmlUCSIsYiRadicals = Module["_xmlUCSIsYiRadicals"] = (a0) => (_xmlUCSIsYiRadicals = Module["_xmlUCSIsYiRadicals"] = wasmExports["xmlUCSIsYiRadicals"])(a0);
    var _xmlUCSIsYiSyllables = Module["_xmlUCSIsYiSyllables"] = (a0) => (_xmlUCSIsYiSyllables = Module["_xmlUCSIsYiSyllables"] = wasmExports["xmlUCSIsYiSyllables"])(a0);
    var _xmlUCSIsYijingHexagramSymbols = Module["_xmlUCSIsYijingHexagramSymbols"] = (a0) => (_xmlUCSIsYijingHexagramSymbols = Module["_xmlUCSIsYijingHexagramSymbols"] = wasmExports["xmlUCSIsYijingHexagramSymbols"])(a0);
    var _xmlUCSIsCatCs = Module["_xmlUCSIsCatCs"] = (a0) => (_xmlUCSIsCatCs = Module["_xmlUCSIsCatCs"] = wasmExports["xmlUCSIsCatCs"])(a0);
    var ___small_fprintf = Module["___small_fprintf"] = (a0, a1, a2) => (___small_fprintf = Module["___small_fprintf"] = wasmExports["__small_fprintf"])(a0, a1, a2);
    var _xmlXPathBooleanFunction = Module["_xmlXPathBooleanFunction"] = (a0, a1) => (_xmlXPathBooleanFunction = Module["_xmlXPathBooleanFunction"] = wasmExports["xmlXPathBooleanFunction"])(a0, a1);
    var _xmlXPathCeilingFunction = Module["_xmlXPathCeilingFunction"] = (a0, a1) => (_xmlXPathCeilingFunction = Module["_xmlXPathCeilingFunction"] = wasmExports["xmlXPathCeilingFunction"])(a0, a1);
    var _xmlXPathCountFunction = Module["_xmlXPathCountFunction"] = (a0, a1) => (_xmlXPathCountFunction = Module["_xmlXPathCountFunction"] = wasmExports["xmlXPathCountFunction"])(a0, a1);
    var _xmlXPathConcatFunction = Module["_xmlXPathConcatFunction"] = (a0, a1) => (_xmlXPathConcatFunction = Module["_xmlXPathConcatFunction"] = wasmExports["xmlXPathConcatFunction"])(a0, a1);
    var _xmlXPathContainsFunction = Module["_xmlXPathContainsFunction"] = (a0, a1) => (_xmlXPathContainsFunction = Module["_xmlXPathContainsFunction"] = wasmExports["xmlXPathContainsFunction"])(a0, a1);
    var _xmlXPathIdFunction = Module["_xmlXPathIdFunction"] = (a0, a1) => (_xmlXPathIdFunction = Module["_xmlXPathIdFunction"] = wasmExports["xmlXPathIdFunction"])(a0, a1);
    var _xmlXPathFalseFunction = Module["_xmlXPathFalseFunction"] = (a0, a1) => (_xmlXPathFalseFunction = Module["_xmlXPathFalseFunction"] = wasmExports["xmlXPathFalseFunction"])(a0, a1);
    var _xmlXPathFloorFunction = Module["_xmlXPathFloorFunction"] = (a0, a1) => (_xmlXPathFloorFunction = Module["_xmlXPathFloorFunction"] = wasmExports["xmlXPathFloorFunction"])(a0, a1);
    var _xmlXPathLastFunction = Module["_xmlXPathLastFunction"] = (a0, a1) => (_xmlXPathLastFunction = Module["_xmlXPathLastFunction"] = wasmExports["xmlXPathLastFunction"])(a0, a1);
    var _xmlXPathLangFunction = Module["_xmlXPathLangFunction"] = (a0, a1) => (_xmlXPathLangFunction = Module["_xmlXPathLangFunction"] = wasmExports["xmlXPathLangFunction"])(a0, a1);
    var _xmlXPathLocalNameFunction = Module["_xmlXPathLocalNameFunction"] = (a0, a1) => (_xmlXPathLocalNameFunction = Module["_xmlXPathLocalNameFunction"] = wasmExports["xmlXPathLocalNameFunction"])(a0, a1);
    var _xmlXPathNotFunction = Module["_xmlXPathNotFunction"] = (a0, a1) => (_xmlXPathNotFunction = Module["_xmlXPathNotFunction"] = wasmExports["xmlXPathNotFunction"])(a0, a1);
    var _xmlXPathNamespaceURIFunction = Module["_xmlXPathNamespaceURIFunction"] = (a0, a1) => (_xmlXPathNamespaceURIFunction = Module["_xmlXPathNamespaceURIFunction"] = wasmExports["xmlXPathNamespaceURIFunction"])(a0, a1);
    var _xmlXPathNormalizeFunction = Module["_xmlXPathNormalizeFunction"] = (a0, a1) => (_xmlXPathNormalizeFunction = Module["_xmlXPathNormalizeFunction"] = wasmExports["xmlXPathNormalizeFunction"])(a0, a1);
    var _xmlXPathNumberFunction = Module["_xmlXPathNumberFunction"] = (a0, a1) => (_xmlXPathNumberFunction = Module["_xmlXPathNumberFunction"] = wasmExports["xmlXPathNumberFunction"])(a0, a1);
    var _xmlXPathPositionFunction = Module["_xmlXPathPositionFunction"] = (a0, a1) => (_xmlXPathPositionFunction = Module["_xmlXPathPositionFunction"] = wasmExports["xmlXPathPositionFunction"])(a0, a1);
    var _xmlXPathRoundFunction = Module["_xmlXPathRoundFunction"] = (a0, a1) => (_xmlXPathRoundFunction = Module["_xmlXPathRoundFunction"] = wasmExports["xmlXPathRoundFunction"])(a0, a1);
    var _xmlXPathStringFunction = Module["_xmlXPathStringFunction"] = (a0, a1) => (_xmlXPathStringFunction = Module["_xmlXPathStringFunction"] = wasmExports["xmlXPathStringFunction"])(a0, a1);
    var _xmlXPathStringLengthFunction = Module["_xmlXPathStringLengthFunction"] = (a0, a1) => (_xmlXPathStringLengthFunction = Module["_xmlXPathStringLengthFunction"] = wasmExports["xmlXPathStringLengthFunction"])(a0, a1);
    var _xmlXPathStartsWithFunction = Module["_xmlXPathStartsWithFunction"] = (a0, a1) => (_xmlXPathStartsWithFunction = Module["_xmlXPathStartsWithFunction"] = wasmExports["xmlXPathStartsWithFunction"])(a0, a1);
    var _xmlXPathSubstringFunction = Module["_xmlXPathSubstringFunction"] = (a0, a1) => (_xmlXPathSubstringFunction = Module["_xmlXPathSubstringFunction"] = wasmExports["xmlXPathSubstringFunction"])(a0, a1);
    var _xmlXPathSubstringBeforeFunction = Module["_xmlXPathSubstringBeforeFunction"] = (a0, a1) => (_xmlXPathSubstringBeforeFunction = Module["_xmlXPathSubstringBeforeFunction"] = wasmExports["xmlXPathSubstringBeforeFunction"])(a0, a1);
    var _xmlXPathSubstringAfterFunction = Module["_xmlXPathSubstringAfterFunction"] = (a0, a1) => (_xmlXPathSubstringAfterFunction = Module["_xmlXPathSubstringAfterFunction"] = wasmExports["xmlXPathSubstringAfterFunction"])(a0, a1);
    var _xmlXPathSumFunction = Module["_xmlXPathSumFunction"] = (a0, a1) => (_xmlXPathSumFunction = Module["_xmlXPathSumFunction"] = wasmExports["xmlXPathSumFunction"])(a0, a1);
    var _xmlXPathTrueFunction = Module["_xmlXPathTrueFunction"] = (a0, a1) => (_xmlXPathTrueFunction = Module["_xmlXPathTrueFunction"] = wasmExports["xmlXPathTrueFunction"])(a0, a1);
    var _xmlXPathTranslateFunction = Module["_xmlXPathTranslateFunction"] = (a0, a1) => (_xmlXPathTranslateFunction = Module["_xmlXPathTranslateFunction"] = wasmExports["xmlXPathTranslateFunction"])(a0, a1);
    var _xmlXPathNextSelf = Module["_xmlXPathNextSelf"] = (a0, a1) => (_xmlXPathNextSelf = Module["_xmlXPathNextSelf"] = wasmExports["xmlXPathNextSelf"])(a0, a1);
    var _xmlXPathNextChild = Module["_xmlXPathNextChild"] = (a0, a1) => (_xmlXPathNextChild = Module["_xmlXPathNextChild"] = wasmExports["xmlXPathNextChild"])(a0, a1);
    var _xmlXPathNextDescendant = Module["_xmlXPathNextDescendant"] = (a0, a1) => (_xmlXPathNextDescendant = Module["_xmlXPathNextDescendant"] = wasmExports["xmlXPathNextDescendant"])(a0, a1);
    var _xmlXPathNextDescendantOrSelf = Module["_xmlXPathNextDescendantOrSelf"] = (a0, a1) => (_xmlXPathNextDescendantOrSelf = Module["_xmlXPathNextDescendantOrSelf"] = wasmExports["xmlXPathNextDescendantOrSelf"])(a0, a1);
    var _xmlXPathNextParent = Module["_xmlXPathNextParent"] = (a0, a1) => (_xmlXPathNextParent = Module["_xmlXPathNextParent"] = wasmExports["xmlXPathNextParent"])(a0, a1);
    var _xmlXPathNextAncestor = Module["_xmlXPathNextAncestor"] = (a0, a1) => (_xmlXPathNextAncestor = Module["_xmlXPathNextAncestor"] = wasmExports["xmlXPathNextAncestor"])(a0, a1);
    var _xmlXPathNextAncestorOrSelf = Module["_xmlXPathNextAncestorOrSelf"] = (a0, a1) => (_xmlXPathNextAncestorOrSelf = Module["_xmlXPathNextAncestorOrSelf"] = wasmExports["xmlXPathNextAncestorOrSelf"])(a0, a1);
    var _xmlXPathNextFollowingSibling = Module["_xmlXPathNextFollowingSibling"] = (a0, a1) => (_xmlXPathNextFollowingSibling = Module["_xmlXPathNextFollowingSibling"] = wasmExports["xmlXPathNextFollowingSibling"])(a0, a1);
    var _xmlXPathNextPrecedingSibling = Module["_xmlXPathNextPrecedingSibling"] = (a0, a1) => (_xmlXPathNextPrecedingSibling = Module["_xmlXPathNextPrecedingSibling"] = wasmExports["xmlXPathNextPrecedingSibling"])(a0, a1);
    var _xmlXPathNextFollowing = Module["_xmlXPathNextFollowing"] = (a0, a1) => (_xmlXPathNextFollowing = Module["_xmlXPathNextFollowing"] = wasmExports["xmlXPathNextFollowing"])(a0, a1);
    var _xmlXPathNextNamespace = Module["_xmlXPathNextNamespace"] = (a0, a1) => (_xmlXPathNextNamespace = Module["_xmlXPathNextNamespace"] = wasmExports["xmlXPathNextNamespace"])(a0, a1);
    var _xmlXPathNextAttribute = Module["_xmlXPathNextAttribute"] = (a0, a1) => (_xmlXPathNextAttribute = Module["_xmlXPathNextAttribute"] = wasmExports["xmlXPathNextAttribute"])(a0, a1);
    var _zcalloc = Module["_zcalloc"] = (a0, a1, a2) => (_zcalloc = Module["_zcalloc"] = wasmExports["zcalloc"])(a0, a1, a2);
    var _zcfree = Module["_zcfree"] = (a0, a1) => (_zcfree = Module["_zcfree"] = wasmExports["zcfree"])(a0, a1);
    var _strerror = Module["_strerror"] = (a0) => (_strerror = Module["_strerror"] = wasmExports["strerror"])(a0);
    var ___dl_seterr = (a0, a1) => (___dl_seterr = wasmExports["__dl_seterr"])(a0, a1);
    var _putc = Module["_putc"] = (a0, a1) => (_putc = Module["_putc"] = wasmExports["putc"])(a0, a1);
    var _gmtime = Module["_gmtime"] = (a0) => (_gmtime = Module["_gmtime"] = wasmExports["gmtime"])(a0);
    var _htonl = (a0) => (_htonl = wasmExports["htonl"])(a0);
    var _htons = (a0) => (_htons = wasmExports["htons"])(a0);
    var _ioctl = Module["_ioctl"] = (a0, a1, a2) => (_ioctl = Module["_ioctl"] = wasmExports["ioctl"])(a0, a1, a2);
    var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
    var _ntohs = (a0) => (_ntohs = wasmExports["ntohs"])(a0);
    var _srand = Module["_srand"] = (a0) => (_srand = Module["_srand"] = wasmExports["srand"])(a0);
    var _rand = Module["_rand"] = () => (_rand = Module["_rand"] = wasmExports["rand"])();
    var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["_emscripten_timeout"])(a0, a1);
    var ___floatsitf = Module["___floatsitf"] = (a0, a1) => (___floatsitf = Module["___floatsitf"] = wasmExports["__floatsitf"])(a0, a1);
    var ___multf3 = Module["___multf3"] = (a0, a1, a2, a3, a4) => (___multf3 = Module["___multf3"] = wasmExports["__multf3"])(a0, a1, a2, a3, a4);
    var ___extenddftf2 = Module["___extenddftf2"] = (a0, a1) => (___extenddftf2 = Module["___extenddftf2"] = wasmExports["__extenddftf2"])(a0, a1);
    var ___getf2 = Module["___getf2"] = (a0, a1, a2, a3) => (___getf2 = Module["___getf2"] = wasmExports["__getf2"])(a0, a1, a2, a3);
    var ___subtf3 = Module["___subtf3"] = (a0, a1, a2, a3, a4) => (___subtf3 = Module["___subtf3"] = wasmExports["__subtf3"])(a0, a1, a2, a3, a4);
    var ___letf2 = Module["___letf2"] = (a0, a1, a2, a3) => (___letf2 = Module["___letf2"] = wasmExports["__letf2"])(a0, a1, a2, a3);
    var ___lttf2 = Module["___lttf2"] = (a0, a1, a2, a3) => (___lttf2 = Module["___lttf2"] = wasmExports["__lttf2"])(a0, a1, a2, a3);
    var _setThrew = (a0, a1) => (_setThrew = wasmExports["setThrew"])(a0, a1);
    var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["_emscripten_tempret_set"])(a0);
    var __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports["_emscripten_tempret_get"])();
    var ___fixtfsi = Module["___fixtfsi"] = (a0, a1) => (___fixtfsi = Module["___fixtfsi"] = wasmExports["__fixtfsi"])(a0, a1);
    var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0);
    var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
    var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
    var _ScanKeywords = Module["_ScanKeywords"] = 69101716;
    var _stderr = Module["_stderr"] = 69124144;
    var _stdout = Module["_stdout"] = 69124448;
    var _CurrentMemoryContext = Module["_CurrentMemoryContext"] = 69156188;
    var _TopMemoryContext = Module["_TopMemoryContext"] = 69156192;
    var _TTSOpsVirtual = Module["_TTSOpsVirtual"] = 68962840;
    var ___THREW__ = Module["___THREW__"] = 69281700;
    var ___threwValue = Module["___threwValue"] = 69281704;
    var _error_context_stack = Module["_error_context_stack"] = 69171244;
    var _PG_exception_stack = Module["_PG_exception_stack"] = 69171248;
    var _CurrentResourceOwner = Module["_CurrentResourceOwner"] = 69156268;
    var _wal_segment_size = Module["_wal_segment_size"] = 68972040;
    var _InterruptPending = Module["_InterruptPending"] = 69162052;
    var _MyLatch = Module["_MyLatch"] = 69162220;
    var _InterruptHoldoffCount = Module["_InterruptHoldoffCount"] = 69162092;
    var _CritSectionCount = Module["_CritSectionCount"] = 69162100;
    var _pg_global_prng_state = Module["_pg_global_prng_state"] = 69267952;
    var _MyProc = Module["_MyProc"] = 69129772;
    var _GUC_check_errdetail_string = Module["_GUC_check_errdetail_string"] = 69157224;
    var _IsUnderPostmaster = Module["_IsUnderPostmaster"] = 69162125;
    var _progname = Module["_progname"] = 69125572;
    var _MyDatabaseId = Module["_MyDatabaseId"] = 69162108;
    var _MyProcPid = Module["_MyProcPid"] = 69162188;
    var _MyProcPort = Module["_MyProcPort"] = 69162208;
    var _single_mode_feed = Module["_single_mode_feed"] = 69125588;
    var _stdin = Module["_stdin"] = 69124296;
    var _SOCKET_DATA = Module["_SOCKET_DATA"] = 69185960;
    var _SOCKET_FILE = Module["_SOCKET_FILE"] = 69185956;
    var _cma_rsize = Module["_cma_rsize"] = 69125620;
    var _debug_query_string = Module["_debug_query_string"] = 69125804;
    var _cma_wsize = Module["_cma_wsize"] = 69125628;
    var _quote_all_identifiers = Module["_quote_all_identifiers"] = 69125577;
    var _TopTransactionContext = Module["_TopTransactionContext"] = 69156212;
    var _TopTransactionResourceOwner = Module["_TopTransactionResourceOwner"] = 69156276;
    var _TTSOpsMinimalTuple = Module["_TTSOpsMinimalTuple"] = 68962936;
    var _ProcessUtility_hook = Module["_ProcessUtility_hook"] = 69125992;
    var _work_mem = Module["_work_mem"] = 69095552;
    var _ParallelWorkerNumber = Module["_ParallelWorkerNumber"] = 68963384;
    var _XactIsoLevel = Module["_XactIsoLevel"] = 68971796;
    var _SnapshotAnyData = Module["_SnapshotAnyData"] = 69034440;
    var _SPI_processed = Module["_SPI_processed"] = 69126504;
    var _SPI_tuptable = Module["_SPI_tuptable"] = 69126512;
    var _SPI_result = Module["_SPI_result"] = 69126516;
    var _CacheMemoryContext = Module["_CacheMemoryContext"] = 69156204;
    var _pgBufferUsage = Module["_pgBufferUsage"] = 69127376;
    var _pgWalUsage = Module["_pgWalUsage"] = 69127488;
    var _TTSOpsHeapTuple = Module["_TTSOpsHeapTuple"] = 68962888;
    var _ExecutorStart_hook = Module["_ExecutorStart_hook"] = 69127512;
    var _ExecutorRun_hook = Module["_ExecutorRun_hook"] = 69127516;
    var _ExecutorFinish_hook = Module["_ExecutorFinish_hook"] = 69127520;
    var _ExecutorEnd_hook = Module["_ExecutorEnd_hook"] = 69127524;
    var _LocalBufferBlockPointers = Module["_LocalBufferBlockPointers"] = 69138204;
    var _BufferBlocks = Module["_BufferBlocks"] = 69132952;
    var _maintenance_work_mem = Module["_maintenance_work_mem"] = 69095568;
    var _wal_level = Module["_wal_level"] = 68972020;
    var _NBuffers = Module["_NBuffers"] = 69095576;
    var _old_snapshot_threshold = Module["_old_snapshot_threshold"] = 69156404;
    var _MainLWLockArray = Module["_MainLWLockArray"] = 69129804;
    var _ShmemVariableCache = Module["_ShmemVariableCache"] = 69128588;
    var _RmgrTable = Module["_RmgrTable"] = 68963600;
    var _process_shared_preload_libraries_in_progress = Module["_process_shared_preload_libraries_in_progress"] = 69162040;
    var _DataDir = Module["_DataDir"] = 69162104;
    var _shmem_startup_hook = Module["_shmem_startup_hook"] = 69132724;
    var _BufferDescriptors = Module["_BufferDescriptors"] = 69132948;
    var _application_name = Module["_application_name"] = 69158428;
    var _pg_crc32_table = Module["_pg_crc32_table"] = 67826528;
    var _oldSnapshotControl = Module["_oldSnapshotControl"] = 69156408;
    var _check_function_bodies = Module["_check_function_bodies"] = 69034614;
    var _cluster_name = Module["_cluster_name"] = 69034668;
    var _extra_float_digits = Module["_extra_float_digits"] = 69084196;
    var _max_parallel_maintenance_workers = Module["_max_parallel_maintenance_workers"] = 69095572;
    var _seq_page_cost = Module["_seq_page_cost"] = 69096440;
    var _cpu_tuple_cost = Module["_cpu_tuple_cost"] = 69096456;
    var _cpu_operator_cost = Module["_cpu_operator_cost"] = 69096472;
    var _Log_directory = Module["_Log_directory"] = 69172148;
    var _Log_filename = Module["_Log_filename"] = 69172152;
    var _IntervalStyle = Module["_IntervalStyle"] = 69162132;
    var _DateStyle = Module["_DateStyle"] = 69095540;
    var _xmlStructuredError = Module["_xmlStructuredError"] = 69268316;
    var _xmlStructuredErrorContext = Module["_xmlStructuredErrorContext"] = 69268324;
    var _xmlGenericErrorContext = Module["_xmlGenericErrorContext"] = 69268320;
    var _xmlGenericError = Module["_xmlGenericError"] = 69106020;
    var _xmlIsBaseCharGroup = Module["_xmlIsBaseCharGroup"] = 69105784;
    var _xmlIsDigitGroup = Module["_xmlIsDigitGroup"] = 69105816;
    var _xmlIsCombiningGroup = Module["_xmlIsCombiningGroup"] = 69105800;
    var _xmlIsExtenderGroup = Module["_xmlIsExtenderGroup"] = 69105832;
    var _xmlFree = Module["_xmlFree"] = 69105984;
    var _pg_number_of_ones = Module["_pg_number_of_ones"] = 68765008;
    var _MyStartTime = Module["_MyStartTime"] = 69162192;
    var _shmem_request_hook = Module["_shmem_request_hook"] = 69162044;
    var _ScanKeywordTokens = Module["_ScanKeywordTokens"] = 68450864;
    var _post_parse_analyze_hook = Module["_post_parse_analyze_hook"] = 69172140;
    var _ConfigReloadPending = Module["_ConfigReloadPending"] = 69172172;
    var _ShutdownRequestPending = Module["_ShutdownRequestPending"] = 69172176;
    var _planner_hook = Module["_planner_hook"] = 69172616;
    var _WalReceiverFunctions = Module["_WalReceiverFunctions"] = 69182296;
    var _check_password_hook = Module["_check_password_hook"] = 69172724;
    var _ClientAuthentication_hook = Module["_ClientAuthentication_hook"] = 69173480;
    var _IDB_STAGE = Module["_IDB_STAGE"] = 69185968;
    var _IDB_PIPE_FP = Module["_IDB_PIPE_FP"] = 69185964;
    var _pg_scram_mech = Module["_pg_scram_mech"] = 69105728;
    var _pg_g_threadlock = Module["_pg_g_threadlock"] = 69103832;
    var _pgresStatus = Module["_pgresStatus"] = 69105520;
    var _xmlIsPubidChar_tab = Module["_xmlIsPubidChar_tab"] = 68765296;
    var _xmlGetWarningsDefaultValue = Module["_xmlGetWarningsDefaultValue"] = 69106012;
    var _xmlMalloc = Module["_xmlMalloc"] = 69105988;
    var _xmlRealloc = Module["_xmlRealloc"] = 69105996;
    var _xmlLastError = Module["_xmlLastError"] = 69268336;
    var _xmlMallocAtomic = Module["_xmlMallocAtomic"] = 69105992;
    var _xmlMemStrdup = Module["_xmlMemStrdup"] = 69106e3;
    var _xmlBufferAllocScheme = Module["_xmlBufferAllocScheme"] = 69106004;
    var _xmlDefaultBufferSize = Module["_xmlDefaultBufferSize"] = 69106008;
    var _xmlParserDebugEntities = Module["_xmlParserDebugEntities"] = 69268276;
    var _xmlDoValidityCheckingDefaultValue = Module["_xmlDoValidityCheckingDefaultValue"] = 69268280;
    var _xmlLoadExtDtdDefaultValue = Module["_xmlLoadExtDtdDefaultValue"] = 69268284;
    var _xmlPedanticParserDefaultValue = Module["_xmlPedanticParserDefaultValue"] = 69268288;
    var _xmlLineNumbersDefaultValue = Module["_xmlLineNumbersDefaultValue"] = 69268292;
    var _xmlKeepBlanksDefaultValue = Module["_xmlKeepBlanksDefaultValue"] = 69106016;
    var _xmlSubstituteEntitiesDefaultValue = Module["_xmlSubstituteEntitiesDefaultValue"] = 69268296;
    var _xmlRegisterNodeDefaultValue = Module["_xmlRegisterNodeDefaultValue"] = 69268300;
    var _xmlDeregisterNodeDefaultValue = Module["_xmlDeregisterNodeDefaultValue"] = 69268304;
    var _xmlParserInputBufferCreateFilenameValue = Module["_xmlParserInputBufferCreateFilenameValue"] = 69268308;
    var _xmlOutputBufferCreateFilenameValue = Module["_xmlOutputBufferCreateFilenameValue"] = 69268312;
    var _xmlIndentTreeOutput = Module["_xmlIndentTreeOutput"] = 69106024;
    var _xmlTreeIndentString = Module["_xmlTreeIndentString"] = 69106028;
    var _xmlSaveNoEmptyTags = Module["_xmlSaveNoEmptyTags"] = 69268328;
    var _xmlDefaultSAXHandler = Module["_xmlDefaultSAXHandler"] = 69106032;
    var _xmlDefaultSAXLocator = Module["_xmlDefaultSAXLocator"] = 69106144;
    var _xmlParserMaxDepth = Module["_xmlParserMaxDepth"] = 69106804;
    var _xmlStringText = Module["_xmlStringText"] = 68767104;
    var _xmlStringComment = Module["_xmlStringComment"] = 68767119;
    var _xmlStringTextNoenc = Module["_xmlStringTextNoenc"] = 68767109;
    var _xmlXPathNAN = Module["_xmlXPathNAN"] = 69269e3;
    var _xmlXPathNINF = Module["_xmlXPathNINF"] = 69269016;
    var _xmlXPathPINF = Module["_xmlXPathPINF"] = 69269008;
    var _z_errmsg = Module["_z_errmsg"] = 69123360;
    var __length_code = Module["__length_code"] = 68786768;
    var __dist_code = Module["__dist_code"] = 68786256;
    function invoke_i(index) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)();
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iii(index, a1, a2) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_ii(index, a1) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viii(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_ji(index, a1) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        return 0n;
      }
    }
    function invoke_vi(index, a1) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiii(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vii(index, a1, a2) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_v(index) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)();
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiii(index, a1, a2, a3, a4, a5) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_jiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        return 0n;
      }
    }
    function invoke_jiiiii(index, a1, a2, a3, a4, a5) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        return 0n;
      }
    }
    function invoke_viiii(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vji(index, a1, a2) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiii(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiijii(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vijiji(index, a1, a2, a3, a4, a5) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viji(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_jiiii(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        return 0n;
      }
    }
    function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_jii(index, a1, a2) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
        return 0n;
      }
    }
    function invoke_iiij(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_di(index, a1) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_id(index, a1) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_ij(index, a1) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiij(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiij(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiji(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiji(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vij(index, a1, a2) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vid(index, a1, a2) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vj(index, a1) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viijii(index, a1, a2, a3, a4, a5) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiji(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viij(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    Module["addRunDependency"] = addRunDependency;
    Module["removeRunDependency"] = removeRunDependency;
    Module["callMain"] = callMain;
    Module["ccall"] = ccall;
    Module["cwrap"] = cwrap;
    Module["setValue"] = setValue;
    Module["getValue"] = getValue;
    Module["UTF8ToString"] = UTF8ToString;
    Module["stringToNewUTF8"] = stringToNewUTF8;
    Module["stringToUTF8OnStack"] = stringToUTF8OnStack;
    Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
    Module["FS_unlink"] = FS_unlink;
    Module["FS_createPath"] = FS_createPath;
    Module["FS_createDevice"] = FS_createDevice;
    Module["FS"] = FS;
    Module["FS_createDataFile"] = FS_createDataFile;
    Module["FS_createLazyFile"] = FS_createLazyFile;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function callMain(args2 = []) {
      var entryFunction = resolveGlobalSymbol("main").sym;
      ;
      if (!entryFunction)
        return;
      args2.unshift(thisProgram);
      var argc = args2.length;
      var argv = stackAlloc((argc + 1) * 4);
      var argv_ptr = argv;
      args2.forEach((arg) => {
        HEAPU32[argv_ptr >> 2] = stringToUTF8OnStack(arg);
        argv_ptr += 4;
      });
      HEAPU32[argv_ptr >> 2] = 0;
      try {
        var ret = entryFunction(argc, argv);
        exitJS(
          ret,
          /* implicit = */
          true
        );
        return ret;
      } catch (e) {
        return handleException(e);
      }
    }
    function run(args2 = arguments_) {
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        preMain();
        readyPromiseResolve(Module);
        Module["onRuntimeInitialized"]?.();
        if (shouldRunNow)
          callMain(args2);
        postRun();
      }
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function")
        Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    var shouldRunNow = true;
    if (Module["noInitialRun"])
      shouldRunNow = false;
    run();
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var postgres_default = Module2;

// node_modules/@electric-sql/pglite/dist/index.js
x();
x();
x();
var Ne2 = new Error("timeout while waiting for mutex to become available");
var Ue2 = new Error("mutex already locked");
var Ae2 = new Error("request for lock canceled");
var Re2 = function(i3, t2, e, s5) {
  function o5(r) {
    return r instanceof e ? r : new e(function(c2) {
      c2(r);
    });
  }
  return new (e || (e = Promise))(function(r, c2) {
    function m5(u4) {
      try {
        d3(s5.next(u4));
      } catch (a2) {
        c2(a2);
      }
    }
    function l4(u4) {
      try {
        d3(s5.throw(u4));
      } catch (a2) {
        c2(a2);
      }
    }
    function d3(u4) {
      u4.done ? r(u4.value) : o5(u4.value).then(m5, l4);
    }
    d3((s5 = s5.apply(i3, t2 || [])).next());
  });
};
var Z3 = class {
  constructor(t2, e = Ae2) {
    this._value = t2, this._cancelError = e, this._weightedQueues = [], this._weightedWaiters = [];
  }
  acquire(t2 = 1) {
    if (t2 <= 0)
      throw new Error(`invalid weight ${t2}: must be positive`);
    return new Promise((e, s5) => {
      this._weightedQueues[t2 - 1] || (this._weightedQueues[t2 - 1] = []), this._weightedQueues[t2 - 1].push({ resolve: e, reject: s5 }), this._dispatch();
    });
  }
  runExclusive(t2, e = 1) {
    return Re2(this, void 0, void 0, function* () {
      let [s5, o5] = yield this.acquire(e);
      try {
        return yield t2(s5);
      } finally {
        o5();
      }
    });
  }
  waitForUnlock(t2 = 1) {
    if (t2 <= 0)
      throw new Error(`invalid weight ${t2}: must be positive`);
    return new Promise((e) => {
      this._weightedWaiters[t2 - 1] || (this._weightedWaiters[t2 - 1] = []), this._weightedWaiters[t2 - 1].push(e), this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(t2) {
    this._value = t2, this._dispatch();
  }
  release(t2 = 1) {
    if (t2 <= 0)
      throw new Error(`invalid weight ${t2}: must be positive`);
    this._value += t2, this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((t2) => t2.forEach((e) => e.reject(this._cancelError))), this._weightedQueues = [];
  }
  _dispatch() {
    var t2;
    for (let e = this._value; e > 0; e--) {
      let s5 = (t2 = this._weightedQueues[e - 1]) === null || t2 === void 0 ? void 0 : t2.shift();
      if (!s5)
        continue;
      let o5 = this._value, r = e;
      this._value -= e, e = this._value + 1, s5.resolve([o5, this._newReleaser(r)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(t2) {
    let e = false;
    return () => {
      e || (e = true, this.release(t2));
    };
  }
  _drainUnlockWaiters() {
    for (let t2 = this._value; t2 > 0; t2--)
      this._weightedWaiters[t2 - 1] && (this._weightedWaiters[t2 - 1].forEach((e) => e()), this._weightedWaiters[t2 - 1] = []);
  }
};
var De2 = function(i3, t2, e, s5) {
  function o5(r) {
    return r instanceof e ? r : new e(function(c2) {
      c2(r);
    });
  }
  return new (e || (e = Promise))(function(r, c2) {
    function m5(u4) {
      try {
        d3(s5.next(u4));
      } catch (a2) {
        c2(a2);
      }
    }
    function l4(u4) {
      try {
        d3(s5.throw(u4));
      } catch (a2) {
        c2(a2);
      }
    }
    function d3(u4) {
      u4.done ? r(u4.value) : o5(u4.value).then(m5, l4);
    }
    d3((s5 = s5.apply(i3, t2 || [])).next());
  });
};
var M3 = class {
  constructor(t2) {
    this._semaphore = new Z3(1, t2);
  }
  acquire() {
    return De2(this, void 0, void 0, function* () {
      let [, t2] = yield this._semaphore.acquire();
      return t2;
    });
  }
  runExclusive(t2) {
    return this._semaphore.runExclusive(() => t2());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
x();
var ye2 = postgres_default;
x();
x();
var L6 = class extends sr {
  async init(t2, e) {
    return this.pg = t2, { emscriptenOpts: { ...e, preRun: [...e.preRun || [], (o5) => {
      let r = o5.FS.filesystems.IDBFS;
      o5.FS.mkdir("/pglite"), o5.FS.mkdir(`/pglite/${this.dataDir}`), o5.FS.mount(r, {}, `/pglite/${this.dataDir}`), o5.FS.symlink(`/pglite/${this.dataDir}`, C2);
    }] } };
  }
  initialSyncFs() {
    return new Promise((t2, e) => {
      this.pg.Module.FS.syncfs(true, (s5) => {
        s5 ? e(s5) : t2();
      });
    });
  }
  syncToFs(t2) {
    return new Promise((e, s5) => {
      this.pg.Module.FS.syncfs(false, (o5) => {
        o5 ? s5(o5) : e();
      });
    });
  }
  async closeFs() {
    let t2 = this.pg.Module.FS.filesystems.IDBFS.dbs[this.dataDir];
    t2 && t2.close(), this.pg.Module.FS.quit();
  }
};
x();
var q3 = class extends sr {
  async closeFs() {
    this.pg.Module.FS.quit();
  }
};
function he2(i3) {
  let t2;
  if (i3?.startsWith("file://")) {
    if (i3 = i3.slice(7), !i3)
      throw new Error("Invalid dataDir, must be a valid path");
    t2 = "nodefs";
  } else
    i3?.startsWith("idb://") ? (i3 = i3.slice(6), t2 = "idbfs") : i3?.startsWith("opfs-ahp://") ? (i3 = i3.slice(11), t2 = "opfs-ahp") : !i3 || i3?.startsWith("memory://") ? t2 = "memoryfs" : t2 = "nodefs";
  return { dataDir: i3, fsType: t2 };
}
async function ge2(i3, t2) {
  let e;
  if (i3 && t2 === "nodefs") {
    let { NodeFS: s5 } = await Promise.resolve().then(() => (init_nodefs(), nodefs_exports));
    e = new s5(i3);
  } else if (i3 && t2 === "idbfs")
    e = new L6(i3);
  else if (i3 && t2 === "opfs-ahp") {
    let { OpfsAhpFS: s5 } = await Promise.resolve().then(() => (init_opfs_ahp(), opfs_ahp_exports));
    e = new s5(i3);
  } else
    e = new q3();
  return e;
}
x();
var we2 = F2(or(), 1);
async function ee2(i3) {
  if (Ge) {
    let t2 = await import("fs"), e = await import("zlib"), { Writable: s5 } = await import("stream"), { pipeline: o5 } = await import("stream/promises");
    if (!t2.existsSync(i3))
      throw new Error(`Extension bundle not found: ${i3}`);
    let r = e.createGunzip(), c2 = [];
    return await o5(t2.createReadStream(i3), r, new s5({ write(m5, l4, d3) {
      c2.push(m5), d3();
    } })), new Blob(c2);
  } else {
    let t2 = await fetch(i3.toString());
    if (!t2.ok || !t2.body)
      return null;
    if (t2.headers.get("Content-Encoding") === "gzip")
      return t2.blob();
    {
      let e = new DecompressionStream("gzip");
      return new Response(t2.body.pipeThrough(e)).blob();
    }
  }
}
async function be2(i3, t2) {
  for (let e in i3.pg_extensions) {
    let s5;
    try {
      s5 = await i3.pg_extensions[e];
    } catch (o5) {
      console.error("Failed to fetch extension:", e, o5);
      continue;
    }
    if (s5) {
      let o5 = new Uint8Array(await s5.arrayBuffer());
      Ie2(i3, e, o5, t2);
    } else
      console.error("Could not get binary data for extension:", e);
  }
}
function Ie2(i3, t2, e, s5) {
  we2.default.untar(e).forEach((r) => {
    if (!r.name.startsWith(".")) {
      let c2 = i3.WASM_PREFIX + "/" + r.name;
      if (r.name.endsWith(".so")) {
        let m5 = (...d3) => {
          s5("pgfs:ext OK", c2, d3);
        }, l4 = (...d3) => {
          s5("pgfs:ext FAIL", c2, d3);
        };
        i3.FS.createPreloadedFile(ke2(c2), r.name.split("/").pop().slice(0, -3), r.data, true, true, m5, l4, false);
      } else
        i3.FS.writeFile(c2, r.data);
    }
  });
}
function ke2(i3) {
  let t2 = i3.lastIndexOf("/");
  return t2 > 0 ? i3.slice(0, t2) : i3;
}
var I3;
var O4;
var A3;
var k4;
var N3;
var K3;
var X3;
var Y3;
var U3;
var $4;
var C5;
var Q3;
var R5;
var F4;
var w5;
var D5;
var P5;
var Pe2;
var W4;
var te2 = class te3 extends z3 {
  constructor(e = {}, s5 = {}) {
    super();
    L2(this, P5);
    L2(this, I3, false);
    L2(this, O4, false);
    L2(this, A3, false);
    L2(this, k4, false);
    L2(this, N3, false);
    L2(this, K3, new M3());
    L2(this, X3, new M3());
    L2(this, Y3, new M3());
    L2(this, U3, false);
    this.debug = 0;
    L2(this, $4);
    L2(this, C5, []);
    L2(this, Q3, new ye());
    L2(this, R5);
    L2(this, F4);
    L2(this, w5, /* @__PURE__ */ new Map());
    L2(this, D5, /* @__PURE__ */ new Set());
    typeof e == "string" ? s5 = { dataDir: e, ...s5 } : s5 = e, this.dataDir = s5.dataDir, s5?.debug !== void 0 && (this.debug = s5.debug), s5?.relaxedDurability !== void 0 && h(this, N3, s5.relaxedDurability), h(this, $4, s5.extensions ?? {}), this.waitReady = P2(this, P5, Pe2).call(this, s5 ?? {});
  }
  static async create(e, s5) {
    let o5 = typeof e == "string" ? { dataDir: e, ...s5 ?? {} } : e ?? {}, r = new te3(o5);
    return await r.waitReady, r;
  }
  get Module() {
    return this.mod;
  }
  get ready() {
    return g2(this, I3) && !g2(this, O4) && !g2(this, A3);
  }
  get closed() {
    return g2(this, A3);
  }
  async close() {
    await this._checkReady(), h(this, O4, true);
    for (let e of g2(this, C5))
      await e();
    try {
      await this.execProtocol(k2.end()), this.mod._pg_shutdown();
    } catch (e) {
      let s5 = e;
      if (!(s5.name === "ExitStatus" && s5.status === 0))
        throw e;
    }
    await this.fs.closeFs(), h(this, A3, true), h(this, O4, false);
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async _handleBlob(e) {
    h(this, R5, e ? await e.arrayBuffer() : void 0);
  }
  async _cleanupBlob() {
    h(this, R5, void 0);
  }
  async _getWrittenBlob() {
    if (!g2(this, F4))
      return;
    let e = new Blob(g2(this, F4));
    return h(this, F4, void 0), e;
  }
  async _checkReady() {
    if (g2(this, O4))
      throw new Error("PGlite is closing");
    if (g2(this, A3))
      throw new Error("PGlite is closed");
    g2(this, I3) || await this.waitReady;
  }
  async execProtocolRaw(e, { syncToFs: s5 = true } = {}) {
    let o5 = e.length, r = this.mod;
    r._interactive_write(o5), r.HEAPU8.set(e, 1), r._interactive_one();
    let c2 = o5 + 2, m5 = c2 + r._interactive_read(), l4 = r.HEAPU8.subarray(c2, m5);
    return s5 && await this.syncToFs(), l4;
  }
  async execProtocol(e, { syncToFs: s5 = true, throwOnError: o5 = true, onNotice: r } = {}) {
    let c2 = await this.execProtocolRaw(e, { syncToFs: s5 }), m5 = [];
    return g2(this, Q3).parse(c2, (l4) => {
      if (l4 instanceof C3) {
        if (h(this, Q3, new ye()), o5)
          throw l4;
      } else if (l4 instanceof ne)
        this.debug > 0 && console.warn(l4), r && r(l4);
      else if (l4 instanceof ee)
        switch (l4.text) {
          case "BEGIN":
            h(this, k4, true);
            break;
          case "COMMIT":
          case "ROLLBACK":
            h(this, k4, false);
            break;
        }
      else if (l4 instanceof X2) {
        let d3 = g2(this, w5).get(l4.channel);
        d3 && d3.forEach((u4) => {
          queueMicrotask(() => u4(l4.payload));
        }), g2(this, D5).forEach((u4) => {
          queueMicrotask(() => u4(l4.channel, l4.payload));
        });
      }
      m5.push([l4, c2]);
    }), m5;
  }
  isInTransaction() {
    return g2(this, k4);
  }
  async syncToFs() {
    if (g2(this, U3))
      return;
    h(this, U3, true);
    let e = async () => {
      await g2(this, Y3).runExclusive(async () => {
        h(this, U3, false), await this.fs.syncToFs(g2(this, N3));
      });
    };
    g2(this, N3) ? e() : await e();
  }
  async listen(e, s5) {
    return g2(this, w5).has(e) || g2(this, w5).set(e, /* @__PURE__ */ new Set()), g2(this, w5).get(e).add(s5), await this.exec(`LISTEN "${e}"`), async () => {
      await this.unlisten(e, s5);
    };
  }
  async unlisten(e, s5) {
    s5 ? (g2(this, w5).get(e)?.delete(s5), g2(this, w5).get(e)?.size === 0 && (await this.exec(`UNLISTEN "${e}"`), g2(this, w5).delete(e))) : (await this.exec(`UNLISTEN "${e}"`), g2(this, w5).delete(e));
  }
  onNotification(e) {
    return g2(this, D5).add(e), () => {
      g2(this, D5).delete(e);
    };
  }
  offNotification(e) {
    g2(this, D5).delete(e);
  }
  async dumpDataDir(e) {
    let s5 = this.dataDir?.split("/").pop() ?? "pgdata";
    return this.fs.dumpTar(s5, e);
  }
  _runExclusiveQuery(e) {
    return g2(this, K3).runExclusive(e);
  }
  _runExclusiveTransaction(e) {
    return g2(this, X3).runExclusive(e);
  }
};
I3 = /* @__PURE__ */ new WeakMap(), O4 = /* @__PURE__ */ new WeakMap(), A3 = /* @__PURE__ */ new WeakMap(), k4 = /* @__PURE__ */ new WeakMap(), N3 = /* @__PURE__ */ new WeakMap(), K3 = /* @__PURE__ */ new WeakMap(), X3 = /* @__PURE__ */ new WeakMap(), Y3 = /* @__PURE__ */ new WeakMap(), U3 = /* @__PURE__ */ new WeakMap(), $4 = /* @__PURE__ */ new WeakMap(), C5 = /* @__PURE__ */ new WeakMap(), Q3 = /* @__PURE__ */ new WeakMap(), R5 = /* @__PURE__ */ new WeakMap(), F4 = /* @__PURE__ */ new WeakMap(), w5 = /* @__PURE__ */ new WeakMap(), D5 = /* @__PURE__ */ new WeakMap(), P5 = /* @__PURE__ */ new WeakSet(), Pe2 = async function(e) {
  if (e.fs)
    this.fs = e.fs;
  else {
    let { dataDir: a2, fsType: h3 } = he2(e.dataDir);
    this.fs = await ge2(a2, h3);
  }
  let s5 = {}, o5 = [], r = [`PGDATA=${C2}`, `PREFIX=${Vr}`, `PGUSER=${e.username ?? "postgres"}`, `PGDATABASE=${e.database ?? "template1"}`, "MODE=REACT", "REPL=N", ...this.debug ? ["-d", this.debug.toString()] : []];
  e.wasmModule || Er();
  let c2 = e.fsBundle ? e.fsBundle.arrayBuffer() : Pr(), m5;
  c2.then((a2) => {
    m5 = a2;
  });
  let l4 = { WASM_PREFIX: Vr, arguments: r, INITIAL_MEMORY: e.initialMemory, noExitRuntime: true, ...this.debug > 0 ? { print: console.info, printErr: console.error } : { print: () => {
  }, printErr: () => {
  } }, instantiateWasm: (a2, h3) => (Cr(a2, e.wasmModule).then(({ instance: g5, module: b4 }) => {
    h3(g5, b4);
  }), {}), getPreloadedPackage: (a2, h3) => {
    if (a2 === "postgres.data") {
      if (m5.byteLength !== h3)
        throw new Error(`Invalid FS bundle size: ${m5.byteLength} !== ${h3}`);
      return m5;
    }
    throw new Error(`Unknown package: ${a2}`);
  }, preRun: [(a2) => {
    let h3 = a2.FS.makedev(64, 0), g5 = { open: (b4) => {
    }, close: (b4) => {
    }, read: (b4, G4, T4, S4, x4) => {
      let se2 = g2(this, R5);
      if (!se2)
        throw new Error("No /dev/blob File or Blob provided to read from");
      let H5 = new Uint8Array(se2);
      if (x4 >= H5.length)
        return 0;
      let ie2 = Math.min(H5.length - x4, S4);
      for (let j4 = 0; j4 < ie2; j4++)
        G4[T4 + j4] = H5[x4 + j4];
      return ie2;
    }, write: (b4, G4, T4, S4, x4) => (g2(this, F4) ?? h(this, F4, []), g2(this, F4).push(G4.slice(T4, T4 + S4)), S4), llseek: (b4, G4, T4) => {
      let S4 = g2(this, R5);
      if (!S4)
        throw new Error("No /dev/blob File or Blob provided to llseek");
      let x4 = G4;
      if (T4 === 1 ? x4 += b4.position : T4 === 2 && (x4 = new Uint8Array(S4).length), x4 < 0)
        throw new a2.FS.ErrnoError(28);
      return x4;
    } };
    a2.FS.registerDevice(h3, g5), a2.FS.mkdev("/dev/blob", h3);
  }] }, { emscriptenOpts: d3 } = await this.fs.init(this, l4);
  l4 = d3;
  for (let [a2, h3] of Object.entries(g2(this, $4)))
    if (h3 instanceof URL)
      s5[a2] = ee2(h3);
    else {
      let g5 = await h3.setup(this, l4);
      if (g5.emscriptenOpts && (l4 = g5.emscriptenOpts), g5.namespaceObj) {
        let b4 = this;
        b4[a2] = g5.namespaceObj;
      }
      g5.bundlePath && (s5[a2] = ee2(g5.bundlePath)), g5.init && o5.push(g5.init), g5.close && g2(this, C5).push(g5.close);
    }
  if (l4.pg_extensions = s5, await c2, this.mod = await ye2(l4), await this.fs.initialSyncFs(), e.loadDataDir) {
    if (this.mod.FS.analyzePath(C2 + "/PG_VERSION").exists)
      throw new Error("Database already exists, cannot load from tarball");
    P2(this, P5, W4).call(this, "pglite: loading data from tarball"), await ce(this.mod.FS, e.loadDataDir, C2);
  }
  this.mod.FS.analyzePath(C2 + "/PG_VERSION").exists ? P2(this, P5, W4).call(this, "pglite: found DB, resuming") : P2(this, P5, W4).call(this, "pglite: no db"), await be2(this.mod, (...a2) => P2(this, P5, W4).call(this, ...a2));
  let u4 = this.mod._pg_initdb();
  if (!u4)
    throw new Error("INITDB failed to return value");
  if (u4 & 1)
    throw new Error("INITDB failed");
  if (u4 & 2) {
    let a2 = e.username ?? "postgres", h3 = e.database ?? "template1";
    if (u4 & 4) {
      if (!(u4 & 12))
        throw new Error("Invalid db/user combination");
    } else if (h3 !== "template1" && a2 !== "postgres")
      throw new Error("INITDB created a new datadir, but an alternative db/user was requested");
  }
  await this.syncToFs(), h(this, I3, true), await this.exec("SET search_path TO public;"), await this._initArrayTypes();
  for (let a2 of o5)
    await a2();
}, W4 = function(...e) {
  this.debug > 0 && console.log(...e);
};
var xe2 = te2;
x();

// src/services/rag/db/Database.ts
init_constants();
init_i18n();
var SUPPORTED_DIMENSIONS = [
  128,
  256,
  384,
  512,
  768,
  1024,
  1280,
  1536,
  1792
];
var Database = class {
  constructor(app) {
    this.pgClient = null;
    this.app = app;
  }
  /**
   * 初始化数据库（加载或新建，并执行迁移）
   */
  async init() {
    const dbPath = DB_PATH;
    const exists = await this.app.vault.adapter.exists(dbPath);
    if (exists) {
      try {
        const fileBuffer = await this.app.vault.adapter.readBinary(dbPath);
        const fileBlob = new Blob([fileBuffer], { type: "application/x-gzip" });
        const { fsBundle, wasmModule, vectorExtensionBundlePath } = await this.loadPgliteResources();
        this.pgClient = await xe2.create({
          loadDataDir: fileBlob,
          fsBundle,
          wasmModule,
          extensions: { vector: vectorExtensionBundlePath }
        });
      } catch (e) {
        console.error("[RAG] \u52A0\u8F7D\u6570\u636E\u5E93\u5931\u8D25\uFF0C\u5C06\u521B\u5EFA\u65B0\u5E93", e);
      }
    }
    if (!this.pgClient) {
      const { fsBundle, wasmModule, vectorExtensionBundlePath } = await this.loadPgliteResources();
      this.pgClient = await xe2.create({
        fsBundle,
        wasmModule,
        extensions: { vector: vectorExtensionBundlePath }
      });
      await this.migrate();
      await this.save();
    }
  }
  /** 提供 pgClient 给外部使用 */
  getClient() {
    if (!this.pgClient)
      throw new Error("Database not initialized");
    return this.pgClient;
  }
  /** 执行迁移脚本 */
  async migrate() {
    if (!this.pgClient)
      return;
    try {
      await this.pgClient.query("CREATE EXTENSION IF NOT EXISTS vector;");
      await this.pgClient.query(`CREATE TABLE IF NOT EXISTS embeddings (
        id serial PRIMARY KEY,
        path text NOT NULL,
        mtime bigint NOT NULL,
        content text NOT NULL,
        model text NOT NULL,
        dimension smallint NOT NULL,
        embedding vector,
        metadata jsonb NOT NULL);
      `);
      await this.pgClient.query(`
        CREATE TABLE IF NOT EXISTS rag_metadata (
          key text PRIMARY KEY,
          value text NOT NULL,
          updated_at bigint NOT NULL
        );
      `);
      await this.pgClient.query(
        `CREATE INDEX IF NOT EXISTS embeddings_path_idx ON embeddings(path);`
      );
      await this.pgClient.query(
        `CREATE INDEX IF NOT EXISTS embeddings_model_idx ON embeddings(model);`
      );
      await this.pgClient.query(
        `CREATE INDEX IF NOT EXISTS embeddings_dimension_idx ON embeddings(dimension);`
      );
      for (const dim of SUPPORTED_DIMENSIONS) {
        await this.pgClient.query(
          `CREATE INDEX IF NOT EXISTS embeddings_embedding_${dim}_hnsw_idx
             ON embeddings USING hnsw ((embedding::vector(${dim})) vector_cosine_ops)
             WITH (m=16, ef_construction=64) -- \u964D\u4F4E\u6784\u5EFA\u53C2\u6570\uFF0C\u52A0\u5FEB\u7D22\u5F15\u521B\u5EFA\u901F\u5EA6
             WHERE dimension = ${dim};`
        );
      }
    } catch (e) {
      console.error("[RAG] \u6570\u636E\u5E93\u8FC1\u79FB\u5931\u8D25", e);
    }
  }
  /**
   * 获取元数据值
   * @param key 元数据键名
   * @returns 元数据值，不存在则返回 null
   */
  async getMetadata(key) {
    if (!this.pgClient)
      return null;
    try {
      const result = await this.pgClient.query(
        "SELECT value FROM rag_metadata WHERE key = $1",
        [key]
      );
      if (result.rows.length === 0) {
        return null;
      }
      const row = result.rows[0];
      return row.value;
    } catch (error2) {
      console.error(`[RAG] \u83B7\u53D6\u5143\u6570\u636E\u5931\u8D25: ${key}`, error2);
      return null;
    }
  }
  /**
   * 设置元数据值
   * @param key 元数据键名
   * @param value 元数据值
   */
  async setMetadata(key, value) {
    if (!this.pgClient)
      return;
    try {
      const timestamp = Date.now();
      await this.pgClient.query(
        `INSERT INTO rag_metadata (key, value, updated_at) 
         VALUES ($1, $2, $3)
         ON CONFLICT (key) 
         DO UPDATE SET value = $2, updated_at = $3`,
        [key, value, timestamp]
      );
    } catch (error2) {
      console.error(`[RAG] \u8BBE\u7F6E\u5143\u6570\u636E\u5931\u8D25: ${key}`, error2);
    }
  }
  /** 保存数据库到压缩包 */
  async save() {
    if (!this.pgClient)
      return;
    try {
      const blob = await this.pgClient.dumpDataDir("gzip");
      const buf = await blob.arrayBuffer();
      await this.app.vault.adapter.writeBinary(DB_PATH, buf);
    } catch (e) {
      console.error("[RAG] \u4FDD\u5B58\u6570\u636E\u5E93\u5931\u8D25", e);
      new import_obsidian33.Notice(t("save RAG database failed"));
    }
  }
  /** 从 unpkg 加载 wasm 等资源 */
  async loadPgliteResources() {
    const ver = "0.2.12";
    const [fsRes, wasmRes] = await Promise.all([
      (0, import_obsidian33.requestUrl)(`https://unpkg.com/@electric-sql/pglite@${ver}/dist/postgres.data`),
      (0, import_obsidian33.requestUrl)(`https://unpkg.com/@electric-sql/pglite@${ver}/dist/postgres.wasm`)
    ]);
    const fsBundle = new Blob([fsRes.arrayBuffer], { type: "application/octet-stream" });
    const wasmModule = await WebAssembly.compile(wasmRes.arrayBuffer);
    const vectorExtensionBundlePath = new URL(`https://unpkg.com/@electric-sql/pglite@${ver}/dist/vector.tar.gz`);
    return { fsBundle, wasmModule, vectorExtensionBundlePath };
  }
};

// src/services/rag/embedding/EmbeddingHelper.ts
var import_exponential_backoff = __toESM(require_backoff());

// src/services/rag/utils.ts
function splitIntoChunks(text, chunkSize, overlap) {
  const cleanText2 = text.trim().replace(/\n\s*\n/g, "\n\n");
  const chunks = [];
  let position = 0;
  while (position < cleanText2.length) {
    const chunk = cleanText2.substring(position, position + chunkSize);
    chunks.push(chunk);
    position += chunkSize - overlap;
    if (position <= 0)
      position = chunkSize;
  }
  return chunks;
}
var sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// src/services/rag/embedding/EmbeddingHelper.ts
init_constants();
var EmbeddingHelper = class {
  constructor(cfg) {
    this.baseUrl = cfg.embeddingEndpoint.replace(/\/+$/, "");
    this.model = cfg.embeddingModel;
    this.apiKey = cfg.apiKey || "";
  }
  /**
   * 请求向量接口，返回 embedding 数组。
   * 带有指数退避重试，最大 10 次。
   */
  async embed(text) {
    return (await this.embedBatch([text]))[0];
  }
  /**
   * 批量请求向量接口，返回 embeddings 数组。
   * 可显著减少 HTTP 往返，提升索引速度。
   */
  async embedBatch(texts) {
    const run2 = async () => {
      if (texts.length === 0)
        return [];
      const validTexts = texts.filter((t2) => t2 && t2.trim().length > 0);
      if (validTexts.length === 0) {
        return [];
      }
      const url = `${this.baseUrl}/embeddings`;
      try {
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.apiKey}`
          },
          body: JSON.stringify({ model: this.model, input: validTexts })
        });
        if (res.status === 429) {
          const retryAfter = Number(res.headers.get("retry-after") ?? "1");
          await sleep((retryAfter || 1) * 1e3);
          throw new Error("Rate limited");
        }
        if (!res.ok) {
          throw new Error(`Embedding failed: ${res.status} ${res.statusText}`);
        }
        const json = await res.json();
        const vectors = (json?.data ?? []).map((d3) => d3.embedding);
        let result = [];
        let validIndex = 0;
        for (let i3 = 0; i3 < texts.length; i3++) {
          if (texts[i3] && texts[i3].trim().length > 0) {
            if (validIndex < vectors.length) {
              result.push(vectors[validIndex++]);
            } else {
              result.push(new Array(VECTOR_DIMENSION).fill(0));
            }
          } else {
            result.push(new Array(VECTOR_DIMENSION).fill(0));
          }
        }
        if (vectors.length !== validTexts.length) {
          throw new Error("Unexpected embedding response");
        }
        return result;
      } catch (err2) {
        throw err2;
      }
    };
    return (0, import_exponential_backoff.backOff)(run2, {
      jitter: "full",
      startingDelay: 500,
      timeMultiple: 2,
      maxDelay: 6e4,
      numOfAttempts: 10,
      retry: (e) => e.message === "Rate limited"
    });
  }
  /** 动态更新配置 */
  update(cfg) {
    if (cfg.embeddingEndpoint)
      this.baseUrl = cfg.embeddingEndpoint.replace(/\/+$/, "");
    if (cfg.embeddingModel)
      this.model = cfg.embeddingModel;
    if (cfg.apiKey !== void 0)
      this.apiKey = cfg.apiKey;
  }
  /** 返回当前使用的模型 id */
  getModelId() {
    return this.model;
  }
};

// src/services/rag/indexer/IndexBuilder.ts
init_constants();
var IndexBuilder = class {
  constructor(app, db, embedder) {
    this.app = app;
    this.db = db;
    this.embedder = embedder;
  }
  /**
   * 构建索引
   * @param reindexAll true=强制全量重建；false=增量
   * @param progress 回调：已完成 chunk / total chunk
   */
  async buildIndex(reindexAll, progress) {
    const pg = this.db.getClient();
    if (reindexAll) {
      await pg.query("TRUNCATE TABLE embeddings");
    } else {
      try {
        const res = await pg.query("SELECT DISTINCT path FROM embeddings");
        const indexedPaths = res?.rows?.map((r) => r.path) || [];
        const liveSet = new Set(
          this.app.vault.getMarkdownFiles().map((f3) => f3.path)
        );
        const toRemove = indexedPaths.filter((p5) => !liveSet.has(p5));
        if (toRemove.length) {
          await pg.query(
            `DELETE FROM embeddings WHERE path = ANY($1::text[])`,
            [toRemove]
          );
        }
      } catch (e) {
      }
    }
    const allFiles = this.app.vault.getMarkdownFiles().filter((f3) => f3.stat.size < MAX_FILE_BYTES);
    let targetFiles = allFiles;
    if (!reindexAll) {
      const rows = await pg.query(
        "SELECT path, MAX(mtime) AS mtime FROM embeddings GROUP BY path"
      );
      const mtimeMap = /* @__PURE__ */ new Map();
      for (const r of rows.rows) {
        mtimeMap.set(r.path, Number(r.mtime));
      }
      targetFiles = allFiles.filter((f3) => {
        const prev = mtimeMap.get(f3.path);
        return prev === void 0 || f3.stat.mtime > prev;
      });
    }
    let totalChunks = 0;
    const fileChunksMap = /* @__PURE__ */ new Map();
    for (const f3 of targetFiles) {
      const content = await this.app.vault.read(f3);
      const chunks = splitIntoChunks(
        content,
        MAX_TOKENS_PER_CHUNK,
        MAX_CHUNK_OVERLAP
      );
      fileChunksMap.set(f3.path, chunks);
      totalChunks += chunks.length;
    }
    if (totalChunks === 0) {
      progress(1, 1);
      return;
    }
    let doneChunks = 0;
    const update = () => progress(++doneChunks, totalChunks);
    const indexRef = { value: 0 };
    const worker = async () => {
      while (true) {
        const idx = indexRef.value++;
        if (idx >= targetFiles.length)
          break;
        const file = targetFiles[idx];
        const chunks = fileChunksMap.get(file.path) || [];
        await pg.query("DELETE FROM embeddings WHERE path=$1", [file.path]);
        let searchStart = 0;
        const fullContent = await this.app.vault.read(file);
        try {
          const embeddings = await this.embedder.embedBatch(chunks);
          await pg.query("BEGIN");
          for (let i3 = 0; i3 < chunks.length; i3++) {
            const chunk = chunks[i3];
            const pos = fullContent.indexOf(chunk, searchStart);
            const before = fullContent.slice(0, pos);
            const startLine = before.split("\n").length;
            const lineCount = chunk.split("\n").length;
            const endLine = startLine + lineCount - 1;
            searchStart = pos + chunk.length;
            const emb = embeddings[i3];
            await pg.query(
              `INSERT INTO embeddings(path, mtime, content, model, dimension, embedding, metadata)
               VALUES($1,$2,$3,$4,$5,$6::vector,$7)`,
              [
                file.path,
                file.stat.mtime,
                chunk,
                this.embedder.getModelId(),
                emb.length,
                `[${emb.join(",")}]`,
                JSON.stringify({ startLine, endLine })
              ]
            );
            update();
          }
          await pg.query("COMMIT");
        } catch (err2) {
          try {
            await pg.query("ROLLBACK");
          } catch (rollbackErr) {
          }
        }
      }
    };
    const workers = Array.from({ length: MAX_CONCURRENCY }, () => worker());
    await Promise.all(workers);
  }
};

// src/services/rag/indexer/NotesIndexBuilder.ts
init_constants();
var NotesIndexBuilder = class {
  constructor(db, embedder) {
    this.db = db;
    this.embedder = embedder;
  }
  /**
   * 构建索引
   * @param dm           DataManager 实例（提供条目）
   * @param reindexAll   是否强制重建（删除全部 note: 记录）
   * @param progress     进度回调
   */
  async buildIndex(dm, reindexAll, progress = () => {
  }) {
    const pg = this.db.getClient();
    const currentTime = Date.now();
    if (reindexAll) {
      await pg.query(`DELETE FROM embeddings WHERE path LIKE 'note:%'`);
    }
    const entries = dm.getAllEntries();
    let targetEntries = entries;
    if (!reindexAll) {
      try {
        const lastIndexTimeStr = await this.db.getMetadata(NOTES_LAST_INDEX_TIME);
        const lastIndexTime = lastIndexTimeStr ? parseInt(lastIndexTimeStr, 10) : 0;
        if (lastIndexTime > 0) {
          targetEntries = entries.filter((entry) => {
            const entryMtime = entry.mtime || 0;
            return entryMtime > lastIndexTime;
          });
        }
      } catch (error2) {
        console.error("\u83B7\u53D6\u4E0A\u6B21\u7D22\u5F15\u65F6\u95F4\u5931\u8D25\uFF0C\u5C06\u6267\u884C\u5168\u91CF\u7D22\u5F15", error2);
        targetEntries = entries;
      }
    }
    const total = targetEntries.length;
    if (total === 0) {
      await this.db.setMetadata(NOTES_LAST_INDEX_TIME, currentTime.toString());
      progress(1, 1);
      return;
    }
    let done = 0;
    const update = () => progress(++done, total);
    const indexRef = { value: 0 };
    const worker = async () => {
      while (true) {
        const idx = indexRef.value++;
        if (idx >= targetEntries.length)
          break;
        const entry = targetEntries[idx];
        try {
          const content = [entry.value, entry.comment].filter(Boolean).join("\n\n");
          const emb = await this.embedder.embed(content);
          await pg.query("DELETE FROM embeddings WHERE path=$1", [
            `note:${entry.hash}`
          ]);
          const mtime = entry.mtime || currentTime;
          await pg.query(
            `INSERT INTO embeddings(path, mtime, content, model, dimension, embedding, metadata)
             VALUES($1,$2,$3,$4,$5,$6::vector,$7)`,
            [
              `note:${entry.hash}`,
              mtime,
              content,
              this.embedder.getModelId(),
              emb.length,
              `[${emb.join(",")}]`,
              JSON.stringify({
                hash: entry.hash,
                set: entry.set,
                tag: entry.tag || [],
                sourceFile: entry.sourceFile,
                value: entry.value,
                comment: entry.comment,
                link: entry.link || []
              })
            ]
          );
          update();
        } catch (error2) {
          console.error(`\u7D22\u5F15\u6761\u76EE\u5931\u8D25: ${entry.hash}`, error2);
          update();
        }
      }
    };
    const workerCount = Math.min(MAX_CONCURRENCY, total);
    const workers = Array.from({ length: workerCount }, () => worker());
    await Promise.all(workers);
    await this.db.setMetadata(NOTES_LAST_INDEX_TIME, currentTime.toString());
  }
};

// src/services/rag/RagService.ts
init_i18n();
var RagService = class {
  constructor(app, cfg) {
    this.app = app;
    const merged = { ...DEFAULT_RAG_CONFIG, ...cfg };
    this.cfg = merged;
    this.db = new Database(app);
    this.embedder = new EmbeddingHelper(merged);
    this.indexer = new IndexBuilder(app, this.db, this.embedder);
    this.db.init().catch((e) => console.error("[RAG] \u6570\u636E\u5E93\u521D\u59CB\u5316\u5931\u8D25", e));
  }
  /** 构建索引（增量 / 全量） */
  async indexVault(reindexAll = false, progressCb) {
    if (!progressCb) {
      const notice = new import_obsidian34.Notice(t("RAG indexing progress") + " 0%", 0);
      await this.indexer.buildIndex(reindexAll, (done, total) => {
        const percent = total === 0 ? 100 : Math.floor(done / total * 100);
        notice.setMessage(t("RAG indexing progress") + " " + percent + "%");
      });
      await this.db.save();
      notice.setMessage(t("RAG indexing completed"));
      await new Promise((resolve2) => setTimeout(resolve2, 3e3));
      setTimeout(() => notice.hide(), 3e3);
    } else {
      await this.indexer.buildIndex(reindexAll, progressCb);
      await this.db.save();
    }
  }
  /** 构建条目索引（BetterNotes entries） */
  async indexNotes(dm, reindexAll = false, progressCb) {
    if (!this.notesIndexer) {
      this.notesIndexer = new NotesIndexBuilder(this.db, this.embedder);
    }
    if (!progressCb) {
      const notice = new import_obsidian34.Notice(t("RAG indexing progress") + " 0%", 0);
      await this.notesIndexer.buildIndex(dm, reindexAll, (done, total) => {
        const percent = total === 0 ? 100 : Math.floor(done / total * 100);
        notice.setMessage(t("RAG indexing progress") + " " + percent + "%");
      });
      await this.db.save();
      notice.setMessage(t("RAG indexing completed"));
      setTimeout(() => notice.hide(), 3e3);
    } else {
      await this.notesIndexer.buildIndex(dm, reindexAll, progressCb);
      await this.db.save();
    }
  }
  /** 插件卸载时调用 */
  async onunload() {
    await this.db.save();
  }
  /** 运行期更新配置 */
  updateConfig(cfg) {
    this.cfg = { ...this.cfg, ...cfg };
    this.embedder.update(cfg);
  }
  /** 当前 RAG 配置 */
  getConfig() {
    return this.cfg;
  }
  /** 暴露底层数据库实例，供查询引擎使用 */
  getDb() {
    return this.db;
  }
  /** 暴露嵌入器实例 */
  getEmbedder() {
    return this.embedder;
  }
  /** 获取（或懒创建）查询引擎 */
  async getQueryEngine() {
    if (!this.queryEngine) {
      const { RagQueryEngine: RagQueryEngine2 } = await Promise.resolve().then(() => (init_RagQueryEngine(), RagQueryEngine_exports));
      this.queryEngine = new RagQueryEngine2(this.app, this);
    }
    return this.queryEngine;
  }
};

// src/services/BackupService.ts
var import_obsidian35 = require("obsidian");
var import_jszip = __toESM(require_jszip_min());
init_i18n();
var BackupService = class {
  /**
   * 构造函数
   * @param app Obsidian 应用实例
   * @param pluginId 插件 ID
   */
  constructor(app, pluginId) {
    this.backupArchiveName = ".BetterNotes_backups.zip";
    // Regex to match both manual (data_<ts>.json) and auto (data_auto_<ts>.json) backups
    this.manualBackupRegex = /^data_(\d{14})\.json$/;
    this.autoBackupRegex = /^data_auto_(\d{14})\.json$/;
    this.maxManualBackups = 10;
    this.maxAutoBackups = 24;
    this.app = app;
    this.pluginId = pluginId;
  }
  /**
   * 获取插件数据文件路径
   * @returns 插件数据文件路径
   */
  getPluginDataPath() {
    return `${this.app.vault.configDir}/plugins/${this.pluginId}/data.json`;
  }
  /**
   * 获取备份压缩包的路径
   * @returns 备份压缩包的路径
   */
  getBackupArchivePath() {
    return this.backupArchiveName;
  }
  /**
   * 生成当前时间的格式化字符串
   * @returns YYYYMMDDHHmmss 格式的时间戳
   */
  getCurrentTimestamp() {
    const now = new Date();
    const Y4 = now.getFullYear();
    const M4 = String(now.getMonth() + 1).padStart(2, "0");
    const D6 = String(now.getDate()).padStart(2, "0");
    const h3 = String(now.getHours()).padStart(2, "0");
    const m5 = String(now.getMinutes()).padStart(2, "0");
    const s5 = String(now.getSeconds()).padStart(2, "0");
    return `${Y4}${M4}${D6}${h3}${m5}${s5}`;
  }
  /**
   * 核心备份逻辑。将当前数据作为新版本添加到压缩包中。
   * @param isAuto - 标记是否为自动备份
   * @returns 是否备份成功
   */
  async performBackup(isAuto) {
    try {
      const dataPath = this.getPluginDataPath();
      if (!await this.app.vault.adapter.exists(dataPath)) {
        if (!isAuto)
          new import_obsidian35.Notice(t("backup failed") + ": " + t("source data file data.json does not exist"));
        console.error("[BetterNotes] \u5907\u4EFD\u5931\u8D25: \u6E90\u6570\u636E\u6587\u4EF6 data.json \u4E0D\u5B58\u5728");
        return false;
      }
      const content = await this.app.vault.adapter.read(dataPath);
      const timestamp = this.getCurrentTimestamp();
      const archivePath = this.getBackupArchivePath();
      let zip;
      try {
        const existingZipBuffer = await this.app.vault.adapter.readBinary(archivePath);
        zip = await import_jszip.default.loadAsync(existingZipBuffer);
      } catch (e) {
        zip = new import_jszip.default();
      }
      const backupRegex = isAuto ? this.autoBackupRegex : this.manualBackupRegex;
      const maxBackups = isAuto ? this.maxAutoBackups : this.maxManualBackups;
      const backupEntries = Object.keys(zip.files).filter((name2) => backupRegex.test(name2)).sort();
      if (backupEntries.length >= maxBackups) {
        const toDeleteCount = backupEntries.length - maxBackups + 1;
        for (let i3 = 0; i3 < toDeleteCount; i3++) {
          zip.remove(backupEntries[i3]);
        }
      }
      const newBackupFilename = `data_${isAuto ? "auto_" : ""}${timestamp}.json`;
      zip.file(newBackupFilename, content);
      const zipBuffer = await zip.generateAsync({ type: "arraybuffer" });
      await this.app.vault.adapter.writeBinary(archivePath, zipBuffer);
      if (!isAuto) {
        new import_obsidian35.Notice(t("backup success") + ": " + archivePath);
      }
      return true;
    } catch (error2) {
      console.error(`[BetterNotes] ${isAuto ? "\u81EA\u52A8" : "\u624B\u52A8"}\u5907\u4EFD\u5931\u8D25:`, error2);
      if (!isAuto)
        new import_obsidian35.Notice(t("backup failed"));
      return false;
    }
  }
  /**
   * 执行手动备份操作。
   * @returns 是否备份成功
   */
  async backupData() {
    return this.performBackup(false);
  }
  /**
   * 执行自动备份操作。
   * @returns 是否备份成功
   */
  async automaticBackup() {
    return this.performBackup(true);
  }
  /**
   * 列出备份压缩包中所有可用的备份版本。
   * @returns Promise<string[]> 一个按时间降序排列的备份条目名称列表。
   */
  async listBackups() {
    const archivePath = this.getBackupArchivePath();
    if (!await this.app.vault.adapter.exists(archivePath)) {
      return [];
    }
    const zipBuffer = await this.app.vault.adapter.readBinary(archivePath);
    const zip = await import_jszip.default.loadAsync(zipBuffer);
    const backupEntries = Object.keys(zip.files).filter((name2) => this.manualBackupRegex.test(name2) || this.autoBackupRegex.test(name2)).sort().reverse();
    return backupEntries;
  }
  /**
   * 从备份压缩包中恢复指定版本的数据。
   * @param backupEntryName 要恢复的备份条目的完整文件名 (e.g., "data_20231027103000.json")。
   * @returns 是否恢复成功
   */
  async restoreBackup(backupEntryName) {
    try {
      const archivePath = this.getBackupArchivePath();
      if (!await this.app.vault.adapter.exists(archivePath)) {
        new import_obsidian35.Notice(t("restore failed") + ": " + t("backup file does not exist"));
        return false;
      }
      const zipBuffer = await this.app.vault.adapter.readBinary(archivePath);
      const zip = await import_jszip.default.loadAsync(zipBuffer);
      const dataFile = zip.file(backupEntryName);
      if (!dataFile) {
        new import_obsidian35.Notice(t("restore failed") + ": " + t("backup file does not contain the version") + " " + backupEntryName);
        return false;
      }
      const content = await dataFile.async("string");
      try {
        JSON.parse(content);
      } catch (e) {
        new import_obsidian35.Notice(t("restore failed") + ": " + t("backup file does not contain the version") + " " + backupEntryName);
        return false;
      }
      const dataPath = this.getPluginDataPath();
      await this.app.vault.adapter.write(dataPath, content);
      new import_obsidian35.Notice(t("restore success") + ": " + backupEntryName + ", " + t("please restart Obsidian to apply changes"));
      return true;
    } catch (error2) {
      console.error("[BetterNotes] \u6062\u590D\u6570\u636E\u5931\u8D25:", error2);
      new import_obsidian35.Notice(t("restore failed"));
      return false;
    }
  }
};

// src/components/BackupRestoreModal.ts
var import_obsidian36 = require("obsidian");
init_i18n();
var BackupRestoreModal = class extends import_obsidian36.Modal {
  /**
   * 构造函数
   * @param app Obsidian 应用实例
   * @param backupService 备份服务实例
   */
  constructor(app, backupService) {
    super(app);
    this.backups = [];
    this.backupService = backupService;
    this.modalEl.addClass("BetterNotes-backup-modal");
  }
  /**
   * 当模态框打开时调用。
   * 获取备份列表并渲染它们。
   */
  async onOpen() {
    this.contentEl.empty();
    this.backups = await this.backupService.listBackups();
    if (this.backups.length === 0) {
      this.contentEl.createEl("p", { text: t("no backups found") });
      return;
    }
    const listEl = this.contentEl.createEl("div", { cls: "BetterNotes-backup-list" });
    this.backups.forEach((backupName) => {
      const isAuto = backupName.includes("_auto_");
      const match = backupName.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/);
      let displayTime = backupName;
      if (match) {
        displayTime = `${match[1]}-${match[2]}-${match[3]} ${match[4]}:${match[5]}:${match[6]}`;
      }
      const setting = new import_obsidian36.Setting(listEl).setName(displayTime).addButton((button) => {
        button.setButtonText(t("restore")).setWarning().onClick(async () => {
          if (confirm(t("confirm restore") + "\n\n" + displayTime + " (" + (isAuto ? t("auto") : t("manual")) + ")\n\n" + t("this will overwrite all data and cannot be undone"))) {
            button.setDisabled(true).setButtonText("\u6062\u590D\u4E2D...");
            const success = await this.backupService.restoreBackup(backupName);
            if (success) {
              this.close();
            } else {
              button.setDisabled(false).setButtonText(t("restore"));
            }
          }
        });
      });
    });
  }
  /**
   * 当模态框关闭时调用。
   */
  onClose() {
    this.contentEl.empty();
  }
};

// src/main.ts
init_i18n();

// src/services/video/markdownPreview.ts
function registerMarkdownPreviewInterceptor(plugin) {
  const handler = async () => {
    const leaf = plugin.app.workspace.activeLeaf;
    if (!leaf)
      return;
    if (leaf.view.getViewType?.() !== "markdown")
      return;
    const mdView = leaf.view;
    if (mdView.getMode?.() !== "preview")
      return;
    const file = mdView.file;
    if (!file)
      return;
    const cache = plugin.app.metadataCache.getFileCache(file);
    const videoSource = cache?.frontmatter?.["video-source"];
    if (!videoSource)
      return;
    const { fileUrl, filePath } = normalizeVideoSource(plugin, videoSource);
    if (!fileUrl) {
      console.warn("Unsupported video-source", videoSource);
      return;
    }
    await leaf.setViewState({
      type: VIDEO_VIEW_TYPE,
      active: true,
      state: { fileUrl, filePath }
    });
  };
  plugin.registerEvent(plugin.app.workspace.on("layout-change", handler));
}

// src/services/video/filePicker.ts
var import_obsidian37 = require("obsidian");
var import_url3 = require("url");
var nodePath3 = __toESM(require("path"));
async function openFilePickerAndPlay(plugin) {
  if (!import_obsidian37.Platform.isDesktopApp) {
    new import_obsidian37.Notice("This feature is not available on mobile.");
    return;
  }
  try {
    const dialog = require("electron").remote.dialog;
    const result = await dialog.showOpenDialog({
      title: "Pick a video file",
      properties: ["openFile"],
      filters: [
        { name: "Videos", extensions: ["mp4", "mkv", "webm", "mov"] },
        { name: "All Files", extensions: ["*"] }
      ]
    });
    if (result.canceled || result.filePaths.length === 0) {
      new import_obsidian37.Notice("File picking cancelled.");
      return;
    }
    const filePath = result.filePaths[0];
    await playVideoInView(plugin, filePath);
  } catch (error2) {
    new import_obsidian37.Notice("Failed to open file picker. Check console for details.");
    console.error("Error opening file picker:", error2);
  }
}
async function playVideoInView(plugin, filePath) {
  let fileUrl;
  const adapter = plugin.app.vault.adapter;
  if (adapter instanceof import_obsidian37.FileSystemAdapter) {
    fileUrl = (0, import_url3.pathToFileURL)(filePath).href;
  } else {
    fileUrl = (0, import_url3.pathToFileURL)(filePath).href;
  }
  await createMetaNote(plugin, filePath, fileUrl);
  const existingLeaves = plugin.app.workspace.getLeavesOfType(VIDEO_VIEW_TYPE);
  const existingLeaf = existingLeaves.find(
    (leaf2) => leaf2.view.getState()?.filePath === filePath
  );
  if (existingLeaf) {
    plugin.app.workspace.setActiveLeaf(existingLeaf);
    return;
  }
  const leaf = plugin.app.workspace.getLeaf(true);
  await leaf.setViewState({
    type: VIDEO_VIEW_TYPE,
    active: true,
    state: { fileUrl, filePath }
  });
  plugin.app.workspace.revealLeaf(leaf);
}
async function createMetaNote(plugin, filePath, fileUrl) {
  const adapter = plugin.app.vault.adapter;
  if (!(adapter instanceof import_obsidian37.FileSystemAdapter))
    return;
  const mdName = `${nodePath3.parse(filePath).name}.md`;
  const mdPath = mdName;
  const existing = plugin.app.vault.getAbstractFileByPath(mdPath);
  const frontMatter = `---
video-source: ${fileUrl}
---
`;
  try {
    if (!existing) {
      await plugin.app.vault.create(mdPath, frontMatter);
    } else if (existing instanceof import_obsidian37.TFile) {
      const content = await plugin.app.vault.read(existing);
      if (!content.includes("video-source:")) {
        await plugin.app.vault.modify(existing, frontMatter + "\n" + content);
      }
    }
  } catch (e) {
    console.error("Failed to create/modify meta note", e);
  }
}

// src/services/NotificationService.ts
var import_obsidian39 = require("obsidian");

// src/components/ServerNotificationModal.ts
var import_obsidian38 = require("obsidian");
var ServerNotificationModal = class extends import_obsidian38.Modal {
  /**
   * @param app  Obsidian App
   * @param htmlContent 来自服务器的 html 字符串（不含标题）
   */
  constructor(app, htmlContent) {
    super(app);
    this.htmlContent = htmlContent;
  }
  /** 渲染模态框内容 */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("BetterNotes-server-notification");
    const wrapper = contentEl.createDiv({ cls: "sn-notification-wrapper" });
    wrapper.innerHTML = this.htmlContent;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/services/NotificationService.ts
var NotificationService = class {
  /**
   * 创建通知服务
   * @param pluginVersion 插件当前版本号
   * @param lastNotificationTimestamp 上次显示的通知时间戳(如果有)
   */
  constructor(pluginVersion, lastNotificationTimestamp) {
    this.API_ENDPOINT = "https://www.butcher-x.com/notifications/get_notification.php";
    this.lastNotificationTimestamp = null;
    this.pluginVersion = pluginVersion;
    this.lastNotificationTimestamp = lastNotificationTimestamp || null;
  }
  /**
   * 从服务器检查并获取通知
   * 只有当通知是新的（基于时间戳比较）才会显示
   * @returns Promise<ServerNotification|null> 如果有新通知则返回通知对象，否则返回null
   */
  async checkForNotifications() {
    try {
      const url = `${this.API_ENDPOINT}?version=${encodeURIComponent(this.pluginVersion)}`;
      const response = await (0, import_obsidian39.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache, no-store, must-revalidate",
          "Pragma": "no-cache",
          "Expires": "0"
        }
      });
      if (response.status !== 200) {
        console.error(`[BetterNotes] \u83B7\u53D6\u901A\u77E5\u5931\u8D25: ${response.status}`);
        return null;
      }
      const notification = response.json;
      if (!notification || !notification.title) {
        return null;
      }
      if (this.lastNotificationTimestamp && notification.published_at <= this.lastNotificationTimestamp) {
        return null;
      }
      this.lastNotificationTimestamp = notification.published_at;
      return notification;
    } catch (error2) {
      console.error("[BetterNotes] \u83B7\u53D6\u901A\u77E5\u51FA\u9519:", error2);
      return null;
    }
  }
  /**
   * 获取上次显示的通知时间戳
   * @returns 上次通知的时间戳
   */
  getLastNotificationTimestamp() {
    return this.lastNotificationTimestamp;
  }
  /**
   * 显示通知给用户
   * @param notification 要显示的通知对象
   */
  displayNotification(notification) {
    new ServerNotificationModal(window.app || window.BetterNotes?.app || document.app || this.app, notification.content).open();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  snippetContext: 10,
  highlightOpacity: 0.5,
  linkTemplates: DEFAULT_LINK_TEMPLATES,
  mdImmediateAnnotation: false,
  // 默认为立即标注模式
  fsrsParams: { ...DEFAULT_FSRS_PARAMETERS },
  ai: { enabled: false, baseUrl: "", apiKey: "", model: "gpt4.1" },
  rag: { embeddingModel: "text-embedding-3-small", embeddingEndpoint: "", apiKey: "" },
  activationCode: "",
  license: "",
  pdfHighlightMode: "embedded",
  // 默认内嵌高亮
  lastNotificationTimestamp: ""
  // 初始为空字符串，表示没有显示过通知
};
var BetterNotesPlugin = class extends import_obsidian42.Plugin {
  constructor() {
    super(...arguments);
    this.sidebarView = null;
    this.aiChatView = null;
    this.deviceId = "";
    this.licenseValid = false;
    /**
     * Tracks the last active leaf that is NOT the sidebar.
     * Used to display relevant comments when the sidebar itself is focused.
     */
    this.lastActiveViewLeaf = null;
    this.ignoredViewTypes = [
      "BetterNotes-sidebar-view",
      "BetterNotes-ai-chat-view",
      "file-explorer",
      "search",
      "bookmarks"
    ];
  }
  /**
   * 插件加载时调用
   */
  async onload() {
    const raw = await this.loadData();
    const savedSettings = raw?.settings ?? raw;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, savedSettings || {});
    this.app.workspace.onLayoutReady(() => {
      this.lastActiveViewLeaf = this.app.workspace.activeLeaf;
      const eventRef = this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf) {
          if (!this.isIgnoredView(leaf.view.getViewType())) {
            this.lastActiveViewLeaf = leaf;
          }
        }
      });
      this.register(() => {
        this.app.workspace.offref(eventRef);
      });
    });
    this.notificationService = new NotificationService(
      this.manifest.version,
      this.settings.lastNotificationTimestamp
    );
    this.checkServerNotifications();
    const vaultPath = this.getVaultPath();
    this.deviceId = vaultPath;
    this.licenseValid = await verifyLicense(this.settings.license || "", this.settings.activationCode || "", vaultPath);
    this.settings.ai.enabled = this.licenseValid;
    this.fsrsService = new FSRSService(this.settings.fsrsParams);
    this.aiService = new AiChatService(this.settings.ai);
    this.ragService = new RagService(this.app, this.settings.rag);
    registerMarkdownPreviewInterceptor(this);
    this.dataManager = new DataManager();
    this.storageManager = new StorageManager(this.app, this.dataManager, this.manifest.id);
    this.backupService = new BackupService(this.app, this.manifest.id);
    this.registerInterval(
      window.setInterval(() => {
        this.backupService.automaticBackup();
      }, 60 * 60 * 1e3)
      // 1 hour
    );
    this.rectHighlightManager = new RectHighlightManager();
    await this.storageManager.loadData();
    this.initRectData();
    this.registerView(
      SidebarView.VIEW_TYPE,
      (leaf) => this.sidebarView = new SidebarView(leaf, this)
    );
    this.registerView(
      AI_CHAT_VIEW_TYPE,
      (leaf) => this.aiChatView = new AiChatView(leaf, this)
    );
    this.registerView(VIDEO_VIEW_TYPE, (leaf) => new VideoView(leaf));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      this.handleFileRename(oldPath, file.path);
    }));
    this.addRibbonIcon("sparkles", "BetterNotes", async () => {
      await this.activateSidebarView();
    });
    this.addCommand({
      id: "open-BetterNotes-sidebar",
      name: t("open-BetterNotes-sidebar"),
      callback: async () => {
        await this.activateSidebarView();
      }
    });
    this.addRibbonIcon("bot", t("AI assistant"), async () => {
      await this.activateAiChatView();
    });
    this.addCommand({
      id: "open-ai-chat-sidebar",
      name: t("open-ai-chat-sidebar"),
      callback: async () => {
        await this.activateAiChatView();
      }
    });
    const toggleIcon = this.addRibbonIcon("wand-2", t("toggle-md-immediate-annotation"), () => {
      this.toggleImmediateAnnotation();
    });
    toggleIcon.addClass("BetterNotes-toggle-ann");
    if (this.settings.mdImmediateAnnotation)
      toggleIcon.addClass("is-active");
    this.ribbonToggleIcon = toggleIcon;
    this.addRibbonIcon("play", t("open local video"), async () => {
      await openFilePickerAndPlay(this);
    });
    this.addCommand({
      id: "toggle-md-immediate-annotation",
      name: t("toggle-md-immediate-annotation"),
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "m" }],
      callback: () => this.toggleImmediateAnnotation()
    });
    this.addCommand({
      id: "index-vault",
      name: t("index-vault"),
      callback: async () => {
        await this.ragService.indexVault();
      }
    });
    this.addCommand({
      id: "reindex-vault",
      name: t("reindex-vault"),
      callback: async () => {
        await this.ragService.indexVault(true);
      }
    });
    this.addCommand({
      id: "index-notes",
      name: t("index-notes"),
      callback: async () => {
        await this.ragService.indexNotes(this.dataManager);
      }
    });
    this.addCommand({
      id: "reindex-notes",
      name: t("reindex-notes"),
      callback: async () => {
        await this.ragService.indexNotes(this.dataManager, true);
      }
    });
    this.addCommand({
      id: "cancel-internal-linking",
      name: t("cancel-internal-linking"),
      callback: () => {
        if (this.internalLinkService.isInLinkingMode()) {
          this.internalLinkService.cancelLinking();
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "capture-pdf-rectangle",
      name: t("capture-pdf-rectangle"),
      callback: () => this.pdfRectCaptureService.startCapture(),
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "r"
        }
      ]
    });
    this.addCommand({
      id: "open-local-file-picker",
      name: "Open Local File Picker",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "o" }],
      callback: () => openFilePickerAndPlay(this)
    });
    this.addSettingTab(new BetterNotesSettingTab(this.app, this));
    this.loadStyles();
    this.hashSpanHandler = new HashSpanHandler(this.app, this);
    this.entryNavigation = new EntryNavigation(this.app, this);
    this.pdfBacklinkHighlighter = new PdfBacklinkHighlighter(this.app, this);
    this.pdfBacklinkHighlighter.setUseEmbeddedHighlights(true);
    this.setSelectionService = new SetSelectionService();
    this.linkService = new LinkService(this);
    this.internalLinkService = new InternalLinkService(this);
    this.setSelectionService.onChange((selected) => {
      const color = selected ? this.dataManager.getCollection(selected)?.color || "" : "";
      document.documentElement.dataset.snCurrentColor = color;
    });
    this.quickCaptureService = new QuickCaptureService(this.app, this, this.setSelectionService);
    this.pdfHighlightHandler = new PdfHighlightHandler(this.app, this);
    this.pdfRectCaptureService = new PdfRectCaptureService(this.app, this);
    this.pdfViewerPatchService = new PdfViewerPatchService(this);
    this.videoLinkService = new OpenLinkService(this.app, this);
    document.addEventListener("BetterNotes-subtitle-entry", async (ev) => {
      const detail = ev.detail;
      const setName = this.setSelectionService.getSelected();
      if (!setName) {
        new import_obsidian42.Notice(t("please select a collection first"));
        return;
      }
      const collection = this.dataManager.getCollection(setName);
      if (!collection) {
        new import_obsidian42.Notice(t(`collection not found`));
        return;
      }
      detail.element.style.color = collection.color;
      const indexStr = `${detail.time}&${detail.line}&${detail.start}&${detail.end}&${detail.url}`;
      try {
        const entry = await this.createEntry(detail.text, setName, {
          type: "video",
          index: indexStr
        });
        detail.element.setAttr("data-entry-hash", entry.hash);
        await this.navigateToEntryInComments(entry);
      } catch (e) {
        console.error("\u521B\u5EFA\u89C6\u9891\u6761\u76EE\u5931\u8D25", e);
      }
    });
    document.addEventListener("BetterNotes-subtitle-line-rendered", (ev) => {
      const { line, container } = ev.detail;
      const videoUrl = container.dataset.videoUrl || "";
      if (!videoUrl)
        return;
      const entries = this.dataManager.getAllEntries().filter((e) => e.type === "video" && typeof e.index === "string" && e.index.endsWith(videoUrl));
      if (entries.length === 0)
        return;
      const lineEntries = entries.filter((e) => {
        const parts2 = e.index.split("&");
        if (parts2.length < 5)
          return false;
        const l4 = Number(parts2[1]);
        return l4 === line;
      });
      if (lineEntries.length === 0)
        return;
      lineEntries.forEach((entry) => {
        const parts2 = entry.index.split("&");
        const l4 = parts2[1];
        const s5 = parts2[2];
        const eIdx = parts2[3];
        const startIdx = Number(s5);
        const endIdx = Number(eIdx);
        const set = entry.set;
        const collection = this.dataManager.getCollection(set);
        const color = collection?.color || "yellow";
        const lineEl = container.querySelector(`[line="${l4}"]`);
        if (!lineEl)
          return;
        if (lineEl.querySelector(`span[data-entry-hash="${entry.hash}"]`))
          return;
        const words = Array.from(lineEl.querySelectorAll("span[index]"));
        const frag = [];
        words.forEach((w6) => {
          const idx = Number(w6.getAttribute("index"));
          if (idx >= startIdx && idx <= endIdx) {
            frag.push(w6);
          }
        });
        if (frag.length === 0)
          return;
        const mergedText = frag.map((f3) => f3.textContent || "").join(" ");
        const newSpan = document.createElement("span");
        newSpan.textContent = mergedText;
        newSpan.classList.add("subtitle-auto-highlight");
        newSpan.style.color = color;
        newSpan.setAttr("data-entry-hash", entry.hash);
        const first = frag[0];
        const last2 = frag[frag.length - 1];
        let n3 = first;
        const toRemove = [];
        while (n3) {
          toRemove.push(n3);
          if (n3 === last2)
            break;
          n3 = n3.nextSibling;
        }
        first.parentElement?.insertBefore(newSpan, first);
        toRemove.forEach((t2) => t2.remove());
      });
    });
    setupSubtitleNavigationKeys();
    document.addEventListener("BetterNotes-navigate-to-entry", async (ev) => {
      const { hash } = ev.detail;
      if (!hash)
        return;
      try {
        const entry = this.dataManager.getEntry(hash);
        if (entry) {
          await this.navigateToEntryInComments(entry);
        }
      } catch (e) {
        console.error("\u5BFC\u822A\u5931\u8D25", e);
      }
    });
    document.addEventListener("BetterNotes-video-entry-deleted", (ev) => {
      const { hash } = ev.detail;
      if (!hash)
        return;
      try {
        const highlightedSpans = document.querySelectorAll(`span.subtitle-auto-highlight[data-entry-hash="${hash}"]`);
        highlightedSpans.forEach((span) => {
          const text = span.textContent || "";
          if (!text.trim())
            return;
          const parent = span.parentElement;
          if (!parent)
            return;
          const line = span.getAttribute("line");
          const words = text.trim().split(/\s+/);
          const fragment = document.createDocumentFragment();
          words.forEach((word, i3) => {
            const wordSpan = document.createElement("span");
            wordSpan.textContent = word;
            wordSpan.setAttribute("index", String(i3 + 1));
            if (line) {
              wordSpan.setAttribute("line", line);
            }
            fragment.appendChild(wordSpan);
            if (i3 < words.length - 1) {
              fragment.appendChild(document.createTextNode(" "));
            }
          });
          parent.insertBefore(fragment, span);
          span.remove();
        });
      } catch (e) {
        console.error("\u79FB\u9664\u89C6\u9891\u6761\u76EE\u9AD8\u4EAE\u5931\u8D25", e);
      }
    });
    document.addEventListener("BetterNotes-video-screenshot-entry", async (ev) => {
      const detail = ev.detail;
      const setName = this.setSelectionService.getSelected();
      if (!setName)
        return;
      const indexStr = `${detail.time}&timestamp&&&${detail.videoUrl}`;
      try {
        const entry = await this.createEntry("", setName, {
          type: "video",
          sourceFile: detail.sourceFile,
          index: indexStr,
          attachmentFile: [detail.attachmentPath]
        });
        await this.navigateToEntryInComments(entry);
      } catch (e) {
        console.error("\u521B\u5EFA\u89C6\u9891\u622A\u56FE\u6761\u76EE\u5931\u8D25", e);
      }
    });
  }
  /**
   * 插件卸载时调用
   */
  async onunload() {
    this.storageManager.saveData(this.settings);
    this.app.workspace.detachLeavesOfType(SidebarView.VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(AI_CHAT_VIEW_TYPE);
    if (this.hashSpanHandler) {
      this.hashSpanHandler.cleanup();
    }
    this.quickCaptureService.cleanup();
    await this.ragService.onunload();
  }
  /**
   * 处理文件重命名和移动事件
   * 自动更新相关条目的 sourceFile 字段
   * @param oldPath 旧文件路径
   * @param newPath 新文件路径
   */
  async handleFileRename(oldPath, newPath) {
    try {
      const allEntries = this.dataManager.getAllEntries();
      const affectedEntries = [];
      for (const entry of allEntries) {
        const updates = {};
        if (entry.sourceFile === oldPath) {
          updates.sourceFile = newPath;
        }
        if (entry.type === "pdf" && entry.index && typeof entry.index === "string") {
          if (entry.index.includes(oldPath)) {
            updates.index = entry.index.replace(oldPath, newPath);
          }
        }
        if (entry.type === "video" && entry.index && typeof entry.index === "string") {
          const parts2 = entry.index.split("&");
          if (parts2.length >= 5 && parts2[4].includes(oldPath)) {
            parts2[4] = parts2[4].replace(oldPath, newPath);
            updates.index = parts2.join("&");
          }
        }
        if (Object.keys(updates).length > 0) {
          affectedEntries.push({ entry, updates });
        }
      }
      if (affectedEntries.length === 0) {
        return;
      }
      let updatedCount = 0;
      for (const { entry, updates } of affectedEntries) {
        try {
          await this.updateEntry(entry.hash, updates);
          updatedCount++;
          const updateDetails = Object.keys(updates).map(
            (key) => `${key}: ${entry[key]} -> ${updates[key]}`
          ).join(", ");
        } catch (error2) {
          console.error(`[BetterNotes] Failed to update entry ${entry.hash}:`, error2);
        }
      }
      if (updatedCount > 0) {
        new import_obsidian42.Notice(`${t("file path updated for entries")}: ${updatedCount} ${t("entries")}`);
        await this.refreshViews();
      }
    } catch (error2) {
      console.error("[BetterNotes] Error handling file rename:", error2);
      new import_obsidian42.Notice(t("failed to update file paths"));
    }
  }
  /**
   * 创建集合并保存
   */
  async createCollection(name2, options = {}) {
    const collection = this.dataManager.createCollection(name2, options);
    await this.storageManager.saveData(this.settings);
    await this.refreshViews();
    return collection;
  }
  /**
   * 更新集合并保存
   */
  async updateCollection(name2, updates) {
    const prevCollection = this.dataManager.getCollection(name2);
    const collection = this.dataManager.updateCollection(name2, updates);
    await this.storageManager.saveData(this.settings);
    if (prevCollection && updates.color && updates.color !== prevCollection.color) {
      try {
        await this.batchUpdateCollectionColor(name2, prevCollection.color, updates.color);
      } catch (e) {
        console.error("\u6279\u91CF\u66F4\u65B0\u96C6\u5408\u989C\u8272\u5931\u8D25", e);
      }
    }
    return collection;
  }
  /**
   * 批量更新指定集合在 Markdown 文件中的颜色
   */
  async batchUpdateCollectionColor(setName, oldColor, newColor) {
    const entries = this.dataManager.getEntriesBySet(setName).filter((e) => e.type === "md" && e.sourceFile);
    if (entries.length === 0)
      return;
    const fileMap = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      const path2 = entry.sourceFile;
      if (!fileMap.has(path2))
        fileMap.set(path2, []);
      fileMap.get(path2).push(entry);
    }
    for (const [path2, list] of fileMap.entries()) {
      const af = this.app.vault.getAbstractFileByPath(path2);
      if (!(af instanceof import_obsidian42.TFile))
        continue;
      let content = await this.app.vault.read(af);
      let modified = false;
      for (const entry of list) {
        const hash = entry.hash;
        const spanRegex = new RegExp(`<span[^>]*data-hash="${hash}"[^>]*>([\\s\\S]*?)<\\/span>`, "g");
        content = content.replace(spanRegex, (_m, inner) => {
          modified = true;
          return `<span class="BetterNotes-hash-span" style="color:${newColor}" data-hash="${hash}">${inner}</span>`;
        });
      }
      if (modified) {
        await this.app.vault.modify(af, content);
      }
    }
  }
  /**
   * 删除集合并保存
   */
  async deleteCollection(name2) {
    const entries = this.dataManager.getEntriesBySet(name2);
    if (entries.length > 0) {
      const fileEntryMap = /* @__PURE__ */ new Map();
      const videoEntries = [];
      for (const entry of entries) {
        if (entry.type === "video") {
          videoEntries.push(entry);
          continue;
        }
        if (!entry.sourceFile)
          continue;
        if (!fileEntryMap.has(entry.sourceFile)) {
          fileEntryMap.set(entry.sourceFile, []);
        }
        fileEntryMap.get(entry.sourceFile)?.push(entry);
      }
      for (const entry of videoEntries) {
        document.dispatchEvent(new CustomEvent("BetterNotes-video-entry-deleted", {
          detail: { hash: entry.hash }
        }));
      }
      for (const entry of entries) {
        if (entry.type === "pdf") {
          this.rectHighlightManager.removeRectByHash(entry.hash);
        }
      }
      for (const [filePath, fileEntries] of fileEntryMap.entries()) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian42.TFile))
          continue;
        const mdEntries = fileEntries.filter((e) => e.type === "md");
        const pdfEntries = fileEntries.filter((e) => e.type === "pdf");
        if (mdEntries.length > 0 && file.extension === "md") {
          await this.batchCleanMarkdownEntries(file, mdEntries);
        }
        if (pdfEntries.length > 0 && file.extension === "pdf") {
          await this.batchCleanPdfEntries(file, pdfEntries);
        }
      }
    }
    const result = this.dataManager.deleteCollection(name2);
    if (result) {
      await this.storageManager.saveData(this.settings);
      await this.refreshViews();
    }
    return result;
  }
  /**
   * 批量清理Markdown文件中的span标签
   */
  async batchCleanMarkdownEntries(file, entries) {
    try {
      const content = await this.app.vault.read(file);
      const hashList = entries.map((e) => e.hash).join("|");
      const regex = new RegExp(`<span[^>]*data-hash="(${hashList})"[^>]*>([^<]*?)<\\/span>`, "g");
      if (regex.test(content)) {
        const newContent = content.replace(regex, (_match, inner) => {
          return inner.replace(/<br>\s*/g, "\n");
        });
        await this.app.vault.modify(file, newContent);
      }
    } catch (e) {
      console.error("\u6279\u91CF\u6E05\u7406Markdown\u6761\u76EE\u5931\u8D25", e);
    }
  }
  /**
   * 批量清理PDF文件中的高亮注释
   */
  async batchCleanPdfEntries(file, entries) {
    try {
      const annotationsToDelete = [];
      for (const entry of entries) {
        if (entry.index) {
          const match = entry.index.match(/page=(\d+)&annotation=(\d+)R/);
          if (match) {
            const pageNum = Number(match[1]);
            const objNum = Number(match[2]);
            annotationsToDelete.push({ pageNumber: pageNum, objectNumber: objNum });
          }
        }
      }
      if (annotationsToDelete.length > 0) {
        const activeLeaf = this.app.workspace.getLeaf();
        let child = void 0;
        try {
          if (activeLeaf && activeLeaf.view) {
            const viewFile = activeLeaf.view.file;
            if (viewFile && viewFile.path === file.path) {
              child = activeLeaf.view.viewer?.child;
            }
          }
        } catch (e) {
          console.error("\u83B7\u53D6PDF\u89C6\u56FE\u72B6\u6001\u5931\u8D25", e);
        }
        const pas = new PdfIOService(this.app);
        await pas.batchDeleteAnnotations(file, annotationsToDelete, child);
      }
    } catch (e) {
      console.error("\u6279\u91CF\u6E05\u7406PDF\u6761\u76EE\u5931\u8D25", e);
    }
  }
  /**
   * 创建条目（md/pdf），并在侧边栏评论视图中自动导航到该条目。
   * @param value 条目内容
   * @param set 集合名
   * @param options 其他条目参数
   * @returns 创建的 Entry
   */
  async createEntry(value, set, options = {}) {
    const entry = this.dataManager.createEntry(value, set, options);
    await this.storageManager.saveData(this.settings);
    return entry;
  }
  /**
   * 辅助函数：在侧边栏评论视图中导航并高亮指定条目。
   * @param entry 目标条目
   */
  async navigateToEntryInComments(entry) {
    await this.activateSidebarView();
    if (this.sidebarView) {
      await this.sidebarView.openCommentsViewAndHighlightEntry(entry);
    }
  }
  /**
   * 更新条目并保存
   * 同时更新文档中的HTML表示
   * @param hash 条目哈希
   * @param updates 更新内容
   * @returns 更新后的条目
   */
  async updateEntry(hash, updates) {
    const originalEntry = this.dataManager.getEntry(hash);
    if (!originalEntry) {
      throw new Error(`\u6761\u76EE "${hash}" \u4E0D\u5B58\u5728`);
    }
    const updatedEntry = this.dataManager.updateEntry(hash, updates);
    await this.storageManager.saveData(this.settings);
    if (updates.set && updates.set !== originalEntry.set) {
      const newCollection = this.dataManager.getCollection(updates.set);
      if (newCollection && originalEntry.sourceFile) {
        this.updateEntrySpanInSourceFile(hash, newCollection.color, originalEntry.sourceFile);
      }
    }
    if (originalEntry.type === "pdf" && updates.comment !== void 0 && originalEntry.index) {
      try {
        const match = originalEntry.index.match(/page=(\d+)&annotation=(\d+)R/);
        if (match) {
          const pageNum = Number(match[1]);
          const objNum = Number(match[2]);
          const file = this.app.vault.getAbstractFileByPath(originalEntry.sourceFile);
          if (file instanceof import_obsidian42.TFile) {
            const activeLeaf = this.app.workspace.getLeaf();
            let child = void 0;
            let viewerState = void 0;
            try {
              if (activeLeaf && activeLeaf.view) {
                const viewFile = activeLeaf.view.file;
                if (viewFile && viewFile.path === originalEntry.sourceFile) {
                  child = activeLeaf.view.viewer?.child;
                  console.warn("capturePdfViewerState", capturePdfViewerState(child));
                  viewerState = capturePdfViewerState(child);
                }
              }
            } catch (e) {
              console.error("\u83B7\u53D6PDF\u89C6\u56FE\u72B6\u6001\u5931\u8D25", e);
            }
            const pas = new PdfIOService(this.app);
            await pas.updateHighlightAnnotationContent(file, pageNum, objNum, updates.comment || "", child);
          }
        }
      } catch (e) {
        console.error("\u66F4\u65B0 PDF \u6CE8\u91CA\u5185\u5BB9\u5931\u8D25", e);
      }
    }
    return updatedEntry;
  }
  /**
   * 更新源文件中包含指定hash的span标签的颜色
   * @param hash 条目哈希
   * @param color 新颜色
   * @param sourceFile 源文件路径
   */
  async updateEntrySpanInSourceFile(hash, color, sourceFile) {
    if (!sourceFile)
      return;
    const file = this.app.vault.getAbstractFileByPath(sourceFile);
    if (!file || !(file instanceof import_obsidian42.TFile))
      return;
    if (file.extension !== "md")
      return;
    try {
      const content = await this.app.vault.read(file);
      const regex = new RegExp(`<span[^>]*data-hash="${hash}"[^>]*>([\\s\\S]*?)<\\/span>`, "g");
      let match;
      let modified = false;
      let newContent = content;
      while ((match = regex.exec(content)) !== null) {
        const originalText = match[1];
        const originalSpan = match[0];
        const newSpan = `<span class="BetterNotes-hash-span" style="color:${color}" data-hash="${hash}">${originalText}</span>`;
        newContent = newContent.replace(originalSpan, newSpan);
        modified = true;
      }
      if (modified) {
        await this.app.vault.modify(file, newContent);
      }
    } catch (error2) {
      console.error(`\u66F4\u65B0\u6587\u4EF6 ${sourceFile} \u4E2D\u7684\u6807\u6CE8\u5931\u8D25:`, error2);
    }
  }
  async deleteEntry(hash) {
    const entry = this.dataManager.getEntry(hash);
    let cleaned = false;
    if (entry && entry.type === "md" && entry.sourceFile) {
      try {
        const file = this.app.vault.getAbstractFileByPath(entry.sourceFile);
        if (file instanceof import_obsidian42.TFile) {
          const content = await this.app.vault.read(file);
          const regex = new RegExp(`<span[^>]*data-hash="${hash}"[^>]*>([\\s\\S]*?)<\\/span>`, "g");
          if (regex.test(content)) {
            const newContent = content.replace(regex, (_match, inner) => {
              return inner.replace(/<br>\s*/g, "\n");
            });
            await this.app.vault.modify(file, newContent);
            cleaned = true;
          }
        }
      } catch (e) {
        console.error("\u5220\u9664\u6761\u76EE\u65F6\u6E05\u7406 span \u5931\u8D25", e);
      }
    }
    if (entry && entry.type === "pdf" && entry.index) {
      try {
        const match = entry.index.match(/page=(\d+)&annotation=(\d+)R/);
        if (match) {
          const pageNum = Number(match[1]);
          const objNum = Number(match[2]);
          const file = this.app.vault.getAbstractFileByPath(entry.sourceFile);
          if (file instanceof import_obsidian42.TFile) {
            const pas = new PdfIOService(this.app);
            const activeLeaf = this.app.workspace.getLeaf();
            let child = void 0;
            try {
              if (activeLeaf && activeLeaf.view) {
                const viewFile = activeLeaf.view.file;
                if (viewFile && viewFile.path === entry.sourceFile) {
                  child = activeLeaf.view.viewer?.child;
                }
              }
            } catch (e) {
              console.error("\u83B7\u53D6PDF\u89C6\u56FE\u72B6\u6001\u5931\u8D25", e);
            }
            await pas.deleteHighlightAnnotation(file, pageNum, objNum, child);
          }
        }
        if (entry.index.includes("rect=") || entry.index.includes("selection=")) {
          this.rectHighlightManager.removeRectByHash(entry.hash);
        }
        cleaned = true;
      } catch (e) {
        console.error("\u5220\u9664 PDF \u6CE8\u91CA\u5931\u8D25", e);
      }
    }
    if (entry && entry.type === "video") {
      document.dispatchEvent(new CustomEvent("BetterNotes-video-entry-deleted", {
        detail: { hash: entry.hash }
      }));
      cleaned = true;
    }
    if (entry?.attachmentFile?.length) {
      for (const rawPath of entry.attachmentFile) {
        const normPath = rawPath.startsWith("/") ? rawPath.slice(1) : rawPath;
        try {
          const af = this.app.vault.getAbstractFileByPath(normPath);
          if (af instanceof import_obsidian42.TFile) {
            await this.app.vault.delete(af, true);
          }
        } catch (e) {
          console.error(`\u5220\u9664\u9644\u4EF6\u5931\u8D25 (${normPath})`, e);
        }
      }
    }
    const result = this.dataManager.deleteEntry(hash);
    if (result) {
      await this.storageManager.saveData(this.settings);
      if (cleaned)
        await this.refreshViews();
    }
    return result;
  }
  /**
   * 激活侧边栏视图
   */
  async activateSidebarView() {
    const { workspace } = this.app;
    const existingView = workspace.getLeavesOfType(SidebarView.VIEW_TYPE);
    if (existingView.length) {
      workspace.revealLeaf(existingView[0]);
      return;
    }
    const leaf = workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: SidebarView.VIEW_TYPE,
        active: true
      });
      const newView = workspace.getLeavesOfType(SidebarView.VIEW_TYPE);
      if (newView.length > 0) {
        workspace.revealLeaf(newView[0]);
      }
    }
  }
  /**
   * 激活 AI 聊天侧边栏
   */
  async activateAiChatView() {
    if (!this.licenseValid) {
      new import_obsidian42.Notice(t("please input valid activation code"));
      return;
    }
    const { workspace } = this.app;
    const existingView = workspace.getLeavesOfType(AI_CHAT_VIEW_TYPE);
    if (existingView.length) {
      workspace.revealLeaf(existingView[0]);
      return;
    }
    const leaf = workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: AI_CHAT_VIEW_TYPE,
        active: true
      });
      const newView = workspace.getLeavesOfType(AI_CHAT_VIEW_TYPE);
      if (newView.length > 0) {
        workspace.revealLeaf(newView[0]);
      }
    }
  }
  /**
   * 刷新所有视图
   */
  async refreshViews() {
    if (this.sidebarView) {
      await this.sidebarView.refresh();
    }
  }
  /**
   * 加载CSS样式
   */
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "BetterNotes-styles";
    document.head.appendChild(styleEl);
    this.app.vault.adapter.read(this.manifest.dir + "/styles.css").then((cssText) => {
      styleEl.textContent = cssText;
    }).catch((error2) => {
      console.error("\u65E0\u6CD5\u52A0\u8F7D\u6837\u5F0F\u6587\u4EF6:", error2);
    });
  }
  /**
   * 打开标注模态框
   * @param selectedText 选中的文本
   * @param sourcePath 源文件路径
   * @param editor 编辑器实例，用于替换选中文本
   */
  openAnnotationModal(selectedText, sourcePath, editor) {
    const hash = generateHash();
    const modal = new AnnotationModal(this, {
      selectedText,
      sourcePath,
      onConfirm: async (entry) => {
        try {
          const collection = this.dataManager.getCollection(entry.set);
          if (!collection) {
            throw new Error(`\u96C6\u5408 "${entry.set}" \u4E0D\u5B58\u5728`);
          }
          const colorValue = collection.color;
          const htmlText = selectedText.replace(/\n/g, "<br>\n");
          const spanHtml = `<span class="BetterNotes-hash-span" style="color:${colorValue}" data-hash="${hash}">${htmlText}</span>`;
          await this.createEntryWithHash(entry.value, entry.set, hash, {
            comment: entry.comment,
            tag: entry.tag,
            sourceFile: sourcePath,
            // 确保保存源文件路径
            type: entry.type || "md",
            index: spanHtml,
            // 将spanHtml保存到index字段
            attachmentFile: entry.attachmentFile || []
            // 添加附件文件路径
          });
          if (editor) {
            editor.replaceSelection(spanHtml);
          }
          await this.refreshViews();
          return Promise.resolve();
        } catch (error2) {
          console.error("\u521B\u5EFA\u6807\u6CE8\u5931\u8D25:", error2);
          return Promise.reject(error2);
        }
      }
    });
    modal.open();
  }
  /**
   * 创建条目并使用指定的hash
   * @param value 条目内容
   * @param set 所属集合
   * @param hash 指定的hash值
   * @param options 其他选项
   * @returns 创建的条目
   */
  async createEntryWithHash(value, set, hash, options = {}) {
    const entry = this.dataManager.createEntryWithHash(value, set, hash, options);
    await this.storageManager.saveData(this.settings);
    return entry;
  }
  // --------------------------- Plan ---------------------------
  /** 创建 Plan 并保存 */
  async createPlan(name2, options = {}) {
    const plan = this.dataManager.createPlan(name2, options);
    await this.storageManager.saveData(this.settings);
    return plan;
  }
  /** 更新 Plan 并保存（不可修改 name） */
  async updatePlan(name2, updates) {
    const plan = this.dataManager.updatePlan(name2, updates);
    await this.storageManager.saveData(this.settings);
    return plan;
  }
  /** 删除 Plan 并保存 */
  async deletePlan(name2) {
    const res = this.dataManager.deletePlan(name2);
    if (res) {
      await this.storageManager.saveData(this.settings);
    }
    return res;
  }
  /*
   * 从 dataManager 的条目中收集所有 PDF 矩形信息加载到 RectHighlightManager
   */
  initRectData() {
    const mgr = this.rectHighlightManager;
    const entries = this.dataManager.getAllEntries();
    entries.forEach((e) => {
      if (e.type !== "pdf" || typeof e.index !== "string")
        return;
      if (e.index.includes("rect=")) {
        const m5 = e.index.match(/page=(\d+)&rect=([\d,]+)/);
        if (!m5)
          return;
        const page = Number(m5[1]);
        const rectNums = m5[2].split(",").map((n3) => Number(n3));
        mgr.addRect(e.sourceFile, page, rectNums, e.hash);
      } else if (e.index.includes("selection=")) {
      }
    });
  }
  /**
   * 清理单个条目在源文件中的可见标记（md span 或 pdf 注释）。
   */
  async cleanEntryArtifact(entry) {
    if (entry.type === "md" && entry.sourceFile) {
      try {
        const file = this.app.vault.getAbstractFileByPath(entry.sourceFile);
        if (file instanceof import_obsidian42.TFile) {
          const content = await this.app.vault.read(file);
          const regex = new RegExp(`<span[^>]*data-hash="${entry.hash}"[^>]*>([\\s\\S]*?)<\\/span>`, "g");
          if (regex.test(content)) {
            const newContent = content.replace(regex, (_match, inner) => {
              return inner.replace(/<br>\s*/g, "\n");
            });
            await this.app.vault.modify(file, newContent);
          }
        }
      } catch (e) {
        console.error("clean md artifact failed", e);
      }
    } else if (entry.type === "pdf" && entry.index) {
      try {
        const match = entry.index.match(/page=(\d+)&annotation=(\d+)R/);
        if (match) {
          const pageNum = Number(match[1]);
          const objNum = Number(match[2]);
          const file = this.app.vault.getAbstractFileByPath(entry.sourceFile);
          if (file instanceof import_obsidian42.TFile) {
            const activeLeaf = this.app.workspace.getLeaf();
            let child = void 0;
            try {
              if (activeLeaf && activeLeaf.view) {
                const viewFile = activeLeaf.view.file;
                if (viewFile && viewFile.path === entry.sourceFile) {
                  child = activeLeaf.view.viewer?.child;
                }
              }
            } catch (e) {
              console.error("\u83B7\u53D6PDF\u89C6\u56FE\u72B6\u6001\u5931\u8D25", e);
            }
            const pas = new PdfIOService(this.app);
            await pas.deleteHighlightAnnotation(file, pageNum, objNum, child);
          }
        }
        if (entry.index.includes("rect=") || entry.index.includes("selection=")) {
          this.rectHighlightManager.removeRectByHash(entry.hash);
        }
      } catch (e) {
        console.error("clean pdf annotation failed", e);
      }
    } else if (entry.type === "video") {
      document.dispatchEvent(new CustomEvent("BetterNotes-video-entry-deleted", {
        detail: { hash: entry.hash }
      }));
    }
  }
  /**
   * 切换 Markdown 即时标注功能并持久化设置。
   * 会在状态更改时通过 Notice 提示当前状态。
   */
  async toggleImmediateAnnotation() {
    this.settings.mdImmediateAnnotation = !this.settings.mdImmediateAnnotation;
    await this.saveData(this.settings);
    new import_obsidian42.Notice(t("markdown immediate annotation is now") + (this.settings.mdImmediateAnnotation ? t("enabled") : t("disabled")));
    if (this.ribbonToggleIcon) {
      this.ribbonToggleIcon.toggleClass("is-active", this.settings.mdImmediateAnnotation);
    }
  }
  /** 获取当前 Vault 的绝对路径（兼容桌面 / 移动） */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    let vaultPath = this.app.vault.getName();
    if (adapter && adapter.basePath) {
      vaultPath = `${adapter.basePath}/${vaultPath}`;
    }
    return vaultPath;
  }
  /** 激活并向服务器验证，成功后保存 license */
  async validateActivation(code) {
    const trimmedCode = code.trim();
    const vaultPath = this.getVaultPath();
    let success = false;
    let licenseStr = "";
    try {
      const resp = await fetch("https://butcher-x.com/activate/index.php", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: trimmedCode, device_id: vaultPath })
      });
      if (resp.ok) {
        const data = await resp.json();
        if (data.success && data.license) {
          licenseStr = String(data.license).trim();
          success = true;
        } else {
          new import_obsidian42.Notice(t("activation failed") + ": " + (data.message || t("unknown error")));
        }
      } else {
        new import_obsidian42.Notice(t("server error") + ": " + resp.status);
      }
    } catch (e) {
      console.error("[BetterNotes] \u6FC0\u6D3B\u8BF7\u6C42\u5931\u8D25:", e);
      new import_obsidian42.Notice(t("network request failed, please check your network connection"));
    }
    if (success) {
      this.settings.activationCode = trimmedCode;
      this.settings.license = licenseStr;
      this.licenseValid = await verifyLicense(licenseStr, trimmedCode, vaultPath);
    } else {
      this.licenseValid = false;
    }
    this.settings.ai.enabled = this.licenseValid;
    await this.saveData(this.settings);
    this.aiService.updateConfig(this.settings.ai);
    new import_obsidian42.Notice(this.licenseValid ? t("activation successful") : t("activation failed"));
    return this.licenseValid;
  }
  /** 更新 AI 配置，并刷新服务实例 */
  async updateAiConfig(cfg) {
    this.settings.ai = cfg;
    await this.saveData(this.settings);
    this.aiService.updateConfig(cfg);
  }
  /**
   * 重写 Plugin.saveData：
   * 1) 仍调用基类方法，保持 Obsidian 默认行为（以防第三方工具读取）
   * 2) 随后将业务数据 + 设置通过 StorageManager 统一写入，避免相互覆盖。
   */
  async saveData(data) {
    await super.saveData(data);
    await this.storageManager.saveData(this.settings);
  }
  // --------- RAG 索引命令 ----------
  /**
   * 解绑（反激活）当前设备。
   * 向服务器发送 `{code, device_id}` 到 /unregister.php。
   * 成功后将本地 activationCode / license 清空并保存。
   *
   * @returns 是否解绑成功
   */
  async deactivateLicense() {
    if (!this.settings.activationCode) {
      new import_obsidian42.Notice(t("no activation info found"));
      return false;
    }
    const vaultPath = this.getVaultPath();
    let success = false;
    try {
      const resp = await fetch("https://butcher-x.com/activate/unregister.php", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: this.settings.activationCode, device_id: vaultPath })
      });
      if (resp.ok) {
        const data = await resp.json();
        success = !!data.success;
        if (!success) {
          new import_obsidian42.Notice(t("deactivation failed") + ": " + (data.message || t("unknown error")));
        }
      } else {
        new import_obsidian42.Notice(t("server error") + ": " + resp.status);
      }
    } catch (e) {
      console.error("[BetterNotes] \u89E3\u7ED1\u8BF7\u6C42\u5931\u8D25:", e);
      new import_obsidian42.Notice(t("network request failed, please check your network connection"));
    }
    if (success) {
      this.settings.activationCode = "";
      this.settings.license = "";
      this.licenseValid = false;
      this.settings.ai.enabled = false;
      await this.saveData(this.settings);
      this.aiService.updateConfig(this.settings.ai);
    }
    return success;
  }
  /**
   * 检查服务器通知
   * 异步获取服务器通知并显示给用户
   */
  async checkServerNotifications() {
    try {
      const notification = await this.notificationService.checkForNotifications();
      if (notification) {
        this.notificationService.displayNotification(notification);
        this.settings.lastNotificationTimestamp = notification.published_at;
        await this.saveData(this.settings);
      }
    } catch (error2) {
      console.error("[BetterNotes] \u68C0\u67E5\u901A\u77E5\u51FA\u9519:", error2);
    }
  }
  /**
   * Checks if a given view type should be ignored when tracking the last active leaf.
   * @param viewType The view type string to check.
   * @returns True if the view should be ignored, false otherwise.
   */
  isIgnoredView(viewType) {
    return this.ignoredViewTypes.includes(viewType);
  }
};
var BetterNotesSettingTab = class extends import_obsidian42.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian42.Setting(containerEl).setName(t("Data backup and restore")).setHeading();
    new import_obsidian42.Setting(containerEl).setName(t("data backup")).addButton((btn) => btn.setButtonText(t("backup now")).setCta().onClick(async () => {
      await this.plugin.backupService.backupData();
    }));
    new import_obsidian42.Setting(containerEl).setName(t("restore data")).addButton((btn) => btn.setButtonText(t("restore data")).setWarning().onClick(async () => {
      new BackupRestoreModal(this.plugin.app, this.plugin.backupService).open();
    }));
    new import_obsidian42.Setting(containerEl).setName(t("General notes settings")).setHeading();
    new import_obsidian42.Setting(containerEl).setName(t("search context length")).addText((text) => text.setPlaceholder("\u4F8B\u5982 10").setValue(String(this.plugin.settings.snippetContext)).onChange(async (value) => {
      const num = parseInt(value) || 10;
      this.plugin.settings.snippetContext = num;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("pdf highlight opacity")).addText((text) => text.setPlaceholder("0.7").setValue(String(this.plugin.settings.highlightOpacity)).onChange(async (value) => {
      let num = parseFloat(value);
      if (isNaN(num) || num < 0 || num > 1) {
        new import_obsidian42.Notice(t("please input a number between 0 and 1"));
        return;
      }
      this.plugin.settings.highlightOpacity = num;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("pdf link template")).addText((text) => text.setPlaceholder("[[{index}|{value}]]").setValue(this.plugin.settings.linkTemplates.pdfTemplate || DEFAULT_LINK_TEMPLATES.pdfTemplate).onChange(async (value) => {
      if (!this.plugin.settings.linkTemplates) {
        this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      }
      this.plugin.settings.linkTemplates.pdfTemplate = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("markdown link template")).setDesc("{index} {file} {value}").addText((text) => text.setPlaceholder("[[{index}|{value}]]").setValue(this.plugin.settings.linkTemplates.mdTemplate || DEFAULT_LINK_TEMPLATES.mdTemplate).onChange(async (value) => {
      if (!this.plugin.settings.linkTemplates) {
        this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      }
      this.plugin.settings.linkTemplates.mdTemplate = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("video link template")).setDesc("{index} {file} {value} {url} {timestamp}").addText((text) => text.setPlaceholder("[[{index}|{value}]]").setValue(this.plugin.settings.linkTemplates.videoTemplate || DEFAULT_LINK_TEMPLATES.videoTemplate).onChange(async (value) => {
      if (!this.plugin.settings.linkTemplates) {
        this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      }
      this.plugin.settings.linkTemplates.videoTemplate = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("card template")).setDesc("{link} {comment} {value} {addTime} {tag} {type} {proficiency} {set}").addTextArea((text) => text.setPlaceholder(DEFAULT_LINK_TEMPLATES.cardTemplate).setValue(this.plugin.settings.linkTemplates.cardTemplate || DEFAULT_LINK_TEMPLATES.cardTemplate).onChange(async (value) => {
      if (!this.plugin.settings.linkTemplates) {
        this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      }
      this.plugin.settings.linkTemplates.cardTemplate = value;
      await this.plugin.saveData(this.plugin.settings);
    })).settingEl.style.gridTemplateColumns = "auto auto";
    new import_obsidian42.Setting(containerEl).setName(t("html export template")).setDesc("{link} {comment} {value} {addTime} {tag} {type} {proficiency} {set} {color}").addTextArea((text) => text.setPlaceholder(DEFAULT_LINK_TEMPLATES.htmlTemplate).setValue(this.plugin.settings.linkTemplates.htmlTemplate || DEFAULT_LINK_TEMPLATES.htmlTemplate).onChange(async (value) => {
      if (!this.plugin.settings.linkTemplates) {
        this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      }
      this.plugin.settings.linkTemplates.htmlTemplate = value;
      await this.plugin.saveData(this.plugin.settings);
    })).settingEl.style.gridTemplateColumns = "auto auto";
    new import_obsidian42.Setting(containerEl).setName(t("reset all templates")).addButton((btn) => btn.setButtonText(t("reset")).onClick(async () => {
      this.plugin.settings.linkTemplates = { ...DEFAULT_LINK_TEMPLATES };
      await this.plugin.saveData(this.plugin.settings);
      this.display();
      new import_obsidian42.Notice(t("all templates reset"));
    }));
    new import_obsidian42.Setting(containerEl).setName(t("fsrs target retention rate")).setDesc(t("the probability of remembering the target on the next review; the higher the value, the shorter the review interval")).addSlider((s5) => {
      s5.setLimits(0.8, 0.95, 0.01).setDynamicTooltip().setValue(this.plugin.settings.fsrsParams.request_retention).onChange((val) => {
        this.plugin.settings.fsrsParams.request_retention = val;
        this.plugin.fsrsService.setParameters({ request_retention: val });
        this.plugin.saveData(this.plugin.settings);
      });
    });
    new import_obsidian42.Setting(containerEl).setName(t("fsrs maximum interval")).setDesc(t("maximum_interval: the maximum review interval allowed to prevent the interval from extending indefinitely")).addText((t2) => t2.setPlaceholder("36500").setValue(String(this.plugin.settings.fsrsParams.maximum_interval)).onChange((val) => {
      const num = Number(val);
      if (!isNaN(num)) {
        this.plugin.settings.fsrsParams.maximum_interval = num;
        this.plugin.fsrsService.setParameters({ maximum_interval: num });
        this.plugin.saveData(this.plugin.settings);
      }
    }));
    new import_obsidian42.Setting(containerEl).setName(t("fsrs detailed weights")).addButton((b4) => b4.setButtonText(t("open")).onClick(() => {
      new (init_FSRSWeightModal(), __toCommonJS(FSRSWeightModal_exports)).FSRSWeightModal(this.plugin).open();
    }));
    new import_obsidian42.Setting(containerEl).setName(t("AI service (OpenAI compatible)")).setHeading();
    new import_obsidian42.Setting(containerEl).setName(t("enable ai function")).setDesc(t("need activation")).addToggle((tgl) => {
      tgl.setValue(this.plugin.licenseValid);
      tgl.setDisabled(true);
    });
    new import_obsidian42.Setting(containerEl).setName(t("base url")).setDesc(t("interface base address, such as https://api.openai.com/v1")).addText((txt) => txt.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.ai.baseUrl).onChange(async (val) => {
      this.plugin.settings.ai.baseUrl = val.trim();
      await this.plugin.updateAiConfig(this.plugin.settings.ai);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("api key")).setDesc(t("bearer token")).addText((txt) => txt.setPlaceholder("sk-...").setValue(this.plugin.settings.ai.apiKey).onChange(async (val) => {
      this.plugin.settings.ai.apiKey = val.trim();
      await this.plugin.updateAiConfig(this.plugin.settings.ai);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("default model name")).setDesc(t("gpt-4o is recommended")).addText((txt) => txt.setPlaceholder("gpt-4o").setValue(this.plugin.settings.ai.model).onChange(async (val) => {
      this.plugin.settings.ai.model = val.trim();
      await this.plugin.updateAiConfig(this.plugin.settings.ai);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("test connection")).setDesc(t("display available model list")).addButton((btn) => btn.setButtonText(t("test")).onClick(async () => {
      try {
        await this.plugin.aiService.testConnection();
      } catch (err2) {
        const msg = err2?.message || String(err2);
        new import_obsidian42.Notice(t("test failed") + ": " + msg);
      }
    }));
    new import_obsidian42.Setting(containerEl).setName(t("ai preset prompt")).setDesc(t("manage common prompt, can be quickly selected in the chat input box through /")).addButton((b4) => b4.setButtonText(t("manage")).onClick(() => {
      Promise.resolve().then(() => (init_PresetModal(), PresetModal_exports)).then((mod) => {
        const PresetModal2 = mod.default;
        new PresetModal2(this.plugin).open();
      });
    }));
    new import_obsidian42.Setting(containerEl).setName(t("Rag embedding settings")).setHeading();
    new import_obsidian42.Setting(containerEl).setName(t("embedding model")).setDesc(t("text-embedding-3-small is recommended")).addText((txt) => txt.setPlaceholder("text-embedding-3-small").setValue(this.plugin.settings.rag.embeddingModel).onChange(async (val) => {
      this.plugin.settings.rag.embeddingModel = val.trim();
      await this.plugin.saveData(this.plugin.settings);
      this.plugin.ragService.updateConfig(this.plugin.settings.rag);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("embedding base url")).addText((txt) => txt.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.rag.embeddingEndpoint).onChange(async (val) => {
      this.plugin.settings.rag.embeddingEndpoint = val.trim();
      await this.plugin.saveData(this.plugin.settings);
      this.plugin.ragService.updateConfig(this.plugin.settings.rag);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("embedding api key")).addText((txt) => txt.setPlaceholder("sk-...").setValue(this.plugin.settings.rag.apiKey || "").onChange(async (val) => {
      this.plugin.settings.rag.apiKey = val.trim();
      await this.plugin.saveData(this.plugin.settings);
      this.plugin.ragService.updateConfig(this.plugin.settings.rag);
    }));
    new import_obsidian42.Setting(containerEl).setName(t("minimum similarity threshold")).setDesc(t("the larger the value, the higher the result similarity; too high may result in no results; should not exceed 0.4")).addSlider((s5) => {
      s5.setLimits(0, 0.5, 0.01).setDynamicTooltip().setValue(this.plugin.settings.rag.minSimilarity ?? 0.25).onChange(async (val) => {
        this.plugin.settings.rag.minSimilarity = parseFloat(val.toFixed(2));
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.ragService.updateConfig({ minSimilarity: this.plugin.settings.rag.minSimilarity });
      });
    });
    new import_obsidian42.Setting(containerEl).setName(t("License")).setHeading();
    new import_obsidian42.Setting(containerEl).setName(t("activation code")).setDesc(t('input activation code and click "activate" button')).addText((t2) => t2.setValue(this.plugin.settings.activationCode || "").onChange((val) => {
      this.plugin.settings.activationCode = val.trim();
      this.plugin.saveData(this.plugin.settings);
    })).addButton((btn) => btn.setButtonText(t("activate")).setCta().onClick(async () => {
      const ok = await this.plugin.validateActivation(this.plugin.settings.activationCode || "");
      this.display();
      if (ok) {
        new import_obsidian42.Notice(t("activation successful"));
      }
    }));
    new import_obsidian42.Setting(containerEl).setName(t("current license status")).addText((t2) => t2.setValue(this.plugin.licenseValid ? "activated" : "not activated").setDisabled(true)).addButton((btn) => btn.setButtonText(t("unbind")).setWarning().setDisabled(!this.plugin.licenseValid).onClick(async () => {
      const ok = await this.plugin.deactivateLicense();
      this.display();
      if (ok)
        new import_obsidian42.Notice(t("device unbound"));
    }));
  }
};
/*! Bundled license information:

html2canvas/dist/html2canvas.js:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
